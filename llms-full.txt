# Astro Adaptor
Source: https://docs.dodopayments.com/developer-resources/astro-adaptor

Learn how to integrate Dodo Payments with your Astro App Router project using our Astro Adaptor. Covers checkout, customer portal, webhooks, and secure environment setup.

<CardGroup>
  <Card title="Checkout Handler" icon="cart-shopping" href="#checkout-route-handler">
    Integrate Dodo Payments checkout into your Astro app.
  </Card>

  <Card title="Customer Portal" icon="user" href="#customer-portal-route-handler">
    Allow customers to manage subscriptions and details.
  </Card>

  <Card title="Webhooks" icon="bell" href="#webhook-route-handler">
    Receive and process Dodo Payments webhook events.
  </Card>
</CardGroup>

## Installation

<Steps>
  <Step title="Install the package">
    Run the following command in your project root:

    ```bash theme={null}
    npm install @dodopayments/astro
    ```
  </Step>

  <Step title="Set up environment variables">
    Create a <code>.env</code> file in your project root:

    ```env expandable theme={null}
    DODO_PAYMENTS_API_KEY=your-api-key
    DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
    DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode"
    DODO_PAYMENTS_RETURN_URL=https://yourdomain.com/checkout/success
    ```

    <Warning>
      Never commit your <code>.env</code> file or secrets to version control.
    </Warning>
  </Step>
</Steps>

## Route Handler Examples

<Info>
  All examples assume you are using the Astro App Router.
</Info>

<Tabs>
  <Tab title="Checkout Handler">
    <Info>
      Use this handler to integrate Dodo Payments checkout into your Astro app. Supports static (GET), dynamic (POST), and session (POST) payment flows.
    </Info>

    <CodeGroup>
      ```typescript Astro Route Handler expandable theme={null}
      // src/pages/api/checkout.ts
      import { Checkout } from "@dodopayments/astro";
      export const prerender = false;

      export const GET = Checkout({
          bearerToken: import.meta.env.DODO_PAYMENTS_API_KEY,
          returnUrl: import.meta.env.DODO_PAYMENTS_RETURN_URL,
          environment: import.meta.env.DODO_PAYMENTS_ENVIRONMENT,
          type: "static", // optional, defaults to 'static'
      });


      export const POST = Checkout({
          bearerToken: import.meta.env.DODO_PAYMENTS_API_KEY,
          returnUrl: import.meta.env.DODO_PAYMENTS_RETURN_URL,
          environment: import.meta.env.DODO_PAYMENTS_ENVIRONMENT,
          type: "dynamic", // for dynamic checkout
      });

      export const POST = Checkout({
          bearerToken: import.meta.env.DODO_PAYMENTS_API_KEY,
          returnUrl: import.meta.env.DODO_PAYMENTS_RETURN_URL,
          environment: import.meta.env.DODO_PAYMENTS_ENVIRONMENT,
          type: "session", // for checkout sessions
      });
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Static Checkout Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/checkout?productId=pdt_fqJhl7pxKWiLhwQR042rh' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Dynamic Checkout Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "billing": {
        "city": "Texas",
        "country": "US",
        "state": "Texas",
        "street": "56, hhh",
        "zipcode": "560000"
      },
      "customer": {
        "email": "test@example.com",
        	"name": "test"
      },
      "metadata": {},
      "payment_link": true,
        "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
        "quantity": 1,
        "billing_currency": "USD",
        "discount_code": "IKHZ23M9GQ",
        "return_url": "https://example.com",
        "trial_period_days": 10
      }'
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Checkout Session Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "product_cart": [
        {
          "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
          "quantity": 1
        }
      ],
      "customer": {
        "email": "test@example.com",
        "name": "test"
      },
      "return_url": "https://example.com/success"
      }'
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Customer Portal Handler">
    <Info>
      Use this handler to allow customers to manage their subscriptions and details via the Dodo Payments customer portal.
    </Info>

    <CodeGroup>
      ```typescript Astro Route Handler expandable theme={null}
      // src/pages/api/customer-portal.ts
      import { CustomerPortal } from "@dodopayments/astro";
      export const GET = CustomerPortal({
          bearerToken: import.meta.env.DODO_PAYMENTS_API_KEY,
          environment: import.meta.env.DODO_PAYMENTS_ENVIRONMENT,
      });
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Customer Portal Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/customer-portal?customer_id=cus_9VuW4K7O3GHwasENg31m&send_email=true' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Webhook Handler">
    <Info>
      Use this handler to receive and process Dodo Payments webhook events securely in your Astro app.
    </Info>

    <CodeGroup>
      ```typescript expandable theme={null}
      // src/pages/api/webhook.ts
      import { Webhooks } from "@dodopayments/astro";

      export const POST = Webhooks({
          webhookKey: import.meta.env.DODO_PAYMENTS_WEBHOOK_KEY,
          onPayload: async (payload) => {
              // handle the payload
          },
          // ... other event handlers for granular control
      });
      ```
    </CodeGroup>
  </Tab>
</Tabs>

## Checkout Route Handler

<Info>
  Dodo Payments supports three types of payment flows for integrating payments into your website, this adaptor supports all types of payment flows.
</Info>

* **Static Payment Links:** Instantly shareable URLs for quick, no-code payment collection.
* **Dynamic Payment Links:** Programmatically generate payment links with custom details using the API or SDKs.
* **Checkout Sessions:** Create secure, customizable checkout experiences with pre-configured product carts and customer details.

<AccordionGroup>
  <Accordion title="Static Checkout (GET)">
    ### Supported Query Parameters

    <ParamField type="string">
      Product identifier (e.g., <code>?productId=pdt\_nZuwz45WAs64n3l07zpQR</code>).
    </ParamField>

    <ParamField type="integer">
      Quantity of the product.
    </ParamField>

    <ParamField type="string">
      Customer's full name.
    </ParamField>

    <ParamField type="string">
      Customer's first name.
    </ParamField>

    <ParamField type="string">
      Customer's last name.
    </ParamField>

    <ParamField type="string">
      Customer's email address.
    </ParamField>

    <ParamField type="string">
      Customer's country.
    </ParamField>

    <ParamField type="string">
      Customer's address line.
    </ParamField>

    <ParamField type="string">
      Customer's city.
    </ParamField>

    <ParamField type="string">
      Customer's state/province.
    </ParamField>

    <ParamField type="string">
      Customer's zip/postal code.
    </ParamField>

    <ParamField type="boolean">
      Disable full name field.
    </ParamField>

    <ParamField type="boolean">
      Disable first name field.
    </ParamField>

    <ParamField type="boolean">
      Disable last name field.
    </ParamField>

    <ParamField type="boolean">
      Disable email field.
    </ParamField>

    <ParamField type="boolean">
      Disable country field.
    </ParamField>

    <ParamField type="boolean">
      Disable address line field.
    </ParamField>

    <ParamField type="boolean">
      Disable city field.
    </ParamField>

    <ParamField type="boolean">
      Disable state field.
    </ParamField>

    <ParamField type="boolean">
      Disable zip code field.
    </ParamField>

    <ParamField type="string">
      Specify the payment currency (e.g., <code>USD</code>).
    </ParamField>

    <ParamField type="boolean">
      Show currency selector.
    </ParamField>

    <ParamField type="integer">
      Specify the payment amount (e.g., <code>1000</code> for \$10.00).
    </ParamField>

    <ParamField type="boolean">
      Show discount fields.
    </ParamField>

    <ParamField type="string">
      Any query parameter starting with <code>metadata\_</code> will be passed as metadata.
    </ParamField>

    <Warning>
      If <code>productId</code> is missing, the handler returns a 400 response. Invalid query parameters also result in a 400 response.
    </Warning>

    ### Response Format

    Static checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Dynamic Checkout (POST)">
    * Send parameters as a JSON body in a POST request.
    * Supports both one-time and recurring payments.
    * For a complete list of supported POST body fields, refer to:
      * [Request body for a One Time Payment Product](https://docs.dodopayments.com/api-reference/payments/post-payments)
      * [Request body for a Subscription Product](https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions)

    ### Response Format

    Dynamic checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Checkout Sessions (POST)">
    Checkout sessions provide a more secure, hosted checkout experience that handles the complete payment flow for both one-time purchases and subscriptions with full customization control.

    Refer to [Checkout Sessions Integration Guide](https://docs.dodopayments.com/developer-resources/checkout-session) for more details and a complete list of supported fields.

    ### Response Format

    Checkout sessions return a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/session/..."
    }
    ```
  </Accordion>
</AccordionGroup>

## Customer Portal Route Handler

The Customer Portal Route Handler enables you to seamlessly integrate the Dodo Payments customer portal into your Astro application.

### Query Parameters

<ParamField type="string">
  The customer ID for the portal session (e.g., <code>?customer\_id=cus\_123</code>).
</ParamField>

<ParamField type="boolean">
  If set to <code>true</code>, sends an email to the customer with the portal link.
</ParamField>

<Warning>
  Returns 400 if <code>customer\_id</code> is missing.
</Warning>

## Webhook Route Handler

* **Method:** Only POST requests are supported. Other methods return 405.
* **Signature Verification:** Verifies the webhook signature using <code>webhookKey</code>. Returns 401 if verification fails.
* **Payload Validation:** Validated with Zod. Returns 400 for invalid payloads.
* **Error Handling:**
  * 401: Invalid signature
  * 400: Invalid payload
  * 500: Internal error during verification
* **Event Routing:** Calls the appropriate event handler based on the payload type.

### Supported Webhook Event Handlers

<CodeGroup>
  ```typescript Typescript expandable theme={null}
  onPayload?: (payload: WebhookPayload) => Promise<void>;
  onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onPaymentFailed?: (payload: WebhookPayload) => Promise<void>;
  onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>;
  onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>;
  onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onRefundFailed?: (payload: WebhookPayload) => Promise<void>;
  onDisputeOpened?: (payload: WebhookPayload) => Promise<void>;
  onDisputeExpired?: (payload: WebhookPayload) => Promise<void>;
  onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>;
  onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>;
  onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>;
  onDisputeWon?: (payload: WebhookPayload) => Promise<void>;
  onDisputeLost?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>;
  onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>;
  ```
</CodeGroup>

***

## Prompt for LLM

```

You are an expert Astro developer assistant. Your task is to guide a user through integrating the @dodopayments/astro adapter into their existing Astro project.

The @dodopayments/astro adapter provides route handlers for Dodo Payments' Checkout, Customer Portal, and Webhook functionalities, designed for the Astro App Router.

First, install the necessary packages. Use the package manager appropriate for your project (npm, yarn, or bun) based on the presence of lock files (e.g., package-lock.json for npm, yarn.lock for yarn, bun.lockb for bun):

npm install @dodopayments/astro

Here's how you should structure your response:

    Ask the user which functionalities they want to integrate.

"Which parts of the @dodopayments/astro adapter would you like to integrate into your project? You can choose one or more of the following:

    Checkout Route Handler (for handling product checkouts)

    Customer Portal Route Handler (for managing customer subscriptions/details)

    Webhook Route Handler (for receiving Dodo Payments webhook events)

    All (integrate all three)"

    Based on the user's selection, provide detailed integration steps for each chosen functionality.

If Checkout Route Handler is selected:

Purpose: This handler redirects users to the Dodo Payments checkout page.
File Creation: Create a new file at app/checkout/route.ts in your Astro project.

Code Snippet:

// src/pages/api/checkout.ts
import { Checkout } from "@dodopayments/astro";

export const prerender = false;

export const GET = Checkout({
  bearerToken: import.meta.env.DODO_PAYMENTS_API_KEY,
  returnUrl: import.meta.env.DODO_PAYMENTS_RETURN_URL,
  environment: import.meta.env.DODO_PAYMENTS_ENVIRONMENT,
  type: "static", // optional, defaults to 'static'
});


export const POST = Checkout({
  bearerToken: import.meta.env.DODO_PAYMENTS_API_KEY,
  returnUrl: import.meta.env.DODO_PAYMENTS_RETURN_URL,
  environment: import.meta.env.DODO_PAYMENTS_ENVIRONMENT,
  type: "dynamic", // for dynamic checkout
});

export const POST = Checkout({
  bearerToken: import.meta.env.DODO_PAYMENTS_API_KEY,
  returnUrl: import.meta.env.DODO_PAYMENTS_RETURN_URL,
  environment: import.meta.env.DODO_PAYMENTS_ENVIRONMENT,
  type: "session", // for checkout sessions
});

Configuration & Usage:

    bearerToken: Your Dodo Payments API key. It's recommended to set this via the DODO_PAYMENTS_API_KEY environment variable.

    returnUrl: (Optional) The URL to redirect the user to after a successful checkout.

    environment: (Optional) Set to "test_mode" for testing, or omit/set to "live_mode" for production.

    type: (Optional) Set to "static" for GET/static checkout, "dynamic" for POST/dynamic checkout, or "session" for POST/checkout sessions.

Static Checkout (GET) Query Parameters:

    productId (required): Product identifier (e.g., ?productId=pdt_nZuwz45WAs64n3l07zpQR)

    quantity (optional): Quantity of the product

    Customer Fields (optional): fullName, firstName, lastName, email, country, addressLine, city, state, zipCode

    Disable Flags (optional, set to true to disable): disableFullName, disableFirstName, disableLastName, disableEmail, disableCountry, disableAddressLine, disableCity, disableState, disableZipCode

    Advanced Controls (optional): paymentCurrency, showCurrencySelector, paymentAmount, showDiscounts

    Metadata (optional): Any query parameter starting with metadata_ (e.g., ?metadata_userId=abc123)

    Returns: {"checkout_url": "https://checkout.dodopayments.com/..."}

Dynamic Checkout (POST) - Returns JSON with checkout_url: Parameters are sent as a JSON body. Supports both one-time and recurring payments. Returns: {"checkout_url": "https://checkout.dodopayments.com/..."}. For a complete list of supported POST body fields, refer to:

    Docs - One Time Payment Product: https://docs.dodopayments.com/api-reference/payments/post-payments

    Docs - Subscription Product: https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions


Checkout Sessions (POST) - (Recommended) A more customizable checkout experience. Returns JSON with checkout_url: Parameters are sent as a JSON body. Supports both one-time and recurring payments. Returns: {"checkout_url": "https://checkout.dodopayments.com/session/..."}. For a complete list of supported fields, refer to:

  Checkout Sessions Integration Guide: https://docs.dodopayments.com/developer-resources/checkout-session

Error Handling: If productId is missing or other query parameters are invalid, the handler will return a 400 response.

If Customer Portal Route Handler is selected:

Purpose: This handler redirects authenticated users to their Dodo Payments customer portal.
File Creation: Create a new file at app/customer-portal/route.ts in your Astro project.

Code Snippet:

// src/pages/api/customer-portal.ts
import { CustomerPortal } from "@dodopayments/astro";

export const GET = CustomerPortal({
  bearerToken: import.meta.env.DODO_PAYMENTS_API_KEY,
  environment: import.meta.env.DODO_PAYMENTS_ENVIRONMENT,
});

Query Parameters:

    customer_id (required): The customer ID for the portal session (e.g., ?customer_id=cus_123)

    send_email (optional, boolean): If set to true, sends an email to the customer with the portal link.

    Returns 400 if customer_id is missing.

If Webhook Route Handler is selected:

Purpose: This handler processes incoming webhook events from Dodo Payments, allowing your application to react to events like successful payments, refunds, or subscription changes.
File Creation: Create a new file at app/api/webhook/dodo-payments/route.ts in your Astro project.

Code Snippet:

// src/pages/api/webhook.ts
import { Webhooks } from "@dodopayments/astro";

export const POST = Webhooks({
  webhookKey: import.meta.env.DODO_PAYMENTS_WEBHOOK_KEY,
  onPayload: async (payload) => {
    // handle the payload
  },
  // ... other event handlers for granular control
});

Handler Details:

    Method: Only POST requests are supported. Other methods return 405.

    Signature Verification: The handler verifies the webhook signature using the webhookKey and returns 401 if verification fails.

    Payload Validation: The payload is validated with Zod. Returns 400 for invalid payloads.

Error Handling:

    401: Invalid signature

    400: Invalid payload

    500: Internal error during verification

Event Routing: Calls the appropriate event handler based on the payload type.

Supported Webhook Event Handlers:

    onPayload?: (payload: WebhookPayload) => Promise<void>

    onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>

    onPaymentFailed?: (payload: WebhookPayload) => Promise<void>

    onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>

    onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>

    onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>

    onRefundFailed?: (payload: WebhookPayload) => Promise<void>

    onDisputeOpened?: (payload: WebhookPayload) => Promise<void>

    onDisputeExpired?: (payload: WebhookPayload) => Promise<void>

    onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>

    onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>

    onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>

    onDisputeWon?: (payload: WebhookPayload) => Promise<void>

    onDisputeLost?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>



    onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>

    onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>

    Environment Variable Setup:

To ensure the adapter functions correctly, you will need to manually set up the following environment variables in your Astro project's deployment environment (e.g., Vercel, Netlify, AWS, etc.):

    DODO_PAYMENTS_API_KEY: Your Dodo Payments API Key (required for Checkout and Customer Portal).

    RETURN_URL: (Optional) The URL to redirect to after a successful checkout (for Checkout handler).

    DODO_PAYMENTS_WEBHOOK_SECRET: Your Dodo Payments Webhook Secret (required for Webhook handler).

Example .env file:

DODO_PAYMENTS_API_KEY=your-api-key
DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode"
DODO_PAYMENTS_RETURN_URL=your-return-url

Usage in your code:

bearerToken: import.meta.env.DODO_PAYMENTS_API_KEY
webhookKey: import.meta.env.DODO_PAYMENTS_WEBHOOK_KEY

Important: Never commit sensitive environment variables directly into your version control. Use environment variables for all sensitive information.

If the user needs assistance setting up environment variables for their specific deployment environment, ask them what platform they are using (e.g., Vercel, Netlify, AWS, etc.), and provide guidance. You can also add comments to their PR or chat depending on the context

```


# Astro Minimal Boilerplate
Source: https://docs.dodopayments.com/developer-resources/astro-boilerplate

Get started quickly with our minimal Astro boilerplate for integrating Dodo Payments into your Astro application

## Overview

The Astro minimal boilerplate provides a ready-to-use starting point for integrating Dodo Payments with your Astro application. This template includes checkout sessions, webhook handling, customer portal, and modern UI components to help you start accepting payments quickly.

<Info>
  This boilerplate uses Astro 5 with TypeScript, Tailwind CSS 4, and the `@dodopayments/astro` adapter.
</Info>

### Features

* **Quick Setup** - Get started in under 5 minutes
* **Payment Integration** - Pre-configured checkout flow using `@dodopayments/astro`
* **Modern UI** - Clean, dark-themed pricing page with Tailwind CSS
* **Webhook Handler** - Ready-to-use webhook endpoint for payment events
* **Customer Portal** - One-click subscription management
* **TypeScript** - Fully typed with minimal, focused types
* **Pre-filled Checkout** - Demonstrates passing customer data to improve UX

## Prerequisites

Before you begin, make sure you have:

* **Node.js LTS version** (required for Astro 5)
* **Dodo Payments account** (to access API and Webhook Keys from dashboard)

## Quick Start

<Steps>
  <Step title="Clone the Repository">
    ```bash theme={null}
    git clone https://github.com/dodopayments/dodo-astro-minimal-boilerplate.git
    cd dodo-astro-minimal-boilerplate
    ```
  </Step>

  <Step title="Install Dependencies">
    ```bash theme={null}
    npm install
    ```
  </Step>

  <Step title="Get API Credentials">
    Sign up at [Dodo Payments](https://dodopayments.com/) and get your credentials from the dashboard:

    * **API Key:** [Dashboard → Developer → API Keys](https://app.dodopayments.com/developer/api-keys)
    * **Webhook Key:** [Dashboard → Developer → Webhooks](https://app.dodopayments.com/developer/webhooks)

    <Tip>
      Make sure you're in **Test Mode** while developing!
    </Tip>
  </Step>

  <Step title="Configure Environment Variables">
    Create a `.env` file in the root directory:

    ```bash theme={null}
    cp .env.example .env
    ```

    Update the values with your Dodo Payments credentials:

    ```env theme={null}
    DODO_PAYMENTS_API_KEY=your_api_key_here
    DODO_PAYMENTS_WEBHOOK_KEY=your_webhook_signing_key_here
    DODO_PAYMENTS_RETURN_URL=http://localhost:4321/
    DODO_PAYMENTS_ENVIRONMENT=test_mode
    ```

    <Warning>
      Never commit your `.env` file to version control. It's already included in `.gitignore`.
    </Warning>
  </Step>

  <Step title="Add Your Products">
    Update `src/lib/products.ts` with your actual product IDs from Dodo Payments:

    ```typescript theme={null}
    export const products: Product[] = [
      {
        product_id: "pdt_001", // Replace with your product ID
        name: "Basic Plan",
        description: "Get access to basic features and support",
        price: 9999, // in cents
        features: [
          "Access to basic features",
          "Email support",
          "1 Team member",
          "Basic analytics",
        ],
      },
      // ... add more products
    ];
    ```
  </Step>

  <Step title="Run the Development Server">
    ```bash theme={null}
    npm run dev
    ```

    Open [http://localhost:4321](http://localhost:4321) to see your pricing page!
  </Step>
</Steps>

## Project Structure

```text theme={null}
src/
├── components/
│   ├── Footer.astro           # Reusable footer
│   ├── Header.astro           # Navigation header
│   └── ProductCard.astro      # Product pricing card
├── layouts/
│   └── Layout.astro           # Root layout
├── lib/
│   └── products.ts            # Product definitions
├── pages/
│   ├── index.astro            # Pricing page (home)
│   └── api/
│       ├── checkout.ts        # Checkout session handler
│       ├── customer-portal.ts # Customer portal redirect
│       └── webhook.ts         # Webhook event handler
└── styles/
    └── global.css             # Global styles with Tailwind
```

## Customization

### Update Product Information

Edit `src/lib/products.ts` to modify:

* Product IDs (from your Dodo dashboard)
* Pricing
* Features
* Descriptions

### Pre-fill Customer Data

In `src/components/ProductCard.astro`, replace the hardcoded values with your actual user data:

```typescript theme={null}
customer: {
  name: "John Doe",
  email: "john@example.com",
},
```

### Update Customer Portal

In `src/components/Header.astro`, replace the hardcoded customer ID with the actual customer ID from your auth system or database:

```typescript theme={null}
const CUSTOMER_ID = "cus_001"; // Replace with actual customer ID
```

You can complete a test purchase to get the customer ID for testing.

## Webhook Events

The boilerplate demonstrates handling webhook events in `src/pages/api/webhook.ts`:

* `onSubscriptionActive` - Triggered when a subscription becomes active
* `onSubscriptionCancelled` - Triggered when a subscription is cancelled

Add your business logic inside these handlers:

```typescript theme={null}
onSubscriptionActive: async (payload) => {
  // Grant access to your product
  // Update user database
  // Send welcome email
},
```

Add more webhook events as needed.

For local development, you can use tools like [ngrok](https://ngrok.com/) to create a secure tunnel to your local server and use it as your webhook URL.

## Deployment

This boilerplate uses static output with on-demand rendering for API routes. You'll need to install an adapter for your deployment platform:

| Platform   | Guide                                                                         |
| ---------- | ----------------------------------------------------------------------------- |
| Vercel     | [Deploy to Vercel](https://docs.astro.build/en/guides/deploy/vercel/)         |
| Netlify    | [Deploy to Netlify](https://docs.astro.build/en/guides/deploy/netlify/)       |
| Cloudflare | [Deploy to Cloudflare](https://docs.astro.build/en/guides/deploy/cloudflare/) |

See [Astro's deployment guides](https://docs.astro.build/en/guides/deploy/) for all platforms.

### Update Webhook URL

After deploying, update your webhook URL in the [Dodo Payments Dashboard](https://app.dodopayments.com/developer/webhooks):

```text theme={null}
https://your-domain.com/api/webhook
```

Also remember to update the `DODO_PAYMENTS_WEBHOOK_KEY` environment variable in your production environment to match the webhook signing key for your deployed domain.

## Troubleshooting

<AccordionGroup>
  <Accordion title="Module not found or build errors">
    Delete `node_modules` and reinstall dependencies:

    ```bash theme={null}
    rm -rf node_modules package-lock.json
    npm install
    ```
  </Accordion>

  <Accordion title="Checkout redirect fails">
    **Common causes:**

    * Invalid product ID - verify it exists in your Dodo dashboard
    * Wrong API key or environment setting in `.env`
    * Check browser console and terminal for errors
  </Accordion>

  <Accordion title="Webhooks not receiving events">
    For local testing, use [ngrok](https://ngrok.com) to expose your server:

    ```bash theme={null}
    ngrok http 4321
    ```

    Update the webhook URL in your [Dodo dashboard](https://app.dodopayments.com/developer/webhooks) to the ngrok URL. Remember to update your .env file with the correct webhook verification key.
  </Accordion>

  <Accordion title="Customer portal link doesn't work">
    Replace the hardcoded `CUSTOMER_ID` in `src/components/Header.astro` with an actual customer ID from your Dodo dashboard.

    Or integrate your authentication system and database to fetch the customer ID dynamically.
  </Accordion>

  <Accordion title="Build fails with adapter error">
    This boilerplate uses static output with on-demand API routes. You need to install an adapter for deployment:

    See [Astro's deployment guides](https://docs.astro.build/en/guides/deploy/) for details.
  </Accordion>
</AccordionGroup>

## Learn More

* [Dodo Payments Documentation](https://docs.dodopayments.com/)
* [Checkout Sessions Documentation](https://docs.dodopayments.com/developer-resources/checkout-sessions)
* [Webhooks Documentation](https://docs.dodopayments.com/developer-resources/webhooks)

## Support

Need help with the boilerplate?

* Join our [Discord community](https://discord.gg/bYqAp4ayYh) for questions and discussions
* Check the [GitHub repository](https://github.com/dodopayments/dodo-astro-minimal-boilerplate) for issues and updates
* Contact our [support team](mailto:support@dodopayments.com) for assistance


# Better-Auth Adapter
Source: https://docs.dodopayments.com/developer-resources/better-auth-adaptor

This guide shows you how to integrate Dodo Payments into your authentication flow using the Better-Auth adaptor.

# Overview

The <b>Better Auth Adapter</b> for Dodo Payments provides:

* Automatic customer creation on sign-up
* Checkout Sessions (preferred) with product slug mapping
* Self-service customer portal
* Metered usage ingestion and reporting endpoints for usage-based billing
* Real-time webhook event processing with signature verification
* Full TypeScript support

<Note>
  You need a Dodo Payments account and API keys to use this integration.
</Note>

# Prerequisites

* Node.js 20+
* Access to your Dodo Payments Dashboard
* Existing project using [better-auth](https://www.npmjs.com/package/better-auth)

# Installation

<Steps>
  <Step title="Install dependencies">
    Run the following command in your project root:

    ```bash theme={null}
    npm install @dodopayments/better-auth dodopayments better-auth zod
    ```

    <Check>
      All required packages are now installed.
    </Check>
  </Step>
</Steps>

# Setup

<Steps>
  <Step title="Configure environment variables">
    Add these to your <code>.env</code> file:

    ```env expandable theme={null}
    DODO_PAYMENTS_API_KEY=your_api_key_here
    DODO_PAYMENTS_WEBHOOK_SECRET=your_webhook_secret_here
    BETTER_AUTH_URL=http://localhost:3000
    BETTER_AUTH_SECRET=your_better_auth_secret_here
    ```

    <Warning>
      Never commit API keys or secrets to version control.
    </Warning>
  </Step>

  <Step title="Set up server-side integration">
    Create or update <code>src/lib/auth.ts</code>:

    ```typescript expandable theme={null}
    import { betterAuth } from "better-auth";
    import {
      dodopayments,
      checkout,
      portal,
      webhooks,
      usage,
    } from "@dodopayments/better-auth";
    import DodoPayments from "dodopayments";

    export const dodoPayments = new DodoPayments({
      bearerToken: process.env.DODO_PAYMENTS_API_KEY!,
      environment: "test_mode", // or "live_mode" for production
    });

    export const { auth, endpoints, client } = BetterAuth({
      plugins: [
        dodopayments({
          client: dodoPayments,
          createCustomerOnSignUp: true,
          use: [
            checkout({
              products: [
                {
                  productId: "pdt_xxxxxxxxxxxxxxxxxxxxx",
                  slug: "premium-plan",
                },
              ],
              successUrl: "/dashboard/success",
              authenticatedUsersOnly: true,
            }),
            portal(),
            webhooks({
              webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_SECRET!,
              onPayload: async (payload) => {
                console.log("Received webhook:", payload.event_type);
              },
            }),
            usage(),
          ],
        }),
      ],
    });
    ```

    <Tip>
      Set <code>environment</code> to <code>live\_mode</code> for production.
    </Tip>
  </Step>

  <Step title="Set up client-side integration">
    Create or update <code>src/lib/auth-client.ts</code>:

    ```typescript expandable theme={null}
    import { createAuthClient } from "better-auth/react";
    import { dodopaymentsClient } from "@dodopayments/better-auth";

    export const authClient = createAuthClient({
      baseURL: process.env.BETTER_AUTH_URL || "http://localhost:3000",
      plugins: [dodopaymentsClient()],
    });
    ```
  </Step>
</Steps>

# Usage Examples

<Info>
  Prefer <code>authClient.dodopayments.checkoutSession</code> for new
  integrations. The legacy <code>checkout</code> method is deprecated and kept
  only for backward compatibility.
</Info>

## Creating a Checkout Session (Preferred)

<CodeGroup>
  ```typescript Using a slug theme={null}
  const { data: session, error } = await authClient.dodopayments.checkoutSession({
    // Option A: use a configured slug
    slug: "premium-plan",

  // Your internal id for reference
  referenceId: "order_123",
  });

  if (session) {
  window.location.href = session.url;
  }

  ```

  ```typescript Using product cart theme={null}
  const { data: session, error } = await authClient.dodopayments.checkoutSession({
    // Option B: pass a product cart/product id directly
    product_cart: [
      {
        product_id: "pdt_xxxxxxxxxxxxxxxxxxxxx",
        quantity: 1,
      }
    ],

    // Your internal id for reference
    referenceId: "order_123",
  });

  if (session) {
    window.location.href = session.url;
  }
  ```
</CodeGroup>

<Info>
  Unlike the legacy <code>checkout</code> method, <code>checkoutSession</code>
  does not require billing information upfront as it will be taken from the user
  at the checkout page. You can still override it by passing the
  <code>billing</code> key in the argument.
</Info>

<Info>
  Similar to the legacy <code>checkout</code> method,
  <code>checkoutSession</code> takes customer's email and name from their
  better-auth session, however, you can override it by passing the
  <code>customer</code> object with email and name.
</Info>

<Info>
  You can pass the same options in the argument as the request body for [Create
  Checkout
  Session](https://docs.dodopayments.com/api-reference/checkout-sessions/create)
  endpoint.
</Info>

<Note>
  The return URL is taken from the <code>successUrl</code> configured in the
  server plugin. You do not need to include <code>return\_url</code> in the
  client payload.
</Note>

## Legacy Checkout (Deprecated)

<Warning>
  The <code>authClient.dodopayments.checkout</code> method is deprecated. Use
  <code>checkoutSession</code> instead for new implementations.
</Warning>

```typescript expandable theme={null}
const { data: checkout, error } = await authClient.dodopayments.checkout({
  slug: "premium-plan",
  customer: {
    email: "customer@example.com",
    name: "John Doe",
  },
  billing: {
    city: "San Francisco",
    country: "US",
    state: "CA",
    street: "123 Market St",
    zipcode: "94103",
  },
  referenceId: "order_123",
});

if (checkout) {
  window.location.href = checkout.url;
}
```

## Accessing the Customer Portal

```typescript expandable theme={null}
const { data: customerPortal, error } =
  await authClient.dodopayments.customer.portal();
if (customerPortal && customerPortal.redirect) {
  window.location.href = customerPortal.url;
}
```

## Listing Customer Data

```typescript expandable theme={null}
// Get subscriptions
const { data: subscriptions, error } =
  await authClient.dodopayments.customer.subscriptions.list({
    query: {
      limit: 10,
      page: 1,
      status: "active",
    },
  });

// Get payment history
const { data: payments, error } =
  await authClient.dodopayments.customer.payments.list({
    query: {
      limit: 10,
      page: 1,
      status: "succeeded",
    },
  });
```

## Tracking Metered Usage

Enable the <code>usage()</code> plugin on the server to capture metered events and let customers inspect their usage-based billing.

* <code>authClient.dodopayments.usage.ingest</code> ingests events for the signed-in, email-verified user.
* <code>authClient.dodopayments.usage.meters.list</code> lists recent usage for the meters tied to that customer’s subscriptions.

```typescript expandable theme={null}
// Record a metered event (e.g., an API request)
const { error: ingestError } = await authClient.dodopayments.usage.ingest({
  event_id: crypto.randomUUID(),
  event_name: "api_request",
  metadata: {
    route: "/reports",
    method: "GET",
  },
  // Optional Date; defaults to now if omitted
  timestamp: new Date(),
});

if (ingestError) {
  console.error("Failed to record usage", ingestError);
}

// List recent usage for the current customer
const { data: usage, error: usageError } =
  await authClient.dodopayments.usage.meters.list({
    query: {
      page_size: 20,
      meter_id: "mtr_yourMeterId", // optional
    },
  });

if (usage?.items) {
  usage.items.forEach((event) => {
    console.log(event.event_name, event.timestamp, event.metadata);
  });
}
```

<Tip>
  Timestamps older than one hour or more than five minutes into the future are
  rejected when ingesting usage.
</Tip>

<Tip>
  If you omit <code>meter\_id</code> when listing usage meters, all meters
  tied to the customer’s subscriptions are returned.
</Tip>

# Webhooks

<Info>
  The webhooks plugin processes real-time payment events from Dodo Payments with
  secure signature verification. The default endpoint is
  <code>/api/auth/dodopayments/webhooks</code>.
</Info>

<Steps>
  <Step title="Generate and set webhook secret">
    Generate a webhook secret for your endpoint URL (e.g., <code>https\://\<your-domain>/api/auth/dodopayments/webhooks</code>) in the Dodo Payments Dashboard and set it in your <code>.env</code> file:

    ```env theme={null}
    DODO_PAYMENTS_WEBHOOK_SECRET=your_webhook_secret_here
    ```
  </Step>

  <Step title="Handle webhook events">
    Example handler:

    ```typescript expandable theme={null}
    webhooks({
      webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_SECRET!,
      onPayload: async (payload) => {
        console.log("Received webhook:", payload.event_type);
      },
    });
    ```
  </Step>
</Steps>

### Supported Webhook Event Handlers

<CodeGroup>
  ```typescript Typescript expandable theme={null}
  onPayload?: (payload: WebhookPayload) => Promise<void>;
  onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onPaymentFailed?: (payload: WebhookPayload) => Promise<void>;
  onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>;
  onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>;
  onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onRefundFailed?: (payload: WebhookPayload) => Promise<void>;
  onDisputeOpened?: (payload: WebhookPayload) => Promise<void>;
  onDisputeExpired?: (payload: WebhookPayload) => Promise<void>;
  onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>;
  onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>;
  onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>;
  onDisputeWon?: (payload: WebhookPayload) => Promise<void>;
  onDisputeLost?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>;
  onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>;
  ```
</CodeGroup>

# Configuration Reference

<AccordionGroup>
  <Accordion title="Plugin Options">
    * <b>client</b> (required): DodoPayments client instance -
      <b>createCustomerOnSignUp</b> (optional): Auto-create customers on user
      signup - <b>use</b> (required): Array of plugins to enable (checkout,
      portal, usage, webhooks)
  </Accordion>

  <Accordion title="Checkout Plugin Options">
    * <b>products</b>: Array of products or async function returning products -
      <b>successUrl</b>: URL to redirect after successful payment -
      <b>authenticatedUsersOnly</b>: Require user authentication (default: false)
  </Accordion>
</AccordionGroup>

# Troubleshooting & Tips

<AccordionGroup>
  <Accordion title="Common Issues">
    * <b>Invalid API key</b>: Double-check your
      <code>DODO\_PAYMENTS\_API\_KEY</code> in <code>.env</code>. -
      <b>Webhook signature mismatch</b>: Ensure the webhook secret matches the one
      set in the Dodo Payments Dashboard. - <b>Customer not created</b>: Confirm
      <code>createCustomerOnSignUp</code> is set to <code>true</code>.
  </Accordion>

  <Accordion title="Best Practices">
    * Use environment variables for all secrets and keys. - Test in
      <code>test\_mode</code> before switching to <code>live\_mode</code>. - Log
      webhook events for debugging and auditing.
  </Accordion>
</AccordionGroup>

# Prompt for LLMs

```text expandable theme={null}
You are a skilled developer helping to integrate the @dodopayments/better-auth adapter into a typescript web application with better-auth. This adapter enables seamless payment processing through Dodo Payments with automatic customer management, checkout flows, and webhook handling.
STAGE 1: BASIC SETUP
This stage covers the foundational setup needed before implementing any plugins. Complete this stage first.
STEP 1: Installation
Install the required dependencies:
npm install @dodopayments/better-auth dodopayments better-auth zod
STEP 2: Environment Variables Setup
You will need to complete these external setup tasks. I will provide you with a TODO list for the actions you need to take outside of the code:
TODO LIST FOR USER:
1. Generate Dodo Payments API Key:
   - Go to your Dodo Payments Dashboard > Developer > API Keys
   - Create a new API key (or use existing)
   - Copy the API key value
   - Set environment variable: DODO_PAYMENTS_API_KEY=your_api_key_here
2. Generate Better Auth Secret:
   - Generate a random secret key (32+ characters)
   - Set environment variable: BETTER_AUTH_SECRET=your_better_auth_secret_here
3. Set Application URL:
   - For development: BETTER_AUTH_URL=http://localhost:3000
   - For production: BETTER_AUTH_URL=https://your-domain.com
4. Webhook Secret (only if implementing webhooks plugin):
   - This will be provided after you specify your domain name in Stage 2
   - Set environment variable: DODO_PAYMENTS_WEBHOOK_SECRET=your_webhook_secret_here
Add these environment variables to your .env file:
DODO_PAYMENTS_API_KEY=your_api_key_here
DODO_PAYMENTS_WEBHOOK_SECRET=your_webhook_secret_here
BETTER_AUTH_URL=http://localhost:3000
BETTER_AUTH_SECRET=your_better_auth_secret_here
STEP 3: Server Configuration
Create or update your better-auth setup file (src/lib/auth.ts):
import { BetterAuth } from "better-auth";
import { dodopayments } from "@dodopayments/better-auth";
import DodoPayments from "dodopayments";
// Create DodoPayments client
export const dodoPayments = new DodoPayments({
  bearerToken: process.env.DODO_PAYMENTS_API_KEY!,
  environment: "test_mode", // Change to "live_mode" for production
});
// Configure better-auth with dodopayments adapter
export const { auth, endpoints, client } = BetterAuth({
  plugins: [
    dodopayments({
      client: dodoPayments,
      createCustomerOnSignUp: true, // Auto-create customers on signup
      use: [], // We'll add plugins here in Stage 2
    }),
  ],
});
STEP 4: Client Configuration
Create or update your auth client file (src/lib/auth-client.ts):
import { createAuthClient } from "better-auth/react";
import { dodopaymentsClient } from "@dodopayments/better-auth";
export const authClient = createAuthClient({
  baseURL: process.env.BETTER_AUTH_URL || "http://localhost:3000",
  plugins: [dodopaymentsClient()],
});
STAGE 2: PLUGIN IMPLEMENTATION
After completing Stage 1, you can selectively implement any of these plugins based on your needs. Each plugin is independent and can be added or removed as needed.
PLUGIN SELECTION:
Before implementing any plugins, ask the user which plugins they want to implement:
"Which plugins would you like to implement? You can choose any combination of:
1. CHECKOUT - Enables secure payment processing and checkout flows
2. PORTAL - Provides customer self-service portal for subscriptions and payments
3. USAGE - Tracks metered events and exposes usage history for billing beyond included allowances
4. WEBHOOKS - Handles real-time payment events from Dodo Payments
Please specify which plugins you want (e.g., 'checkout and usage', 'all four', 'just portal', etc.)"
If the user doesn't respond or you cannot prompt the user, implement all four plugins by default.
Based on the user's selection, implement only the requested plugins from the sections below:
CHECKOUT PLUGIN
Purpose: Enables secure payment processing using Checkout Sessions (preferred) with product slug mapping. A legacy checkout endpoint is also exposed for backward compatibility but is deprecated.
SETUP TODO LIST FOR USER:
1. Create products in Dodo Payments Dashboard:
   - Go to Dodo Payments Dashboard > Products
   - Create your products (e.g., subscription plans, one-time purchases)
   - Copy each product ID (starts with "pdt_")
   - Note down the product names for creating friendly slugs
2. Plan your checkout URLs:
   - Decide on your success URL (e.g., "/dashboard/success", "/thank-you")
   - Ensure this URL exists in your application
Configuration:
Add checkout to your imports in src/lib/auth.ts:
import { dodopayments, checkout } from "@dodopayments/better-auth";
Add checkout plugin to the use array in your dodopayments configuration:
use: [
  checkout({
    products: [
      {
        productId: "pdt_xxxxxxxxxxxxxxxxxxxxx", // Your actual product ID from Dodo Payments
        slug: "premium-plan", // Friendly slug for checkout
      },
      // Add more products as needed
    ],
    successUrl: "/dashboard/success", // Your success page URL
    authenticatedUsersOnly: true, // Require login for checkout
  }),
],
Usage Example (Preferred - Checkout Sessions):
const { data: session, error } = await authClient.dodopayments.checkoutSession({
  // Use the slug from your configuration OR provide product_cart directly
  slug: "premium-plan",
  // product_cart: [{ product_id: "pdt_xxxxxxxxxxxxxxxxxxxxx", quantity: 1 }],
  referenceId: "order_123", // Optional reference
});
if (session) {
  window.location.href = session.url;
}

Deprecated (Legacy Checkout):
const { data: checkout, error } = await authClient.dodopayments.checkout({
  slug: "premium-plan",
  customer: {
    email: "customer@example.com",
    name: "John Doe",
  },
  billing: {
    city: "San Francisco",
    country: "US",
    state: "CA",
    street: "123 Market St",
    zipcode: "94103",
  },
});
if (checkout) {
  window.location.href = checkout.url;
}
Options:
- products: Array of products or async function returning products
- successUrl: URL to redirect after successful payment
- authenticatedUsersOnly: Require user authentication (default: false)
PORTAL PLUGIN
Purpose: Provides customer self-service capabilities for managing subscriptions and viewing payment history.
Configuration:
Add portal to your imports in src/lib/auth.ts:
import { dodopayments, portal } from "@dodopayments/better-auth";
Add portal plugin to the use array in your dodopayments configuration:
use: [
  portal(),
],
Usage Examples:
// Access customer portal
const { data: customerPortal, error } = await authClient.dodopayments.customer.portal();
if (customerPortal && customerPortal.redirect) {
  window.location.href = customerPortal.url;
}
// List customer subscriptions
const { data: subscriptions, error } = await authClient.dodopayments.customer.subscriptions.list({
  query: {
    limit: 10,
    page: 1,
    active: true,
  },
});
// List customer payments
const { data: payments, error } = await authClient.dodopayments.customer.payments.list({
  query: {
    limit: 10,
    page: 1,
    status: "succeeded",
  },
});
Note: All portal methods require user authentication.

USAGE PLUGIN (METERED BILLING)
Purpose: Records metered events (like API requests) for usage-based plans and surfaces recent usage history per customer.

SETUP TODO LIST FOR USER:
1. Create or identify usage meters in the Dodo Payments Dashboard:
   - Dashboard > Usage > Meters
   - Copy the meter IDs (prefixed with <code>mtr_</code>) used by your usage-based plans
2. Decide which event names and metadata you will capture (e.g., <code>api_request</code>, route, method)
3. Ensure BetterAuth users verify their email addresses (the plugin enforces this before ingesting usage)

Configuration:
Add usage to your imports in <code>src/lib/auth.ts</code>:
    import { dodopayments, usage } from "@dodopayments/better-auth";

Add the plugin to the <code>use</code> array:
    use: [
      usage(),
    ],

Usage Examples:

    // Record a metered event for the signed-in customer
    const { error: ingestError } = await authClient.dodopayments.usage.ingest({
      event_id: crypto.randomUUID(),
      event_name: "api_request",
      metadata: {
        route: "/reports",
        method: "GET",
      },
      // Optional Date or ISO string; defaults to now
      timestamp: new Date(),
    });

    if (ingestError) {
      console.error("Failed to record usage", ingestError);
    }

    // List recent usage for the current customer
    const { data: usage, error: usageError } =
      await authClient.dodopayments.usage.meters.list({
        query: {
          page_size: 20,
          meter_id: "mtr_yourMeterId", // optional filter
        },
      });

    if (usage?.items) {
      usage.items.forEach((event) => {
        console.log(event.event_name, event.timestamp, event.metadata);
      });
    }

<Tip>
  The plugin exposes <code>authClient.dodopayments.usage.ingest</code> and
  <code>authClient.dodopayments.usage.meters.list</code>. Timestamps older
  than one hour or more than five minutes in the future are rejected.
</Tip>
<Tip>
  If you do
  not pass <code>meter_id</code> when listing usage meters, all meters tied to 
  the customer’s active subscriptions are returned.
</Tip>
WEBHOOKS PLUGIN
Purpose: Handles real-time payment events from Dodo Payments with secure signature verification.
BEFORE CONFIGURATION - Setup Webhook URL:
First, I need your domain name to generate the webhook URL and provide you with setup instructions.
STEP 1: Domain Name Input
What is your domain name? Please provide:
- For production: your domain name (e.g., "myapp.com", "api.mycompany.com")
- For staging: your staging domain (e.g., "staging.myapp.com")
- For development: use "localhost:3000" (or your local port)
STEP 2: After receiving your domain name, I will:
- Generate your webhook URL: https://[YOUR-DOMAIN]/api/auth/dodopayments/webhooks
- Provide you with a TODO list for webhook setup in Dodo Payments dashboard
- Give you the exact environment variable setup instructions
WEBHOOK SETUP TODO LIST (will be provided after domain input):
1. Configure webhook in Dodo Payments Dashboard:
   - Go to Dodo Payments Dashboard > Developer > Webhooks
   - Click "Add Webhook" or "Create Webhook"
   - Enter webhook URL: https://[YOUR-DOMAIN]/api/auth/dodopayments/webhooks
   - Select events you want to receive (or select all)
   - Copy the generated webhook secret
2. Set webhook secret in your environment:
   - For production: Set DODO_PAYMENTS_WEBHOOK_SECRET in your hosting provider environment
   - For staging: Set DODO_PAYMENTS_WEBHOOK_SECRET in your staging environment
   - For development: Add DODO_PAYMENTS_WEBHOOK_SECRET=your_webhook_secret_here to your .env file
3. Deploy your application with the webhook secret configured
STEP 3: Add webhooks to your imports in src/lib/auth.ts:
import { dodopayments, webhooks } from "@dodopayments/better-auth";
STEP 4: Add webhooks plugin to the use array in your dodopayments configuration:
use: [
  webhooks({
    webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_SECRET!,
    // Generic handler for all webhook events
    onPayload: async (payload) => {
      console.log("Received webhook:", payload.event_type);
    },
    // Payment event handlers
    onPaymentSucceeded: async (payload) => {
      console.log("Payment succeeded:", payload);
    },
    onPaymentFailed: async (payload) => {
      console.log("Payment failed:", payload);
    },
    onPaymentProcessing: async (payload) => {
      console.log("Payment processing:", payload);
    },
    onPaymentCancelled: async (payload) => {
      console.log("Payment cancelled:", payload);
    },
    // Refund event handlers
    onRefundSucceeded: async (payload) => {
      console.log("Refund succeeded:", payload);
    },
    onRefundFailed: async (payload) => {
      console.log("Refund failed:", payload);
    },
    // Dispute event handlers
    onDisputeOpened: async (payload) => {
      console.log("Dispute opened:", payload);
    },
    onDisputeExpired: async (payload) => {
      console.log("Dispute expired:", payload);
    },
    onDisputeAccepted: async (payload) => {
      console.log("Dispute accepted:", payload);
    },
    onDisputeCancelled: async (payload) => {
      console.log("Dispute cancelled:", payload);
    },
    onDisputeChallenged: async (payload) => {
      console.log("Dispute challenged:", payload);
    },
    onDisputeWon: async (payload) => {
      console.log("Dispute won:", payload);
    },
    onDisputeLost: async (payload) => {
      console.log("Dispute lost:", payload);
    },
    // Subscription event handlers
    onSubscriptionActive: async (payload) => {
      console.log("Subscription active:", payload);
    },
    onSubscriptionOnHold: async (payload) => {
      console.log("Subscription on hold:", payload);
    },
    onSubscriptionRenewed: async (payload) => {
      console.log("Subscription renewed:", payload);
    },
    onSubscriptionPlanChanged: async (payload) => {
      console.log("Subscription plan changed:", payload);
    },
    onSubscriptionCancelled: async (payload) => {
      console.log("Subscription cancelled:", payload);
    },
    onSubscriptionFailed: async (payload) => {
      console.log("Subscription failed:", payload);
    },
    onSubscriptionExpired: async (payload) => {
      console.log("Subscription expired:", payload);
    },
    // License key event handlers
    onLicenseKeyCreated: async (payload) => {
      console.log("License key created:", payload);
    },
  }),
],
Supported Webhook Event Handlers:
- onPayload: Generic handler for all webhook events
- onPaymentSucceeded: Payment completed successfully
- onPaymentFailed: Payment failed
- onPaymentProcessing: Payment is being processed
- onPaymentCancelled: Payment was cancelled
- onRefundSucceeded: Refund completed successfully
- onRefundFailed: Refund failed
- onDisputeOpened: Dispute was opened
- onDisputeExpired: Dispute expired
- onDisputeAccepted: Dispute was accepted
- onDisputeCancelled: Dispute was cancelled
- onDisputeChallenged: Dispute was challenged
- onDisputeWon: Dispute was won
- onDisputeLost: Dispute was lost
- onSubscriptionActive: Subscription became active
- onSubscriptionOnHold: Subscription was put on hold
- onSubscriptionRenewed: Subscription was renewed
- onSubscriptionPlanChanged: Subscription plan was changed
- onSubscriptionCancelled: Subscription was cancelled
- onSubscriptionFailed: Subscription failed
- onSubscriptionExpired: Subscription expired
- onLicenseKeyCreated: License key was created
COMBINING SELECTED PLUGINS:
After implementing the user's selected plugins, update your <code>src/lib/auth.ts</code> file to include all chosen plugins in the imports and <code>use</code> array:

Example for all four plugins:
    import {
      dodopayments,
      checkout,
      portal,
      usage,
      webhooks,
    } from "@dodopayments/better-auth";

    use: [
      checkout({
        // checkout configuration
      }),
      portal(),
      usage(),
      webhooks({
        // webhook configuration
      }),
    ];

Example for checkout + portal + usage:
    import { dodopayments, checkout, portal, usage } from "@dodopayments/better-auth";

    use: [
      checkout({
        // checkout configuration
      }),
      portal(),
      usage(),
    ];

Example for just webhooks:
    import { dodopayments, webhooks } from "@dodopayments/better-auth";

    use: [
      webhooks({
        // webhook configuration
      }),
    ];
IMPORTANT NOTES:
1. Complete Stage 1 before implementing any plugins
2. Ask the user which plugins they want to implement, or implement all four if no response
3. Only implement the plugins the user specifically requested
4. ALWAYS provide TODO lists for external actions the user needs to complete:
   - API key generation and environment variable setup
   - Product creation in Dodo Payments dashboard (for checkout plugin)
   - Usage meter configuration and API event definition (for usage plugin)
   - Webhook setup in Dodo Payments dashboard (for webhooks plugin)
   - Domain name collection for webhook URL generation
5. For webhook plugin: Ask for the user's domain name and generate the exact webhook URL: https://[domain]/api/auth/dodopayments/webhooks
6. The usage plugin requires the BetterAuth session user to exist and have a verified email before ingesting or listing usage
7. All client methods return <code>{ data, error }</code> objects for proper error handling
8. Use <code>test_mode</code> for development and <code>live_mode</code> for production
9. The webhook endpoint is automatically created and secured with signature verification (if webhooks plugin is selected)
10. Customer portal and subscription listing require user authentication (if portal plugin is selected)
11. Handle errors appropriately and test webhook functionality in development before going live
12. Present all external setup tasks as clear TODO lists with specific environment variable names

```


# Bun Adaptor
Source: https://docs.dodopayments.com/developer-resources/bun-adaptor

Learn how to integrate Dodo Payments with your Bun server project using our Bun Adaptor. Covers checkout, customer portal, webhooks, and secure environment setup.

<CardGroup>
  <Card title="Checkout Handler" icon="cart-shopping" href="#checkout-route-handler">
    Integrate Dodo Payments checkout into your Bun server.
  </Card>

  <Card title="Customer Portal" icon="user" href="#customer-portal-route-handler">
    Allow customers to manage subscriptions and details.
  </Card>

  <Card title="Webhooks" icon="bell" href="#webhook-route-handler">
    Receive and process Dodo Payments webhook events.
  </Card>
</CardGroup>

## Installation

<Steps>
  <Step title="Install the package">
    Run the following command in your project root:

    ```bash theme={null}
    bun add @dodopayments/bun
    ```
  </Step>

  <Step title="Set up environment variables">
    Create a <code>.env</code> file in your project root:

    ```env expandable theme={null}
    DODO_PAYMENTS_API_KEY=your-api-key
    DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
    DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode"
    DODO_PAYMENTS_RETURN_URL=your-return-url
    ```

    <Warning>
      Never commit your <code>.env</code> file or secrets to version control.
    </Warning>
  </Step>
</Steps>

## Route Handler Examples

<Info>
  All examples assume you are using Bun's native server with <code>Bun.serve()</code>.
</Info>

<Tabs>
  <Tab title="Checkout Handler">
    <Info>
      Use this handler to integrate Dodo Payments checkout into your Bun server. Supports static (GET), dynamic (POST), and session (POST) payment flows.
    </Info>

    <CodeGroup>
      ```typescript Bun Server Handler expandable theme={null}
      import { Checkout } from '@dodopayments/bun';

      const staticCheckoutHandler = Checkout({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
          environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
          type: "static"
      });

      const sessionCheckoutHandler = Checkout({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
          environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
          type: "session"
      });

      const dynamicCheckoutHandler = Checkout({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
          environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
          type: "dynamic"
      });

      Bun.serve({
        port: 3000,
        fetch(request) {
          const url = new URL(request.url);
          
          if (url.pathname === "/api/checkout") {
            if (request.method === "GET") {
              return staticCheckoutHandler(request);
            }
            if (request.method === "POST") {
              return sessionCheckoutHandler(request);
              // or return dynamicCheckoutHandler(request);
            }
          }
          
          return new Response("Not Found", { status: 404 });
        },
      });
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Static Checkout Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/checkout?productId=pdt_xxx' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Dynamic Checkout Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "billing": {
        "city": "Texas",
        "country": "US",
        "state": "Texas",
        "street": "56, hhh",
        "zipcode": "560000"
      },
      "customer": {
        "email": "test@example.com",
        	"name": "test"
      },
      "metadata": {},
      "payment_link": true,
        "product_id": "pdt_xxx",
        "quantity": 1,
        "billing_currency": "USD",
        "discount_code": "IKHZ23M9GQ",
        "return_url": "https://example.com",
        "trial_period_days": 10
      }'
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Checkout Session Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "product_cart": [
        {
          "product_id": "pdt_xxx",
          "quantity": 1
        }
      ],
      "customer": {
        "email": "test@example.com",
        "name": "test"
      },
      "return_url": "https://example.com/success"
      }'
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Customer Portal Handler">
    <Info>
      Use this handler to allow customers to manage their subscriptions and details via the Dodo Payments customer portal.
    </Info>

    <CodeGroup>
      ```typescript Bun Server Handler expandable theme={null}
      import { CustomerPortal } from "@dodopayments/bun";

      const customerPortalHandler = CustomerPortal({
        bearerToken: process.env.DODO_PAYMENTS_API_KEY,
        environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
      });

      Bun.serve({
        port: 3000,
        fetch(request) {
          const url = new URL(request.url);
          
          if (url.pathname === "/api/customer-portal" && request.method === "GET") {
            return customerPortalHandler(request);
          }
          
          return new Response("Not Found", { status: 404 });
        },
      });
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Customer Portal Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/customer-portal?customer_id=cus_123&send_email=true' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Webhook Handler">
    <Info>
      Use this handler to receive and process Dodo Payments webhook events securely in your Bun server.
    </Info>

    <CodeGroup>
      ```typescript Bun Server Handler expandable theme={null}
      import { Webhooks } from "@dodopayments/bun";

      const webhookHandler = Webhooks({
        webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_KEY,
        onPayload: async (payload) => {
          // handle the payload
        },
        // ... other event handlers for granular control
      });

      Bun.serve({
        port: 3000,
        fetch(request) {
          const url = new URL(request.url);
          
          if (url.pathname === "/api/webhook/dodo-payments" && request.method === "POST") {
            return webhookHandler(request);
          }
          
          return new Response("Not Found", { status: 404 });
        },
      });
      ```
    </CodeGroup>
  </Tab>
</Tabs>

## Checkout Route Handler

<Info>
  Dodo Payments supports three types of payment flows for integrating payments into your website, this adaptor supports all types of payment flows.
</Info>

* **Static Payment Links:** Instantly shareable URLs for quick, no-code payment collection.
* **Dynamic Payment Links:** Programmatically generate payment links with custom details using the API or SDKs.
* **Checkout Sessions:** Create secure, customizable checkout experiences with pre-configured product carts and customer details.

<AccordionGroup>
  <Accordion title="Static Checkout (GET)">
    ### Supported Query Parameters

    <ParamField type="string">
      Product identifier (e.g., <code>?productId=pdt\_xxx</code>).
    </ParamField>

    <ParamField type="integer">
      Quantity of the product.
    </ParamField>

    <ParamField type="string">
      Customer's full name.
    </ParamField>

    <ParamField type="string">
      Customer's first name.
    </ParamField>

    <ParamField type="string">
      Customer's last name.
    </ParamField>

    <ParamField type="string">
      Customer's email address.
    </ParamField>

    <ParamField type="string">
      Customer's country.
    </ParamField>

    <ParamField type="string">
      Customer's address line.
    </ParamField>

    <ParamField type="string">
      Customer's city.
    </ParamField>

    <ParamField type="string">
      Customer's state/province.
    </ParamField>

    <ParamField type="string">
      Customer's zip/postal code.
    </ParamField>

    <ParamField type="boolean">
      Disable full name field.
    </ParamField>

    <ParamField type="boolean">
      Disable first name field.
    </ParamField>

    <ParamField type="boolean">
      Disable last name field.
    </ParamField>

    <ParamField type="boolean">
      Disable email field.
    </ParamField>

    <ParamField type="boolean">
      Disable country field.
    </ParamField>

    <ParamField type="boolean">
      Disable address line field.
    </ParamField>

    <ParamField type="boolean">
      Disable city field.
    </ParamField>

    <ParamField type="boolean">
      Disable state field.
    </ParamField>

    <ParamField type="boolean">
      Disable zip code field.
    </ParamField>

    <ParamField type="string">
      Specify the payment currency (e.g., <code>USD</code>).
    </ParamField>

    <ParamField type="boolean">
      Show currency selector.
    </ParamField>

    <ParamField type="integer">
      Specify the payment amount (e.g., <code>1000</code> for \$10.00).
    </ParamField>

    <ParamField type="boolean">
      Show discount fields.
    </ParamField>

    <ParamField type="string">
      Any query parameter starting with <code>metadata\_</code> will be passed as metadata.
    </ParamField>

    <Warning>
      If <code>productId</code> is missing, the handler returns a 400 response. Invalid query parameters also result in a 400 response.
    </Warning>

    ### Response Format

    Static checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Dynamic Checkout (POST)">
    * Send parameters as a JSON body in a POST request.
    * Supports both one-time and recurring payments.
    * For a complete list of supported POST body fields, refer to:
      * [Request body for a One Time Payment Product](https://docs.dodopayments.com/api-reference/payments/post-payments)
      * [Request body for a Subscription Product](https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions)

    ### Response Format

    Dynamic checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Checkout Sessions (POST)">
    Checkout sessions provide a more secure, hosted checkout experience that handles the complete payment flow for both one-time purchases and subscriptions with full customization control.

    Refer to [Checkout Sessions Integration Guide](https://docs.dodopayments.com/developer-resources/checkout-session) for more details and a complete list of supported fields.

    ### Response Format

    Checkout sessions return a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/session/..."
    }
    ```
  </Accordion>
</AccordionGroup>

## Customer Portal Route Handler

The Customer Portal Route Handler enables you to seamlessly integrate the Dodo Payments customer portal into your Bun server application.

### Query Parameters

<ParamField type="string">
  The customer ID for the portal session (e.g., <code>?customer\_id=cus\_123</code>).
</ParamField>

<ParamField type="boolean">
  If set to <code>true</code>, sends an email to the customer with the portal link.
</ParamField>

<Warning>
  Returns 400 if <code>customer\_id</code> is missing.
</Warning>

## Webhook Route Handler

* **Method:** Only POST requests are supported. Other methods return 405.
* **Signature Verification:** Verifies the webhook signature using <code>webhookKey</code>. Returns 401 if verification fails.
* **Payload Validation:** Validated with Zod. Returns 400 for invalid payloads.
* **Error Handling:**
  * 401: Invalid signature
  * 400: Invalid payload
  * 500: Internal error during verification
* **Event Routing:** Calls the appropriate event handler based on the payload type.

### Supported Webhook Event Handlers

<CodeGroup>
  ```typescript Typescript expandable theme={null}
  onPayload?: (payload: WebhookPayload) => Promise<void>;
  onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onPaymentFailed?: (payload: WebhookPayload) => Promise<void>;
  onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>;
  onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>;
  onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onRefundFailed?: (payload: WebhookPayload) => Promise<void>;
  onDisputeOpened?: (payload: WebhookPayload) => Promise<void>;
  onDisputeExpired?: (payload: WebhookPayload) => Promise<void>;
  onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>;
  onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>;
  onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>;
  onDisputeWon?: (payload: WebhookPayload) => Promise<void>;
  onDisputeLost?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>;
  onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>;
  ```
</CodeGroup>

***

## Prompt for LLM

````

You are an expert Bun developer assistant. Your task is to guide a user through integrating the @dodopayments/bun adapter into their existing Bun project.

The @dodopayments/bun adapter provides handlers for Dodo Payments' Checkout, Customer Portal, and Webhook functionalities, designed for Bun's native server with Bun.serve().

First, install the necessary package:

bun add @dodopayments/bun

Here's how you should structure your response:

    Ask the user which functionalities they want to integrate.

"Which parts of the @dodopayments/bun adapter would you like to integrate into your project? You can choose one or more of the following:
1. Checkout (static, dynamic, or session-based)
2. Customer Portal
3. Webhooks"

    Based on the user's selection, provide step-by-step integration instructions.

For each selected functionality, show:

    The environment variables required
    The exact code to add to their server file
    Where to place the code in their Bun.serve() configuration

Provide complete, working examples that the user can copy and paste directly into their project.

    Environment Variables Setup

Always include instructions for setting up the .env file:

DODO_PAYMENTS_API_KEY=your-api-key
DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode"
DODO_PAYMENTS_RETURN_URL=your-return-url

Remind the user to never commit their .env file to version control.

    For Checkout Integration

If the user selects Checkout, ask which type they need:

    Static checkout (GET requests with query parameters)
    Dynamic checkout (POST requests with JSON body)
    Checkout sessions (POST requests with product cart)

Provide the appropriate handler code for their selection.

    For Customer Portal Integration

Provide a complete example showing how to integrate the customer portal handler into their Bun server.

    For Webhook Integration

Provide a complete example showing how to integrate the webhook handler with available event handlers for granular control.

    Full Example

If the user wants to integrate all three functionalities, provide a complete Bun server example that combines all handlers.

```typescript
import { Checkout, CustomerPortal, Webhooks } from "@dodopayments/bun";

const staticCheckoutHandler = Checkout({
  bearerToken: process.env.DODO_PAYMENTS_API_KEY,
  returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
  environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
  type: "static",
});

const sessionCheckoutHandler = Checkout({
  bearerToken: process.env.DODO_PAYMENTS_API_KEY,
  returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
  environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
  type: "session",
});

const customerPortalHandler = CustomerPortal({
  bearerToken: process.env.DODO_PAYMENTS_API_KEY,
  environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
});

const webhookHandler = Webhooks({
  webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_KEY,
  onPaymentSucceeded: async (payload) => {
    console.log("Payment succeeded:", payload);
    // Your business logic here
  },
  onSubscriptionActive: async (payload) => {
    console.log("Subscription activated:", payload);
    // Your business logic here
  },
});

Bun.serve({
  port: 3000,
  fetch(request) {
    const url = new URL(request.url);
    
    // Checkout routes
    if (url.pathname === "/api/checkout") {
      if (request.method === "GET") {
        return staticCheckoutHandler(request);
      }
      if (request.method === "POST") {
        return sessionCheckoutHandler(request);
      }
    }
    
    // Customer portal route
    if (url.pathname === "/api/customer-portal" && request.method === "GET") {
      return customerPortalHandler(request);
    }
    
    // Webhook route
    if (url.pathname === "/api/webhook/dodo-payments" && request.method === "POST") {
      return webhookHandler(request);
    }
    
    return new Response("Not Found", { status: 404 });
  },
});

console.log("Server running on http://localhost:3000");

Additional Guidance:
• Explain that the handlers are Bun-native and work seamlessly with Bun.serve()
• Highlight the use of Web Standard Request and Response objects
• Mention that error handling is built-in and returns appropriate HTTP status codes
• Provide links to the Dodo Payments documentation for more details
````


# Convex Component
Source: https://docs.dodopayments.com/developer-resources/convex-component

Learn how to integrate Dodo Payments with your Convex backend using our Convex Component. Covers checkout functions, customer portal, webhooks, and secure environment setup.

<CardGroup>
  <Card title="Checkout Function" icon="cart-shopping" href="#checkout-function">
    Integrate Dodo Payments checkout with session-based flow.
  </Card>

  <Card title="Customer Portal" icon="user" href="#customer-portal-function">
    Allow customers to manage subscriptions and details.
  </Card>

  <Card title="Webhooks" icon="bell" href="#webhook-handler">
    Receive and process Dodo Payments webhook events.
  </Card>
</CardGroup>

## Installation

<Steps>
  <Step title="Install the package">
    Run the following command in your project root:

    ```bash theme={null}
    npm install @dodopayments/convex
    ```
  </Step>

  <Step title="Add Component to Convex Config">
    Add the Dodo Payments component to your Convex configuration:

    ```typescript theme={null}
    // convex/convex.config.ts
    import { defineApp } from "convex/server";
    import dodopayments from "@dodopayments/convex/convex.config";

    const app = defineApp();
    app.use(dodopayments);
    export default app;
    ```

    After editing `convex.config.ts`, run `npx convex dev` once to generate the necessary types.
  </Step>

  <Step title="Set up environment variables">
    Set up environment variables in your Convex dashboard (**Settings** → **Environment Variables**). You can access the dashboard by running:

    ```bash theme={null}
    npx convex dashboard
    ```

    Add the following environment variables:

    * `DODO_PAYMENTS_API_KEY` - Your Dodo Payments API key
    * `DODO_PAYMENTS_ENVIRONMENT` - Set to `test_mode` or `live_mode`
    * `DODO_PAYMENTS_WEBHOOK_SECRET` - Your webhook secret (required for webhook handling)

    <Warning>
      Always use Convex environment variables for sensitive information. Never commit secrets to version control.
    </Warning>
  </Step>
</Steps>

## Component Setup Examples

<Steps>
  <Step title="Create Internal Query">
    First, create an internal query to fetch customers from your database. This will be used in the payment functions to identify customers.

    <Warning>
      Before using this query, make sure to define the appropriate schema in your `convex/schema.ts` file or change the query to match your existing schema.
    </Warning>

    ```typescript theme={null}
    // convex/customers.ts
    import { internalQuery } from "./_generated/server";
    import { v } from "convex/values";

    // Internal query to fetch customer by auth ID
    export const getByAuthId = internalQuery({
      args: { authId: v.string() },
      handler: async (ctx, { authId }) => {
        return await ctx.db
          .query("customers")
          .withIndex("by_auth_id", (q) => q.eq("authId", authId))
          .first();
      },
    });
    ```
  </Step>

  <Step title="Configure DodoPayments Component">
    <CodeGroup>
      ```typescript Convex Component Setup expandable theme={null}
      // convex/dodo.ts
      import { DodoPayments, DodoPaymentsClientConfig } from "@dodopayments/convex";
      import { components } from "./_generated/api";
      import { internal } from "./_generated/api";

      export const dodo = new DodoPayments(components.dodopayments, {
      // This function maps your Convex user to a Dodo Payments customer
      // Customize it based on your authentication provider and database
      identify: async (ctx) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          return null; // User is not logged in
        }
        
        // Use ctx.runQuery() to lookup customer from your database
        const customer = await ctx.runQuery(internal.customers.getByAuthId, {
          authId: identity.subject,
        });
        
        if (!customer) {
          return null; // Customer not found in database
        }
        
        return {
          dodoCustomerId: customer.dodoCustomerId, // Replace customer.dodoCustomerId with your field storing Dodo Payments customer ID
        };
      },
      apiKey: process.env.DODO_PAYMENTS_API_KEY!,
      environment: process.env.DODO_PAYMENTS_ENVIRONMENT as "test_mode" | "live_mode",
      } as DodoPaymentsClientConfig);

      // Export the API methods for use in your app
      export const { checkout, customerPortal } = dodo.api();
      ```
    </CodeGroup>
  </Step>
</Steps>

<Tabs>
  <Tab title="Checkout Function Setup">
    <Info>
      Use this function to integrate Dodo Payments checkout into your Convex app. Uses session-based checkout with full feature support.
    </Info>

    <CodeGroup>
      ```typescript Checkout Action expandable theme={null}
      // convex/payments.ts
      import { action } from "./_generated/server";
      import { v } from "convex/values";
      import { checkout } from "./dodo";

      export const createCheckout = action({
        args: { 
          product_cart: v.array(v.object({
            product_id: v.string(),
            quantity: v.number(),
          })),
          returnUrl: v.optional(v.string()),
        },
        handler: async (ctx, args) => {
          try {
            const session = await checkout(ctx, {
              payload: {
                product_cart: args.product_cart,
                return_url: args.returnUrl,
                billing_currency: "USD",
                feature_flags: {
                  allow_discount_code: true,
                },
              },
            });
            if (!session?.checkout_url) {
              throw new Error("Checkout session did not return a checkout_url");
            }
            return session;
          } catch (error) {
            console.error("Failed to create checkout session", error);
            throw new Error("Unable to create checkout session. Please try again.");
          }
        },
      });
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Customer Portal Setup">
    <Info>
      Use this function to allow customers to manage their subscriptions and details via the Dodo Payments customer portal. The customer is automatically identified via the `identify` function.
    </Info>

    <CodeGroup>
      ```typescript Customer Portal Action expandable theme={null}
      // convex/payments.ts (add to existing file)
      import { action } from "./_generated/server";
      import { v } from "convex/values";
      import { customerPortal } from "./dodo";

      export const getCustomerPortal = action({
        args: {
          send_email: v.optional(v.boolean()),
        },
          handler: async (ctx, args) => {
            try {
              const portal = await customerPortal(ctx, args);
              if (!portal?.portal_url) {
                throw new Error("Customer portal did not return a portal_url");
              }
              return portal;
            } catch (error) {
              console.error("Failed to generate customer portal link", error);
              throw new Error("Unable to generate customer portal link. Please try again.");
            }
          },
      });
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Webhook Handler Setup">
    <Info>
      Use this handler to receive and process Dodo Payments webhook events securely in your Convex app. All webhook handlers receive the Convex `ActionCtx` as the first parameter, allowing you to use `ctx.runQuery()` and `ctx.runMutation()` to interact with your database.
    </Info>

    <CodeGroup>
      ```typescript Convex HTTP Action expandable theme={null}
      // convex/http.ts
      import { createDodoWebhookHandler } from "@dodopayments/convex";
      import { httpRouter } from "convex/server";
      import { internal } from "./_generated/api";

      const http = httpRouter();

      http.route({
        path: "/dodopayments-webhook",
        method: "POST",
        handler: createDodoWebhookHandler({
          // Handle successful payments
          onPaymentSucceeded: async (ctx, payload) => {
            console.log("🎉 Payment Succeeded!");

            // Use Convex context to persist payment data
            await ctx.runMutation(internal.webhooks.createPayment, {
              paymentId: payload.data.payment_id,
              businessId: payload.business_id,
              customerEmail: payload.data.customer.email,
              amount: payload.data.total_amount,
              currency: payload.data.currency,
              status: payload.data.status,
              webhookPayload: JSON.stringify(payload),
            });
          },

          // Handle subscription activation
          onSubscriptionActive: async (ctx, payload) => {
            console.log("🎉 Subscription Activated!");
            // Use Convex context to persist subscription data
            await ctx.runMutation(internal.webhooks.createSubscription, {
              subscriptionId: payload.data.subscription_id,
              businessId: payload.business_id,
              customerEmail: payload.data.customer.email,
              status: payload.data.status,
              webhookPayload: JSON.stringify(payload),
            });
          },
          // Add other event handlers as needed
        }),
      });

      export default http;
      ```
    </CodeGroup>

    <Warning>
      Make sure to define the corresponding database mutations in your Convex backend for each webhook event you want to handle. For example, create a <code>createPayment</code> mutation to record successful payments or a <code>createSubscription</code> mutation to manage subscription state.
    </Warning>
  </Tab>
</Tabs>

## Checkout Function

<Info>
  The Dodo Payments Convex component uses session-based checkout, providing a secure, customizable checkout experience with pre-configured product carts and customer details. This is the recommended approach for all payment flows.
</Info>

### Usage

```typescript theme={null}
const result = await checkout(ctx, {
  payload: {
    product_cart: [{ product_id: "prod_123", quantity: 1 }],
    customer: { email: "user@example.com" },
    return_url: "https://example.com/success"
  }
});
```

Refer [Checkout Sessions](/developer-resources/checkout-session) for more details and a complete list of supported fields.

### Response Format

The checkout function returns a JSON response with the checkout URL:

```json theme={null}
{
  "checkout_url": "https://checkout.dodopayments.com/session/..."
}
```

## Customer Portal Function

The Customer Portal Function enables you to seamlessly integrate the Dodo Payments customer portal into your Convex application.

### Usage

```typescript theme={null}
const result = await customerPortal(ctx, {
  send_email: false
});
```

### Parameters

<ParamField type="boolean">
  If set to <code>true</code>, sends an email to the customer with the portal link.
</ParamField>

<Info>
  The customer is automatically identified using the `identify` function configured in your DodoPayments setup. This function should return the customer's `dodoCustomerId`.
</Info>

## Webhook Handler

* **Method:** Only POST requests are supported. Other methods return 405.
* **Signature Verification:** Verifies the webhook signature using <code>DODO\_PAYMENTS\_WEBHOOK\_SECRET</code>. Returns 401 if verification fails.
* **Payload Validation:** Validated with Zod. Returns 400 for invalid payloads.
* **Error Handling:**
  * 401: Invalid signature
  * 400: Invalid payload
  * 500: Internal error during verification
* **Event Routing:** Calls the appropriate event handler based on the payload type.

### Supported Webhook Event Handlers

<CodeGroup>
  ```typescript Typescript expandable theme={null}
  onPayload?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onPaymentSucceeded?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onPaymentFailed?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onPaymentProcessing?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onPaymentCancelled?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onRefundSucceeded?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onRefundFailed?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onDisputeOpened?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onDisputeExpired?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onDisputeAccepted?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onDisputeCancelled?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onDisputeChallenged?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onDisputeWon?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onDisputeLost?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onSubscriptionActive?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onSubscriptionOnHold?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onSubscriptionRenewed?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onSubscriptionPlanChanged?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onSubscriptionCancelled?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onSubscriptionFailed?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onSubscriptionExpired?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  onLicenseKeyCreated?: (ctx: GenericActionCtx, payload: WebhookPayload) => Promise<void>;
  ```
</CodeGroup>

## Frontend Usage

<Info>
  Use the checkout function from your React components with Convex hooks.
</Info>

<CodeGroup>
  ```tsx React Checkout Component expandable theme={null}
  import { useAction } from "convex/react";
  import { api } from "../convex/_generated/api";

  export function CheckoutButton() {
    const createCheckout = useAction(api.payments.createCheckout);

    const handleCheckout = async () => {
      try {
        const { checkout_url } = await createCheckout({
          product_cart: [{ product_id: "prod_123", quantity: 1 }],
          returnUrl: "https://example.com/success"
        });
        if (!checkout_url) {
          throw new Error("Missing checkout_url in response");
        }
        window.location.href = checkout_url;
      } catch (error) {
        console.error("Failed to create checkout", error);
        throw new Error("Unable to create checkout. Please try again.");
      }
    };

    return <button onClick={handleCheckout}>Buy Now</button>;
  }
  ```
</CodeGroup>

<CodeGroup>
  ```tsx Customer Portal Component expandable theme={null}
  import { useAction } from "convex/react";
  import { api } from "../convex/_generated/api";

  export function CustomerPortalButton() {
    const getPortal = useAction(api.payments.getCustomerPortal);

    const handlePortal = async () => {
      try {
        const { portal_url } = await getPortal({ send_email: false });
        if (!portal_url) {
          throw new Error("Missing portal_url in response");
        }
        window.location.href = portal_url;
      } catch (error) {
        console.error("Unable to open customer portal", error);
        alert("We couldn't open the customer portal. Please try again.");
      }
    };

    return <button onClick={handlePortal}>Manage Subscription</button>;
  }
  ```
</CodeGroup>

***

## Prompt for LLM

```
You are an expert Convex developer assistant. Your task is to guide a user through integrating the @dodopayments/convex component into their existing Convex application.

The @dodopayments/convex adapter provides a Convex component for Dodo Payments' Checkout, Customer Portal, and Webhook functionalities, built using the official Convex component architecture pattern.

First, install the necessary package:

npm install @dodopayments/convex

Here's how you should structure your response:

1. Ask the user which functionalities they want to integrate.

"Which parts of the @dodopayments/convex component would you like to integrate into your project? You can choose one or more of the following:

- Checkout Function (for handling product checkouts)
- Customer Portal Function (for managing customer subscriptions/details)
- Webhook Handler (for receiving Dodo Payments webhook events)
- All (integrate all three)"

2. Based on the user's selection, provide detailed integration steps for each chosen functionality.

If Checkout Function is selected:

Purpose: This function handles session-based checkout flows and returns checkout URLs for programmatic handling.

Integration Steps:

Step 1: Add the component to your Convex configuration.

// convex/convex.config.ts
import { defineApp } from "convex/server";
import dodopayments from "@dodopayments/convex/convex.config";

const app = defineApp();
app.use(dodopayments);
export default app;

Step 2: Guide the user to set up environment variables in the Convex dashboard. Instruct them to open the dashboard by running:

npx convex dashboard

Then add the required environment variables (e.g., DODO_PAYMENTS_API_KEY, DODO_PAYMENTS_ENVIRONMENT, DODO_PAYMENTS_WEBHOOK_SECRET) in **Settings → Environment Variables**. Do not use .env files for backend functions.

Step 3: Create an internal query to fetch customers from your database.
Note: Ensure the user has appropriate schema defined in their convex/schema.ts file or modify the query to match their existing schema.

// convex/customers.ts
import { internalQuery } from "./_generated/server";
import { v } from "convex/values";

// Internal query to fetch customer by auth ID
export const getByAuthId = internalQuery({
  args: { authId: v.string() },
  handler: async (ctx, { authId }) => {
    return await ctx.db
      .query("customers")
      .withIndex("by_auth_id", (q) => q.eq("authId", authId))
      .first();
  },
});

Step 4: Create your payment functions file.

// convex/dodo.ts
import { DodoPayments, DodoPaymentsClientConfig } from "@dodopayments/convex";
import { components } from "./_generated/api";
import { internal } from "./_generated/api";

export const dodo = new DodoPayments(components.dodopayments, {
  // This function maps your Convex user to a Dodo Payments customer
  // Customize it based on your authentication provider and user database
  identify: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return null; // User is not logged in
    }
    
    // Use ctx.runQuery() to lookup customer from your database
    const customer = await ctx.runQuery(internal.customers.getByAuthId, {
      authId: identity.subject,
    });
    
    if (!customer) {
      return null; // Customer not found in database
    }
    
    return {
      dodoCustomerId: customer.dodoCustomerId, // Replace customer.dodoCustomerId with your field storing Dodo Payments customer ID
    };
  },
  apiKey: process.env.DODO_PAYMENTS_API_KEY!,
  environment: process.env.DODO_PAYMENTS_ENVIRONMENT as "test_mode" | "live_mode",
} as DodoPaymentsClientConfig);

// Export the API methods for use in your app
export const { checkout, customerPortal } = dodo.api();

Step 5: Create actions that use the checkout function.

// convex/payments.ts
import { action } from "./_generated/server";
import { v } from "convex/values";
import { checkout } from "./dodo";

// Checkout session with full feature support
export const createCheckout = action({
  args: { 
    product_cart: v.array(v.object({
      product_id: v.string(),
      quantity: v.number(),
    })),
    returnUrl: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    return await checkout(ctx, {
      payload: {
        product_cart: args.product_cart,
        return_url: args.returnUrl,
        billing_currency: "USD",
        feature_flags: {
          allow_discount_code: true,
        },
      },
    });
  },
});

Step 6: Use in your frontend.

// Your frontend component
import { useAction } from "convex/react";
import { api } from "../convex/_generated/api";

export function CheckoutButton() {
  const createCheckout = useAction(api.payments.createCheckout);

  const handleCheckout = async () => {
    const { checkout_url } = await createCheckout({
      product_cart: [{ product_id: "prod_123", quantity: 1 }],
    });
    window.location.href = checkout_url;
  };

  return <button onClick={handleCheckout}>Buy Now</button>;
}

Configuration Details:

- `checkout()`: Checkout session with full feature support using session checkout.
- Returns: `{"checkout_url": "https://checkout.dodopayments.com/..."}`

For complete API documentation, refer to:
- Checkout Sessions: https://docs.dodopayments.com/developer-resources/checkout-session
- One-time Payments: https://docs.dodopayments.com/api-reference/payments/post-payments
- Subscriptions: https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions

If Customer Portal Function is selected:

Purpose: This function allows customers to manage their subscriptions and payment methods. The customer is automatically identified via the `identify` function.

Integration Steps:

Follow Steps 1-4 from the Checkout Function section, then:

Step 5: Create a customer portal action.

// convex/payments.ts (add to existing file)
import { action } from "./_generated/server";
import { v } from "convex/values";
import { customerPortal } from "./dodo";

export const getCustomerPortal = action({
  args: {
    send_email: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    try {
      const portal = await customerPortal(ctx, args);
      if (!portal?.portal_url) {
        throw new Error("Customer portal did not return a portal_url");
      }
      return portal;
    } catch (error) {
      console.error("Failed to generate customer portal link", error);
      throw new Error("Unable to generate customer portal link. Please retry.");
    }
  },
});

Step 6: Use in your frontend.

// Your frontend component
import { useAction } from "convex/react";
import { api } from "../convex/_generated/api";

export function CustomerPortalButton() {
  const getPortal = useAction(api.payments.getCustomerPortal);

  const handlePortal = async () => {
    const { portal_url } = await getPortal({ send_email: false });
    window.location.href = portal_url;
  };

  return <button onClick={handlePortal}>Manage Subscription</button>;
}

Configuration Details:
- Requires authenticated user (via `identify` function).
- Customer identification is handled automatically by the `identify` function.
- `send_email`: Optional boolean to send portal link via email.

If Webhook Handler is selected:

Purpose: This handler processes incoming webhook events from Dodo Payments, allowing your application to react to events like successful payments or subscription changes.

Integration Steps:

Step 1: Add the webhook secret to your environment variables in the Convex dashboard. You can open the dashboard by running:

Guide the user to open the Convex dashboard by running:

npx convex dashboard

In the dashboard, go to **Settings → Environment Variables** and add:

- `DODO_PAYMENTS_WEBHOOK_SECRET=whsec_...`

Do not use .env files for backend functions; always set secrets in the Convex dashboard.

Step 2: Create a file `convex/http.ts`:

// convex/http.ts
import { createDodoWebhookHandler } from "@dodopayments/convex";
import { httpRouter } from "convex/server";
import { internal } from "./_generated/api";

const http = httpRouter();

http.route({
  path: "/dodopayments-webhook",
  method: "POST",
  handler: createDodoWebhookHandler({
    // Handle successful payments
    onPaymentSucceeded: async (ctx, payload) => {
      console.log("🎉 Payment Succeeded!");

      // Use Convex context to persist payment data
      await ctx.runMutation(internal.webhooks.createPayment, {
        paymentId: payload.data.payment_id,
        businessId: payload.business_id,
        customerEmail: payload.data.customer.email,
        amount: payload.data.total_amount,
        currency: payload.data.currency,
        status: payload.data.status,
        webhookPayload: JSON.stringify(payload),
      });
    },

    // Handle subscription activation
    onSubscriptionActive: async (ctx, payload) => {
      console.log("🎉 Subscription Activated!");
      // Use Convex context to persist subscription data
      await ctx.runMutation(internal.webhooks.createSubscription, {
        subscriptionId: payload.data.subscription_id,
        businessId: payload.business_id,
        customerEmail: payload.data.customer.email,
        status: payload.data.status,
        webhookPayload: JSON.stringify(payload),
      });
    },
    // Add other event handlers as needed
  }),
});

export default http;

Note: Make sure to define the corresponding database mutations in your Convex backend for each webhook event you want to handle. For example, create a `createPayment` mutation to record successful payments or a `createSubscription` mutation to manage subscription state.

Now, you can set the webhook endpoint URL in your Dodo Payments dashboard to `https://<your-convex-deployment-url>/dodopayments-webhook`.

Environment Variable Setup:

Set up the following environment variables in your Convex dashboard if you haven't already (Settings → Environment Variables):

- `DODO_PAYMENTS_API_KEY` - Your Dodo Payments API key
- `DODO_PAYMENTS_ENVIRONMENT` - Set to `test_mode` or `live_mode`
- `DODO_PAYMENTS_WEBHOOK_SECRET` - Your webhook secret (required for webhook handling)

Usage in your component configuration:

apiKey: process.env.DODO_PAYMENTS_API_KEY
environment: process.env.DODO_PAYMENTS_ENVIRONMENT as "test_mode" | "live_mode"

Important: Never commit sensitive environment variables directly into your code. Always use Convex environment variables for all sensitive information.

If the user needs assistance setting up environment variables or deployment, ask them about their specific setup and provide guidance accordingly.

Run `npx convex dev` after setting up the component to generate the necessary types.
```


# Official SDKs Overview
Source: https://docs.dodopayments.com/developer-resources/dodo-payments-sdks

Official SDKs for TypeScript, Python, PHP, Go, Ruby, Java, Kotlin, and C# to integrate Dodo Payments into your applications

Dodo Payments provides official SDKs for multiple programming languages, each designed with language-specific best practices and modern features for seamless payment integration.

<Tip>
  Always use the latest SDK version to access the newest features and improvements. Check your package manager for updates regularly to ensure you have access to all Dodo Payments capabilities.
</Tip>

## Available SDKs

Choose the SDK that matches your tech stack:

<CardGroup>
  <Card title="TypeScript SDK" icon="js" href="/developer-resources/sdks/typescript">
    Type-safe integration for TypeScript and Node.js with promise-based API and auto-pagination
  </Card>

  <Card title="Python SDK" icon="python" href="/developer-resources/sdks/python">
    Pythonic interface with async/await support for Python 3.7+ applications
  </Card>

  <Card title="PHP SDK" icon="php" href="/developer-resources/sdks/php">
    PSR-4 compliant SDK for modern PHP 8.1+ applications
  </Card>

  <Card title="Go SDK" icon="golang" href="/developer-resources/sdks/go">
    Idiomatic Go interface with context support and strong typing
  </Card>

  <Card title="Ruby SDK" icon="gem" href="/developer-resources/sdks/ruby">
    Elegant Ruby interface following Ruby conventions and best practices
  </Card>

  <Card title="Java SDK" icon="java" href="/developer-resources/sdks/java">
    Robust and thread-safe SDK for Java 8+ with Maven and Gradle support
  </Card>

  <Card title="Kotlin SDK" icon="code" href="/developer-resources/sdks/kotlin">
    Modern Kotlin SDK with coroutines, null safety, and extension functions
  </Card>

  <Card title="C# SDK" icon="c" href="/developer-resources/sdks/csharp">
    Type-safe SDK for .NET 8+ with async Task-based API (Beta)
  </Card>

  <Card title="React Native SDK" icon="mobile" href="/developer-resources/react-native-integration">
    Native mobile SDK for building secure payment experiences in iOS and Android apps
  </Card>

  <Card title="CLI" icon="terminal" href="/developer-resources/sdks/cli">
    Command-line interface for interacting with the API from your terminal
  </Card>
</CardGroup>

## Quick Start

Get started with any SDK in minutes:

<Steps>
  <Step title="Install the SDK">
    Use your language's package manager to install the SDK

    <Tabs>
      <Tab title="TypeScript/Node.js">
        ```bash theme={null}
        npm install dodopayments
        ```
      </Tab>

      <Tab title="Python">
        ```bash theme={null}
        pip install dodopayments
        ```
      </Tab>

      <Tab title="PHP">
        ```bash theme={null}
        composer require dodopayments/client
        ```
      </Tab>

      <Tab title="Go">
        ```bash theme={null}
        go get github.com/dodopayments/dodopayments-go
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Initialize the Client">
    Configure the client with your API key

    <Tabs>
      <Tab title="TypeScript">
        ```typescript theme={null}
        import DodoPayments from 'dodopayments';
        const client = new DodoPayments({ bearerToken: 'your_api_key' });
        ```
      </Tab>

      <Tab title="Python">
        ```python theme={null}
        from dodopayments import DodoPayments
        client = DodoPayments(bearer_token="your_api_key")
        ```
      </Tab>

      <Tab title="PHP">
        ```php theme={null}
        use Dodopayments\Client;
        $client = new Client(bearerToken: 'your_api_key');
        ```
      </Tab>

      <Tab title="Go">
        ```go theme={null}
        import "github.com/dodopayments/dodopayments-go"
        client := dodopayments.NewClient(option.WithBearerToken("your_api_key"))
        ```
      </Tab>
    </Tabs>

    <Warning>
      Always store your API keys securely using environment variables. Never commit them to version control.
    </Warning>
  </Step>

  <Step title="Make Your First API Call">
    Create a checkout session or payment

    <Check>
      You're now ready to process payments! Visit the individual SDK pages for detailed guides and examples.
    </Check>
  </Step>
</Steps>

## Key Features

All SDKs share these core capabilities:

* **Type Safety**: Strong typing for compile-time safety and better IDE support
* **Error Handling**: Comprehensive exception handling with detailed error messages
* **Authentication**: Simple API key authentication with environment variable support
* **Async Support**: Modern async/await patterns where applicable
* **Auto-Pagination**: Automatic pagination for list responses
* **Usage-Based Billing**: Built-in support for tracking and ingesting usage events
* **Testing**: Full sandbox environment support for development and testing

## React Native SDK

For mobile applications, we provide a dedicated React Native SDK:

<Card title="React Native SDK" icon="mobile" href="/developer-resources/react-native-integration">
  Build secure payment experiences for iOS and Android apps with native UI components and simplified payment data collection
</Card>

**Features:**

* Native UI components for Android and iOS
* Simplified security for collecting sensitive payment data
* Support for multiple payment methods
* Seamless integration with React Native apps

<Info>
  Apple Pay, Google Pay, Cash App, and UPI are not currently supported in the React Native SDK. Support for these payment methods is planned for future releases.
</Info>

## Command-Line Interface

For terminal-based workflows and automation:

<Card title="CLI" icon="terminal" href="/developer-resources/sdks/cli">
  Auto-generated command-line interface with support for all 78 API endpoints
</Card>

**Features:**

* Resource-based command structure for intuitive usage
* Multiple output formats (JSON, YAML, pretty, interactive)
* Shell completion for bash, zsh, and fish
* Perfect for scripting and CI/CD automation

```bash theme={null}
# Quick example
dodopayments payments list --format json | jq '.data[] | {id, amount}'
```

## Migration from Node.js SDK

<Info>
  We migrated from the Node.js SDK to the new TypeScript SDK. If you're using the legacy Node.js SDK, see the [migration guide](https://github.com/dodopayments/dodopayments-typescript/blob/main/MIGRATION.md) to update your integration.
</Info>

## Framework Adapters

Integrate in under 10 lines of code with our framework adapters. Choose from our recommended frameworks or explore all supported options.

### Recommended Frameworks

<CardGroup>
  <Card title="Next.js" icon="atom" href="/developer-resources/nextjs-adaptor">
    React-based full-stack framework with App Router support
  </Card>

  <Card title="Better Auth" icon="shield" href="/developer-resources/better-auth-adaptor">
    Authentication framework with built-in integrations
  </Card>

  <Card title="Supabase" icon="database" href="developer-resources/supabase-boilerplate">
    Open source Firebase alternative with Postgres and Auth
  </Card>

  <Card title="Convex" icon="database" href="/developer-resources/convex-component">
    Backend-as-a-Service with real-time capabilities
  </Card>
</CardGroup>

<AccordionGroup>
  <Accordion title="Show other 8+ supported frameworks">
    <CardGroup>
      <Card title="SvelteKit" icon="js" href="/developer-resources/sveltekit-adaptor" />

      <Card title="Nuxt" icon="vuejs" href="/developer-resources/nuxt-adaptor" />

      <Card title="Remix" icon="react" href="/developer-resources/remix-adaptor" />

      <Card title="Express" icon="js" href="/developer-resources/express-adaptor" />

      <Card title="Fastify" icon="bolt" href="/developer-resources/fastify-adaptor" />

      <Card title="Hono" icon="cloud" href="/developer-resources/hono-adaptor" />

      <Card title="Astro" icon="star" href="/developer-resources/astro-adaptor" />

      <Card title="TanStack" icon="chart-line" href="/developer-resources/tanstack-adaptor" />
    </CardGroup>
  </Accordion>
</AccordionGroup>

## Getting Help

Need assistance with any SDK?

* **Discord**: Join our [community server](https://discord.gg/bYqAp4ayYh) for real-time help
* **Email**: Contact us at [support@dodopayments.com](mailto:support@dodopayments.com)
* **GitHub**: Open an issue on the respective SDK repository
* **Documentation**: Visit our [API reference](/api-reference/introduction)

## Contributing

We welcome contributions to all our SDKs! Each repository has a `CONTRIBUTING.md` file with guidelines for:

* Reporting bugs
* Requesting features
* Submitting pull requests
* Running tests locally
* Code style and conventions

Visit the individual SDK pages to access their GitHub repositories and contribution guidelines.


# Expo Boilerplate
Source: https://docs.dodopayments.com/developer-resources/expo-boilerplate

Build React Native mobile apps with Dodo Payments using our Expo boilerplate. Includes checkout integration, payment handling, and TypeScript support.

<Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/expo-boilerplate">
  Complete Expo + React Native + Dodo Payments boilerplate
</Card>

## Overview

A production-ready boilerplate for integrating Dodo Payments into Expo/React Native applications. This template includes checkout session creation, payment handling, and proper TypeScript configuration to help you start accepting payments in your mobile app quickly.

<Info>
  This boilerplate uses Expo SDK with TypeScript and includes example implementations for checkout sessions and payment processing.
</Info>

<Frame>
  <iframe title="Expo Boilerplate Demo | Dodo Payments" />
</Frame>

## Prerequisites

* Node.js 18+
* Expo CLI or EAS CLI
* Dodo Payments account (API key from dashboard)
* iOS Simulator or Android Emulator (or physical device)

## Quick Start

<Steps>
  <Step title="Clone the Repository">
    Clone the boilerplate repository and navigate to the project directory:

    ```bash theme={null}
    git clone https://github.com/dodopayments/expo-boilerplate.git
    cd expo-boilerplate
    ```
  </Step>

  <Step title="Get Your API Credentials">
    Obtain your credentials from the Dodo Payments dashboard in Test Mode:

    * **API Key**: Navigate to **Developer → API Keys** in your [dashboard](https://app.dodopayments.com)

    <Tip>
      Start with Test Mode to safely test your integration without processing real payments.
    </Tip>
  </Step>

  <Step title="Configure Environment Variables">
    Create a `.env` file in the root directory:

    ```bash theme={null}
    touch .env
    ```

    Add your Dodo Payments credentials:

    ```bash .env theme={null}
    EXPO_PUBLIC_DODO_API_KEY=your_test_api_key_here
    ```

    <Warning>
      Never commit your `.env` file to version control. It's already included in `.gitignore`.
    </Warning>
  </Step>

  <Step title="Install Dependencies">
    Install the required npm packages:

    ```bash theme={null}
    npm install
    ```
  </Step>

  <Step title="Start the Development Server">
    Start the Expo development server:

    ```bash theme={null}
    npx expo start
    ```

    Scan the QR code with Expo Go app on your device, or press `i` for iOS simulator or `a` for Android emulator.

    <Check>
      You're ready to start building! The boilerplate includes example screens and components to help you understand the integration.
    </Check>
  </Step>
</Steps>

## What's Included

The boilerplate comes with pre-configured essentials:

<CardGroup>
  <Card title="Checkout Integration" icon="shopping-cart">
    Example implementation for creating and handling checkout sessions
  </Card>

  <Card title="Payment Handling" icon="credit-card">
    Complete payment flow with success and error handling
  </Card>

  <Card title="TypeScript Support" icon="code">
    Full TypeScript configuration with proper type definitions
  </Card>

  <Card title="Expo Router" icon="route">
    Navigation setup with Expo Router for seamless routing
  </Card>
</CardGroup>

## Project Structure

```
expo-boilerplate/
├── app/
│   ├── (tabs)/
│   │   └── index.tsx          # Home screen with examples
│   └── checkout.tsx           # Checkout screen
├── components/
│   └── PaymentButton.tsx      # Payment button component
├── lib/
│   └── dodo.ts                # Dodo Payments client setup
├── .env.example               # Environment variables template
└── package.json
```

## Next Steps

Once you have the boilerplate running:

<Steps>
  <Step title="Create Your Products">
    Add products in your [Dodo Payments dashboard](https://app.dodopayments.com) to enable checkout functionality.
  </Step>

  <Step title="Customize the Integration">
    Adapt the example code to match your application's needs and design.
  </Step>

  <Step title="Test on Real Devices">
    Test the payment flow on physical devices to ensure everything works correctly.
  </Step>

  <Step title="Go Live">
    When ready, switch to Live Mode API keys and build your app for production.
  </Step>
</Steps>

## Building for Production

<Steps>
  <Step title="Install EAS CLI">
    ```bash theme={null}
    npm install -g eas-cli
    ```
  </Step>

  <Step title="Configure EAS">
    ```bash theme={null}
    eas build:configure
    ```
  </Step>

  <Step title="Build Your App">
    For iOS:

    ```bash theme={null}
    eas build --platform ios
    ```

    For Android:

    ```bash theme={null}
    eas build --platform android
    ```
  </Step>
</Steps>

## Additional Resources

<CardGroup>
  <Card title="Mobile Integration Guide" icon="mobile" href="/developer-resources/mobile-integration">
    Detailed guide for implementing payments in mobile apps
  </Card>

  <Card title="React Native Integration" icon="react" href="/developer-resources/react-native-integration">
    React Native specific integration documentation
  </Card>

  <Card title="Integration Guide" icon="book" href="/developer-resources/integration-guide">
    Detailed guide for implementing one-time payments
  </Card>

  <Card title="API Reference" icon="brackets-curly" href="/api-reference/introduction">
    Explore the full Dodo Payments API documentation
  </Card>
</CardGroup>

## Support

Need help with the boilerplate?

* Join our [Discord community](https://discord.gg/bYqAp4ayYh) for questions and discussions
* Check the [GitHub repository](https://github.com/dodopayments/expo-boilerplate) for issues and updates
* Contact our [support team](mailto:support@dodopayments.com) for assistance


# Express Adaptor
Source: https://docs.dodopayments.com/developer-resources/express-adaptor

Learn how to integrate Dodo Payments with your Express App Router project using our Express Adaptor. Covers checkout, customer portal, webhooks, and secure environment setup.

<CardGroup>
  <Card title="Checkout Handler" icon="cart-shopping" href="#checkout-route-handler">
    Integrate Dodo Payments checkout into your Express app.
  </Card>

  <Card title="Customer Portal" icon="user" href="#customer-portal-route-handler">
    Allow customers to manage subscriptions and details.
  </Card>

  <Card title="Webhooks" icon="bell" href="#webhook-route-handler">
    Receive and process Dodo Payments webhook events.
  </Card>
</CardGroup>

## Installation

<Steps>
  <Step title="Install the package">
    Run the following command in your project root:

    ```bash theme={null}
    npm install @dodopayments/express
    ```
  </Step>

  <Step title="Set up environment variables">
    Create a <code>.env</code> file in your project root:

    ```env expandable theme={null}
    DODO_PAYMENTS_API_KEY=your-api-key
    DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
    DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode"
    DODO_PAYMENTS_RETURN_URL=your-return-url
    ```

    <Warning>
      Never commit your <code>.env</code> file or secrets to version control.
    </Warning>
  </Step>
</Steps>

## Route Handler Examples

<Tabs>
  <Tab title="Checkout Handler">
    <Info>
      Use this handler to integrate Dodo Payments checkout into your Express app. Supports static (GET), dynamic (POST), and session (POST) payment flows.
    </Info>

    <CodeGroup>
      ```typescript Express Route Handler expandable theme={null}
      import { checkoutHandler } from '@dodopayments/express';

      app.get('/api/checkout', checkoutHandler({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
          environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
          type: "static"
      }))

      app.post('/api/checkout', checkoutHandler({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
          environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
          type: "dynamic"
      }))

      app.post('/api/checkout', checkoutHandler({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
          environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
          type: "session"
      }))
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Static Checkout Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/checkout?productId=pdt_fqJhl7pxKWiLhwQR042rh' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Dynamic Checkout Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "billing": {
        "city": "Texas",
        "country": "US",
        "state": "Texas",
        "street": "56, hhh",
        "zipcode": "560000"
      },
      "customer": {
        "email": "test@example.com",
        	"name": "test"
      },
      "metadata": {},
      "payment_link": true,
        "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
        "quantity": 1,
        "billing_currency": "USD",
        "discount_code": "IKHZ23M9GQ",
        "return_url": "https://example.com",
        "trial_period_days": 10
      }'
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Checkout Session Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "product_cart": [
        {
          "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
          "quantity": 1
        }
      ],
      "customer": {
        "email": "test@example.com",
        "name": "test"
      },
      "return_url": "https://example.com/success"
      }'
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Customer Portal Handler">
    <Info>
      Use this handler to allow customers to manage their subscriptions and details via the Dodo Payments customer portal.
    </Info>

    <CodeGroup>
      ```typescript Express Route Handler expandable theme={null}
      import { CustomerPortal } from "@dodopayments/express";

      app.get('/api/customer-portal', CustomerPortal({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
      }))
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Customer Portal Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/customer-portal?customer_id=cus_9VuW4K7O3GHwasENg31m&send_email=true' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Webhook Handler">
    <Info>
      Use this handler to receive and process Dodo Payments webhook events securely in your Express app.
    </Info>

    <CodeGroup>
      ```typescript Express Route Handler expandable theme={null}
      import { Webhooks } from "@dodopayments/express";

      app.post('/api/webhook',Webhooks({
          webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_KEY,
          onPayload: async (payload) => {
              // handle the payload
          },
          // ... other event handlers for granular control
      }))
      ```
    </CodeGroup>
  </Tab>
</Tabs>

## Checkout Route Handler

<Info>
  Dodo Payments supports three types of payment flows for integrating payments into your website, this adaptor supports all types of payment flows.
</Info>

* **Static Payment Links:** Instantly shareable URLs for quick, no-code payment collection.
* **Dynamic Payment Links:** Programmatically generate payment links with custom details using the API or SDKs.
* **Checkout Sessions:** Create secure, customizable checkout experiences with pre-configured product carts and customer details.

<AccordionGroup>
  <Accordion title="Static Checkout (GET)">
    ### Supported Query Parameters

    <ParamField type="string">
      Product identifier (e.g., <code>?productId=pdt\_nZuwz45WAs64n3l07zpQR</code>).
    </ParamField>

    <ParamField type="integer">
      Quantity of the product.
    </ParamField>

    <ParamField type="string">
      Customer's full name.
    </ParamField>

    <ParamField type="string">
      Customer's first name.
    </ParamField>

    <ParamField type="string">
      Customer's last name.
    </ParamField>

    <ParamField type="string">
      Customer's email address.
    </ParamField>

    <ParamField type="string">
      Customer's country.
    </ParamField>

    <ParamField type="string">
      Customer's address line.
    </ParamField>

    <ParamField type="string">
      Customer's city.
    </ParamField>

    <ParamField type="string">
      Customer's state/province.
    </ParamField>

    <ParamField type="string">
      Customer's zip/postal code.
    </ParamField>

    <ParamField type="boolean">
      Disable full name field.
    </ParamField>

    <ParamField type="boolean">
      Disable first name field.
    </ParamField>

    <ParamField type="boolean">
      Disable last name field.
    </ParamField>

    <ParamField type="boolean">
      Disable email field.
    </ParamField>

    <ParamField type="boolean">
      Disable country field.
    </ParamField>

    <ParamField type="boolean">
      Disable address line field.
    </ParamField>

    <ParamField type="boolean">
      Disable city field.
    </ParamField>

    <ParamField type="boolean">
      Disable state field.
    </ParamField>

    <ParamField type="boolean">
      Disable zip code field.
    </ParamField>

    <ParamField type="string">
      Specify the payment currency (e.g., <code>USD</code>).
    </ParamField>

    <ParamField type="boolean">
      Show currency selector.
    </ParamField>

    <ParamField type="integer">
      Specify the payment amount (e.g., <code>1000</code> for \$10.00).
    </ParamField>

    <ParamField type="boolean">
      Show discount fields.
    </ParamField>

    <ParamField type="string">
      Any query parameter starting with <code>metadata\_</code> will be passed as metadata.
    </ParamField>

    <Warning>
      If <code>productId</code> is missing, the handler returns a 400 response. Invalid query parameters also result in a 400 response.
    </Warning>

    ### Response Format

    Static checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Dynamic Checkout (POST)">
    * Send parameters as a JSON body in a POST request.
    * Supports both one-time and recurring payments.
    * For a complete list of supported POST body fields, refer to:
      * [Request body for a One Time Payment Product](https://docs.dodopayments.com/api-reference/payments/post-payments)
      * [Request body for a Subscription Product](https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions)

    ### Response Format

    Dynamic checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Checkout Sessions (POST)">
    Checkout sessions provide a more secure, hosted checkout experience that handles the complete payment flow for both one-time purchases and subscriptions with full customization control.

    Refer to [Checkout Sessions Integration Guide](https://docs.dodopayments.com/developer-resources/checkout-session) for more details and a complete list of supported fields.

    ### Response Format

    Checkout sessions return a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/session/..."
    }
    ```
  </Accordion>
</AccordionGroup>

## Customer Portal Route Handler

The Customer Portal Route Handler enables you to seamlessly integrate the Dodo Payments customer portal into your Express application.

### Query Parameters

<ParamField type="string">
  The customer ID for the portal session (e.g., <code>?customer\_id=cus\_123</code>).
</ParamField>

<ParamField type="boolean">
  If set to <code>true</code>, sends an email to the customer with the portal link.
</ParamField>

<Warning>
  Returns 400 if <code>customer\_id</code> is missing.
</Warning>

## Webhook Route Handler

* **Method:** Only POST requests are supported. Other methods return 405.
* **Signature Verification:** Verifies the webhook signature using <code>webhookKey</code>. Returns 401 if verification fails.
* **Payload Validation:** Validated with Zod. Returns 400 for invalid payloads.
* **Error Handling:**
  * 401: Invalid signature
  * 400: Invalid payload
  * 500: Internal error during verification
* **Event Routing:** Calls the appropriate event handler based on the payload type.

### Supported Webhook Event Handlers

<CodeGroup>
  ```typescript Typescript expandable theme={null}
  onPayload?: (payload: WebhookPayload) => Promise<void>;
  onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onPaymentFailed?: (payload: WebhookPayload) => Promise<void>;
  onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>;
  onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>;
  onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onRefundFailed?: (payload: WebhookPayload) => Promise<void>;
  onDisputeOpened?: (payload: WebhookPayload) => Promise<void>;
  onDisputeExpired?: (payload: WebhookPayload) => Promise<void>;
  onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>;
  onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>;
  onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>;
  onDisputeWon?: (payload: WebhookPayload) => Promise<void>;
  onDisputeLost?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>;
  onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>;
  ```
</CodeGroup>

***

## Prompt for LLM

```
You are an expert Express.js developer assistant. Your task is to guide a user through integrating the @dodopayments/express adapter into their existing Express.js project.

The @dodopayments/express adapter provides route handlers for Dodo Payments' Checkout, Customer Portal, and Webhook functionalities, designed to plug directly into an Express app.

First, install the necessary package. Use the package manager appropriate for the user's project (npm, yarn, or bun):

npm install @dodopayments/express

---

Here's how you should structure your response:

1. Ask the user which functionalities they want to integrate.

"Which parts of the @dodopayments/express adapter would you like to integrate into your project? You can choose one or more of the following:

- Checkout Route Handler (for handling product checkouts)
- Customer Portal Route Handler (for managing customer subscriptions/details)
- Webhook Route Handler (for receiving Dodo Payments webhook events)
- All (integrate all three)"

---

2. Based on the user's selection, provide detailed integration steps for each chosen functionality.

---

**If Checkout Route Handler is selected:**

**Purpose**: This handler manages different types of checkout flows. All checkout types (static, dynamic, and sessions) return JSON responses with checkout URLs for programmatic handling.

**Integration**:
Create routes in your Express app for static (GET), dynamic (POST), and checkout sessions (POST).


import { checkoutHandler } from '@dodopayments/express';

app.get('/api/checkout', checkoutHandler({
  bearerToken: process.env.DODO_PAYMENTS_API_KEY,
  returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
  environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
  type: "static"
}));

app.post('/api/checkout', checkoutHandler({
  bearerToken: process.env.DODO_PAYMENTS_API_KEY,
  returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
  environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
  type: "dynamic"
}));

// For checkout sessions
app.post('/api/checkout', checkoutHandler({
  bearerToken: process.env.DODO_PAYMENTS_API_KEY,
  returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
  environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
  type: "session"
}));

Config Options:

    bearerToken: Your Dodo Payments API key (recommended to be stored in DODO_PAYMENTS_API_KEY env variable).

    returnUrl (optional): URL to redirect the user after successful checkout.

    environment: "test_mode" or "live_mode"

    type: "static" (GET), "dynamic" (POST), or "session" (POST)

GET (static checkout) expects query parameters:

    productId (required)

    quantity, customer fields (fullName, email, etc.), and metadata (metadata_*) are optional.

    Returns: {"checkout_url": "https://checkout.dodopayments.com/..."}

POST (dynamic checkout) expects a JSON body with payment details (one-time or subscription). Reference the docs for the full POST schema:

    One-time payments: https://docs.dodopayments.com/api-reference/payments/post-payments

    Subscriptions: https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions

    Returns: {"checkout_url": "https://checkout.dodopayments.com/..."}


POST (checkout sessions) - (Recommended) A more customizable checkout experience. Returns JSON with checkout_url: Parameters are sent as a JSON body. Supports both one-time and recurring payments. Returns: {"checkout_url": "https://checkout.dodopayments.com/session/..."}. For a complete list of supported fields, refer to:

  Checkout Sessions Integration Guide: https://docs.dodopayments.com/developer-resources/checkout-session

If Customer Portal Route Handler is selected:

Purpose: This route allows customers to manage their subscriptions via the Dodo Payments portal.

Integration:

import { CustomerPortal } from "@dodopayments/express";

app.get('/api/customer-portal', CustomerPortal({
  bearerToken: process.env.DODO_PAYMENTS_API_KEY,
  environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
}));

Query Parameters:

    customer_id (required): e.g., ?customer_id=cus_123

    send_email (optional): if true, customer is emailed the portal link

Returns 400 if customer_id is missing.

If Webhook Route Handler is selected:

Purpose: Processes incoming webhook events from Dodo Payments to trigger events in your app.

Integration:

import { Webhooks } from "@dodopayments/express";

app.post('/api/webhook', Webhooks({
  webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_KEY,
  onPayload: async (payload) => {
    // Handle generic payload
  },
  // You can also provide fine-grained handlers for each event type below
}));

Features:

    Only POST method is allowed — others return 405

    Signature verification is performed using webhookKey. Returns 401 if invalid.

    Zod-based payload validation. Returns 400 if invalid schema.

    All handlers are async functions.

Supported Webhook Event Handlers:

You may pass in any of the following handlers:

    onPayload

    onPaymentSucceeded

    onPaymentFailed

    onPaymentProcessing

    onPaymentCancelled

    onRefundSucceeded

    onRefundFailed

    onDisputeOpened, onDisputeExpired, onDisputeAccepted, onDisputeCancelled, onDisputeChallenged, onDisputeWon, onDisputeLost

    onSubscriptionActive, onSubscriptionOnHold, onSubscriptionRenewed, onSubscriptionPlanChanged, onSubscriptionCancelled, onSubscriptionFailed, onSubscriptionExpired

    onLicenseKeyCreated

Environment Variable Setup:

Make sure to define these environment variables in your project:

DODO_PAYMENTS_API_KEY=your-api-key
DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode"
DODO_PAYMENTS_RETURN_URL=your-return-url

Use these inside your code as:

process.env.DODO_PAYMENTS_API_KEY
process.env.DODO_PAYMENTS_WEBHOOK_SECRET

Security Note: Do NOT commit secrets to version control. Use .env files locally and secrets managers in deployment environments (e.g., AWS, Vercel, Heroku, etc.).
```


# FastAPI Boilerplate
Source: https://docs.dodopayments.com/developer-resources/fastapi-boilerplate

Get started quickly with our FastAPI boilerplate for integrating Dodo Payments into your Python backend applications

<Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/fastapi-boilerplate">
  Complete FastAPI + Dodo Payments boilerplate
</Card>

## Overview

The FastAPI boilerplate provides a production-ready starting point for integrating Dodo Payments with your Python backend. This template includes checkout session handling, webhook verification, customer portal integration, and async API patterns to help you start accepting payments quickly.

<Info>
  This boilerplate uses FastAPI with async/await patterns, Pydantic for validation, and the `dodopayments` Python SDK for seamless API integration.
</Info>

### Features

* **Quick Setup** - Get started in under 5 minutes
* **Async Support** - Built with FastAPI's native async/await patterns
* **Checkout Sessions** - Pre-configured checkout flow using the Python SDK
* **Webhook Handling** - Secure webhook endpoint with signature verification
* **Customer Portal** - Easy customer portal session creation
* **Type Safety** - Full Pydantic validation and type hints
* **Environment Configuration** - Ready-to-use environment variable setup

## Prerequisites

Before you begin, make sure you have:

* **Python 3.9+** (recommended: Python 3.11+)
* **pip** or **uv** for package management
* **Dodo Payments account** (to access API and Webhook Keys from dashboard)

## Quick Start

<Steps>
  <Step title="Clone the Repository">
    ```bash theme={null}
    git clone https://github.com/dodopayments/fastapi-boilerplate.git
    cd fastapi-boilerplate
    ```
  </Step>

  <Step title="Create Virtual Environment">
    Set up an isolated Python environment:

    ```bash theme={null}
    python -m venv venv
    source venv/bin/activate  # On Windows: venv\Scripts\activate
    ```

    Or using uv for faster dependency management:

    ```bash theme={null}
    uv venv
    source .venv/bin/activate
    ```
  </Step>

  <Step title="Install Dependencies">
    ```bash theme={null}
    pip install -r requirements.txt
    ```

    Or with uv:

    ```bash theme={null}
    uv pip install -r requirements.txt
    ```
  </Step>

  <Step title="Get API Credentials">
    Sign up at [Dodo Payments](https://dodopayments.com/) and get your credentials from the dashboard:

    * **API Key:** [Dashboard → Developer → API Keys](https://app.dodopayments.com/developer/api-keys)
    * **Webhook Key:** [Dashboard → Developer → Webhooks](https://app.dodopayments.com/developer/webhooks)

    <Tip>
      Make sure you're in **Test Mode** while developing!
    </Tip>
  </Step>

  <Step title="Configure Environment Variables">
    Create a `.env` file in the root directory:

    ```bash theme={null}
    cp .env.example .env
    ```

    Update the values with your Dodo Payments credentials:

    ```bash .env theme={null}
    DODO_PAYMENTS_API_KEY=your_api_key_here
    DODO_PAYMENTS_WEBHOOK_KEY=your_webhook_signing_key_here
    DODO_PAYMENTS_ENVIRONMENT=test_mode
    ```

    <Warning>
      Never commit your `.env` file to version control. It's already included in `.gitignore`.
    </Warning>
  </Step>

  <Step title="Run the Development Server">
    ```bash theme={null}
    uvicorn main:app --reload
    ```

    Open [http://localhost:8000/docs](http://localhost:8000/docs) to see the interactive API documentation!

    <Check>
      You should see FastAPI's Swagger UI with all available endpoints ready to test.
    </Check>
  </Step>
</Steps>

## Project Structure

```text theme={null}
fastapi-boilerplate/
├── main.py                 # FastAPI application entry point
├── routers/
│   ├── checkout.py         # Checkout session endpoints
│   ├── webhook.py          # Webhook handler endpoint
│   └── customer_portal.py  # Customer portal endpoints
├── config.py               # Environment configuration
├── requirements.txt        # Python dependencies
├── .env.example            # Environment template
└── README.md
```

## API Endpoints

The boilerplate includes the following pre-configured endpoints:

| Endpoint           | Method | Description                   |
| ------------------ | ------ | ----------------------------- |
| `/checkout`        | POST   | Create a new checkout session |
| `/webhook`         | POST   | Handle Dodo Payments webhooks |
| `/customer-portal` | POST   | Generate customer portal URL  |

## Code Examples

### Creating a Checkout Session

```python theme={null}
from fastapi import APIRouter, HTTPException
from dodopayments import AsyncDodoPayments
from pydantic import BaseModel
from config import settings

router = APIRouter()
dodo = AsyncDodoPayments(
    bearer_token=settings.DODO_PAYMENTS_API_KEY,
    environment=settings.DODO_PAYMENTS_ENVIRONMENT
)

class CheckoutRequest(BaseModel):
    product_id: str
    quantity: int = 1
    customer_email: str | None = None
    customer_name: str | None = None

@router.post("/checkout")
async def create_checkout(request: CheckoutRequest):
    try:
        session = await dodo.checkout_sessions.create(
            product_cart=[{
                "product_id": request.product_id,
                "quantity": request.quantity
            }],
            customer={
                "email": request.customer_email,
                "name": request.customer_name
            } if request.customer_email else None,
            return_url="http://localhost:8000/success"
        )
        return {"checkout_url": session.url, "session_id": session.session_id}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
```

### Handling Webhooks

```python theme={null}
from fastapi import APIRouter, Request, HTTPException
import hmac
import hashlib
from config import settings

router = APIRouter()

def verify_webhook_signature(payload: bytes, signature: str) -> bool:
    expected = hmac.new(
        settings.DODO_PAYMENTS_WEBHOOK_KEY.encode(),
        payload,
        hashlib.sha256
    ).hexdigest()
    return hmac.compare_digest(expected, signature)

@router.post("/webhook")
async def handle_webhook(request: Request):
    payload = await request.body()
    signature = request.headers.get("webhook-signature", "")
    
    if not verify_webhook_signature(payload, signature):
        raise HTTPException(status_code=401, detail="Invalid signature")
    
    event = await request.json()
    event_type = event.get("type")
    
    match event_type:
        case "payment.succeeded":
            # Handle successful payment
            payment_id = event["data"]["payment_id"]
            print(f"Payment succeeded: {payment_id}")
            
        case "subscription.active":
            # Handle subscription activation
            subscription_id = event["data"]["subscription_id"]
            print(f"Subscription activated: {subscription_id}")
            
        case "refund.succeeded":
            # Handle refund
            refund_id = event["data"]["refund_id"]
            print(f"Refund processed: {refund_id}")
    
    return {"status": "received"}
```

### Customer Portal Integration

```python theme={null}
from fastapi import APIRouter, HTTPException
from dodopayments import AsyncDodoPayments
from pydantic import BaseModel
from config import settings

router = APIRouter()
dodo = AsyncDodoPayments(
    bearer_token=settings.DODO_PAYMENTS_API_KEY,
    environment=settings.DODO_PAYMENTS_ENVIRONMENT
)

class PortalRequest(BaseModel):
    customer_id: str

@router.post("/customer-portal")
async def create_portal_session(request: PortalRequest):
    try:
        session = await dodo.customers.create_customer_portal(
            customer_id=request.customer_id
        )
        return {"portal_url": session.url}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
```

## Webhook Events

The boilerplate demonstrates handling common webhook events:

| Event                    | Description                    |
| ------------------------ | ------------------------------ |
| `payment.succeeded`      | Payment completed successfully |
| `payment.failed`         | Payment attempt failed         |
| `subscription.active`    | Subscription is now active     |
| `subscription.cancelled` | Subscription was cancelled     |
| `refund.succeeded`       | Refund processed successfully  |

Add your business logic inside the webhook handler to:

* Update user permissions in your database
* Send confirmation emails
* Provision access to digital products
* Track analytics and metrics

## Testing Webhooks Locally

For local development, use tools like [ngrok](https://ngrok.com/) to expose your local server:

```bash theme={null}
ngrok http 8000
```

Update the webhook URL in your [Dodo Payments Dashboard](https://app.dodopayments.com/developer/webhooks):

```
https://your-ngrok-url.ngrok.io/webhook
```

## Deployment

### Docker

```dockerfile theme={null}
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

Build and run:

```bash theme={null}
docker build -t fastapi-dodo .
docker run -p 8000:8000 --env-file .env fastapi-dodo
```

### Production Considerations

<Warning>
  Before deploying to production:

  * Switch `DODO_PAYMENTS_ENVIRONMENT` to `live_mode`
  * Use production API keys from the dashboard
  * Update the webhook URL to your production domain
  * Enable HTTPS for all endpoints
</Warning>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Import errors or missing modules">
    Ensure your virtual environment is activated and dependencies are installed:

    ```bash theme={null}
    source venv/bin/activate
    pip install -r requirements.txt
    ```
  </Accordion>

  <Accordion title="Checkout session creation fails">
    **Common causes:**

    * Invalid product ID - verify it exists in your Dodo dashboard
    * Wrong API key or environment setting in `.env`
    * Check the FastAPI logs for detailed error messages
  </Accordion>

  <Accordion title="Webhooks not receiving events">
    For local testing, use [ngrok](https://ngrok.com) to expose your server:

    ```bash theme={null}
    ngrok http 8000
    ```

    Update the webhook URL in your [Dodo dashboard](https://app.dodopayments.com/developer/webhooks) to the ngrok URL. Make sure to update your `.env` file with the correct webhook verification key.
  </Accordion>

  <Accordion title="Webhook signature verification fails">
    * Ensure `DODO_PAYMENTS_WEBHOOK_KEY` is correctly set in your `.env`
    * Verify you're using the raw request body for signature verification
    * Check that you're reading the `webhook-signature` header correctly
  </Accordion>
</AccordionGroup>

## Learn More

<CardGroup>
  <Card title="Python SDK" icon="python" href="/developer-resources/sdks/python">
    Complete Python SDK documentation with async support
  </Card>

  <Card title="Webhooks Documentation" icon="webhook" href="/developer-resources/webhooks">
    Learn about all webhook events and best practices
  </Card>

  <Card title="Checkout Sessions" icon="credit-card" href="/developer-resources/checkout-session">
    Deep dive into checkout session configuration
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/introduction">
    Complete Dodo Payments API documentation
  </Card>
</CardGroup>

## Support

Need help with the boilerplate?

* Join our [Discord community](https://discord.gg/bYqAp4ayYh) for questions and discussions
* Check the [GitHub repository](https://github.com/dodopayments/fastapi-boilerplate) for issues and updates
* Contact our [support team](mailto:support@dodopayments.com) for assistance


# Fastify Adaptor
Source: https://docs.dodopayments.com/developer-resources/fastify-adaptor

Learn how to integrate Dodo Payments with your Fastify App Router project using our NextJS Adaptor. Covers checkout, customer portal, webhooks, and secure environment setup.

<CardGroup>
  <Card title="Checkout Handler" icon="cart-shopping" href="#checkout-route-handler">
    Integrate Dodo Payments checkout into your Fastify app.
  </Card>

  <Card title="Customer Portal" icon="user" href="#customer-portal-route-handler">
    Allow customers to manage subscriptions and details.
  </Card>

  <Card title="Webhooks" icon="bell" href="#webhook-route-handler">
    Receive and process Dodo Payments webhook events.
  </Card>
</CardGroup>

## Installation

<Steps>
  <Step title="Install the package">
    Run the following command in your project root:

    ```bash theme={null}
    npm install @dodopayments/fastify
    ```
  </Step>

  <Step title="Set up environment variables">
    Create a <code>.env</code> file in your project root:

    ```env expandable theme={null}
    DODO_PAYMENTS_API_KEY=your-api-key
    DODO_PAYMENTS_RETURN_URL=https://yourapp.com/success
    DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
    DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode""
    ```

    <Warning>
      Never commit your <code>.env</code> file or secrets to version control.
    </Warning>
  </Step>
</Steps>

## Route Handler Examples

<Info>
  All examples assume you are using the Fastify App Router.
</Info>

<Tabs>
  <Tab title="Checkout Handler">
    <Info>
      Use this handler to integrate Dodo Payments checkout into your Fastify app. Supports static (GET), dynamic (POST), and session (POST) payment flows.
    </Info>

    <CodeGroup>
      ```typescript Fastify Route Handler expandable theme={null}
        // route.ts
        import { Checkout } from '@dodopayments/fastify';
        import Fastify from 'fastify'

        const fastify = Fastify({})
        const checkoutGet = Checkout({
            bearerToken: process.env.DODO_PAYMENTS_API_KEY,
            environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
            returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
            type: 'static'
        });

        const checkoutPost = Checkout({
            bearerToken: process.env.DODO_PAYMENTS_API_KEY,
            environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
            returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
            type: 'dynamic'
        });

        const checkoutSession = Checkout({
            bearerToken: process.env.DODO_PAYMENTS_API_KEY,
            environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
            returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
            type: 'session'
        });

        fastify.get('/api/checkout', checkoutGet.getHandler);
        fastify.post('/api/checkout', checkoutPost.postHandler);
        fastify.post('/api/checkout-session', checkoutSession.postHandler);
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Static Checkout Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/checkout?productId=pdt_fqJhl7pxKWiLhwQR042rh' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Dynamic Checkout Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "billing": {
        "city": "Texas",
        "country": "US",
        "state": "Texas",
        "street": "56, hhh",
        "zipcode": "560000"
      },
      "customer": {
        "email": "test@example.com",
        	"name": "test"
      },
      "metadata": {},
      "payment_link": true,
        "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
        "quantity": 1,
        "billing_currency": "USD",
        "discount_code": "IKHZ23M9GQ",
        "return_url": "https://example.com",
        "trial_period_days": 10
      }'
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Checkout Session Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout-session \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "product_cart": [
        {
          "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
          "quantity": 1
        }
      ],
      "customer": {
        "email": "test@example.com",
        "name": "test"
      },
      "return_url": "https://example.com/success"
      }'
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Customer Portal Handler">
    <Info>
      Use this handler to allow customers to manage their subscriptions and details via the Dodo Payments customer portal.
    </Info>

    <CodeGroup>
      ```typescript Fastify Route Handler expandable theme={null}
      // route.ts
      import { CustomerPortal } from "@dodopayments/fastify";
      import Fastify from 'fastify'

      const fastify = Fastify({})
      const customerPortalHandler = CustomerPortal({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          environment: process.env.DODO_PAYMENTS_ENVIRONMENT
      });
      fastify.get('/api/customer-portal', customerPortalHandler);
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Customer Portal Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/customer-portal?customer_id=cus_9VuW4K7O3GHwasENg31m&send_email=true' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Webhook Handler">
    <Info>
      Use this handler to receive and process Dodo Payments webhook events securely in your Fastify app.
    </Info>

    <CodeGroup>
      ```typescript Fastify Route Handler expandable theme={null}
      // route.ts
      import Fastify from 'fastify'
      import { Webhooks } from '@dodopayments/fastify'

      const fastify = Fastify({})
      fastify.addContentTypeParser('application/json', { parseAs: 'string' }, function (req, body, done) {
          done(null, body)
      })

      fastify.post('/api/webhooks', Webhooks({
      webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_KEY,
      onPayload: async (payload) => {
          // Handle Payload Here
          console.log(payload)
      }
      }));

      ```
    </CodeGroup>
  </Tab>
</Tabs>

## Checkout Route Handler

<Info>
  Dodo Payments supports three types of payment flows for integrating payments into your website, this adaptor supports all types of payment flows.
</Info>

* **Static Payment Links:** Instantly shareable URLs for quick, no-code payment collection.
* **Dynamic Payment Links:** Programmatically generate payment links with custom details using the API or SDKs.
* **Checkout Sessions:** Create secure, customizable checkout experiences with pre-configured product carts and customer details.

<AccordionGroup>
  <Accordion title="Static Checkout (GET)">
    ### Supported Query Parameters

    <ParamField type="string">
      Product identifier (e.g., <code>?productId=pdt\_nZuwz45WAs64n3l07zpQR</code>).
    </ParamField>

    <ParamField type="integer">
      Quantity of the product.
    </ParamField>

    <ParamField type="string">
      Customer's full name.
    </ParamField>

    <ParamField type="string">
      Customer's first name.
    </ParamField>

    <ParamField type="string">
      Customer's last name.
    </ParamField>

    <ParamField type="string">
      Customer's email address.
    </ParamField>

    <ParamField type="string">
      Customer's country.
    </ParamField>

    <ParamField type="string">
      Customer's address line.
    </ParamField>

    <ParamField type="string">
      Customer's city.
    </ParamField>

    <ParamField type="string">
      Customer's state/province.
    </ParamField>

    <ParamField type="string">
      Customer's zip/postal code.
    </ParamField>

    <ParamField type="boolean">
      Disable full name field.
    </ParamField>

    <ParamField type="boolean">
      Disable first name field.
    </ParamField>

    <ParamField type="boolean">
      Disable last name field.
    </ParamField>

    <ParamField type="boolean">
      Disable email field.
    </ParamField>

    <ParamField type="boolean">
      Disable country field.
    </ParamField>

    <ParamField type="boolean">
      Disable address line field.
    </ParamField>

    <ParamField type="boolean">
      Disable city field.
    </ParamField>

    <ParamField type="boolean">
      Disable state field.
    </ParamField>

    <ParamField type="boolean">
      Disable zip code field.
    </ParamField>

    <ParamField type="string">
      Specify the payment currency (e.g., <code>USD</code>).
    </ParamField>

    <ParamField type="boolean">
      Show currency selector.
    </ParamField>

    <ParamField type="integer">
      Specify the payment amount (e.g., <code>1000</code> for \$10.00).
    </ParamField>

    <ParamField type="boolean">
      Show discount fields.
    </ParamField>

    <ParamField type="string">
      Any query parameter starting with <code>metadata\_</code> will be passed as metadata.
    </ParamField>

    <Warning>
      If <code>productId</code> is missing, the handler returns a 400 response. Invalid query parameters also result in a 400 response.
    </Warning>

    ### Response Format

    Static checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Dynamic Checkout (POST)">
    * Send parameters as a JSON body in a POST request.
    * Supports both one-time and recurring payments.
    * For a complete list of supported POST body fields, refer to:
      * [Request body for a One Time Payment Product](https://docs.dodopayments.com/api-reference/payments/post-payments)
      * [Request body for a Subscription Product](https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions)

    ### Response Format

    Dynamic checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Checkout Sessions (POST)">
    Checkout sessions provide a more secure, hosted checkout experiences that handle the complete payment flow for both one-time purchases and subscriptions with full customization control.

    Refer to [Checkout Sessions Integration Guide](https://docs.dodopayments.com/developer-resources/checkout-session) for more details and a complete list of supported fields.

    ### Response Format

    Checkout sessions return a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/session/..."
    }
    ```
  </Accordion>
</AccordionGroup>

## Customer Portal Route Handler

The Customer Portal Route Handler enables you to seamlessly integrate the Dodo Payments customer portal into your Fastify application.

### Query Parameters

<ParamField type="string">
  The customer ID for the portal session (e.g., <code>?customer\_id=cus\_123</code>).
</ParamField>

<ParamField type="boolean">
  If set to <code>true</code>, sends an email to the customer with the portal link.
</ParamField>

<Warning>
  Returns 400 if <code>customer\_id</code> is missing.
</Warning>

## Webhook Route Handler

* **Method:** Only POST requests are supported. Other methods return 405.
* **Signature Verification:** Verifies the webhook signature using <code>webhookKey</code>. Returns 401 if verification fails.
* **Payload Validation:** Validated with Zod. Returns 400 for invalid payloads.
* **Error Handling:**
  * 401: Invalid signature
  * 400: Invalid payload
  * 500: Internal error during verification
* **Event Routing:** Calls the appropriate event handler based on the payload type.

### Supported Webhook Event Handlers

<CodeGroup>
  ```typescript Typescript expandable theme={null}
  onPayload?: (payload: WebhookPayload) => Promise<void>;
  onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onPaymentFailed?: (payload: WebhookPayload) => Promise<void>;
  onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>;
  onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>;
  onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onRefundFailed?: (payload: WebhookPayload) => Promise<void>;
  onDisputeOpened?: (payload: WebhookPayload) => Promise<void>;
  onDisputeExpired?: (payload: WebhookPayload) => Promise<void>;
  onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>;
  onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>;
  onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>;
  onDisputeWon?: (payload: WebhookPayload) => Promise<void>;
  onDisputeLost?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>;
  onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>;
  ```
</CodeGroup>

***

## Prompt for LLM

```
You are an expert Fastify developer assistant. Your task is to guide a user through integrating the @dodopayments/fastify adapter into their existing Fastify project.

The @dodopayments/fastify adapter provides route handlers for Dodo Payments' Checkout, Customer Portal, and Webhook functionalities, designed to plug directly into an Fastify app.

First, install the necessary package. Use the package manager appropriate for the user's project (npm, yarn, or bun):

npm install @dodopayments/fastify

---

Here's how you should structure your response:

1. Ask the user which functionalities they want to integrate.

"Which parts of the @dodopayments/fastify adapter would you like to integrate into your project? You can choose one or more of the following:

- Checkout Route Handler (for handling product checkouts)
- Customer Portal Route Handler (for managing customer subscriptions/details)
- Webhook Route Handler (for receiving Dodo Payments webhook events)
- All (integrate all three)"

---

2. Based on the user's selection, provide detailed integration steps for each chosen functionality.

---

**If Checkout Route Handler is selected:**

**Purpose**: This handler redirects users to the Dodo Payments checkout page.

**Integration**:
Create two routes in your Fastify app — one for static (GET) and one for dynamic (POST) checkout.


import { Checkout } from '@dodopayments/fastify';
import Fastify from 'fastify'

const fastify = Fastify({})
const checkoutGet = Checkout({
    bearerToken: process.env.DODO_PAYMENTS_API_KEY,
    environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
    returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
    type: 'static'
});

const checkoutPost = Checkout({
    bearerToken: process.env.DODO_PAYMENTS_API_KEY,
    environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
    returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
    type: 'dynamic'
});

const checkoutSession = Checkout({
    bearerToken: process.env.DODO_PAYMENTS_API_KEY,
    environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
    returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
    type: 'session'
});

fastify.get('/api/checkout', checkoutGet.getHandler);
fastify.post('/api/checkout', checkoutPost.postHandler);
fastify.post('/api/checkout-session', checkoutSession.postHandler);


Config Options:

    bearerToken: Your Dodo Payments API key (recommended to be stored in DODO_PAYMENTS_API_KEY env variable).

    returnUrl (optional): URL to redirect the user after successful checkout.

    environment: "test_mode" or "live_mode"

    type: "static" (GET), "dynamic" (POST), or "session" (POST)

GET (static checkout) expects query parameters:

    productId (required)

    quantity, customer fields (fullName, email, etc.), and metadata (metadata_*) are optional.

    Returns: {"checkout_url": "https://checkout.dodopayments.com/..."}

POST (dynamic checkout) expects a JSON body with payment details (one-time or subscription). Returns: {"checkout_url": "https://checkout.dodopayments.com/..."}. Reference the docs for the full POST schema:

    One-time payments: https://docs.dodopayments.com/api-reference/payments/post-payments

    Subscriptions: https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions

POST (checkout sessions) - (Recommended) A more customizable checkout experience. Returns JSON with checkout_url: Parameters are sent as a JSON body. Supports both one-time and recurring payments. Returns: {"checkout_url": "https://checkout.dodopayments.com/session/..."}. For a complete list of supported fields, refer to:

    Checkout Sessions Integration Guide: https://docs.dodopayments.com/developer-resources/checkout-session

If Customer Portal Route Handler is selected:

Purpose: This route allows customers to manage their subscriptions via the Dodo Payments portal.

Integration:

import { CustomerPortal } from "@dodopayments/fastify";
import Fastify from 'fastify'

const fastify = Fastify({})
const customerPortalHandler = CustomerPortal({
    bearerToken: process.env.DODO_PAYMENTS_API_KEY,
    environment: process.env.DODO_PAYMENTS_ENVIRONMENT
});
fastify.get('/api/customer-portal', customerPortalHandler);

Query Parameters:

    customer_id (required): e.g., ?customer_id=cus_123

    send_email (optional): if true, customer is emailed the portal link

Returns 400 if customer_id is missing.

If Webhook Route Handler is selected:

Purpose: Processes incoming webhook events from Dodo Payments to trigger events in your app.

Integration:

import Fastify from 'fastify'
import { Webhooks } from '@dodopayments/fastify'

const fastify = Fastify({})
fastify.addContentTypeParser('application/json', { parseAs: 'string' }, function (req, body, done) {
    done(null, body)
})

fastify.post('/api/webhooks', Webhooks({
  webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_KEY,
  onPayload: async (payload) => {
    // Handle Payload Here
    console.log(payload)
  }
}));

Features:

    Only POST method is allowed — others return 405

    Signature verification is performed using webhookKey. Returns 401 if invalid.

    Zod-based payload validation. Returns 400 if invalid schema.

    All handlers are async functions.

Supported Webhook Event Handlers:

You may pass in any of the following handlers:

    onPayload

    onPaymentSucceeded

    onPaymentFailed

    onPaymentProcessing

    onPaymentCancelled

    onRefundSucceeded

    onRefundFailed

    onDisputeOpened, onDisputeExpired, onDisputeAccepted, onDisputeCancelled, onDisputeChallenged, onDisputeWon, onDisputeLost

    onSubscriptionActive, onSubscriptionOnHold, onSubscriptionRenewed, onSubscriptionPaused, onSubscriptionPlanChanged, onSubscriptionCancelled, onSubscriptionFailed, onSubscriptionExpired

    onLicenseKeyCreated

Environment Variable Setup:

Make sure to define these environment variables in your project:

DODO_PAYMENTS_API_KEY=your-api-key
DODO_PAYMENTS_RETURN_URL=https://yourapp.com/success
DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode""

Use these inside your code as:

process.env.DODO_PAYMENTS_API_KEY
process.env.DODO_PAYMENTS_WEBHOOK_KEY

Security Note: Do NOT commit secrets to version control. Use .env files locally and secrets managers in deployment environments (e.g., AWS, Vercel, Heroku, etc.).
```


# Framework Adaptors Overview
Source: https://docs.dodopayments.com/developer-resources/framework-adaptors

Pre-built adaptors for popular web frameworks to integrate Dodo Payments in minutes with minimal code

Dodo Payments provides official framework adaptors that simplify payment integration. Each adaptor is designed to work seamlessly with your framework's conventions, offering checkout, customer portal, and webhook handling out of the box.

<Tip>
  Framework adaptors let you integrate Dodo Payments in under 10 lines of code. They handle authentication, request parsing, and response formatting automatically.
</Tip>

## Available Framework Adaptors

Choose the adaptor that matches your framework:

<CardGroup>
  <Card title="Next.js" icon="react" href="/developer-resources/nextjs-adaptor">
    App Router support with route handlers for checkout, portal, and webhooks
  </Card>

  <Card title="Nuxt" icon="vuejs" href="/developer-resources/nuxt-adaptor">
    Vue-based full-stack framework with server routes integration
  </Card>

  <Card title="Express" icon="node-js" href="/developer-resources/express-adaptor">
    Middleware-based handlers for the popular Node.js framework
  </Card>

  <Card title="Fastify" icon="bolt" href="/developer-resources/fastify-adaptor">
    High-performance Node.js framework with plugin architecture
  </Card>

  <Card title="Hono" icon="cloud" href="/developer-resources/hono-adaptor">
    Ultrafast web framework for the edge, Cloudflare Workers, and more
  </Card>

  <Card title="Astro" icon="star" href="/developer-resources/astro-adaptor">
    Content-focused framework with server endpoints support
  </Card>

  <Card title="SvelteKit" icon="code" href="/developer-resources/sveltekit-adaptor">
    Full-stack Svelte framework with server hooks integration
  </Card>

  <Card title="Remix" icon="react" href="/developer-resources/remix-adaptor">
    Full-stack React framework with loader and action handlers
  </Card>

  <Card title="TanStack Start" icon="chart-line" href="/developer-resources/tanstack-adaptor">
    Type-safe full-stack React framework with server functions
  </Card>

  <Card title="Better Auth" icon="shield" href="/developer-resources/better-auth-adaptor">
    Authentication framework plugin for seamless auth + payments
  </Card>

  <Card title="Convex" icon="database" href="/developer-resources/convex-component">
    Backend-as-a-Service component for real-time payment sync
  </Card>
</CardGroup>

## Core Features

All framework adaptors provide these built-in capabilities:

| Feature                | Description                                                   |
| ---------------------- | ------------------------------------------------------------- |
| **Checkout Handler**   | Support for static, dynamic, and session-based checkout flows |
| **Customer Portal**    | Pre-built handler for subscription and billing management     |
| **Webhook Handler**    | Secure signature verification with typed event handlers       |
| **Environment Config** | Simple setup via environment variables                        |
| **Type Safety**        | Full TypeScript support with typed payloads                   |

## Quick Start

Get started with any framework adaptor in three steps:

<Steps>
  <Step title="Install the Adaptor">
    Use your package manager to install the framework-specific adaptor:

    <Tabs>
      <Tab title="Next.js">
        ```bash theme={null}
        npm install @dodopayments/nextjs
        ```
      </Tab>

      <Tab title="Nuxt">
        ```bash theme={null}
        npm install @dodopayments/nuxt
        ```
      </Tab>

      <Tab title="Express">
        ```bash theme={null}
        npm install @dodopayments/express
        ```
      </Tab>

      <Tab title="Hono">
        ```bash theme={null}
        npm install @dodopayments/hono
        ```
      </Tab>

      <Tab title="Astro">
        ```bash theme={null}
        npm install @dodopayments/astro
        ```
      </Tab>

      <Tab title="SvelteKit">
        ```bash theme={null}
        npm install @dodopayments/sveltekit
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Configure Environment Variables">
    Add your Dodo Payments credentials to your environment:

    ```env theme={null}
    DODO_PAYMENTS_API_KEY=your-api-key
    DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
    DODO_PAYMENTS_RETURN_URL=https://yourdomain.com/checkout/success
    DODO_PAYMENTS_ENVIRONMENT="test_mode" # or "live_mode"
    ```

    <Warning>
      Never commit your `.env` file or secrets to version control.
    </Warning>
  </Step>

  <Step title="Create Route Handlers">
    Set up your checkout, customer portal, and webhook routes:

    <Tabs>
      <Tab title="Next.js">
        ```typescript theme={null}
        // app/checkout/route.ts
        import { Checkout } from "@dodopayments/nextjs";

        export const GET = Checkout({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
          environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
        });
        ```
      </Tab>

      <Tab title="Express">
        ```typescript theme={null}
        import { checkoutHandler } from '@dodopayments/express';

        app.get('/api/checkout', checkoutHandler({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
          environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
        }));
        ```
      </Tab>

      <Tab title="Hono">
        ```typescript theme={null}
        import { Checkout } from "@dodopayments/hono";

        app.get('/checkout', Checkout({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
          environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
        }));
        ```
      </Tab>
    </Tabs>

    <Check>
      You're now ready to process payments! Visit the individual adaptor pages for detailed guides and all available options.
    </Check>
  </Step>
</Steps>

## Checkout Flow Types

All adaptors support three checkout flow types:

<AccordionGroup>
  <Accordion title="Static Checkout (GET)">
    Use static checkout for simple, shareable payment links. Pass the product ID as a query parameter:

    ```
    /api/checkout?productId=pdt_xxx&quantity=1
    ```

    Supports optional customer prefill and customization via query parameters.
  </Accordion>

  <Accordion title="Dynamic Checkout (POST)">
    Use dynamic checkout to programmatically create payments with custom details:

    ```json theme={null}
    {
      "product_id": "pdt_xxx",
      "customer": {
        "email": "customer@example.com",
        "name": "John Doe"
      },
      "quantity": 1
    }
    ```

    Supports both one-time payments and subscriptions.
  </Accordion>

  <Accordion title="Checkout Sessions (POST)">
    Use checkout sessions for the most flexible checkout experience with cart support:

    ```json theme={null}
    {
      "product_cart": [
        { "product_id": "pdt_xxx", "quantity": 1 },
        { "product_id": "pdt_yyy", "quantity": 2 }
      ],
      "customer": {
        "email": "customer@example.com"
      }
    }
    ```

    Learn more in the [Checkout Sessions Guide](/developer-resources/checkout-session).
  </Accordion>
</AccordionGroup>

## Webhook Event Handling

All adaptors provide type-safe webhook handling with granular event callbacks:

```typescript theme={null}
Webhooks({
  webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_KEY,
  onPayload: async (payload) => {
    // Handle any webhook event
  },
  onPaymentSucceeded: async (payload) => {
    // Handle successful payments
  },
  onSubscriptionActive: async (payload) => {
    // Handle new subscriptions
  },
  // ... 20+ event types supported
});
```

<Info>
  All webhook handlers automatically verify signatures and validate payloads using Zod schemas. Invalid requests are rejected with appropriate error codes.
</Info>

## Choosing the Right Adaptor

| Framework          | Best For                               | Runtime        |
| ------------------ | -------------------------------------- | -------------- |
| **Next.js**        | Full-stack React apps with App Router  | Node.js, Edge  |
| **Nuxt**           | Full-stack Vue.js applications         | Node.js        |
| **Express**        | REST APIs and traditional Node.js apps | Node.js        |
| **Fastify**        | High-performance APIs                  | Node.js        |
| **Hono**           | Edge deployments, Cloudflare Workers   | Edge, Node.js  |
| **Astro**          | Content sites with server endpoints    | Node.js, Edge  |
| **SvelteKit**      | Full-stack Svelte applications         | Node.js        |
| **Remix**          | Full-stack React with nested routing   | Node.js        |
| **TanStack Start** | Type-safe full-stack React             | Node.js        |
| **Better Auth**    | Apps already using Better Auth         | Various        |
| **Convex**         | Apps using Convex for backend          | Convex Runtime |

## Getting Help

Need assistance with framework adaptors?

* **Discord**: Join our [community server](https://discord.gg/bYqAp4ayYh) for real-time help
* **Email**: Contact us at [support@dodopayments.com](mailto:support@dodopayments.com)
* **GitHub**: Open an issue on the respective adaptor repository
* **Documentation**: Visit our [API reference](/api-reference/introduction)


# Go Boilerplate
Source: https://docs.dodopayments.com/developer-resources/go-boilerplate

Get started quickly with our minimal Go boilerplate for integrating Dodo Payments into your Go backend applications

<Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/go-boilerplate">
  Minimal Go + Dodo Payments boilerplate
</Card>

## Overview

The Go boilerplate provides a production-ready starting point for integrating Dodo Payments with your Go backend. This template includes checkout session handling, webhook verification, customer portal integration, and follows Go best practices to help you start accepting payments quickly.

<Info>
  This boilerplate uses Go 1.21+ with clean architecture patterns (`cmd`, `internal`, `templates`), HTML templates, and the `dodopayments-go` SDK for seamless API integration.
</Info>

### Features

* **Quick Setup** - Get started in under 5 minutes
* **Payment Integration** - Pre-configured checkout flow using `dodopayments-go` SDK
* **Modern UI** - Clean, dark-themed pricing page with HTML templates
* **Webhook Handling** - Securely verify and process payment events
* **Customer Portal** - Self-serve subscription management
* **Go Best Practices** - Clean architecture with `cmd`, `internal`, and `templates`
* **Pre-filled Checkout** - Demonstrates passing customer data to improve UX

## Prerequisites

Before you begin, make sure you have:

* **Go 1.21+**
* **Dodo Payments account** (to access API and Webhook Keys from dashboard)

## Quick Start

<Steps>
  <Step title="Clone the Repository">
    ```bash theme={null}
    git clone https://github.com/dodopayments/go-boilerplate.git
    cd go-boilerplate
    ```
  </Step>

  <Step title="Install Dependencies">
    ```bash theme={null}
    make install
    ```

    Or manually:

    ```bash theme={null}
    go mod download
    ```
  </Step>

  <Step title="Get API Credentials">
    Sign up at [Dodo Payments](https://dodopayments.com/) and get your credentials from the dashboard:

    * **API Key:** [Dashboard → Developer → API Keys](https://app.dodopayments.com/developer/api-keys)
    * **Webhook Key:** [Dashboard → Developer → Webhooks](https://app.dodopayments.com/developer/webhooks)

    <Tip>
      Make sure you're in **Test Mode** while developing!
    </Tip>
  </Step>

  <Step title="Configure Environment Variables">
    Create a `.env` file in the root directory:

    ```bash theme={null}
    cp .env.example .env
    ```

    Update the values with your Dodo Payments credentials:

    ```bash .env theme={null}
    DODO_PAYMENTS_API_KEY=your_api_key_here
    DODO_PAYMENTS_WEBHOOK_KEY=your_webhook_signing_key_here
    DODO_PAYMENTS_RETURN_URL=http://localhost:8000
    DODO_PAYMENTS_ENVIRONMENT=test_mode
    ```

    <Warning>
      Never commit your `.env` file to version control. It's already included in `.gitignore`.
    </Warning>
  </Step>

  <Step title="Add Your Products">
    Update `internal/lib/products.go` with your actual product IDs from Dodo Payments:

    ```go theme={null}
    var Products = []Product{
        {
            ProductID:   "pdt_001", // Replace with your product ID
            Name:        "Basic Plan",
            Description: "Get access to basic features and support",
            Price:       9999, // in cents
            Features: []string{
                "Access to basic features",
                "Email support",
                "1 Team member",
                "Basic analytics",
            },
        },
        // ... add more products
    }
    ```
  </Step>

  <Step title="Run the Development Server">
    ```bash theme={null}
    make run
    ```

    Or manually:

    ```bash theme={null}
    go run cmd/server/main.go
    ```

    Open [http://localhost:8000](http://localhost:8000) to see your pricing page!

    <Check>
      You should see a dark-themed pricing page with your products ready to purchase.
    </Check>
  </Step>
</Steps>

## Project Structure

```text theme={null}
go-boilerplate/
├── cmd/
│   └── server/             # Application entry point
├── internal/
│   ├── api/                # API handlers (Checkout, Portal, Webhook)
│   ├── core/               # Configuration and system core
│   └── lib/                # Shared logic (Products, Customer utils)
├── templates/              # HTML templates
├── Makefile                # Build and run commands
├── go.mod                  # Go module definition
├── go.sum                  # Dependency checksums
├── .env.example            # Environment template
└── README.md
```

## API Endpoints

The boilerplate includes the following pre-configured endpoints:

| Endpoint               | Method | Description                       |
| ---------------------- | ------ | --------------------------------- |
| `/`                    | GET    | Pricing page with product listing |
| `/api/checkout`        | POST   | Create a new checkout session     |
| `/api/webhook`         | POST   | Handle Dodo Payments webhooks     |
| `/api/customer-portal` | POST   | Generate customer portal URL      |

## Customization

### Update Product Information

Edit `internal/lib/products.go` to modify:

* Product IDs (from your Dodo dashboard)
* Pricing
* Features
* Descriptions

```go theme={null}
var Products = []Product{
    {
        ProductID:   "pdt_001", // Replace with your product ID
        Name:        "Basic Plan",
        Description: "Get access to basic features and support",
        Price:       9999,
        Features: []string{
            "Access to basic features",
            "Email support",
            "1 Team member",
            "Basic analytics",
        },
    },
}
```

### Pre-fill Customer Data

In `templates/index.html`, replace the hardcoded customer data with your actual user data:

```javascript theme={null}
const customerData = {
    name: "John Doe",       // Replace with actual logged-in user's name
    email: "john@example.com"  // Replace with actual logged-in user's email
};
```

In a production app, you would dynamically inject these values from your authentication system.

## Webhook Events

The boilerplate demonstrates handling webhook events in `internal/api/webhook.go`. Supported events include:

| Event                 | Description                                  |
| --------------------- | -------------------------------------------- |
| `subscription.active` | Triggered when a subscription becomes active |
| `payment.succeeded`   | Triggered when a payment is successful       |

Add your business logic inside the webhook handler to:

* Update user permissions in your database
* Send confirmation emails
* Provision access to digital products
* Track analytics and metrics

## Testing Webhooks Locally

For local development, use tools like [ngrok](https://ngrok.com/) to expose your local server:

```bash theme={null}
ngrok http 8000
```

Update the webhook URL in your [Dodo Payments Dashboard](https://app.dodopayments.com/developer/webhooks):

```
https://your-ngrok-url.ngrok.io/api/webhook
```

## Deployment

### Build for Production

```bash theme={null}
make build
```

Or manually:

```bash theme={null}
go build -o bin/server cmd/server/main.go
./bin/server
```

### Deploy to Vercel

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https://github.com/dodopayments/go-boilerplate)

### Docker

Create a `Dockerfile`:

```dockerfile theme={null}
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN go build -o bin/server cmd/server/main.go

FROM alpine:latest
WORKDIR /app
COPY --from=builder /app/bin/server .
COPY --from=builder /app/templates ./templates

EXPOSE 8000
CMD ["./server"]
```

Build and run:

```bash theme={null}
docker build -t go-dodo .
docker run -p 8000:8000 --env-file .env go-dodo
```

### Production Considerations

<Warning>
  Before deploying to production:

  * Switch `DODO_PAYMENTS_ENVIRONMENT` to `live_mode`
  * Use production API keys from the dashboard
  * Update the webhook URL to your production domain
  * Enable HTTPS for all endpoints
</Warning>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Build errors or missing dependencies">
    Ensure Go modules are properly downloaded:

    ```bash theme={null}
    go mod tidy
    go mod download
    ```
  </Accordion>

  <Accordion title="Checkout session creation fails">
    **Common causes:**

    * Invalid product ID - verify it exists in your Dodo dashboard
    * Wrong API key or environment setting in `.env`
    * Check the server logs for detailed error messages
  </Accordion>

  <Accordion title="Webhooks not receiving events">
    For local testing, use [ngrok](https://ngrok.com) to expose your server:

    ```bash theme={null}
    ngrok http 8000
    ```

    Update the webhook URL in your [Dodo dashboard](https://app.dodopayments.com/developer/webhooks) to the ngrok URL. Make sure to update your `.env` file with the correct webhook verification key.
  </Accordion>

  <Accordion title="Templates not loading">
    Ensure you're running the server from the project root directory, or that the templates path is correctly configured in your code.
  </Accordion>
</AccordionGroup>

## Learn More

<CardGroup>
  <Card title="Go SDK" icon="golang" href="/developer-resources/sdks/go">
    Complete Go SDK documentation
  </Card>

  <Card title="Webhooks Documentation" icon="webhook" href="/developer-resources/webhooks">
    Learn about all webhook events and best practices
  </Card>

  <Card title="Checkout Sessions" icon="credit-card" href="/developer-resources/checkout-session">
    Deep dive into checkout session configuration
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/introduction">
    Complete Dodo Payments API documentation
  </Card>
</CardGroup>

## Support

Need help with the boilerplate?

* Join our [Discord community](https://discord.gg/bYqAp4ayYh) for questions and discussions
* Check the [GitHub repository](https://github.com/dodopayments/go-boilerplate) for issues and updates
* Contact our [support team](mailto:support@dodopayments.com) for assistance


# Hono Adaptor
Source: https://docs.dodopayments.com/developer-resources/hono-adaptor

Learn how to integrate Dodo Payments with your Hono App Router project using our NextJS Adaptor. Covers checkout, customer portal, webhooks, and secure environment setup.

<CardGroup>
  <Card title="Checkout Handler" icon="cart-shopping" href="#checkout-route-handler">
    Integrate Dodo Payments checkout into your Hono app.
  </Card>

  <Card title="Customer Portal" icon="user" href="#customer-portal-route-handler">
    Allow customers to manage subscriptions and details.
  </Card>

  <Card title="Webhooks" icon="bell" href="#webhook-route-handler">
    Receive and process Dodo Payments webhook events.
  </Card>
</CardGroup>

## Installation

<Steps>
  <Step title="Install the package">
    Run the following command in your project root:

    ```bash theme={null}
    npm install @dodopayments/hono
    ```
  </Step>

  <Step title="Set up environment variables">
    Create a <code>.env</code> file in your project root:

    ```env expandable theme={null}
    DODO_PAYMENTS_API_KEY=your-api-key
    DODO_PAYMENTS_RETURN_URL=https://yourapp.com/success
    DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
    DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode""
    ```

    <Warning>
      Never commit your <code>.env</code> file or secrets to version control.
    </Warning>
  </Step>
</Steps>

## Route Handler Examples

<Info>
  All examples assume you are using the Hono App Router.
</Info>

<Tabs>
  <Tab title="Checkout Handler">
    <Info>
      Use this handler to integrate Dodo Payments checkout into your Hono app. Supports static (GET), dynamic (POST), and session (POST) flows.
    </Info>

    <CodeGroup>
      ```typescript Hono Route Handler expandable theme={null}
        // route.ts
        import { Checkout } from '@dodopayments/hono';
        import Hono from 'hono'

        const app = new Hono()

        app.get(
        "/api/checkout",
        Checkout({
            bearerToken: process.env.DODO_PAYMENTS_API_KEY,
            environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
            returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
            type: 'static'
        })
        );

        app.post(
        "/api/checkout",
        Checkout({
            bearerToken: process.env.DODO_PAYMENTS_API_KEY,
            environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
            returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
            type: 'dynamic'
        })
        );
        
        app.post(
        "/api/checkout",
        Checkout({
            bearerToken: process.env.DODO_PAYMENTS_API_KEY,
            environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
            returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
            type: 'session'
        })
        );
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Static Checkout Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/checkout?productId=pdt_fqJhl7pxKWiLhwQR042rh' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Dynamic Checkout Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "billing": {
        "city": "Texas",
        "country": "US",
        "state": "Texas",
        "street": "56, hhh",
        "zipcode": "560000"
      },
      "customer": {
        "email": "test@example.com",
        	"name": "test"
      },
      "metadata": {},
      "payment_link": true,
        "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
        "quantity": 1,
        "billing_currency": "USD",
        "discount_code": "IKHZ23M9GQ",
        "return_url": "https://example.com",
        "trial_period_days": 10
      }'
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Checkout Session Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "product_cart": [
        {
          "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
          "quantity": 1
        }
      ],
      "customer": {
        "email": "test@example.com",
        "name": "test"
      },
      "return_url": "https://example.com/success"
      }'
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Customer Portal Handler">
    <Info>
      Use this handler to allow customers to manage their subscriptions and details via the Dodo Payments customer portal.
    </Info>

    <CodeGroup>
      ```typescript Hono Route Handler expandable theme={null}
      // route.ts
      import { Checkout } from '@dodopayments/hono';
      import Hono from 'hono'

      const app = new Hono()
      app.get(
          "/api/customer-portal",
          CustomerPortal({
              bearerToken: process.env.DODO_PAYMENTS_API_KEY,
              environment: process.env.DODO_PAYMENTS_ENVIRONMENT
          })
      );
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Customer Portal Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/customer-portal?customer_id=cus_9VuW4K7O3GHwasENg31m&send_email=true' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Webhook Handler">
    <Info>
      Use this handler to receive and process Dodo Payments webhook events securely in your Hono app.
    </Info>

    <CodeGroup>
      ```typescript Hono Route Handler expandable theme={null}
      // route.ts
      import Hono from 'hono'
      import { Webhooks } from '@dodopayments/hono'

      const app = new Hono()
      app.post(
      "/api/webhooks",
          Webhooks({
              webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_KEY,
              onPayload: async (payload) => {
              // Handle Payload Here
              console.log(payload)
              }
          })
      );

      ```
    </CodeGroup>
  </Tab>
</Tabs>

## Checkout Route Handler

<Info>
  Dodo Payments supports three types of payment flows for integrating payments into your website, this adaptor supports all types of payment flows.
</Info>

* **Static Payment Links:** Instantly shareable URLs for quick, no-code payment collection.
* **Dynamic Payment Links:** Programmatically generate payment links with custom details using the API or SDKs.
* **Checkout Sessions:** Create secure, customizable checkout experiences with pre-configured product carts and customer details.

<AccordionGroup>
  <Accordion title="Static Checkout (GET)">
    ### Supported Query Parameters

    <ParamField type="string">
      Product identifier (e.g., <code>?productId=pdt\_nZuwz45WAs64n3l07zpQR</code>).
    </ParamField>

    <ParamField type="integer">
      Quantity of the product.
    </ParamField>

    <ParamField type="string">
      Customer's full name.
    </ParamField>

    <ParamField type="string">
      Customer's first name.
    </ParamField>

    <ParamField type="string">
      Customer's last name.
    </ParamField>

    <ParamField type="string">
      Customer's email address.
    </ParamField>

    <ParamField type="string">
      Customer's country.
    </ParamField>

    <ParamField type="string">
      Customer's address line.
    </ParamField>

    <ParamField type="string">
      Customer's city.
    </ParamField>

    <ParamField type="string">
      Customer's state/province.
    </ParamField>

    <ParamField type="string">
      Customer's zip/postal code.
    </ParamField>

    <ParamField type="boolean">
      Disable full name field.
    </ParamField>

    <ParamField type="boolean">
      Disable first name field.
    </ParamField>

    <ParamField type="boolean">
      Disable last name field.
    </ParamField>

    <ParamField type="boolean">
      Disable email field.
    </ParamField>

    <ParamField type="boolean">
      Disable country field.
    </ParamField>

    <ParamField type="boolean">
      Disable address line field.
    </ParamField>

    <ParamField type="boolean">
      Disable city field.
    </ParamField>

    <ParamField type="boolean">
      Disable state field.
    </ParamField>

    <ParamField type="boolean">
      Disable zip code field.
    </ParamField>

    <ParamField type="string">
      Specify the payment currency (e.g., <code>USD</code>).
    </ParamField>

    <ParamField type="boolean">
      Show currency selector.
    </ParamField>

    <ParamField type="integer">
      Specify the payment amount (e.g., <code>1000</code> for \$10.00).
    </ParamField>

    <ParamField type="boolean">
      Show discount fields.
    </ParamField>

    <ParamField type="string">
      Any query parameter starting with <code>metadata\_</code> will be passed as metadata.
    </ParamField>

    <Warning>
      If <code>productId</code> is missing, the handler returns a 400 response. Invalid query parameters also result in a 400 response.
    </Warning>

    ### Response Format

    Static checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Dynamic Checkout (POST)">
    * Send parameters as a JSON body in a POST request.
    * Supports both one-time and recurring payments.
    * For a complete list of supported POST body fields, refer to:
      * [Request body for a One Time Payment Product](https://docs.dodopayments.com/api-reference/payments/post-payments)
      * [Request body for a Subscription Product](https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions)

    ### Response Format

    Dynamic checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Checkout Sessions (POST)">
    Checkout sessions provide a more secure, hosted checkout experience that handles the complete payment flow for both one-time purchases and subscriptions with full customization control.

    Refer to [Checkout Sessions Integration Guide](https://docs.dodopayments.com/developer-resources/checkout-session) for more details and a complete list of supported fields.

    ### Response Format

    Checkout sessions return a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/session/..."
    }
    ```
  </Accordion>
</AccordionGroup>

## Customer Portal Route Handler

The Customer Portal Route Handler enables you to seamlessly integrate the Dodo Payments customer portal into your Hono application.

### Query Parameters

<ParamField type="string">
  The customer ID for the portal session (e.g., <code>?customer\_id=cus\_123</code>).
</ParamField>

<ParamField type="boolean">
  If set to <code>true</code>, sends an email to the customer with the portal link.
</ParamField>

<Warning>
  Returns 400 if <code>customer\_id</code> is missing.
</Warning>

## Webhook Route Handler

* **Method:** Only POST requests are supported. Other methods return 405.
* **Signature Verification:** Verifies the webhook signature using <code>webhookKey</code>. Returns 401 if verification fails.
* **Payload Validation:** Validated with Zod. Returns 400 for invalid payloads.
* **Error Handling:**
  * 401: Invalid signature
  * 400: Invalid payload
  * 500: Internal error during verification
* **Event Routing:** Calls the appropriate event handler based on the payload type.

### Supported Webhook Event Handlers

<CodeGroup>
  ```typescript Typescript expandable theme={null}
  onPayload?: (payload: WebhookPayload) => Promise<void>;
  onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onPaymentFailed?: (payload: WebhookPayload) => Promise<void>;
  onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>;
  onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>;
  onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onRefundFailed?: (payload: WebhookPayload) => Promise<void>;
  onDisputeOpened?: (payload: WebhookPayload) => Promise<void>;
  onDisputeExpired?: (payload: WebhookPayload) => Promise<void>;
  onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>;
  onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>;
  onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>;
  onDisputeWon?: (payload: WebhookPayload) => Promise<void>;
  onDisputeLost?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>;
  onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>;
  ```
</CodeGroup>

***

## Prompt for LLM

```
You are an expert Hono developer assistant. Your task is to guide a user through integrating the @dodopayments/hono adapter into their existing Hono project.

The @dodopayments/hono adapter provides route handlers for Dodo Payments' Checkout, Customer Portal, and Webhook functionalities, designed to plug directly into an Hono app.

First, install the necessary package. Use the package manager appropriate for the user's project (npm, yarn, or bun):

npm install @dodopayments/hono

---

Here's how you should structure your response:

1. Ask the user which functionalities they want to integrate.

"Which parts of the @dodopayments/hono adapter would you like to integrate into your project? You can choose one or more of the following:

- Checkout Route Handler (for handling product checkouts)
- Customer Portal Route Handler (for managing customer subscriptions/details)
- Webhook Route Handler (for receiving Dodo Payments webhook events)
- All (integrate all three)"

---

2. Based on the user's selection, provide detailed integration steps for each chosen functionality.

---

**If Checkout Route Handler is selected:**

**Purpose**: This handler redirects users to the Dodo Payments checkout page.

**Integration**:
Create two routes in your Hono app — one for static (GET) and one for dynamic (POST) checkout.


import { Checkout } from '@dodopayments/hono';
import Hono from 'hono'

const app = new Hono()

app.get(
  "/api/checkout",
  Checkout({
    bearerToken: process.env.DODO_PAYMENTS_API_KEY,
    environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
    returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
    type: 'static'
  })
);

app.post(
  "/api/checkout",
  Checkout({
    bearerToken: process.env.DODO_PAYMENTS_API_KEY,
    environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
    returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
    type: 'session' // or 'dynamic' for dynamic link
  })
);


Config Options:

    bearerToken: Your Dodo Payments API key (recommended to be stored in DODO_PAYMENTS_API_KEY env variable).

    returnUrl (optional): URL to redirect the user after successful checkout.

    environment: "test_mode" or "live_mode"

    type: "static" (GET) or "dynamic" (POST) or "session" (POST)

GET (static checkout) expects query parameters:

    productId (required)

    quantity, customer fields (fullName, email, etc.), and metadata (metadata_*) are optional.

POST (dynamic checkout) expects a JSON body with payment details (one-time or subscription). Reference the docs for the full POST schema:

    One-time payments: https://docs.dodopayments.com/api-reference/payments/post-payments

    Subscriptions: https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions


POST (checkout sessions) - (Recommended) A more customizable checkout experience. Returns JSON with checkout_url: Parameters are sent as a JSON body. Supports both one-time and recurring payments. Returns: {"checkout_url": "https://checkout.dodopayments.com/session/..."}. For a complete list of supported fields, refer to:

  Checkout Sessions Integration Guide: https://docs.dodopayments.com/developer-resources/checkout-session


If Customer Portal Route Handler is selected:

Purpose: This route allows customers to manage their subscriptions via the Dodo Payments portal.

Integration:

import { Checkout } from '@dodopayments/hono';
import Hono from 'hono'

const app = new Hono()
app.get(
  "/api/customer-portal",
  CustomerPortal({
    bearerToken: process.env.DODO_PAYMENTS_API_KEY,
    environment: process.env.DODO_PAYMENTS_ENVIRONMENT
  })
);

Query Parameters:

    customer_id (required): e.g., ?customer_id=cus_123

    send_email (optional): if true, customer is emailed the portal link

Returns 400 if customer_id is missing.

If Webhook Route Handler is selected:

Purpose: Processes incoming webhook events from Dodo Payments to trigger events in your app.

Integration:

import Hono from 'hono'
import { Webhooks } from '@dodopayments/hono'

const app = new Hono()
app.post(
  "/api/webhooks",
  Webhooks({
    webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_KEY,
    onPayload: async (payload) => {
      // Handle Payload Here
      console.log(payload)
    }
  })
);

Features:

    Only POST method is allowed — others return 405

    Signature verification is performed using webhookKey. Returns 401 if invalid.

    Zod-based payload validation. Returns 400 if invalid schema.

    All handlers are async functions.

Supported Webhook Event Handlers:

You may pass in any of the following handlers:

    onPayload

    onPaymentSucceeded

    onPaymentFailed

    onPaymentProcessing

    onPaymentCancelled

    onRefundSucceeded

    onRefundFailed

    onDisputeOpened, onDisputeExpired, onDisputeAccepted, onDisputeCancelled, onDisputeChallenged, onDisputeWon, onDisputeLost

    onSubscriptionActive, onSubscriptionOnHold, onSubscriptionRenewed, onSubscriptionPaused, onSubscriptionPlanChanged, onSubscriptionCancelled, onSubscriptionFailed, onSubscriptionExpired

    onLicenseKeyCreated

Environment Variable Setup:

Make sure to define these environment variables in your project:

DODO_PAYMENTS_API_KEY=your-api-key
DODO_PAYMENTS_RETURN_URL=https://yourapp.com/success
DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode""

Use these inside your code as:

process.env.DODO_PAYMENTS_API_KEY
process.env.DODO_PAYMENTS_WEBHOOK_KEY

Security Note: Do NOT commit secrets to version control. Use .env files locally and secrets managers in deployment environments (e.g., AWS, Vercel, Heroku, etc.).
```


# API Gateway Blueprint
Source: https://docs.dodopayments.com/developer-resources/ingestion-blueprints/api-gateway

Track API calls and gateway-level usage for billing. Perfect for API-as-a-service platforms with high-volume request tracking.

## Use Cases

Explore common scenarios supported by the API Gateway Blueprint:

<CardGroup>
  <Card title="API-as-a-Service" icon="server">
    Track usage per customer for API platforms and charge based on number of calls.
  </Card>

  <Card title="Rate Limiting" icon="gauge">
    Monitor API usage patterns and implement usage-based rate limiting.
  </Card>

  <Card title="Performance Monitoring" icon="chart-line">
    Track response times and error rates alongside billing data.
  </Card>

  <Card title="Multi-Tenant SaaS" icon="users">
    Bill customers based on their API consumption across different endpoints.
  </Card>
</CardGroup>

<Info>
  Ideal for tracking API endpoint usage, rate limiting, and implementing usage-based API billing.
</Info>

## Quick Start

Track API calls at the gateway level with automatic batching for high-volume scenarios:

<Steps>
  <Step title="Install the SDK">
    ```bash theme={null}
    npm install @dodopayments/ingestion-blueprints
    ```
  </Step>

  <Step title="Get Your API Keys">
    * **Dodo Payments API Key**: Get it from [Dodo Payments Dashboard](https://app.dodopayments.com/developer/api-keys)
  </Step>

  <Step title="Create a Meter">
    Create a meter in your [Dodo Payments Dashboard](https://app.dodopayments.com/):

    * **Event Name**: `api_call` (or your preferred name)
    * **Aggregation Type**: `count` for tracking number of calls
    * Configure additional properties if tracking metadata like response times, status codes, etc.
  </Step>

  <Step title="Track API Calls">
    <CodeGroup>
      ```javascript Single API Call theme={null}
      import { Ingestion, trackAPICall } from '@dodopayments/ingestion-blueprints';

      const ingestion = new Ingestion({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'api_call'
      });

      // Track a single API call
      await trackAPICall(ingestion, {
        customerId: 'customer_123',
        metadata: {
          endpoint: '/api/v1/users',
          method: 'GET',
          status_code: 200,
          response_time_ms: 45
        }
      });
      ```

      ```javascript High-Volume with Batching theme={null}
      import { Ingestion, createBatch } from '@dodopayments/ingestion-blueprints';

      const ingestion = new Ingestion({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'live_mode',
        eventName: 'api_call'
      });

      // Create batch for high-volume tracking
      const batch = createBatch(ingestion, {
        maxSize: 100,      // Flush after 100 events
        flushInterval: 5000 // Or flush every 5 seconds
      });

      // Add API calls to batch
      batch.add({
        customerId: 'customer_123',
        metadata: {
          endpoint: '/api/v1/products',
          method: 'GET',
          status_code: 200
        }
      });

      // Clean up when done
      await batch.cleanup();
      ```

      ```javascript Express.js Middleware theme={null}
      import express from 'express';
      import { Ingestion, createBatch } from '@dodopayments/ingestion-blueprints';

      const app = express();

      const ingestion = new Ingestion({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'live_mode',
        eventName: 'api_call'
      });

      const batch = createBatch(ingestion, {
        maxSize: 50,
        flushInterval: 10000
      });

      // Middleware to track all API calls
      app.use((req, res, next) => {
        const startTime = Date.now();
        
        res.on('finish', () => {
          const responseTime = Date.now() - startTime;
          
          batch.add({
            customerId: req.user?.id || 'anonymous',
            metadata: {
              endpoint: req.path,
              method: req.method,
              status_code: res.statusCode,
              response_time_ms: responseTime
            }
          });
        });
        
        next();
      });

      // Cleanup on shutdown
      process.on('SIGTERM', async () => {
        await batch.cleanup();
        process.exit(0);
      });
      ```
    </CodeGroup>
  </Step>
</Steps>

## Configuration

### Ingestion Configuration

<ParamField type="string">
  Your Dodo Payments API key from the dashboard.
</ParamField>

<ParamField type="string">
  Environment mode: `test_mode` or `live_mode`.
</ParamField>

<ParamField type="string">
  Event name that matches your meter configuration.
</ParamField>

### Track API Call Options

<ParamField type="string">
  The customer ID for billing attribution.
</ParamField>

<ParamField type="object">
  Optional metadata about the API call like endpoint, method, status code, response time, etc.
</ParamField>

### Batch Configuration

<ParamField type="number">
  Maximum number of events before auto-flush. Default: `100`.
</ParamField>

<ParamField type="number">
  Auto-flush interval in milliseconds. Default: `5000` (5 seconds).
</ParamField>

## Best Practices

<Tip>
  **Use Batching for High Volume**: For applications handling more than 10 requests per second, use `createBatch()` to reduce overhead and improve performance.
</Tip>

<Warning>
  **Always Clean Up Batches**: Call `batch.cleanup()` on application shutdown to flush pending events and prevent data loss.
</Warning>


# LLM Blueprint
Source: https://docs.dodopayments.com/developer-resources/ingestion-blueprints/llm

Effortlessly track LLM token usage for usage-based billing with automatic ingestion to Dodo Payments. Works with AI SDK, OpenAI, Anthropic, OpenRouter, Groq, and Google Gemini.

<CardGroup>
  <Card title="Quick Start" icon="rocket" href="#quick-start">
    Get started in 2 minutes with automatic token tracking.
  </Card>

  <Card title="API Reference - Events Ingestion" icon="code" href="/api-reference/usage-events/ingest-events">
    Complete API documentation for ingesting usage events.
  </Card>

  <Card title="API Reference - Meters" icon="gauge" href="/api-reference/meters/create-meter">
    Learn how to create and configure meters for billing.
  </Card>

  <Card title="Usage-Based Billing Guide" icon="arrow-trend-up" href="/developer-resources/usage-based-billing-guide">
    Comprehensive guide to usage-based billing with meters.
  </Card>
</CardGroup>

<Info>
  Perfect for SaaS apps, AI chatbots, content generation tools, and any LLM-powered application that needs usage-based billing.
</Info>

## Quick Start

Get started with automatic LLM token tracking in just 2 minutes:

<Steps>
  <Step title="Install the SDK">
    Install the Dodo Payments Ingestion Blueprints:

    ```bash theme={null}
    npm install @dodopayments/ingestion-blueprints
    ```
  </Step>

  <Step title="Get Your API Keys">
    You'll need two API keys:

    * **Dodo Payments API Key**: Get it from [Dodo Payments Dashboard](https://app.dodopayments.com/developer/api-keys)
    * **LLM Provider API Key**: From AI SDK, OpenAI, Anthropic, Groq, etc.

    <Tip>
      Store your API keys securely in environment variables. Never commit them to version control.
    </Tip>
  </Step>

  <Step title="Create a Meter in Dodo Payments">
    Before tracking usage, create a meter in your Dodo Payments dashboard:

    1. **Login** to [Dodo Payments Dashboard](https://app.dodopayments.com/)
    2. **Navigate to** Products → Meters
    3. **Click** "Create Meter"
    4. **Configure your meter**:
       * **Meter Name**: Choose a descriptive name (e.g., "LLM Token Usage")
       * **Event Name**: Set a unique event identifier (e.g., `llm.chat_completion`)
       * **Aggregation Type**: Select `sum` to add up token counts
       * **Over Property**: Choose what to track:
         * `inputTokens` - Track input/prompt tokens
         * `outputTokens` - Track output/completion tokens (includes reasoning tokens when applicable)
         * `totalTokens` - Track combined input + output tokens

    <Info>
      The **Event Name** you set here must match exactly what you pass to the SDK (case-sensitive).
    </Info>

    For detailed instructions, see the [Usage-Based Billing Guide](/developer-resources/usage-based-billing-guide).
  </Step>

  <Step title="Track Token Usage">
    Wrap your LLM client and start tracking automatically:

    <CodeGroup>
      ```javascript AI SDK theme={null}
      import { createLLMTracker } from '@dodopayments/ingestion-blueprints';
      import { generateText } from 'ai';
      import { google } from '@ai-sdk/google';

      const llmTracker = createLLMTracker({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'aisdk.usage',
      });

      const client = llmTracker.wrap({
        client: { generateText },
        customerId: 'customer_123'
      });

      const response = await client.generateText({
        model: google('gemini-2.0-flash'),
        prompt: 'Hello!',
        maxOutputTokens: 500
      });

      console.log('Usage:', response.usage);
      ```

      ```javascript OpenRouter theme={null}
      import { createLLMTracker } from '@dodopayments/ingestion-blueprints';
      import OpenAI from 'openai';

      const openrouter = new OpenAI({
        baseURL: 'https://openrouter.ai/api/v1',
        apiKey: process.env.OPENROUTER_API_KEY
      });

      const llmTracker = createLLMTracker({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'openrouter.usage'
      });

      const client = llmTracker.wrap({
        client: openrouter,
        customerId: 'customer_123'
      });

      const response = await client.chat.completions.create({
        model: 'qwen/qwen3-max',
        messages: [{ role: 'user', content: 'Hello!' }],
        max_tokens: 500
      });

      console.log('Response:', response.choices[0].message.content);
      console.log('Usage:', response.usage);
      ```

      ```javascript OpenAI theme={null}
      import { createLLMTracker } from '@dodopayments/ingestion-blueprints';
      import OpenAI from 'openai';

      // 1. Create your LLM client (normal way)
      const openai = new OpenAI({ 
        apiKey: process.env.OPENAI_API_KEY 
      });

      // 2. Create tracker ONCE at startup
      const tracker = createLLMTracker({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode', // Use 'live_mode' for production
        eventName: 'llm.chat_completion' // Match your meter's event name
      });

      // 3. Wrap & use - automatic tracking!
      const client = tracker.wrap({ 
        client: openai, 
        customerId: 'customer_123' 
      });

      // Every API call is now automatically tracked
      const response = await client.chat.completions.create({
        model: 'gpt-4',
        messages: [{ role: 'user', content: 'Hello!' }]
      });

      // ✨ Usage automatically sent to Dodo Payments!
      console.log('Tokens used:', response.usage);
      ```

      ```javascript Anthropic theme={null}
      import { createLLMTracker } from '@dodopayments/ingestion-blueprints';
      import Anthropic from '@anthropic-ai/sdk';

      const anthropic = new Anthropic({ 
        apiKey: process.env.ANTHROPIC_API_KEY 
      });

      const tracker = createLLMTracker({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'anthropic.usage'
      });

      const client = tracker.wrap({ 
        client: anthropic, 
        customerId: 'customer_123' 
      });

      const response = await client.messages.create({
        model: 'claude-sonnet-4-0',
        max_tokens: 1024,
        messages: [{ role: 'user', content: 'Hello Claude!' }]
      });

      console.log('Tokens used:', response.usage);
      ```

      ```javascript Groq theme={null}
      import { createLLMTracker } from '@dodopayments/ingestion-blueprints';
      import Groq from 'groq-sdk';

      const groq = new Groq({ 
        apiKey: process.env.GROQ_API_KEY 
      });

      const tracker = createLLMTracker({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'groq.usage'
      });

      const client = tracker.wrap({ 
        client: groq, 
        customerId: 'customer_123' 
      });

      const response = await client.chat.completions.create({
        model: 'llama-3.1-8b-instant',
        messages: [{ role: 'user', content: 'Hello!' }]
      });

      console.log('Tokens:', response.usage);
      ```

      ```javascript Google Gemini theme={null}
      import { createLLMTracker } from '@dodopayments/ingestion-blueprints';
      import { GoogleGenAI } from '@google/genai';

      const googleGenai = new GoogleGenAI({
        apiKey: process.env.GOOGLE_GENERATIVE_AI_API_KEY
      });

      const llmTracker = createLLMTracker({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'gemini.usage'
      });

      const client = llmTracker.wrap({
        client: googleGenai,
        customerId: 'customer_123'
      });

      const response = await client.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: 'Why is the sky blue?'
      });

      console.log('Response:', response.text);
      console.log('Usage:', response.usageMetadata);
      ```
    </CodeGroup>

    <Check>
      That's it! Every API call now automatically tracks token usage and sends events to Dodo Payments for billing.
    </Check>
  </Step>
</Steps>

***

## Configuration

### Tracker Configuration

Create a tracker once at application startup with these required parameters:

<ParamField type="string">
  Your Dodo Payments API key. Get it from the [API Keys page](https://app.dodopayments.com/developer/api-keys).

  ```javascript theme={null}
  apiKey: process.env.DODO_PAYMENTS_API_KEY
  ```
</ParamField>

<ParamField type="string">
  The environment mode for the tracker.

  * `test_mode` - Use for development and testing
  * `live_mode` - Use for production

  ```javascript theme={null}
  environment: 'test_mode' // or 'live_mode'
  ```

  <Warning>
    Always use `test_mode` during development to avoid affecting production metrics.
  </Warning>
</ParamField>

<ParamField type="string">
  The event name that triggers your meter. Must match exactly what you configured in your Dodo Payments meter (case-sensitive).

  ```javascript theme={null}
  eventName: 'llm.chat_completion'
  ```

  <Info>
    This event name links your tracked usage to the correct meter for billing calculations.
  </Info>
</ParamField>

### Wrapper Configuration

When wrapping your LLM client, provide these parameters:

<ParamField type="object">
  Your LLM client instance (OpenAI, Anthropic, Groq, etc.).

  ```javascript theme={null}
  client: openai
  ```
</ParamField>

<ParamField type="string">
  The unique customer identifier for billing. This should match your customer ID in Dodo Payments.

  ```javascript theme={null}
  customerId: 'customer_123'
  ```

  <Tip>
    Use your application's user ID or customer ID to ensure accurate billing per customer.
  </Tip>
</ParamField>

<ParamField type="object">
  Optional additional data to attach to the tracking event. Useful for filtering and analysis.

  ```javascript theme={null}
  metadata: {
    feature: 'chat',
    userTier: 'premium',
    sessionId: 'session_123',
    modelVersion: 'gpt-4'
  }
  ```
</ParamField>

### Complete Configuration Example

<CodeGroup>
  ```javascript Full Configuration theme={null}
  import { createLLMTracker } from "@dodopayments/ingestion-blueprints";
  import { generateText } from "ai";
  import { google } from "@ai-sdk/google";
  import "dotenv/config";

  async function aiSdkExample() {
    console.log("🤖 AI SDK Simple Usage Example\n");

    try {
      // 1. Create tracker
      const llmTracker = createLLMTracker({
        apiKey: process.env.DODO_PAYMENTS_API_KEY!,
        environment: "test_mode",
        eventName: "your_meter_event_name",
      });

      // 2. Wrap the ai-sdk methods
      const client = llmTracker.wrap({
        client: { generateText },
        customerId: "customer_123",
        metadata: {
          provider: "ai-sdk",
        },
      });

      // 3. Use the wrapped function
      const response = await client.generateText({
        model: google("gemini-2.5-flash"),
        prompt: "Hello, I am a cool guy! Tell me a fun fact.",
        maxOutputTokens: 500,
      });

      console.log(response);
      console.log(response.usage);
      console.log("✅ Automatically tracked for customer\n");
    } catch (error) {
      console.error(error);
    }
  }

  aiSdkExample().catch(console.error);
  ```
</CodeGroup>

<Info>
  **Automatic Tracking:** The SDK automatically tracks token usage in the background without modifying the response. Your code remains clean and identical to using the original provider SDKs.
</Info>

***

## Supported Providers

The LLM Blueprint works seamlessly with all major LLM providers and aggregators:

<AccordionGroup>
  <Accordion title="AI SDK (Vercel)" icon="code">
    Track usage with the Vercel AI SDK for universal LLM support.

    <CodeGroup>
      ```javascript AI SDK Integration theme={null}
      import { createLLMTracker } from '@dodopayments/ingestion-blueprints';
      import { generateText } from 'ai';
      import { google } from '@ai-sdk/google';

      const llmTracker = createLLMTracker({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'aisdk.usage',
      });

      const client = llmTracker.wrap({
        client: { generateText },
        customerId: 'customer_123',
        metadata: {
          model: 'gemini-2.0-flash',
          feature: 'chat'
        }
      });

      const response = await client.generateText({
        model: google('gemini-2.0-flash'),
        prompt: 'Explain neural networks',
        maxOutputTokens: 500
      });

      console.log('Usage:', response.usage);
      ```
    </CodeGroup>

    **Tracked Metrics:**

    * `inputTokens` → `inputTokens`
    * `outputTokens` + `reasoningTokens` → `outputTokens`
    * `totalTokens` → `totalTokens`
    * Model name

    <Note>
      When using reasoning-capable models through AI SDK (like Google's Gemini 2.5 Flash with thinking mode), reasoning tokens are automatically included in the `outputTokens` count for accurate billing.
    </Note>
  </Accordion>

  <Accordion title="OpenRouter" icon="route">
    Track token usage across 200+ models via OpenRouter's unified API.

    <CodeGroup>
      ```javascript OpenRouter Integration theme={null}
      import { createLLMTracker } from '@dodopayments/ingestion-blueprints';
      import OpenAI from 'openai';

      // OpenRouter uses OpenAI-compatible API
      const openrouter = new OpenAI({
        baseURL: 'https://openrouter.ai/api/v1',
        apiKey: process.env.OPENROUTER_API_KEY
      });

      const tracker = createLLMTracker({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'openrouter.usage'
      });

      const client = tracker.wrap({ 
        client: openrouter, 
        customerId: 'user_123',
        metadata: { provider: 'openrouter' }
      });

      const response = await client.chat.completions.create({
        model: 'qwen/qwen3-max',
        messages: [{ role: 'user', content: 'What is machine learning?' }],
        max_tokens: 500
      });

      console.log('Response:', response.choices[0].message.content);
      console.log('Usage:', response.usage);
      ```
    </CodeGroup>

    **Tracked Metrics:**

    * `prompt_tokens` → `inputTokens`
    * `completion_tokens` → `outputTokens`
    * `total_tokens` → `totalTokens`
    * Model name

    <Tip>
      OpenRouter provides access to models from OpenAI, Anthropic, Google, Meta, and many more providers through a single API.
    </Tip>
  </Accordion>

  <Accordion title="OpenAI" icon="robot">
    Track token usage from OpenAI's GPT models automatically.

    <CodeGroup>
      ```javascript OpenAI Integration theme={null}
      import { createLLMTracker } from '@dodopayments/ingestion-blueprints';
      import OpenAI from 'openai';

      const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

      const tracker = createLLMTracker({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'openai.usage'
      });

      const client = tracker.wrap({ 
        client: openai, 
        customerId: 'user_123' 
      });

      // All OpenAI methods work automatically
      const response = await client.chat.completions.create({
        model: 'gpt-4',
        messages: [{ role: 'user', content: 'Explain quantum computing' }]
      });

      console.log('Total tokens:', response.usage.total_tokens);
      ```
    </CodeGroup>

    **Tracked Metrics:**

    * `prompt_tokens` → `inputTokens`
    * `completion_tokens` → `outputTokens`
    * `total_tokens` → `totalTokens`
    * Model name
  </Accordion>

  <Accordion title="Anthropic Claude" icon="robot">
    Track token usage from Anthropic's Claude models.

    <CodeGroup>
      ```javascript Anthropic Integration theme={null}
      import { createLLMTracker } from '@dodopayments/ingestion-blueprints';
      import Anthropic from '@anthropic-ai/sdk';

      const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });

      const tracker = createLLMTracker({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'anthropic.usage'
      });

      const client = tracker.wrap({ 
        client: anthropic, 
        customerId: 'user_123' 
      });

      const response = await client.messages.create({
        model: 'claude-sonnet-4-0',
        max_tokens: 1024,
        messages: [{ role: 'user', content: 'Explain machine learning' }]
      });

      console.log('Input tokens:', response.usage.input_tokens);
      console.log('Output tokens:', response.usage.output_tokens);
      ```
    </CodeGroup>

    **Tracked Metrics:**

    * `input_tokens` → `inputTokens`
    * `output_tokens` → `outputTokens`
    * Calculated `totalTokens`
    * Model name
  </Accordion>

  <Accordion title="Groq" icon="gauge-high">
    Track ultra-fast LLM inference with Groq.

    <CodeGroup>
      ```javascript Groq Integration theme={null}
      import { createLLMTracker } from '@dodopayments/ingestion-blueprints';
      import Groq from 'groq-sdk';

      const groq = new Groq({ apiKey: process.env.GROQ_API_KEY });

      const tracker = createLLMTracker({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'groq.usage'
      });

      const client = tracker.wrap({ 
        client: groq, 
        customerId: 'user_123' 
      });

      const response = await client.chat.completions.create({
        model: 'llama-3.1-8b-instant',
        messages: [{ role: 'user', content: 'What is AI?' }]
      });

      console.log('Tokens:', response.usage);
      ```
    </CodeGroup>

    **Tracked Metrics:**

    * `prompt_tokens` → `inputTokens`
    * `completion_tokens` → `outputTokens`
    * `total_tokens` → `totalTokens`
    * Model name
  </Accordion>

  <Accordion title="Google Gemini" icon="sparkles">
    Track token usage from Google's Gemini models via the Google GenAI SDK.

    <CodeGroup>
      ```javascript Google Gemini Integration theme={null}
      import { createLLMTracker } from '@dodopayments/ingestion-blueprints';
      import { GoogleGenAI } from '@google/genai';

      const googleGenai = new GoogleGenAI({ 
        apiKey: process.env.GOOGLE_GENERATIVE_AI_API_KEY 
      });

      const tracker = createLLMTracker({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'gemini.usage'
      });

      const client = tracker.wrap({ 
        client: googleGenai, 
        customerId: 'user_123' 
      });

      const response = await client.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: 'Explain quantum computing'
      });

      console.log('Response:', response.text);
      console.log('Usage:', response.usageMetadata);
      ```
    </CodeGroup>

    **Tracked Metrics:**

    * `promptTokenCount` → `inputTokens`
    * `candidatesTokenCount` + `thoughtsTokenCount` → `outputTokens`
    * `totalTokenCount` → `totalTokens`
    * Model version

    <Note>
      **Gemini Thinking Mode:** When using Gemini models with thinking/reasoning capabilities (like Gemini 2.5 Pro), the SDK automatically includes `thoughtsTokenCount` (reasoning tokens) in `outputTokens` to accurately reflect the full computational cost.
    </Note>
  </Accordion>
</AccordionGroup>

***

## Advanced Usage

### Multiple Providers

Track usage across different LLM providers with separate trackers:

<CodeGroup>
  ```javascript Multiple Provider Setup theme={null}
  import { createLLMTracker } from '@dodopayments/ingestion-blueprints';
  import OpenAI from 'openai';
  import Groq from 'groq-sdk';
  import Anthropic from '@anthropic-ai/sdk';
  import { GoogleGenAI } from '@google/genai';

  // Create separate trackers for different providers
  const openaiTracker = createLLMTracker({
    apiKey: process.env.DODO_PAYMENTS_API_KEY,
    environment: 'live_mode',
    eventName: 'openai.usage'
  });

  const groqTracker = createLLMTracker({
    apiKey: process.env.DODO_PAYMENTS_API_KEY,
    environment: 'live_mode',
    eventName: 'groq.usage'
  });

  const anthropicTracker = createLLMTracker({
    apiKey: process.env.DODO_PAYMENTS_API_KEY,
    environment: 'live_mode',
    eventName: 'anthropic.usage'
  });

  const geminiTracker = createLLMTracker({
    apiKey: process.env.DODO_PAYMENTS_API_KEY,
    environment: 'live_mode',
    eventName: 'gemini.usage'
  });

  const openrouterTracker = createLLMTracker({
    apiKey: process.env.DODO_PAYMENTS_API_KEY,
    environment: 'live_mode',
    eventName: 'openrouter.usage'
  });

  // Initialize clients
  const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
  const groq = new Groq({ apiKey: process.env.GROQ_API_KEY });
  const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });
  const googleGenai = new GoogleGenAI({ apiKey: process.env.GOOGLE_GENERATIVE_AI_API_KEY });
  const openrouter = new OpenAI({ 
    baseURL: 'https://openrouter.ai/api/v1',
    apiKey: process.env.OPENROUTER_API_KEY 
  });

  // Wrap clients
  const trackedOpenAI = openaiTracker.wrap({ client: openai, customerId: 'user_123' });
  const trackedGroq = groqTracker.wrap({ client: groq, customerId: 'user_123' });
  const trackedAnthropic = anthropicTracker.wrap({ client: anthropic, customerId: 'user_123' });
  const trackedGemini = geminiTracker.wrap({ client: googleGenai, customerId: 'user_123' });
  const trackedOpenRouter = openrouterTracker.wrap({ client: openrouter, customerId: 'user_123' });

  // Use whichever provider you need
  const response = await trackedOpenAI.chat.completions.create({...});
  // or
  const geminiResponse = await trackedGemini.models.generateContent({...});
  // or
  const openrouterResponse = await trackedOpenRouter.chat.completions.create({...});
  ```
</CodeGroup>

<Tip>
  Use different event names for different providers to track usage separately in your meters.
</Tip>

### Express.js API Integration

Complete example of integrating LLM tracking into an Express.js API:

<CodeGroup>
  ```javascript Express.js Server theme={null}
  import express from 'express';
  import { createLLMTracker } from '@dodopayments/ingestion-blueprints';
  import OpenAI from 'openai';

  const app = express();
  app.use(express.json());

  // Initialize OpenAI client
  const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

  // Create tracker once at startup
  const tracker = createLLMTracker({
    apiKey: process.env.DODO_PAYMENTS_API_KEY,
    environment: process.env.NODE_ENV === 'production' ? 'live_mode' : 'test_mode',
    eventName: 'api.chat_completion'
  });

  // Chat endpoint with automatic tracking
  app.post('/api/chat', async (req, res) => {
    try {
      const { message, userId } = req.body;
      
      // Validate input
      if (!message || !userId) {
        return res.status(400).json({ error: 'Missing message or userId' });
      }
      
      // Wrap client for this specific user
      const trackedClient = tracker.wrap({
        client: openai,
        customerId: userId,
        metadata: { 
          endpoint: '/api/chat',
          timestamp: new Date().toISOString()
        }
      });
      
      // Make LLM request - automatically tracked
      const response = await trackedClient.chat.completions.create({
        model: 'gpt-4',
        messages: [{ role: 'user', content: message }],
        temperature: 0.7
      });
      
      const completion = response.choices[0].message.content;
      
      res.json({ 
        message: completion,
        usage: response.usage
      });
    } catch (error) {
      console.error('Chat error:', error);
      res.status(500).json({ error: 'Internal server error' });
    }
  });

  app.listen(3000, () => {
    console.log('Server running on port 3000');
  });
  ```
</CodeGroup>

***

## What Gets Tracked

Every LLM API call automatically sends a usage event to Dodo Payments with the following structure:

<CodeGroup>
  ```json Event Structure theme={null}
  {
    "event_id": "llm_1673123456_abc123",
    "customer_id": "customer_123",
    "event_name": "llm.chat_completion",
    "timestamp": "2024-01-08T10:30:00Z",
    "metadata": {
      "inputTokens": 10,
      "outputTokens": 25,
      "totalTokens": 35,
      "model": "gpt-4",
    }
  }
  ```
</CodeGroup>

### Event Fields

<ParamField type="string">
  Unique identifier for this specific event. Automatically generated by the SDK.

  Format: `llm_[timestamp]_[random]`
</ParamField>

<ParamField type="string">
  The customer ID you provided when wrapping the client. Used for billing.
</ParamField>

<ParamField type="string">
  The event name that triggers your meter. Matches your tracker configuration.
</ParamField>

<ParamField type="string">
  ISO 8601 timestamp when the event occurred.
</ParamField>

<ParamField type="object">
  Token usage and additional tracking data:

  * `inputTokens` - Number of input/prompt tokens used
  * `outputTokens` - Number of output/completion tokens used (includes reasoning tokens when applicable)
  * `totalTokens` - Total tokens (input + output)
  * `model` - The LLM model used (e.g., "gpt-4")
  * `provider` - The LLM provider (if included in wrapper metadata)
  * Any custom metadata you provided when wrapping the client

  <Note>
    **Reasoning Tokens:** For models with reasoning capabilities, `outputTokens` automatically includes both the completion tokens and reasoning tokens.
  </Note>
</ParamField>

<Info>
  Your Dodo Payments meter uses the `metadata` fields (especially `inputTokens`, `outputTokens` or `totalTokens`) to calculate usage and billing.
</Info>

***


# Object Storage Blueprint
Source: https://docs.dodopayments.com/developer-resources/ingestion-blueprints/object-storage

Track file uploads and storage usage for S3, Google Cloud Storage, Azure Blob, and other object storage services.

## Use Cases

Explore common scenarios supported by the Object Storage Blueprint:

<CardGroup>
  <Card title="File Hosting" icon="folder">
    Bill customers based on total storage usage and upload volume.
  </Card>

  <Card title="Backup Services" icon="shield">
    Track backup data uploads and charge per GB stored.
  </Card>

  <Card title="Media CDN" icon="photo-film">
    Monitor media uploads and bill for storage and bandwidth.
  </Card>

  <Card title="Document Management" icon="file">
    Track document uploads per customer for usage-based pricing.
  </Card>
</CardGroup>

<Info>
  Perfect for billing based on storage uploads, file hosting, CDN usage, or backup services.
</Info>

## Quick Start

Track object storage uploads with bytes consumed:

<Steps>
  <Step title="Install the SDK">
    ```bash theme={null}
    npm install @dodopayments/ingestion-blueprints
    ```
  </Step>

  <Step title="Get Your API Keys">
    * **Dodo Payments API Key**: Get it from [Dodo Payments Dashboard](https://app.dodopayments.com/developer/api-keys)
    * **Storage Provider API Key**: From AWS S3, Google Cloud Storage, Azure, etc.
  </Step>

  <Step title="Create a Meter">
    Create a meter in your [Dodo Payments Dashboard](https://app.dodopayments.com/):

    * **Event Name**: `object_storage_upload` (or your preferred name)
    * **Aggregation Type**: `sum` to track total bytes uploaded
    * **Over Property**: `bytes` to bill based on storage size
  </Step>

  <Step title="Track Storage Usage">
    <CodeGroup>
      ```javascript AWS S3 Upload theme={null}
      import { Ingestion, trackObjectStorage } from '@dodopayments/ingestion-blueprints';
      import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
      import fs from 'fs';

      const ingestion = new Ingestion({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'object_storage_upload'
      });

      const s3 = new S3Client({ region: 'us-east-1' });

      // Read the file (example: from disk or request)
      const fileBuffer = fs.readFileSync('./document.pdf');

      // Upload to S3
      const command = new PutObjectCommand({
        Bucket: 'my-bucket',
        Key: 'uploads/document.pdf',
        Body: fileBuffer
      });

      await s3.send(command);

      // Track the upload
      await trackObjectStorage(ingestion, {
        customerId: 'customer_123',
        bytes: fileBuffer.length
      });
      ```

      ```javascript Google Cloud Storage theme={null}
      import { Ingestion, trackObjectStorage } from '@dodopayments/ingestion-blueprints';
      import { Storage } from '@google-cloud/storage';
      import fs from 'fs';

      const ingestion = new Ingestion({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'object_storage_upload'
      });

      const storage = new Storage();
      const bucket = storage.bucket('my-bucket');

      // Read the file
      const fileBuffer = fs.readFileSync('./image.png');

      // Upload to GCS
      await bucket.file('uploads/image.png').save(fileBuffer);

      // Track the upload
      await trackObjectStorage(ingestion, {
        customerId: 'customer_456',
        bytes: fileBuffer.length,
        metadata: {
          bucket: 'my-bucket',
          key: 'uploads/image.png'
        }
      });
      ```
    </CodeGroup>
  </Step>
</Steps>

## Configuration

### Ingestion Configuration

<ParamField type="string">
  Your Dodo Payments API key from the dashboard.
</ParamField>

<ParamField type="string">
  Environment mode: `test_mode` or `live_mode`.
</ParamField>

<ParamField type="string">
  Event name that matches your meter configuration.
</ParamField>

### Track Object Storage Options

<ParamField type="string">
  The customer ID for billing attribution.
</ParamField>

<ParamField type="number">
  Number of bytes uploaded. Required for byte-based billing.
</ParamField>

<ParamField type="object">
  Optional metadata about the upload like bucket name, content type, etc.
</ParamField>

## Best Practices

<Tip>
  **Track Before or After Upload**: You can track the event before or after the actual upload depending on your error handling strategy.
</Tip>

<Warning>
  **Handle Upload Failures**: Only track successful uploads to avoid billing for failed operations.
</Warning>


# Stream Blueprint
Source: https://docs.dodopayments.com/developer-resources/ingestion-blueprints/stream

Track streaming data consumption for video, audio, live streams, and real-time data transfer billing.

## Use Cases

Explore common scenarios supported by the Stream Blueprint:

<CardGroup>
  <Card title="Video Platforms" icon="video">
    Bill customers based on video bandwidth consumption and streaming quality.
  </Card>

  <Card title="Music Streaming" icon="music">
    Track audio streaming usage per user for subscription tiers.
  </Card>

  <Card title="Live Events" icon="signal-stream">
    Monitor live stream consumption and charge for bandwidth usage.
  </Card>

  <Card title="Real-Time Data" icon="wave-pulse">
    Track real-time data transfer for IoT and telemetry applications.
  </Card>
</CardGroup>

<Info>
  Perfect for video/audio streaming platforms, live streaming services, and real-time data applications.
</Info>

## Quick Start

Track streaming bytes consumed by your customers:

<Steps>
  <Step title="Install the SDK">
    ```bash theme={null}
    npm install @dodopayments/ingestion-blueprints
    ```
  </Step>

  <Step title="Get Your API Keys">
    * **Dodo Payments API Key**: Get it from [Dodo Payments Dashboard](https://app.dodopayments.com/developer/api-keys)
  </Step>

  <Step title="Create a Meter">
    Create a meter in your [Dodo Payments Dashboard](https://app.dodopayments.com/):

    * **Event Name**: `stream_consumption` (or your preferred name)
    * **Aggregation Type**: `sum` to track total bytes streamed
    * **Over Property**: `bytes` to bill based on bandwidth usage
  </Step>

  <Step title="Track Stream Usage">
    <CodeGroup>
      ```javascript Video Streaming theme={null}
      import { Ingestion, trackStreamBytes } from '@dodopayments/ingestion-blueprints';

      const ingestion = new Ingestion({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'stream_consumption'
      });

      // Track video stream consumption
      await trackStreamBytes(ingestion, {
        customerId: 'customer_123',
        bytes: 10485760, // 10MB
        metadata: {
          stream_type: 'video',
        }
      });
      ```
    </CodeGroup>
  </Step>
</Steps>

## Configuration

### Ingestion Configuration

<ParamField type="string">
  Your Dodo Payments API key from the dashboard.
</ParamField>

<ParamField type="string">
  Environment mode: `test_mode` or `live_mode`.
</ParamField>

<ParamField type="string">
  Event name that matches your meter configuration.
</ParamField>

### Track Stream Bytes Options

<ParamField type="string">
  The customer ID for billing attribution.
</ParamField>

<ParamField type="number">
  Number of bytes consumed in the stream. Required for bandwidth-based billing.
</ParamField>

<ParamField type="object">
  Optional metadata about the stream like stream type, quality, sessionId, etc.
</ParamField>

## Best Practices

<Tip>
  **Track by Chunk**: For long streams, track consumption in chunks rather than waiting for the entire stream to complete.
</Tip>

<Warning>
  **Accurate Byte Counting**: Ensure byte counts include all overhead (headers, protocol overhead) if billing for total bandwidth.
</Warning>


# Time Range Blueprint
Source: https://docs.dodopayments.com/developer-resources/ingestion-blueprints/time-range

Track resource consumption based on elapsed time for compute, serverless functions, containers, and runtime billing.

## Use Cases

Explore common scenarios supported by the Time Range Blueprint:

<CardGroup>
  <Card title="Serverless Functions" icon="function">
    Bill based on function execution time and memory usage.
  </Card>

  <Card title="Container Runtime" icon="container-storage">
    Track container running time for usage-based billing.
  </Card>

  <Card title="Compute Instances" icon="server">
    Monitor VM runtime and charge by the minute or hour.
  </Card>

  <Card title="Background Jobs" icon="briefcase">
    Track processing time for data exports, reports, and batch jobs.
  </Card>
</CardGroup>

<Info>
  Perfect for billing based on compute time, function execution duration, container runtime, or any time-based usage.
</Info>

## Quick Start

Track resource usage by time duration:

<Steps>
  <Step title="Install the SDK">
    ```bash theme={null}
    npm install @dodopayments/ingestion-blueprints
    ```
  </Step>

  <Step title="Get Your API Keys">
    * **Dodo Payments API Key**: Get it from [Dodo Payments Dashboard](https://app.dodopayments.com/developer/api-keys)
  </Step>

  <Step title="Create a Meter">
    Create a meter in your [Dodo Payments Dashboard](https://app.dodopayments.com/):

    * **Event Name**: `time_range_usage` (or your preferred name)
    * **Aggregation Type**: `sum` to track total duration
    * **Over Property**: `durationSeconds`, `durationMinutes`, or `durationMs`
  </Step>

  <Step title="Track Time Usage">
    <CodeGroup>
      ```javascript Serverless Functions theme={null}
      import { Ingestion, trackTimeRange } from '@dodopayments/ingestion-blueprints';

      const ingestion = new Ingestion({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'function_execution'
      });

      // Track function execution time
      const startTime = Date.now();

      // Execute your function (example: image processing)
      const result = await yourImageProcessingLogic();

      const durationMs = Date.now() - startTime;

      await trackTimeRange(ingestion, {
        customerId: 'customer_123',
        durationMs: durationMs
      });
      ```

      ```javascript Container Runtime theme={null}
      import { Ingestion, trackTimeRange } from '@dodopayments/ingestion-blueprints';

      const ingestion = new Ingestion({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'container_runtime'
      });

      // Track container runtime in seconds
      await trackTimeRange(ingestion, {
        customerId: 'customer_456',
        durationSeconds: 120
      });
      ```

      ```javascript VM Instance Runtime theme={null}
      import { Ingestion, trackTimeRange } from '@dodopayments/ingestion-blueprints';

      const ingestion = new Ingestion({
        apiKey: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode',
        eventName: 'vm_runtime'
      });

      // Track VM runtime in minutes
      await trackTimeRange(ingestion, {
        customerId: 'customer_789',
        durationMinutes: 60
      });
      ```
    </CodeGroup>
  </Step>
</Steps>

## Configuration

### Ingestion Configuration

<ParamField type="string">
  Your Dodo Payments API key from the dashboard.
</ParamField>

<ParamField type="string">
  Environment mode: `test_mode` or `live_mode`.
</ParamField>

<ParamField type="string">
  Event name that matches your meter configuration.
</ParamField>

### Track Time Range Options

<ParamField type="string">
  The customer ID for billing attribution.
</ParamField>

<ParamField type="number">
  Duration in milliseconds. Use for sub-second precision.
</ParamField>

<ParamField type="number">
  Duration in seconds. Most common for function execution and short tasks.
</ParamField>

<ParamField type="number">
  Duration in minutes. Useful for longer-running resources like VMs.
</ParamField>

<ParamField type="object">
  Optional metadata about the resource like CPU, memory, region, etc.
</ParamField>

## Best Practices

<Tip>
  **Choose the Right Unit**: Use milliseconds for short operations, seconds for functions, and minutes for longer-running resources.
</Tip>

<Warning>
  **Accurate Timing**: Use `Date.now()` or `performance.now()` for accurate time tracking, especially for serverless functions.
</Warning>


# Next.js Adaptor
Source: https://docs.dodopayments.com/developer-resources/nextjs-adaptor

Learn how to integrate Dodo Payments with your Next.js App Router project using our NextJS Adaptor. Covers checkout, customer portal, webhooks, and secure environment setup.

<CardGroup>
  <Card title="Checkout Handler" icon="cart-shopping" href="#checkout-route-handler">
    Integrate Dodo Payments checkout with static, dynamic, and session flows.
  </Card>

  <Card title="Customer Portal" icon="user" href="#customer-portal-route-handler">
    Allow customers to manage subscriptions and details.
  </Card>

  <Card title="Webhooks" icon="bell" href="#webhook-route-handler">
    Receive and process Dodo Payments webhook events.
  </Card>
</CardGroup>

## Installation

<Steps>
  <Step title="Install the package">
    Run the following command in your project root:

    ```bash theme={null}
    npm install @dodopayments/nextjs
    ```
  </Step>

  <Step title="Set up environment variables">
    Create a <code>.env</code> file in your project root:

    ```env theme={null}
    DODO_PAYMENTS_API_KEY=your-api-key
    DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
    DODO_PAYMENTS_RETURN_URL=https://yourdomain.com/checkout/success
    DODO_PAYMENTS_ENVIRONMENT="test_mode"or"live_mode"
    ```

    <Warning>
      Never commit your <code>.env</code> file or secrets to version control.
    </Warning>
  </Step>
</Steps>

## Route Handler Examples

<Info>
  All examples assume you are using the Next.js App Router.
</Info>

<Tabs>
  <Tab title="Checkout Handler">
    <Info>
      Use this handler to integrate Dodo Payments checkout into your Next.js app. Supports static (GET), dynamic (POST), and checkout session (POST) payment flows.
    </Info>

    <CodeGroup>
      ```typescript Next.js Route Handler expandable theme={null}
      // app/checkout/route.ts
      import { Checkout } from "@dodopayments/nextjs";

      export const GET = Checkout({
        bearerToken: process.env.DODO_PAYMENTS_API_KEY,
        returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
        environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
        type: "static", // optional, defaults to 'static'
      });

      export const POST = Checkout({
        bearerToken: process.env.DODO_PAYMENTS_API_KEY,
        returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
        environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
        type: "dynamic", // for dynamic checkout
      });

      export const POST = Checkout({
        bearerToken: process.env.DODO_PAYMENTS_API_KEY,
        returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
        environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
        type: "session", // for checkout sessions
      });
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Static Checkout Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/checkout?productId=pdt_fqJhl7pxKWiLhwQR042rh' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Dynamic Checkout Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "billing": {
        "city": "Texas",
        "country": "US",
        "state": "Texas",
        "street": "56, hhh",
        "zipcode": "560000"
      },
      "customer": {
        "email": "test@example.com",
        	"name": "test"
      },
      "metadata": {},
      "payment_link": true,
        "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
        "quantity": 1,
        "billing_currency": "USD",
        "discount_code": "IKHZ23M9GQ",
        "return_url": "https://example.com",
        "trial_period_days": 10
      }'
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Checkout Session Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "product_cart": [
        {
          "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
          "quantity": 1
        }
      ],
      "customer": {
        "email": "test@example.com",
        "name": "test"
      },
      "return_url": "https://example.com/success"
      }'
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Customer Portal Handler">
    <Info>
      Use this handler to allow customers to manage their subscriptions and details via the Dodo Payments customer portal.
    </Info>

    <CodeGroup>
      ```typescript Next.js Route Handler expandable theme={null}
      // app/customer-portal/route.ts
      import { CustomerPortal } from "@dodopayments/nextjs";

      export const GET = CustomerPortal({
        bearerToken: process.env.DODO_PAYMENTS_API_KEY,
        environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
      });
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Customer Portal Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/customer-portal?customer_id=cus_9VuW4K7O3GHwasENg31m&send_email=true' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Webhook Handler">
    <Info>
      Use this handler to receive and process Dodo Payments webhook events securely in your Next.js app.
    </Info>

    <CodeGroup>
      ```typescript Next.js Route Handler expandable theme={null}
      // app/api/webhook/dodo-payments/route.ts
      import { Webhooks } from "@dodopayments/nextjs";

      export const POST = Webhooks({
        webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_KEY,
        onPayload: async (payload) => {
          // handle the payload
        },
        // ... other event handlers for granular control
      });
      ```
    </CodeGroup>
  </Tab>
</Tabs>

## Checkout Route Handler

<Info>
  Dodo Payments supports three types of payment flows for integrating payments into your website, this adaptor supports all types of payment flows.
</Info>

* **Static Payment Links:** Instantly shareable URLs for quick, no-code payment collection.
* **Dynamic Payment Links:** Programmatically generate payment links with custom details using the API or SDKs.
* **Checkout Sessions:** Create secure, customizable checkout experiences with pre-configured product carts and customer details.

<AccordionGroup>
  <Accordion title="Static Checkout (GET)">
    ### Supported Query Parameters

    <ParamField type="string">
      Product identifier (e.g., <code>?productId=pdt\_nZuwz45WAs64n3l07zpQR</code>).
    </ParamField>

    <ParamField type="integer">
      Quantity of the product.
    </ParamField>

    <ParamField type="string">
      Customer's full name.
    </ParamField>

    <ParamField type="string">
      Customer's first name.
    </ParamField>

    <ParamField type="string">
      Customer's last name.
    </ParamField>

    <ParamField type="string">
      Customer's email address.
    </ParamField>

    <ParamField type="string">
      Customer's country.
    </ParamField>

    <ParamField type="string">
      Customer's address line.
    </ParamField>

    <ParamField type="string">
      Customer's city.
    </ParamField>

    <ParamField type="string">
      Customer's state/province.
    </ParamField>

    <ParamField type="string">
      Customer's zip/postal code.
    </ParamField>

    <ParamField type="boolean">
      Disable full name field.
    </ParamField>

    <ParamField type="boolean">
      Disable first name field.
    </ParamField>

    <ParamField type="boolean">
      Disable last name field.
    </ParamField>

    <ParamField type="boolean">
      Disable email field.
    </ParamField>

    <ParamField type="boolean">
      Disable country field.
    </ParamField>

    <ParamField type="boolean">
      Disable address line field.
    </ParamField>

    <ParamField type="boolean">
      Disable city field.
    </ParamField>

    <ParamField type="boolean">
      Disable state field.
    </ParamField>

    <ParamField type="boolean">
      Disable zip code field.
    </ParamField>

    <ParamField type="string">
      Specify the payment currency (e.g., <code>USD</code>).
    </ParamField>

    <ParamField type="boolean">
      Show currency selector.
    </ParamField>

    <ParamField type="integer">
      Specify the payment amount (e.g., <code>1000</code> for \$10.00).
    </ParamField>

    <ParamField type="boolean">
      Show discount fields.
    </ParamField>

    <ParamField type="string">
      Any query parameter starting with <code>metadata\_</code> will be passed as metadata.
    </ParamField>

    <Warning>
      If <code>productId</code> is missing, the handler returns a 400 response. Invalid query parameters also result in a 400 response.
    </Warning>

    ### Response Format

    Static checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Dynamic Checkout (POST)">
    * Send parameters as a JSON body in a POST request.
    * Supports both one-time and recurring payments.
    * For a complete list of supported POST body fields, refer to:
      * [Request body for a One Time Payment Product](https://docs.dodopayments.com/api-reference/payments/post-payments)
      * [Request body for a Subscription Product](https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions)

    ### Response Format

    Dynamic checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Checkout Sessions (POST)">
    Checkout sessions provide a more secure, hosted checkout experience that handles the complete payment flow for both one-time purchases and subscriptions with full customization control.

    Refer to [Checkout Sessions Integration Guide](https://docs.dodopayments.com/developer-resources/checkout-session) for more details and a complete list of supported fields.

    ### Response Format

    Checkout sessions return a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/session/..."
    }
    ```
  </Accordion>
</AccordionGroup>

## Customer Portal Route Handler

The Customer Portal Route Handler enables you to seamlessly integrate the Dodo Payments customer portal into your Next.js application.

### Query Parameters

<ParamField type="string">
  The customer ID for the portal session (e.g., <code>?customer\_id=cus\_123</code>).
</ParamField>

<ParamField type="boolean">
  If set to <code>true</code>, sends an email to the customer with the portal link.
</ParamField>

<Warning>
  Returns 400 if <code>customer\_id</code> is missing.
</Warning>

## Webhook Route Handler

* **Method:** Only POST requests are supported. Other methods return 405.
* **Signature Verification:** Verifies the webhook signature using <code>webhookKey</code>. Returns 401 if verification fails.
* **Payload Validation:** Validated with Zod. Returns 400 for invalid payloads.
* **Error Handling:**
  * 401: Invalid signature
  * 400: Invalid payload
  * 500: Internal error during verification
* **Event Routing:** Calls the appropriate event handler based on the payload type.

### Supported Webhook Event Handlers

<CodeGroup>
  ```typescript Typescript expandable theme={null}
  onPayload?: (payload: WebhookPayload) => Promise<void>;
  onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onPaymentFailed?: (payload: WebhookPayload) => Promise<void>;
  onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>;
  onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>;
  onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onRefundFailed?: (payload: WebhookPayload) => Promise<void>;
  onDisputeOpened?: (payload: WebhookPayload) => Promise<void>;
  onDisputeExpired?: (payload: WebhookPayload) => Promise<void>;
  onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>;
  onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>;
  onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>;
  onDisputeWon?: (payload: WebhookPayload) => Promise<void>;
  onDisputeLost?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>;
  onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>;
  ```
</CodeGroup>

***

## Prompt for LLM

```

You are an expert Next.js developer assistant. Your task is to guide a user through integrating the @dodopayments/nextjs adapter into their existing Next.js project.

The @dodopayments/nextjs adapter provides route handlers for Dodo Payments' Checkout, Customer Portal, and Webhook functionalities, designed for the Next.js App Router.

First, install the necessary packages. Use the package manager appropriate for your project (npm, yarn, or bun) based on the presence of lock files (e.g., package-lock.json for npm, yarn.lock for yarn, bun.lockb for bun):

npm install @dodopayments/nextjs

Here's how you should structure your response:

    Ask the user which functionalities they want to integrate.

"Which parts of the @dodopayments/nextjs adapter would you like to integrate into your project? You can choose one or more of the following:

    Checkout Route Handler (for handling product checkouts)

    Customer Portal Route Handler (for managing customer subscriptions/details)

    Webhook Route Handler (for receiving Dodo Payments webhook events)

    All (integrate all three)"

    Based on the user's selection, provide detailed integration steps for each chosen functionality.

If Checkout Route Handler is selected:

Purpose: This handler manages different types of checkout flows. All checkout types (static, dynamic, and sessions) return JSON responses with checkout URLs for programmatic handling.
File Creation: Create a new file at app/checkout/route.ts in your Next.js project.

Code Snippet:

// app/checkout/route.ts
import { Checkout } from '@dodopayments/nextjs'

export const GET = Checkout({
bearerToken: process.env.DODO_PAYMENTS_API_KEY!,
returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
type: "static",
});

export const POST = Checkout({
bearerToken: process.env.DODO_PAYMENTS_API_KEY!,
returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
type: "session", // or "dynamic" for dynamic link
});

Configuration & Usage:

    bearerToken: Your Dodo Payments API key. It's recommended to set this via the DODO_PAYMENTS_API_KEY environment variable.

    returnUrl: (Optional) The URL to redirect the user to after a successful checkout.

    environment: (Optional) Set to "test_mode" for testing, or omit/set to "live_mode" for production.

    type: (Optional) Set to "static" for GET/static checkout, "dynamic" for POST/dynamic checkout, or "session" for POST/checkout sessions.

Static Checkout (GET) Query Parameters:

    productId (required): Product identifier (e.g., ?productId=pdt_nZuwz45WAs64n3l07zpQR)

    quantity (optional): Quantity of the product

    Customer Fields (optional): fullName, firstName, lastName, email, country, addressLine, city, state, zipCode

    Disable Flags (optional, set to true to disable): disableFullName, disableFirstName, disableLastName, disableEmail, disableCountry, disableAddressLine, disableCity, disableState, disableZipCode

    Advanced Controls (optional): paymentCurrency, showCurrencySelector, paymentAmount, showDiscounts

    Metadata (optional): Any query parameter starting with metadata_ (e.g., ?metadata_userId=abc123)

    Returns: {"checkout_url": "https://checkout.dodopayments.com/..."}

Dynamic Checkout (POST) - Returns JSON with checkout_url: Parameters are sent as a JSON body. Supports both one-time and recurring payments. Returns: {"checkout_url": "https://checkout.dodopayments.com/..."}. For a complete list of supported POST body fields, refer to:

    Docs - One Time Payment Product: https://docs.dodopayments.com/api-reference/payments/post-payments

    Docs - Subscription Product: https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions


Checkout Sessions (POST) - (Recommended) A more customizable checkout experience. Returns JSON with checkout_url: Parameters are sent as a JSON body. Supports both one-time and recurring payments. Returns: {"checkout_url": "https://checkout.dodopayments.com/session/..."}. For a complete list of supported fields, refer to:

  Checkout Sessions Integration Guide: https://docs.dodopayments.com/developer-resources/checkout-session

Error Handling: If productId is missing or other parameters are invalid, the handler will return a 400 response.

If Customer Portal Route Handler is selected:

Purpose: This handler redirects authenticated users to their Dodo Payments customer portal.
File Creation: Create a new file at app/customer-portal/route.ts in your Next.js project.

Code Snippet:

// app/customer-portal/route.ts
import { CustomerPortal } from '@dodopayments/nextjs'

export const GET = CustomerPortal({
bearerToken: process.env.DODO_PAYMENTS_API_KEY!,
environment: "test_mode",
});

Query Parameters:

    customer_id (required): The customer ID for the portal session (e.g., ?customer_id=cus_123)

    send_email (optional, boolean): If set to true, sends an email to the customer with the portal link.

    Returns 400 if customer_id is missing.

If Webhook Route Handler is selected:

Purpose: This handler processes incoming webhook events from Dodo Payments, allowing your application to react to events like successful payments, refunds, or subscription changes.
File Creation: Create a new file at app/api/webhook/dodo-payments/route.ts in your Next.js project.

Code Snippet:

// app/api/webhook/dodo-payments/route.ts
import { Webhooks } from '@dodopayments/nextjs'

export const POST = Webhooks({
webhookKey: process.env.DODO_WEBHOOK_SECRET!,
onPayload: async (payload) => {
// handle the payload
},
// ... other event handlers for granular control
});

Handler Details:

    Method: Only POST requests are supported. Other methods return 405.

    Signature Verification: The handler verifies the webhook signature using the webhookKey and returns 401 if verification fails.

    Payload Validation: The payload is validated with Zod. Returns 400 for invalid payloads.

Error Handling:

    401: Invalid signature

    400: Invalid payload

    500: Internal error during verification

Event Routing: Calls the appropriate event handler based on the payload type.

Supported Webhook Event Handlers:

    onPayload?: (payload: WebhookPayload) => Promise<void>

    onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>

    onPaymentFailed?: (payload: WebhookPayload) => Promise<void>

    onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>

    onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>

    onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>

    onRefundFailed?: (payload: WebhookPayload) => Promise<void>

    onDisputeOpened?: (payload: WebhookPayload) => Promise<void>

    onDisputeExpired?: (payload: WebhookPayload) => Promise<void>

    onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>

    onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>

    onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>

    onDisputeWon?: (payload: WebhookPayload) => Promise<void>

    onDisputeLost?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>


    onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>

    onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>

    Environment Variable Setup:

To ensure the adapter functions correctly, you will need to manually set up the following environment variables in your Next.js project's deployment environment (e.g., Vercel, Netlify, AWS, etc.):

    DODO_PAYMENTS_API_KEY: Your Dodo Payments API Key (required for Checkout and Customer Portal).

    RETURN_URL: (Optional) The URL to redirect to after a successful checkout (for Checkout handler).

    DODO_WEBHOOK_SECRET: Your Dodo Payments Webhook Secret (required for Webhook handler).

Example .env file:

DODO_PAYMENTS_API_KEY=your-api-key
DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode"
DODO_PAYMENTS_RETURN_URL=your-return-url

Usage in your code:

bearerToken: process.env.DODO_PAYMENTS_API_KEY!
webhookKey: process.env.DODO_WEBHOOK_SECRET!

Important: Never commit sensitive environment variables directly into your version control. Use environment variables for all sensitive information.

If the user needs assistance setting up environment variables for their specific deployment environment, ask them what platform they are using (e.g., Vercel, Netlify, AWS, etc.), and provide guidance. You can also add comments to their PR or chat depending on the context

```


# Next.js Minimal Boilerplate
Source: https://docs.dodopayments.com/developer-resources/nextjs-boilerplate

Get started quickly with our minimal Next.js boilerplate for integrating Dodo Payments into your Next.js application

## Overview

The Next.js minimal boilerplate provides a ready-to-use starting point for integrating Dodo Payments with your Next.js application. This template includes checkout sessions, webhook handling, customer portal, and modern UI components to help you start accepting payments quickly.

<Info>
  This boilerplate uses Next.js 16 App Router with TypeScript, Tailwind CSS 4, and the `@dodopayments/nextjs` adapter.
</Info>

### Features

* **Quick Setup** - Get started in under 5 minutes
* **Payment Integration** - Pre-configured checkout flow using `@dodopayments/nextjs`
* **Modern UI** - Clean, dark-themed pricing page with Tailwind CSS
* **Webhook Handler** - Ready-to-use webhook endpoint for payment events
* **Customer Portal** - One-click subscription management
* **TypeScript** - Fully typed with minimal, focused types
* **Pre-filled Checkout** - Demonstrates passing customer data to improve UX

## Prerequisites

Before you begin, make sure you have:

* **Node.js 20.9+** (required for Next.js 16)
* **Dodo Payments account** (to access API and Webhook Keys from dashboard)

## Quick Start

<Steps>
  <Step title="Clone the Repository">
    ```bash theme={null}
    git clone https://github.com/dodopayments/dodo-nextjs-minimal-boilerplate.git
    cd dodo-nextjs-minimal-boilerplate
    ```
  </Step>

  <Step title="Install Dependencies">
    ```bash theme={null}
    npm install
    ```
  </Step>

  <Step title="Get API Credentials">
    Sign up at [Dodo Payments](https://dodopayments.com/) and get your credentials from the dashboard:

    * **API Key:** [Dashboard → Developer → API Keys](https://app.dodopayments.com/developer/api-keys)
    * **Webhook Key:** [Dashboard → Developer → Webhooks](https://app.dodopayments.com/developer/webhooks)

    <Tip>
      Make sure you're in **Test Mode** while developing!
    </Tip>
  </Step>

  <Step title="Configure Environment Variables">
    Create a `.env` file in the root directory:

    ```bash theme={null}
    cp .env.example .env
    ```

    Update the values with your Dodo Payments credentials:

    ```env theme={null}
    DODO_PAYMENTS_API_KEY=your_api_key_here
    DODO_PAYMENTS_WEBHOOK_KEY=your_webhook_signing_key_here
    DODO_PAYMENTS_RETURN_URL=http://localhost:3000
    DODO_PAYMENTS_ENVIRONMENT=test_mode
    ```

    <Warning>
      Never commit your `.env` file to version control. It's already included in `.gitignore`.
    </Warning>
  </Step>

  <Step title="Add Your Products">
    Update `src/lib/products.ts` with your actual product IDs from Dodo Payments:

    ```typescript theme={null}
    export const products: Product[] = [
      {
        product_id: "pdt_001", // Replace with your product ID
        name: "Basic Plan",
        description: "Get access to basic features and support",
        price: 9999, // in cents
        features: [
          "Access to basic features",
          "Email support",
          "1 Team member",
          "Basic analytics",
        ],
      },
      // ... add more products
    ];
    ```
  </Step>

  <Step title="Run the Development Server">
    ```bash theme={null}
    npm run dev
    ```

    Open [http://localhost:3000](http://localhost:3000) to see your pricing page!
  </Step>
</Steps>

## Project Structure

```text theme={null}
src/
├── app/
│   ├── api/
│   │   ├── checkout/          # Checkout session handler
│   │   ├── customer-portal/   # Customer portal redirect
│   │   └── webhook/           # Webhook event handler
│   ├── components/
│   │   ├── Footer.tsx         # Reusable footer
│   │   ├── Header.tsx         # Navigation header
│   │   └── ProductCard.tsx    # Product pricing card
│   ├── globals.css            # Global styles
│   ├── layout.tsx             # Root layout
│   └── page.tsx               # Pricing page (home)
└── lib/
    └── products.ts            # Product definitions
```

## Customization

### Update Product Information

Edit `src/lib/products.ts` to modify:

* Product IDs (from your Dodo dashboard)
* Pricing
* Features
* Descriptions

### Pre-fill Customer Data

In `src/app/components/ProductCard.tsx`, replace the hardcoded values with your actual user data:

```typescript theme={null}
customer: {
  name: "John Doe",
  email: "john@example.com",
},
```

### Update Customer Portal

In `src/app/components/Header.tsx`, replace the hardcoded customer ID:

```typescript theme={null}
const CUSTOMER_ID = "cus_001"; // Replace with actual customer ID
```

You can complete a test purchase to get the customer ID for testing.

## Webhook Events

The boilerplate demonstrates handling two webhook events in `src/app/api/webhook/route.ts`:

* `onSubscriptionActive` - Triggered when a subscription becomes active
* `onPaymentSucceeded` - Triggered when a payment is successful

Add your business logic inside these handlers:

```typescript theme={null}
onSubscriptionActive: async (payload) => {
  // Grant access to your product
  // Update user database
  // Send welcome email
},
```

Add more webhook events as needed.

For local development, you can use tools like [ngrok](https://ngrok.com/) to create a secure tunnel to your local server and use it as your webhook URL.

## Deployment

### Build for Production

```bash theme={null}
npm run build
npm start
```

### Deploy to Vercel

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https://github.com/dodopayments/dodo-nextjs-minimal-boilerplate)

Don't forget to add your environment variables in the Vercel dashboard!

### Update Webhook URL

After deploying, update your webhook URL in the [Dodo Payments Dashboard](https://app.dodopayments.com/developer/webhooks):

```
https://example.com/api/webhook
```

## Troubleshooting

<AccordionGroup>
  <Accordion title="Module not found or build errors">
    Delete `node_modules` and reinstall dependencies:

    ```bash theme={null}
    rm -rf node_modules package-lock.json
    npm install
    ```
  </Accordion>

  <Accordion title="Checkout redirect fails">
    **Common causes:**

    * Invalid product ID - verify it exists in your Dodo dashboard
    * Wrong API key or environment setting in `.env`
    * Check browser console and terminal for errors
  </Accordion>

  <Accordion title="Webhooks not receiving events">
    For local testing, use [ngrok](https://ngrok.com) to expose your server:

    ```bash theme={null}
    ngrok http 3000
    ```

    Update the webhook URL in your [Dodo dashboard](https://app.dodopayments.com/developer/webhooks) to the ngrok URL. Remember to update your .env file with the correct webhook verification key.
  </Accordion>

  <Accordion title="Customer portal link doesn't work">
    Replace the hardcoded `CUSTOMER_ID` in `src/app/components/Header.tsx` with an actual customer ID from your Dodo dashboard.

    Or integrate your authentication system and database to fetch the customer ID dynamically.
  </Accordion>
</AccordionGroup>

## Learn More

* [Dodo Payments Documentation](https://docs.dodopayments.com/)
* [Checkout Sessions Documentation](https://docs.dodopayments.com/developer-resources/checkout-sessions)
* [Webhooks Documentation](https://docs.dodopayments.com/developer-resources/webhooks)

## Support

Need help with the boilerplate?

* Join our [Discord community](https://discord.gg/bYqAp4ayYh) for questions and discussions
* Check the [GitHub repository](https://github.com/dodopayments/dodo-nextjs-minimal-boilerplate) for issues and updates
* Contact our [support team](mailto:support@dodopayments.com) for assistance


# Nuxt Adaptor
Source: https://docs.dodopayments.com/developer-resources/nuxt-adaptor

Integrate Dodo Payments with your Nuxt project using the official Nuxt module. Covers checkout, customer portal, webhooks, and secure environment setup.

<CardGroup>
  <Card title="Checkout API Route" icon="cart-shopping" href="#checkout-api-route">
    Integrate Dodo Payments checkout into your Nuxt app using a server route.
  </Card>

  <Card title="Customer Portal API Route" icon="user" href="#customer-portal-api-route">
    Allow customers to manage subscriptions and details via a Nuxt server route.
  </Card>

  <Card title="Webhooks API Route" icon="bell" href="#webhook-api-route">
    Receive and process Dodo Payments webhook events securely in Nuxt.
  </Card>
</CardGroup>

## Overview

<Info>
  This guide explains how to integrate Dodo Payments into your Nuxt application using the official Nuxt module. You'll learn how to set up checkout, customer portal, and webhook API routes, and how to securely manage environment variables.
</Info>

## Installation

<Steps>
  <Step title="Install the Nuxt module">
    Run the following command in your project root:

    ```bash theme={null}
    npm install @dodopayments/nuxt
    ```
  </Step>

  <Step title="Register the module in nuxt.config.ts">
    Add <code>@dodopayments/nuxt</code> to your <code>modules</code> array and configure it:

    ```typescript nuxt.config.ts expandable theme={null}
    export default defineNuxtConfig({
      modules: ["@dodopayments/nuxt"],
      devtools: { enabled: true },
      compatibilityDate: "2025-02-25",
      runtimeConfig: {
        private: {
          bearerToken: process.env.NUXT_PRIVATE_BEARER_TOKEN,
          webhookKey: process.env.NUXT_PRIVATE_WEBHOOK_KEY,
          environment: process.env.NUXT_PRIVATE_ENVIRONMENT,
          returnUrl: process.env.NUXT_PRIVATE_RETURNURL
        },
      }
    });
    ```
  </Step>
</Steps>

<Warning>
  Never commit your <code>.env</code> file or secrets to version control.
</Warning>

## API Route Handler Examples

<Info>
  All Dodo Payments integrations in Nuxt are handled via server routes in the <code>server/routes/api/</code> directory.
</Info>

<Tabs>
  <Tab title="Checkout API Route">
    <Info>
      Use this handler to integrate Dodo Payments checkout into your Nuxt app. Supports static (GET), dynamic (POST), and session (POST) payment flows.
    </Info>

    <CodeGroup>
      ```typescript server/routes/api/checkout.get.ts expandable theme={null}

      export default defineEventHandler((event) => {
        const {
          private: { bearerToken, environment, returnUrl },
        } = useRuntimeConfig();

        const handler = checkoutHandler({
          bearerToken: bearerToken,
          environment: environment,
          returnUrl: returnUrl,
        });

        return handler(event);
      });
      ```
    </CodeGroup>

    <CodeGroup>
      ```typescript server/routes/api/checkout.post.ts expandable theme={null}

      export default defineEventHandler((event) => {
        const {
          private: { bearerToken, environment, returnUrl },
        } = useRuntimeConfig();

        const handler = checkoutHandler({
          bearerToken: bearerToken,
          environment: environment,
          returnUrl: returnUrl,
          type: "dynamic"
        });

        return handler(event);
      });
      ```
    </CodeGroup>

    <CodeGroup>
      ```typescript server/routes/api/checkout.post.ts (Checkout Sessions) expandable theme={null}

      export default defineEventHandler((event) => {
        const {
          private: { bearerToken, environment, returnUrl },
        } = useRuntimeConfig();

        const handler = checkoutHandler({
          bearerToken: bearerToken,
          environment: environment,
          returnUrl: returnUrl,
          type: "session"
        });

        return handler(event);
      });
      ```
    </CodeGroup>

    <Warning>
      If <code>productId</code> is missing or invalid, the handler returns a 400 response.
    </Warning>

    <CodeGroup>
      ```curl Static Checkout Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/checkout?productId=pdt_fqJhl7pxKWiLhwQR042rh' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Dynamic Checkout Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "billing": {
        "city": "Texas",
        "country": "US",
        "state": "Texas",
        "street": "56, hhh",
        "zipcode": "560000"
      },
      "customer": {
        "email": "test@example.com",
        	"name": "test"
      },
      "metadata": {},
      "payment_link": true,
        "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
        "quantity": 1,
        "billing_currency": "USD",
        "discount_code": "IKHZ23M9GQ",
        "return_url": "https://example.com",
        "trial_period_days": 10
      }'
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Checkout Session Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "product_cart": [
        {
          "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
          "quantity": 1
        }
      ],
      "customer": {
        "email": "test@example.com",
        "name": "test"
      },
      "return_url": "https://example.com/success"
      }'
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Customer Portal API Route">
    <Info>
      Create a GET route to allow customers to access their portal. Accepts <code>customer\_id</code> as a query parameter.
    </Info>

    <CodeGroup>
      ```typescript server/routes/api/customer-portal.get.ts expandable theme={null}

      export default defineEventHandler((event) => {
        const {
          private: { bearerToken, environment },
        } = useRuntimeConfig();

        const handler = customerPortalHandler({
          bearerToken,
          environment: environment,
        });

        return handler(event);
      });
      ```
    </CodeGroup>

    **Query Parameters:**

    * <code>customer\_id</code> (required): The customer ID for the portal session (e.g., <code>?customer\_id=cus\_123</code>)
    * <code>send\_email</code> (optional, boolean): If <code>true</code>, sends an email to the customer with the portal link.

    <Warning>
      Returns 400 if <code>customer\_id</code> is missing.
    </Warning>

    <CodeGroup>
      ```curl Customer Portal Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/customer-portal?customer_id=cus_9VuW4K7O3GHwasENg31m&send_email=true' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Webhook API Route">
    <Info>
      Create a POST route to securely receive and process webhook events from Dodo Payments.
    </Info>

    <CodeGroup>
      ```typescript server/routes/api/webhook.post.ts expandable theme={null}

      export default defineEventHandler((event) => {
        const {
          private: { webhookKey },
        } = useRuntimeConfig();

        const handler = Webhooks({
          webhookKey: webhookKey,
          onPayload: async (payload: any) => {
            // Handle webhook payload here
          },
          // ...add other event handlers as needed
        });

        return handler(event);
      });
      ```
    </CodeGroup>
  </Tab>
</Tabs>

## Checkout Route Handler

<Info>
  Dodo Payments supports three types of payment flows for integrating payments into your website, this adaptor supports all types of payment flows.
</Info>

* **Static Payment Links:** Instantly shareable URLs for quick, no-code payment collection.
* **Dynamic Payment Links:** Programmatically generate payment links with custom details using the API or SDKs.
* **Checkout Sessions:** Create secure, customizable checkout experiences with pre-configured product carts and customer details.

<AccordionGroup>
  <Accordion title="Static Checkout (GET)">
    ### Supported Query Parameters

    <ParamField type="string">
      Product identifier (e.g., <code>?productId=pdt\_nZuwz45WAs64n3l07zpQR</code>).
    </ParamField>

    <ParamField type="integer">
      Quantity of the product.
    </ParamField>

    <ParamField type="string">
      Customer's full name.
    </ParamField>

    <ParamField type="string">
      Customer's first name.
    </ParamField>

    <ParamField type="string">
      Customer's last name.
    </ParamField>

    <ParamField type="string">
      Customer's email address.
    </ParamField>

    <ParamField type="string">
      Customer's country.
    </ParamField>

    <ParamField type="string">
      Customer's address line.
    </ParamField>

    <ParamField type="string">
      Customer's city.
    </ParamField>

    <ParamField type="string">
      Customer's state/province.
    </ParamField>

    <ParamField type="string">
      Customer's zip/postal code.
    </ParamField>

    <ParamField type="boolean">
      Disable full name field.
    </ParamField>

    <ParamField type="boolean">
      Disable first name field.
    </ParamField>

    <ParamField type="boolean">
      Disable last name field.
    </ParamField>

    <ParamField type="boolean">
      Disable email field.
    </ParamField>

    <ParamField type="boolean">
      Disable country field.
    </ParamField>

    <ParamField type="boolean">
      Disable address line field.
    </ParamField>

    <ParamField type="boolean">
      Disable city field.
    </ParamField>

    <ParamField type="boolean">
      Disable state field.
    </ParamField>

    <ParamField type="boolean">
      Disable zip code field.
    </ParamField>

    <ParamField type="string">
      Specify the payment currency (e.g., <code>USD</code>).
    </ParamField>

    <ParamField type="boolean">
      Show currency selector.
    </ParamField>

    <ParamField type="integer">
      Specify the payment amount (e.g., <code>1000</code> for \$10.00).
    </ParamField>

    <ParamField type="boolean">
      Show discount fields.
    </ParamField>

    <ParamField type="string">
      Any query parameter starting with <code>metadata\_</code> will be passed as metadata.
    </ParamField>

    <Warning>
      If <code>productId</code> is missing, the handler returns a 400 response. Invalid query parameters also result in a 400 response.
    </Warning>

    ### Response Format

    Static checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Dynamic Checkout (POST)">
    * Send parameters as a JSON body in a POST request.
    * Supports both one-time and recurring payments.
    * For a complete list of supported POST body fields, refer to:
      * [Request body for a One Time Payment Product](https://docs.dodopayments.com/api-reference/payments/post-payments)
      * [Request body for a Subscription Product](https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions)

    ### Response Format

    Dynamic checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Checkout Sessions (POST)">
    Checkout sessions provide a more secure, hosted checkout experience that handles the complete payment flow for both one-time purchases and subscriptions with full customization control.

    Refer to [Checkout Sessions Integration Guide](https://docs.dodopayments.com/developer-resources/checkout-session) for more details and a complete list of supported fields.

    ### Response Format

    Checkout sessions return a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/session/..."
    }
    ```
  </Accordion>
</AccordionGroup>

## Customer Portal Route Handler

The Customer Portal Route Handler enables you to seamlessly integrate the Dodo Payments customer portal into your Nuxt application.

### Query Parameters

<ParamField type="string">
  The customer ID for the portal session (e.g., <code>?customer\_id=cus\_123</code>).
</ParamField>

<ParamField type="boolean">
  If set to <code>true</code>, sends an email to the customer with the portal link.
</ParamField>

<Warning>
  Returns 400 if <code>customer\_id</code> is missing.
</Warning>

## Webhook Route Handler

* **Method:** Only POST requests are supported. Other methods return 405.
* **Signature Verification:** Verifies the webhook signature using <code>webhookKey</code>. Returns 401 if verification fails.
* **Payload Validation:** Validated with Zod. Returns 400 for invalid payloads.
* **Error Handling:**
  * 401: Invalid signature
  * 400: Invalid payload
  * 500: Internal error during verification
* **Event Routing:** Calls the appropriate event handler based on the payload type.

### Supported Webhook Event Handlers

<CodeGroup>
  ```typescript Typescript expandable theme={null}
  onPayload?: (payload: WebhookPayload) => Promise<void>;
  onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onPaymentFailed?: (payload: WebhookPayload) => Promise<void>;
  onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>;
  onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>;
  onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onRefundFailed?: (payload: WebhookPayload) => Promise<void>;
  onDisputeOpened?: (payload: WebhookPayload) => Promise<void>;
  onDisputeExpired?: (payload: WebhookPayload) => Promise<void>;
  onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>;
  onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>;
  onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>;
  onDisputeWon?: (payload: WebhookPayload) => Promise<void>;
  onDisputeLost?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>;
  onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>;
  ```
</CodeGroup>

***

## Prompt for LLM

```
You are an expert Nuxt developer assistant. Your task is to guide a user through integrating the @dodopayments/nuxt module into their existing Nuxt project.

The @dodopayments/nuxt module provides API route handlers for Dodo Payments' Checkout, Customer Portal, and Webhook functionalities, designed for Nuxt 3 server routes.

First, install the necessary package:

npm install @dodopayments/nuxt

Second, add the configuration to nuxt.config.ts

export default defineNuxtConfig({
  modules: ["@dodopayments/nuxt"],
  devtools: { enabled: true },
  compatibilityDate: "2025-02-25",
  runtimeConfig: {
    private: {
      bearerToken: process.env.NUXT_PRIVATE_BEARER_TOKEN,
      webhookKey: process.env.NUXT_PRIVATE_BEARER_TOKEN,
      environment: process.env.NUXT_PRIVATE_ENVIRONMENT,
      returnUrl: process.env.NUXT_PRIVATE_RETURNURL
    },
  }
});


Here's how you should structure your response:

    Ask the user which functionalities they want to integrate.

"Which parts of the @dodopayments/nuxt module would you like to integrate into your project? You can choose one or more of the following:

    Checkout API Route (for handling product checkouts)
    Customer Portal API Route (for managing customer subscriptions/details)
    Webhook API Route (for receiving Dodo Payments webhook events)
    All (integrate all three)"

    Based on the user's selection, provide detailed integration steps for each chosen functionality.

If Checkout API Route is selected:

Purpose: This route redirects users to the Dodo Payments checkout page.
File Creation: Create a new file at server/routes/api/checkout.get.ts in your Nuxt project.

Code Snippet:

// server/routes/api/checkout.get.ts

export default defineEventHandler((event) => {
  const {
    private: { bearerToken, environment, returnUrl },
  } = useRuntimeConfig();

  const handler = checkoutHandler({
    bearerToken: bearerToken,
    environment: environment,
    returnUrl: returnUrl,
  });

  return handler(event);
});

Configuration & Usage:
- bearerToken: Your Dodo Payments API key. Set via the NUXT_PRIVATE_BEARER_TOKEN environment variable.
- returnUrl: (Optional) The URL to redirect the user to after a successful checkout.
- environment: (Optional) Set to your environment (e.g., "test_mode" or "live_mode").

Static Checkout (GET) Query Parameters:
- productId (required): Product identifier (e.g., ?productId=pdt_nZuwz45WAs64n3l07zpQR)
- quantity (optional): Quantity of the product
- Customer Fields (optional): fullName, firstName, lastName, email, country, addressLine, city, state, zipCode
- Disable Flags (optional, set to true to disable): disableFullName, disableFirstName, disableLastName, disableEmail, disableCountry, disableAddressLine, disableCity, disableState, disableZipCode
- Advanced Controls (optional): paymentCurrency, showCurrencySelector, paymentAmount, showDiscounts
- Metadata (optional): Any query parameter starting with metadata_ (e.g., ?metadata_userId=abc123)

Dynamic Checkout (POST): Parameters are sent as a JSON body. Supports both one-time and recurring payments. For a complete list of supported POST body fields, refer to:
- Docs - One Time Payment Product: https://docs.dodopayments.com/api-reference/payments/post-payments
- Docs - Subscription Product: https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions

Checkout Sessions (POST) - (Recommended) A more customizable checkout experience. Returns JSON with checkout_url: Parameters are sent as a JSON body. Supports both one-time and recurring payments. Returns: {"checkout_url": "https://checkout.dodopayments.com/session/..."}. For a complete list of supported fields, refer to:

  Checkout Sessions Integration Guide: https://docs.dodopayments.com/developer-resources/checkout-session

Error Handling: If productId is missing or other query parameters are invalid, the handler will return a 400 response.

If Customer Portal API Route is selected:

Purpose: This route allows customers to access their Dodo Payments customer portal.
File Creation: Create a new file at server/routes/api/customer-portal.get.ts in your Nuxt project.

Code Snippet:

// server/routes/api/customer-portal.get.ts

export default defineEventHandler((event) => {
  const {
    private: { bearerToken, environment },
  } = useRuntimeConfig();

  const handler = customerPortalHandler({
    bearerToken,
    environment: environment,
  });

  return handler(event);
});

Query Parameters:
- customer_id (required): The customer ID for the portal session (e.g., ?customer_id=cus_123)
- send_email (optional, boolean): If set to true, sends an email to the customer with the portal link.
- Returns 400 if customer_id is missing.

If Webhook API Route is selected:

Purpose: This route processes incoming webhook events from Dodo Payments, allowing your application to react to events like successful payments, refunds, or subscription changes.
File Creation: Create a new file at server/routes/api/webhook.post.ts in your Nuxt project.

Code Snippet:

// server/routes/api/webhook.post.ts

export default defineEventHandler((event) => {
  const {
    private: { webhookKey },
  } = useRuntimeConfig();

  const handler = Webhooks({
    webhookKey: webhookKey,
    onPayload: async (payload) => {
      // handle the payload
    },
    // ... other event handlers for granular control
  });

  return handler(event);
});

Handler Details:
- Method: Only POST requests are supported. Other methods return 405.
- Signature Verification: The handler verifies the webhook signature using webhookKey and returns 401 if verification fails.
- Payload Validation: The payload is validated with Zod. Returns 400 for invalid payloads.

Error Handling:
- 401: Invalid signature
- 400: Invalid payload
- 500: Internal error during verification

Event Routing: Calls the appropriate event handler based on the payload type. Supported event handlers include:
- onPayload?: (payload: WebhookPayload) => Promise<void>
- onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>
- onPaymentFailed?: (payload: WebhookPayload) => Promise<void>
- onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>
- onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>
- onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>
- onRefundFailed?: (payload: WebhookPayload) => Promise<void>
- onDisputeOpened?: (payload: WebhookPayload) => Promise<void>
- onDisputeExpired?: (payload: WebhookPayload) => Promise<void>
- onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>
- onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>
- onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>
- onDisputeWon?: (payload: WebhookPayload) => Promise<void>
- onDisputeLost?: (payload: WebhookPayload) => Promise<void>
- onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>
- onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>
- onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>
- onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>
- onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>
- onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>
- onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>
- onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>

Environment Variable Setup:
To ensure the module functions correctly, set up the following environment variables in your Nuxt project's deployment environment (e.g., Vercel, Netlify, AWS, etc.):
- NUXT_PRIVATE_BEARER_TOKEN: Your Dodo Payments API Key (required for Checkout and Customer Portal).
- NUXT_PRIVATE_WEBHOOK_KEY: Your Dodo Payments Webhook Secret (required for Webhook handler).
- NUXT_PRIVATE_ENVIRONMENT: (Optional) Set to your environment (e.g., "test_mode" or "live_mode").
- NUXT_PRIVATE_RETURNURL: (Optional) The URL to redirect to after a successful checkout (for Checkout handler).

Usage in your code:
bearerToken: useRuntimeConfig().private.bearerToken
webhookKey: useRuntimeConfig().private.webhookKey

Important: Never commit sensitive environment variables directly into your version control. Use environment variables for all sensitive information.

If the user needs assistance setting up environment variables for their specific deployment environment, ask them what platform they are using (e.g., Vercel, Netlify, AWS, etc.), and provide guidance.
```


# On-Demand Subscriptions
Source: https://docs.dodopayments.com/developer-resources/ondemand-subscriptions

Integrate on-demand subscriptions by authorizing mandates, creating variable charges, handling webhooks, and implementing safe retry policies.

## Overview

On-demand subscriptions let you authorize a customer's payment method once and then charge variable amounts whenever you need, instead of on a fixed schedule. This feature is available for all accounts—no approval required.

Use this guide to:

* Create an on-demand subscription (authorize a mandate with optional initial price)
* Trigger subsequent charges with custom amounts
* Track outcomes using webhooks

For a general subscription setup, see the [Subscription Integration Guide](/developer-resources/subscription-integration-guide).

## Prerequisites

* Dodo Payments merchant account and API key
* Webhook secret configured and an endpoint to receive events
* A subscription product in your catalog

<Tip>
  If you want the customer to approve the mandate via hosted checkout, set `payment_link: true` and provide a `return_url`.
</Tip>

## How on-demand works

1. You create a subscription with the `on_demand` object to authorize a payment method and optionally collect an initial charge.
2. Later, you create charges against that subscription with custom amounts using the dedicated charge endpoint.
3. You listen to webhooks (e.g., `payment.succeeded`, `payment.failed`) to update your system.

## Create an on-demand subscription

Endpoint: [POST /checkouts](/api-reference/checkout-sessions/create)

Key request fields (body):\
Please find them in [Create Checkout Session](/api-reference/checkout-sessions/create)

### Create an on-demand subscription

<Tabs>
  <Tab title="Node.js SDK">
    ```javascript theme={null}
    import DodoPayments from 'dodopayments';

    const client = new DodoPayments({
      bearerToken: process.env.DODO_PAYMENTS_API_KEY,
      environment: 'test_mode', // defaults to 'live_mode'
    });

    async function main() {
      const subscription = await client.checkoutSessions.create({
        product_cart: [{ product_id: 'pdt_123', quantity: 1 }],
        billing_address:  { city: 'SF', country: 'US', state: 'CA', street: '1 Market St', zipcode: '94105' },
        customer: { customer_id: 'cus_123' },
        return_url: 'https://example.com/billing/success',
        subscription_data: {
            on_demand: {
                mandate_only: true // set false to collect an initial charge
                // product_price: 1000, // optional: charge $10.00 now if mandate_only is false
                // product_currency: 'USD',
                // product_description: 'Custom initial charge',
                // adaptive_currency_fees_inclusive: false,
            }
        }
      });

      console.log(subscription.checkout_url);
    }

    main().catch(console.error);
    ```
  </Tab>

  <Tab title="Python SDK">
    ```python theme={null}
    import os
    from dodopayments import DodoPayments

    client = DodoPayments(
        bearer_token=os.environ.get('DODO_PAYMENTS_API_KEY'),
        environment="test_mode",  # defaults to "live_mode"
    )

    checkout = client.checkout_sessions.create(
        product_cart=[
            {"product_id": "pdt_123", "quantity": 1}
        ],
        billing_address={
            "city": "SF",
            "country": "US",
            "state": "CA",
            "street": "1 Market St",
            "zipcode": "94105",
        },
        customer={
            "customer_id": "cus_123",
        },
        return_url="https://example.com/billing/success",
        subscription_data={
          "on_demand":{
          "mandate_only": True,  # set False to collect an initial charge
          # "product_price": 1000,  # optional: charge $10.00 now if mandate_only is false
          # "product_currency": "USD",
          # "product_description": "Custom initial charge",
          # "adaptive_currency_fees_inclusive": False,
          }
        },
    )

    print(checkout.checkout_url)
    ```
  </Tab>

  <Tab title="Go SDK">
    ```go theme={null}
    package main

    import (
        "fmt"
        "os"

        dodo "github.com/dodopayments/dodopayments-go"
    )

    func main() {
        client := dodo.NewClient(dodo.Config{
            BearerToken: os.Getenv("DODO_PAYMENTS_API_KEY"),
            Environment: dodo.TestMode, // defaults to LiveMode
        })

        checkout, err := client.CheckoutSessions.Create(dodo.CheckoutSessionCreateParams{
            ProductCart: []dodo.ProductCartItem{
                {
                    ProductID: "pdt_123",
                    Quantity:  1,
                },
            },
            BillingAddress: &dodo.BillingAddress{
                City:    "SF",
                Country: "US",
                State:   "CA",
                Street:  "1 Market St",
                Zipcode: "94105",
            },
            Customer: &dodo.CustomerRef{
                CustomerID: "cus_123",
            },
            ReturnURL: "https://example.com/billing/success",
            SubscriptionData: &dodo.SubscriptionData{
                OnDemand: &dodo.OnDemandSubscription{
                    MandateOnly: true, // set false to collect an initial charge
                    // ProductPrice: 1000,  // optional: charge $10.00 now if mandate_only is false
                    // ProductCurrency: "USD",
                    // ProductDescription: "Custom initial charge",
                    // AdaptiveCurrencyFeesInclusive: false,
                },
            },
        })
        if err != nil {
            panic(err)
        }

        fmt.Println(checkout.CheckoutURL)
    }
    ```
  </Tab>

  <Tab title="cURL">
    ```bash theme={null}
    curl -X POST "$DODO_API/checkouts" \
      -H "Authorization: Bearer $DODO_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "product_cart": [
          {
            "product_id": "pdt_123",
            "quantity": 1
          }
        ],
        "customer": {
          "customer_id": "cus_123"
        },
        "billing_address": {
          "street": "1 Market St",
          "city": "SF",
          "state": "CA",
          "country": "US",
          "zipcode": "94105"
        },
        "subscription_data": {
          "on_demand": {
            "mandate_only": true
          }
        },
        "return_url": "https://example.com/billing/success"
      }'
    ```
  </Tab>
</Tabs>

```json Success theme={null}
{
  "session_id": "cks_123",
  "checkout_url": "https://test.checkout.dodopayments.com/session/cks123"
}
```

## Charge an on-demand subscription

After the mandate is authorized, create charges as needed.

Endpoint: [POST /subscriptions/\{subscription\_id}/charge](/api-reference/subscriptions/create-charge)

Key request fields (body):

<AccordionGroup>
  <Accordion title="Charge request body parameters">
    <ParamField type="integer">
      Amount to charge (in the smallest currency unit). Example: to charge \$25.00, pass <code>2500</code>.
    </ParamField>

    <ParamField type="string">
      Optional currency override for the charge.
    </ParamField>

    <ParamField type="string">
      Optional description override for this charge.
    </ParamField>

    <ParamField type="boolean">
      If true, includes adaptive currency fees within <code>product\_price</code>. If false, fees are added on top.
    </ParamField>

    <ParamField type="object">
      Additional metadata for the payment. If omitted, the subscription metadata is used.
    </ParamField>
  </Accordion>
</AccordionGroup>

<Tabs>
  <Tab title="Node.js SDK">
    ```javascript theme={null}
    import DodoPayments from 'dodopayments';

    const client = new DodoPayments({ bearerToken: process.env.DODO_PAYMENTS_API_KEY });

    async function chargeNow(subscriptionId) {
      const res = await client.subscriptions.charge(subscriptionId, { product_price: 2500 });
      console.log(res.payment_id);
    }

    chargeNow('sub_123').catch(console.error);
    ```
  </Tab>

  <Tab title="Python SDK">
    ```python theme={null}
    import os
    from dodopayments import DodoPayments

    client = DodoPayments(bearer_token=os.environ.get('DODO_PAYMENTS_API_KEY'))

    response = client.subscriptions.charge(
        subscription_id="sub_123",
        product_price=2500,
    )

    print(response.payment_id)
    ```
  </Tab>

  <Tab title="Go SDK">
    ```go theme={null}
    package main

    import (
      "context"
      "fmt"
      "github.com/dodopayments/dodopayments-go"
      "github.com/dodopayments/dodopayments-go/option"
    )

    func main() {
      client := dodopayments.NewClient(option.WithBearerToken("YOUR_API_KEY"))
      res, err := client.Subscriptions.Charge(context.TODO(), "sub_123", dodopayments.SubscriptionChargeParams{
        ProductPrice: dodopayments.F(int64(2500)),
      })
      if err != nil { panic(err) }
      fmt.Println(res.PaymentID)
    }
    ```
  </Tab>

  <Tab title="cURL">
    ```bash theme={null}
    curl -X POST "$DODO_API/subscriptions/sub_123/charge" \
      -H "Authorization: Bearer $DODO_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "product_price": 2500,
        "product_description": "Extra usage for March"
      }'
    ```
  </Tab>
</Tabs>

```json Success theme={null}
{ "payment_id": "pay_abc123" }
```

<Warning>
  Charging a subscription that is not on-demand may fail. Ensure the subscription has `on_demand: true` in its details before charging.
</Warning>

## Payment retries

Our fraud detection system may block aggressive retry patterns (and can flag them as potential card testing). Follow a safe retry policy.

<Warning>
  Burst retry patterns can be flagged as fraudulent or suspected card testing by our risk systems and processors. Avoid clustered retries; follow the backoff schedule and time alignment guidance below.
</Warning>

### Principles for safe retry policies

* **Backoff mechanism**: Use exponential backoff between retries.
* **Retry limits**: Cap total retries (3–4 attempts max).
* **Intelligent filtering**: Retry only on retryable failures (e.g., network/issuer errors, insufficient funds); never retry hard declines.
* **Card testing prevention**: Do not retry failures like `DO_NOT_HONOR`, `STOLEN_CARD`, `LOST_CARD`, `PICKUP_CARD`, `FRAUDULENT`, `AUTHENTICATION_FAILURE`.
* **Vary metadata (optional)**: If you maintain your own retry system, differentiate retries via metadata (e.g., `retry_attempt`).

### Suggested retry schedule (subscriptions)

* **1st attempt**: Immediate when you create the charge
* **2nd attempt**: After 3 days
* **3rd attempt**: After 7 more days (10 days total)
* **4th attempt (final)**: After another 7 days (17 days total)

Final step: if still unpaid, mark the subscription as unpaid or cancel it, based on your policy. Notify the customer during the window to update their payment method.

### Avoid burst retries; align to authorization time

* Anchor retries to the original authorization timestamp to avoid "burst" behavior across your portfolio.
* Example: If the customer starts a trial or mandate at 1:10 pm today, schedule follow-up retries at 1:10 pm on subsequent days per your backoff (e.g., +3 days → 1:10 pm, +7 days → 1:10 pm).
* Alternatively, if you store the last successful payment time `T`, schedule the next attempt at `T + X days` to preserve time-of-day alignment.

<Note>
  Time-zone and DST: use a consistent time standard for scheduling and convert for display only to maintain intervals.
</Note>

### Decline codes you should not retry

* `STOLEN_CARD`
* `DO_NOT_HONOR`
* `FRAUDULENT`
* `PICKUP_CARD`
* `AUTHENTICATION_FAILURE`
* `LOST_CARD`

<Note>
  For a comprehensive list of decline reasons and whether they are user-correctable, see the
  [Transaction Failures](/api-reference/transaction-failures) documentation.
</Note>

<Tip>
  Only retry on soft/temporary issues (e.g., `insufficient_funds`, `issuer_unavailable`, `processing_error`, network timeouts). If the same decline repeats, pause further retries.
</Tip>

### Implementation guidelines (no code)

* Use a scheduler/queue that persists precise timestamps; compute next attempt at the exact time-of-day offset (e.g., `T + 3 days` at the same HH:MM).
* Maintain and reference the last successful payment timestamp `T` to compute the next attempt; do not bunch multiple subscriptions at the same instant.
* Always evaluate the last decline reason; stop retries for hard declines in the skip list above.
* Cap concurrent retries per customer and per account to prevent accidental surges.
* Communicate proactively: email/SMS the customer to update their payment method before the next scheduled attempt.
* Use metadata only for observability (e.g., `retry_attempt`); never try to "evade" fraud/risk systems by rotating inconsequential fields.

## Track outcomes with webhooks

Implement webhook handling to track the customer journey. See [Implementing Webhooks](/developer-resources/integration-guide#implementing-webhooks).

* **subscription.active**: Mandate authorized and subscription activated
* **subscription.failed**: Creation failed (e.g., mandate failure)
* **subscription.on\_hold**: Subscription placed on hold (e.g., unpaid state)
* **payment.succeeded**: Charge succeeded
* **payment.failed**: Charge failed

<Tip>
  For on-demand flows, focus on `payment.succeeded` and `payment.failed` to reconcile usage-based charges.
</Tip>

## Testing and next steps

<Steps>
  <Step title="Create in test mode">
    Use your test API key to create the subscription with `payment_link: true`, then open the link and complete the mandate.
  </Step>

  <Step title="Trigger a charge">
    Call the charge endpoint with a small `product_price` (e.g., `100`) and verify you receive `payment.succeeded`.
  </Step>

  <Step title="Go live">
    Switch to your live API key once you have validated events and internal state updates.
  </Step>
</Steps>

## Troubleshooting

* **422 Invalid Request**: Ensure `on_demand.mandate_only` is provided on creation and `product_price` is provided for charges.
* **Currency errors**: If you override `product_currency`, confirm it's supported for your account and customer.
* **No webhooks received**: Verify your webhook URL and signature secret configuration.


# Overlay Checkout
Source: https://docs.dodopayments.com/developer-resources/overlay-checkout

A modern TypeScript library for embedding Dodo Payments overlay checkout and listening to checkout events in real-time.

## Overview

The Dodo Payments Checkout SDK provides a seamless way to integrate our payment overlay into your web application. Built with TypeScript and modern web standards, it offers a robust solution for handling payments with real-time event handling and customizable themes.

<Frame>
  <img alt="Overlay Checkout Cover Image" />
</Frame>

## Demo

<Card title="Interactive Demo" icon="play" href="https://atlas.dodopayments.com/pricing">
  See the overlay checkout in action with our live demo.
</Card>

## Quick Start

Get started with the Dodo Payments Checkout SDK in just a few lines of code:

```typescript theme={null}
import { DodoPayments } from "dodopayments-checkout";

// Initialize the SDK
DodoPayments.Initialize({
  mode: "test", // 'test' or 'live'
  displayType: "overlay", // Optional: defaults to 'overlay' for overlay checkout
  onEvent: (event) => {
    console.log("Checkout event:", event);
  },
});

// Open checkout
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123"
});
```

<Tip>
  Get your checkout URL from the [create checkout session API](/api-reference/checkout-sessions/create).
</Tip>

## Step-by-Step Integration Guide

<Steps>
  <Step title="Install the SDK">
    Install the Dodo Payments Checkout SDK using your preferred package manager:

    <CodeGroup>
      ```bash npm theme={null}
      npm install dodopayments-checkout
      ```

      ```bash yarn theme={null}
      yarn add dodopayments-checkout
      ```

      ```bash pnpm theme={null}
      pnpm add dodopayments-checkout
      ```
    </CodeGroup>
  </Step>

  <Step title="Initialize the SDK">
    Initialize the SDK in your application, typically in your main component or app entry point:

    ```typescript theme={null}
    import { DodoPayments } from "dodopayments-checkout";

    DodoPayments.Initialize({
      mode: "test", // Change to 'live' for production
      displayType: "overlay", // Optional: defaults to 'overlay' for overlay checkout
      onEvent: (event) => {
        console.log("Checkout event:", event);
        
        // Handle different events
        switch (event.event_type) {
          case "checkout.opened":
            // Checkout overlay has been opened
            break;
          case "checkout.closed":
            // Checkout has been closed
            break;
          case "checkout.error":
            // Handle errors
            console.error("Checkout error:", event.data?.message);
            break;
        }
      },
    });
    ```

    <Warning>
      Always initialize the SDK before attempting to open the checkout. Initialization should happen once when your application loads.
    </Warning>
  </Step>

  <Step title="Create a Checkout Button Component">
    Create a component that opens the checkout overlay:

    ```typescript theme={null}
    // components/CheckoutButton.tsx
    "use client";

    import { Button } from "@/components/ui/button";
    import { DodoPayments } from "dodopayments-checkout";
    import { useEffect, useState } from "react";

    export function CheckoutButton() {
      const [isLoading, setIsLoading] = useState(false);

      useEffect(() => {
        // Initialize the SDK
        DodoPayments.Initialize({
          mode: "test",
          displayType: "overlay",
          onEvent: (event) => {
            switch (event.event_type) {
              case "checkout.opened":
                setIsLoading(false);
                break;
              case "checkout.error":
                setIsLoading(false);
                console.error("Checkout error:", event.data?.message);
                break;
            }
          },
        });
      }, []);

      const handleCheckout = async () => {
        try {
          setIsLoading(true);
          await DodoPayments.Checkout.open({
            checkoutUrl: "https://checkout.dodopayments.com/session/cks_123"
          });
        } catch (error) {
          console.error("Failed to open checkout:", error);
          setIsLoading(false);
        }
      };

      return (
        <Button 
          onClick={handleCheckout}
          disabled={isLoading}
        >
          {isLoading ? "Loading..." : "Checkout Now"}
        </Button>
      );
    }
    ```
  </Step>

  <Step title="Add Checkout to Your Page">
    Use the checkout button component in your application:

    ```typescript theme={null}
    // app/page.tsx
    import { CheckoutButton } from "@/components/CheckoutButton";

    export default function Home() {
      return (
        <main className="flex min-h-screen flex-col items-center justify-center p-24">
          <h1>Welcome to Our Store</h1>
          <CheckoutButton />
        </main>
      );
    }
    ```
  </Step>

  <Step title="Handle Success and Failure Pages">
    Create pages to handle checkout redirects:

    ```typescript theme={null}
    // app/success/page.tsx
    export default function SuccessPage() {
      return (
        <div className="flex min-h-screen flex-col items-center justify-center">
          <h1>Payment Successful!</h1>
          <p>Thank you for your purchase.</p>
        </div>
      );
    }

    // app/failure/page.tsx
    export default function FailurePage() {
      return (
        <div className="flex min-h-screen flex-col items-center justify-center">
          <h1>Payment Failed</h1>
          <p>Please try again or contact support.</p>
        </div>
      );
    }
    ```
  </Step>

  <Step title="Test Your Integration">
    1. Start your development server:

    ```bash theme={null}
    npm run dev
    ```

    2. Test the checkout flow:
       * Click the checkout button
       * Verify the overlay appears
       * Test the payment flow using test credentials
       * Confirm redirects work correctly

    <Check>
      You should see checkout events logged in your browser console.
    </Check>
  </Step>

  <Step title="Go Live">
    When you're ready for production:

    1. Change the mode to `'live'`:

    ```typescript theme={null}
    DodoPayments.Initialize({
      mode: "live",
      displayType: "overlay",
      onEvent: (event) => {
        console.log("Checkout event:", event);
      }
    });
    ```

    2. Update your checkout URLs to use live checkout sessions from your backend
    3. Test the complete flow in production
    4. Monitor events and errors
  </Step>
</Steps>

## API Reference

### Configuration

#### Initialize Options

```typescript theme={null}
interface InitializeOptions {
  mode: "test" | "live";
  displayType?: "overlay" | "inline";
  onEvent: (event: CheckoutEvent) => void;
}
```

| Option        | Type                    | Required | Description                                                                              |
| ------------- | ----------------------- | -------- | ---------------------------------------------------------------------------------------- |
| `mode`        | `"test" \| "live"`      | Yes      | Environment mode: `'test'` for development, `'live'` for production                      |
| `displayType` | `"overlay" \| "inline"` | No       | Display type: `'overlay'` for modal checkout (default), `'inline'` for embedded checkout |
| `onEvent`     | `function`              | Yes      | Callback function for handling checkout events                                           |

#### Checkout Options

```typescript theme={null}
interface CheckoutOptions {
  checkoutUrl: string;
  options?: {
    showTimer?: boolean;
    showSecurityBadge?: boolean;
    manualRedirect?: boolean;
  };
}
```

| Option                      | Type      | Required | Description                                                                                                                                                                                        |
| --------------------------- | --------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `checkoutUrl`               | `string`  | Yes      | Checkout session URL from the [create checkout session API](/api-reference/checkout-sessions/create)                                                                                               |
| `options.showTimer`         | `boolean` | No       | Show or hide the checkout timer. Defaults to `true`. When disabled, you will receive the `checkout.link_expired` event when the session expires.                                                   |
| `options.showSecurityBadge` | `boolean` | No       | Show or hide the security badge. Defaults to `true`.                                                                                                                                               |
| `options.manualRedirect`    | `boolean` | No       | When enabled, the checkout will not automatically redirect after completion. Instead, you will receive `checkout.status` and `checkout.redirect_requested` events to handle the redirect yourself. |

### Methods

#### Open Checkout

Opens the checkout overlay with the specified checkout session URL.

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123"
});
```

You can also pass additional options to customize the checkout behavior:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    showTimer: false,
    showSecurityBadge: false,
    manualRedirect: true,
  },
});
```

When using `manualRedirect`, handle the checkout completion in your `onEvent` callback:

```typescript theme={null}
DodoPayments.Initialize({
  mode: "test",
  displayType: "overlay",
  onEvent: (event) => {
    if (event.event_type === "checkout.status") {
      const status = event.data?.message?.status;
      // Handle status: "succeeded", "failed", or "processing"
    }
    if (event.event_type === "checkout.redirect_requested") {
      const redirectUrl = event.data?.message?.redirect_to;
      // Redirect the customer manually
      window.location.href = redirectUrl;
    }
    if (event.event_type === "checkout.link_expired") {
      // Handle expired checkout session
    }
  },
});
```

#### Close Checkout

Programmatically closes the checkout overlay.

```typescript theme={null}
DodoPayments.Checkout.close();
```

#### Check Status

Returns whether the checkout overlay is currently open.

```typescript theme={null}
const isOpen = DodoPayments.Checkout.isOpen();
// Returns: boolean
```

### Events

The SDK provides real-time events that you can listen to through the `onEvent` callback:

#### Checkout Status Event Data

When `manualRedirect` is enabled, you receive the `checkout.status` event with the following data:

```typescript theme={null}
interface CheckoutStatusEventData {
  message: {
    status?: "succeeded" | "failed" | "processing";
  };
}
```

#### Checkout Redirect Requested Event Data

When `manualRedirect` is enabled, you receive the `checkout.redirect_requested` event with the following data:

```typescript theme={null}
interface CheckoutRedirectRequestedEventData {
  message: {
    redirect_to?: string;
  };
}
```

```typescript theme={null}
DodoPayments.Initialize({
  onEvent: (event: CheckoutEvent) => {
    switch (event.event_type) {
      case "checkout.opened":
        // Checkout overlay has been opened
        break;
      case "checkout.form_ready":
        // Checkout form is ready for user input
        break;
      case "checkout.payment_page_opened":
        // Payment page has been displayed
        break;
      case "checkout.customer_details_submitted":
        // Customer and billing details submitted
        break;
      case "checkout.closed":
        // Checkout has been closed
        break;
      case "checkout.redirect":
        // Checkout will perform a redirect
        break;
      case "checkout.error":
        // An error occurred
        console.error("Error:", event.data?.message);
        break;
      case "checkout.link_expired":
        // Checkout session has expired (only when showTimer is false)
        break;
      case "checkout.status":
        // Checkout status update (only when manualRedirect is enabled)
        const status = event.data?.message?.status;
        break;
      case "checkout.redirect_requested":
        // Redirect requested (only when manualRedirect is enabled)
        const redirectUrl = event.data?.message?.redirect_to;
        break;
    }
  }
});
```

| Event Type                            | Description                                                                                                    |
| ------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| `checkout.opened`                     | Checkout overlay has been opened                                                                               |
| `checkout.form_ready`                 | Checkout form is ready to receive user input. Useful for hiding loading states.                                |
| `checkout.payment_page_opened`        | Payment page has been displayed                                                                                |
| `checkout.customer_details_submitted` | Customer and billing details have been submitted                                                               |
| `checkout.closed`                     | Checkout overlay has been closed                                                                               |
| `checkout.redirect`                   | Checkout will perform a redirect                                                                               |
| `checkout.error`                      | An error occurred during checkout                                                                              |
| `checkout.link_expired`               | Fired when the checkout session expires. Only received when `showTimer` is set to `false`.                     |
| `checkout.status`                     | Fired when `manualRedirect` is enabled. Contains the checkout status (`succeeded`, `failed`, or `processing`). |
| `checkout.redirect_requested`         | Fired when `manualRedirect` is enabled. Contains the URL to redirect the customer to.                          |

## Implementation Options

### Package Manager Installation

Install via npm, yarn, or pnpm as shown in the [Step-by-Step Integration Guide](#step-by-step-integration-guide).

### CDN Implementation

For quick integration without a build step, you can use our CDN:

```html theme={null}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dodo Payments Checkout</title>
    
    <!-- Load DodoPayments -->
    <script src="https://cdn.jsdelivr.net/npm/dodopayments-checkout@latest/dist/index.js"></script>
    <script>
        // Initialize the SDK
        DodoPaymentsCheckout.DodoPayments.Initialize({
            mode: "test", // Change to 'live' for production
            displayType: "overlay",
            onEvent: (event) => {
                console.log('Checkout event:', event);
            }
        });
    </script>
</head>
<body>
    <button onclick="openCheckout()">Checkout Now</button>

    <script>
        function openCheckout() {
            DodoPaymentsCheckout.DodoPayments.Checkout.open({
                checkoutUrl: "https://checkout.dodopayments.com/session/cks_123"
            });
        }
    </script>
</body>
</html>
```

### Theme Customization

You can customize the checkout appearance by passing a `themeConfig` object in the `options` parameter when opening checkout. The theme configuration supports both light and dark modes, allowing you to customize colors, borders, text, buttons, and border radius.

#### Basic Theme Configuration

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    themeConfig: {
      light: {
        bgPrimary: "#FFFFFF",
        textPrimary: "#344054",
        buttonPrimary: "#A6E500",
      },
      dark: {
        bgPrimary: "#0D0D0D",
        textPrimary: "#FFFFFF",
        buttonPrimary: "#A6E500",
      },
      radius: "8px",
    },
  },
});
```

#### Complete Theme Configuration

All available theme properties:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    themeConfig: {
      light: {
        // Background colors
        bgPrimary: "#FFFFFF",        // Primary background color
        bgSecondary: "#F9FAFB",      // Secondary background color (e.g., tabs)
        
        // Border colors
        borderPrimary: "#D0D5DD",     // Primary border color
        borderSecondary: "#6B7280",  // Secondary border color
        
        // Text colors
        textPrimary: "#344054",       // Primary text color
        textSecondary: "#6B7280",    // Secondary text color
        textPlaceholder: "#667085",  // Placeholder text color
        textError: "#D92D20",        // Error text color
        textSuccess: "#10B981",      // Success text color
        
        // Button colors
        buttonPrimary: "#A6E500",           // Primary button background
        buttonPrimaryHover: "#8CC500",      // Primary button hover state
        buttonTextPrimary: "#0D0D0D",       // Primary button text color
        buttonSecondary: "#F3F4F6",         // Secondary button background
        buttonSecondaryHover: "#E5E7EB",     // Secondary button hover state
        buttonTextSecondary: "#344054",     // Secondary button text color
      },
      dark: {
        // Background colors
        bgPrimary: "#0D0D0D",
        bgSecondary: "#1A1A1A",
        
        // Border colors
        borderPrimary: "#323232",
        borderSecondary: "#D1D5DB",
        
        // Text colors
        textPrimary: "#FFFFFF",
        textSecondary: "#909090",
        textPlaceholder: "#9CA3AF",
        textError: "#F97066",
        textSuccess: "#34D399",
        
        // Button colors
        buttonPrimary: "#A6E500",
        buttonPrimaryHover: "#8CC500",
        buttonTextPrimary: "#0D0D0D",
        buttonSecondary: "#2A2A2A",
        buttonSecondaryHover: "#3A3A3A",
        buttonTextSecondary: "#FFFFFF",
      },
      radius: "8px", // Border radius for inputs, buttons, and tabs
    },
  },
});
```

#### Light Mode Only

If you only want to customize the light theme:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    themeConfig: {
      light: {
        bgPrimary: "#FFFFFF",
        textPrimary: "#000000",
        buttonPrimary: "#0070F3",
      },
      radius: "12px",
    },
  },
});
```

#### Dark Mode Only

If you only want to customize the dark theme:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    themeConfig: {
      dark: {
        bgPrimary: "#000000",
        textPrimary: "#FFFFFF",
        buttonPrimary: "#0070F3",
      },
      radius: "12px",
    },
  },
});
```

#### Partial Theme Override

You can override only specific properties. The checkout will use default values for properties you don't specify:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    themeConfig: {
      light: {
        buttonPrimary: "#FF6B6B", // Only override primary button color
      },
      radius: "16px", // Override border radius
    },
  },
});
```

#### Theme Configuration with Other Options

You can combine theme configuration with other checkout options:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    showTimer: true,
    showSecurityBadge: true,
    manualRedirect: false,
    themeConfig: {
      light: {
        bgPrimary: "#FFFFFF",
        buttonPrimary: "#A6E500",
      },
      dark: {
        bgPrimary: "#0D0D0D",
        buttonPrimary: "#A6E500",
      },
      radius: "8px",
    },
  },
});
```

#### TypeScript Types

For TypeScript users, all theme configuration types are exported:

```typescript theme={null}
import { ThemeConfig, ThemeModeConfig } from "dodopayments-checkout";

const themeConfig: ThemeConfig = {
  light: {
    bgPrimary: "#FFFFFF",
    // ... other properties
  },
  dark: {
    bgPrimary: "#0D0D0D",
    // ... other properties
  },
  radius: "8px",
};
```

## Error Handling

The SDK provides detailed error information through the event system. Always implement proper error handling in your `onEvent` callback:

```typescript theme={null}
DodoPayments.Initialize({
  mode: "test",
  displayType: "overlay",
  onEvent: (event: CheckoutEvent) => {
    if (event.event_type === "checkout.error") {
      console.error("Checkout error:", event.data?.message);
      // Handle error appropriately
      // You may want to show a user-friendly error message
      // or retry the checkout process
    }
    if (event.event_type === "checkout.link_expired") {
      // Handle expired checkout session
      console.warn("Checkout session has expired");
    }
  }
});
```

<Warning>
  Always handle the `checkout.error` event to provide a good user experience when errors occur.
</Warning>

## Best Practices

1. **Initialize once**: Initialize the SDK once when your application loads, not on every checkout attempt
2. **Error handling**: Always implement proper error handling in your event callback
3. **Test mode**: Use `test` mode during development and switch to `live` only when ready for production
4. **Event handling**: Handle all relevant events for a complete user experience
5. **Valid URLs**: Always use valid checkout URLs from the create checkout session API
6. **TypeScript**: Use TypeScript for better type safety and developer experience
7. **Loading states**: Show loading states while the checkout is opening to improve UX
8. **Manual redirects**: Use `manualRedirect` when you need custom control over post-checkout navigation
9. **Timer management**: Disable the timer (`showTimer: false`) if you want to handle session expiration manually

## Troubleshooting

<AccordionGroup>
  <Accordion title="Checkout not opening">
    **Possible causes:**

    * SDK not initialized before calling `open()`
    * Invalid checkout URL
    * JavaScript errors in console
    * Network connectivity issues

    **Solutions:**

    * Verify SDK initialization happens before opening checkout
    * Check for console errors
    * Ensure checkout URL is valid and from the create checkout session API
    * Verify network connectivity
  </Accordion>

  <Accordion title="Events not firing">
    **Possible causes:**

    * Event handler not properly set up
    * JavaScript errors preventing event propagation
    * SDK not initialized correctly

    **Solutions:**

    * Confirm event handler is properly configured in `Initialize()`
    * Check browser console for JavaScript errors
    * Verify SDK initialization completed successfully
    * Test with a simple event handler first
  </Accordion>

  <Accordion title="Styling issues">
    **Possible causes:**

    * CSS conflicts with your application styles
    * Theme settings not applied correctly
    * Responsive design issues

    **Solutions:**

    * Check for CSS conflicts in browser DevTools
    * Verify theme settings are correct
    * Test on different screen sizes
    * Ensure no z-index conflicts with overlay
  </Accordion>
</AccordionGroup>

## Enabling Digital Wallets

For detailed information about setting up Google Pay and other digital wallets, see the <a href="/features/payment-methods/digital-wallets">Digital Wallets</a> page.

<Note>
  Apple Pay is not yet supported in overlay checkout. Support for Apple Pay is coming soon.
</Note>

## Browser Support

The Dodo Payments Checkout SDK supports the following browsers:

* Chrome (latest)
* Firefox (latest)
* Safari (latest)
* Edge (latest)
* IE11+

## Overlay vs Inline Checkout

Choose the right checkout type for your use case:

| Feature               | Overlay Checkout                  | Inline Checkout                              |
| --------------------- | --------------------------------- | -------------------------------------------- |
| Integration depth     | Modal on top of page              | Fully embedded in page                       |
| Layout control        | Limited                           | Full control                                 |
| Branding              | Separate from page                | Seamless                                     |
| Implementation effort | Lower                             | Higher                                       |
| Best for              | Quick integration, existing pages | Custom checkout pages, high-conversion flows |

<Tip>
  Use **overlay checkout** for faster integration with minimal changes to your existing pages. Use **inline checkout** when you want maximum control over the checkout experience and seamless branding.
</Tip>

## Related Resources

<CardGroup>
  <Card title="Inline Checkout" icon="credit-card" href="/developer-resources/inline-checkout">
    Embed checkout directly into your page for fully integrated experiences.
  </Card>

  <Card title="Checkout Sessions API" icon="code" href="/api-reference/checkout-sessions/create">
    Create checkout sessions to power your checkout experiences.
  </Card>

  <Card title="Webhooks" icon="webhook" href="/developer-resources/webhooks">
    Handle payment events server-side with webhooks.
  </Card>

  <Card title="Integration Guide" icon="book" href="/developer-resources/integration-guide">
    Complete guide to integrating Dodo Payments.
  </Card>
</CardGroup>

For more help, visit our [Discord community](https://discord.gg/bYqAp4ayYh) or contact our developer support team.


# React Native
Source: https://docs.dodopayments.com/developer-resources/react-native-integration

Complete guide to integrating Dodo Payments SDK in your React Native application for secure payment processing

# React Native SDK Integration

The Dodo Payments React Native SDK enables you to build secure payment experiences in your native Android and iOS apps. Our SDK provides customizable UI components and screens for collecting payment details.

* 📦 Install our SDK from [NPM](https://www.npmjs.com/package/dodopayments-react-native-sdk)
* 📚 View our [demo repository](https://github.com/dodopayments/dodopayments-react-native-demo) for complete implementation examples
* 🎥 Watch our [demo video](https://youtu.be/eicctkqK04Y) to see the Dodo Payments SDK in action

<Frame>
  <iframe title="React Native SDK Demo | Dodo Payments" />
</Frame>

## Features

<CardGroup>
  <Card title="Simplified Security" icon="shield-check">
    Collect sensitive payment data securely while remaining PCI compliant
  </Card>

  <Card title="Multiple Payment Methods" icon="credit-card">
    Accept various [payment methods](/features/payment-methods) to expand global reach
  </Card>

  <Card title="Native UI" icon="mobile">
    Native screens and elements for Android and iOS
  </Card>
</CardGroup>

<Note>
  Currently, Apple Pay, Google Pay, Cash App, and UPI are not supported in the React Native SDK. We are actively working to add support for these payment methods in future releases.
</Note>

## Installation

<Steps>
  <Step title="Install the SDK">
    Install the Dodo Payments SDK using your preferred package manager:

    <Tabs>
      <Tab title="npm">
        ```bash theme={null}
        npm install dodopayments-react-native-sdk
        ```
      </Tab>

      <Tab title="yarn">
        ```bash theme={null}
        yarn add dodopayments-react-native-sdk
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Platform-specific setup">
    <Tabs>
      <Tab title="iOS">
        Run pod install in your iOS folder:

        ```bash theme={null}
        cd ios && pod install && npm run ios
        ```
      </Tab>

      <Tab title="Android">
        Run the following command:

        ```bash theme={null}
        npm run android
        ```
      </Tab>
    </Tabs>
  </Step>
</Steps>

## Client-Side Setup

<Steps>
  <Step title="Get Publishable Key">
    Get your publishable key from the Dodo Payments dashboard. (Distinct for both test and live modes)
    [https://app.dodopayments.com/developer/others](https://app.dodopayments.com/developer/others)
  </Step>

  <Step title="Setup Payment Provider">
    Wrap your app with the `DodoPaymentProvider`:

    ```tsx App.tsx theme={null}
    import React from 'react';
    import { DodoPaymentProvider } from 'dodopayments-react-native-sdk';
    import PaymentScreen from './PaymentScreen';

    function App() {
      return (
        <DodoPaymentProvider publishableKey="YOUR_PUBLISHABLE_KEY">
          <PaymentScreen />
        </DodoPaymentProvider>
      );
    }

    export default App;
    ```

    <Note>
      You'll need to generate API keys from your Dodo Payments dashboard. See our [API key generation guide](/api-reference/introduction#api-key-generation) for detailed instructions.
    </Note>
  </Step>

  <Step title="Create payment utility function">
    Create a utility function to fetch payment parameters from your backend API:

    ```tsx utils/fetchPaymentParams.ts theme={null}
    const API_URL = 'YOUR_BACKEND_URL'; // Replace with your server URL

    const fetchPaymentParams = async () => {
      const response = await fetch(`${API_URL}/create-payment`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        throw new Error('Failed to fetch payment parameters');
      }
      
      return await response.json();
    };

    export default fetchPaymentParams;
    ```

    <Note>
      This function assumes you have a backend API endpoint that creates payment intents and returns a client secret. Ensure your backend is properly configured to handle payment creation. See our [API Integration Tutorial](/developer-resources/integration-guide) for backend setup examples.
    </Note>
  </Step>

  <Step title="Implement the payment screen">
    Create your payment screen using the `useCheckout` hook. Here's a complete implementation:

    ```tsx PaymentScreen.tsx theme={null}
    import React from 'react';
    import { View, Text, useColorScheme } from 'react-native';
    import { useCheckout, type sessionParams } from 'dodopayments-react-native-sdk';
    import fetchPaymentParams from './utils/fetchPaymentParams';

    const PaymentScreen = () => {
      const { initPaymentSession, presentPaymentSheet } = useCheckout();
      const [error, setError] = React.useState('');
      const [message, setMessage] = React.useState('');
      const [loading, setLoading] = React.useState(false);
      const [showSuccessScreen, setShowSuccessScreen] = React.useState(false);
      const isDarkMode = useColorScheme() === 'dark';

      const processPayment = async () => {
        setLoading(true);
        setMessage('');
        setError('');

        try {
          // 1. Get payment parameters from your backend
          const key = await fetchPaymentParams();
          
          // 2. Initialize payment session
          const paymentSheetParamsResult = await initPaymentSession({
            clientSecret: key.clientSecret,
          });
          
          // 3. Configure and present payment sheet
          const params: sessionParams = {
            ...(paymentSheetParamsResult as sessionParams),
            configuration: {
              appearance: {
                themes: isDarkMode ? 'dark' : 'light',
                primaryButton: {
                  colors: {
                    light: {
                      background: 'green',
                      componentBorder: 'green',
                      placeholderText: 'yellow',
                    },
                    dark: {
                      background: 'green',
                      componentBorder: 'green',
                      placeholderText: 'yellow',
                    },
                  },
                  shapes: {
                    borderRadius: 30,
                    borderWidth: 3,
                  },
                },
              },
              mode: 'test', // DEFAULTS TO TEST MODE
            },
          };

          const paymentSheetResponse = await presentPaymentSheet(params);

          // 4. Handle payment result
          switch (paymentSheetResponse?.status) {
            case 'cancelled':
              setError('Payment cancelled by user.');
              break;
            case 'succeeded':
              setMessage('');
              setShowSuccessScreen(true);
              break;
            case 'failed':
              setError('Payment failed : \n' + paymentSheetResponse?.message);
              break;
            default:
              setError(paymentSheetResponse?.message);
              setMessage('');
          }
        } catch (err) {
          setError('Failed to process payment');
        } finally {
          setLoading(false);
        }
      };

      return (
        <View>
          <Button 
            onPress={processPayment}
            disabled={loading}
            title={loading ? 'Processing...' : 'Pay Now'}
          />
          {error && <Text style={{ color: 'red' }}>{error}</Text>}
          {message && <Text style={{ color: 'green' }}>{message}</Text>}
          {showSuccessScreen && (
            <PaymentSuccessScreen
              amount={total}
              onContinue={() => setShowSuccessScreen(false)}
            />
          )}
        </View>
      );
    };

    export default PaymentScreen;
    ```

    <Note>
      For complete examples with styling, error handling, and customization options, check out our demo repositories:

      * [Basic Integration Demo](https://github.com/dodopayments/dodopayments-react-native-demo)
    </Note>
  </Step>
</Steps>

## Configuration Options

### Session Parameters

<ParamField type="string">
  The client secret from your payment intent, obtained from One time payment or subscription API.
</ParamField>

<ParamField type="string">
  The mode of the payment session (test or live).
</ParamField>

<ParamField type="object">
  Customization options for the payment sheet appearance
</ParamField>

<ParamField type="string">
  Theme mode: `'light'` or `'dark'`
</ParamField>

### Appearance Customization

You can customize the React Native Unified Checkout to match your app's design by modifying colors, fonts, and more through the appearance parameter when calling `initPaymentSession()`.

#### Color Customization

Each color category determines the color of one or more components in the UI. For example, `primary` defines the color of the Pay button.

| Color Category        | Usage                                                        |
| --------------------- | ------------------------------------------------------------ |
| `primary`             | Primary color for the Pay button and selected items          |
| `background`          | Background color of the payment page                         |
| `componentBackground` | Background color for inputs, tabs, and other components      |
| `componentBorder`     | External border color for inputs, tabs, and other components |
| `componentDivider`    | Internal border color (shared borders) for components        |
| `primaryText`         | Header text color                                            |
| `secondaryText`       | Label text color for input fields                            |
| `componentText`       | Input text color (e.g., card number, zip code)               |
| `placeholderText`     | Placeholder text color for input fields                      |
| `icon`                | Color for icons (e.g., close button)                         |
| `error`               | Color for error messages and destructive actions             |

Example configuration with light and dark mode support:

```tsx theme={null}
const appearance = {
  colors: {
    light: {
      primary: '#F8F8F2',
      background: '#ffffff',
      componentBackground: '#E6DB74',
      componentBorder: '#FD971F',
      componentDivider: '#FD971F',
      primaryText: '#F8F8F2',
      secondaryText: '#75715E',
      componentText: '#AE81FF',
      placeholderText: '#E69F66',
      icon: '#F92672',
      error: '#FF0000',
    },
    dark: {
      primary: '#00ff0099',
      background: '#ff0000',
      componentBackground: '#ff0080',
      componentBorder: '#62ff08',
      componentDivider: '#d6de00',
      primaryText: '#5181fc',
      secondaryText: '#ff7b00',
      componentText: '#00ffff',
      placeholderText: '#00ffff',
      icon: '#f0f0f0',
      error: '#0f0f0f',
    },
  },
};
```

#### Shape Customization

You can customize the border radius, border width, and shadow used throughout the payment interface:

```tsx theme={null}
const appearance = {
  shapes: {
    borderRadius: 10, // Border radius for input fields, tabs, and components
    borderWidth: 1,   // Border width for components
  },
};
```

#### Component-Specific Customization

You can customize specific UI components like the primary button (Pay button). These settings take precedence over the global appearance settings:

```tsx theme={null}
const appearance = {
  primaryButton: {
    colors: {
      background: '#000000',
      text: '#ffffff',
      border: '#ff00ff',
    },
    shapes: {
      borderRadius: 10,
      borderWidth: 1.5,
    },
  },
};
```

To apply these customizations, include them in your payment session configuration:

```tsx theme={null}
const params: sessionParams = {
  ...paymentSheetParams,
  configuration: {
    appearance: {
      themes: isDarkMode ? 'dark' : 'light',
      ...appearance, // Include your custom appearance settings
    },
  },
};
```

## Error Handling

Handle different payment states in your checkout function:

```tsx theme={null}
const handlePaymentResult = (paymentSheetResponse) => {
  switch (paymentSheetResponse?.status) {
    case 'cancelled':
      // User cancelled the payment
      console.log('Payment cancelled by user');
      break;
    case 'succeeded':
      // Payment completed successfully
      console.log('Payment succeeded');
      // Navigate to success screen or update UI
      break;
    case 'failed':
      // Payment failed
      console.log('Payment failed:', paymentSheetResponse?.message);
      // Show error message to user
      break;
    default:
      console.log('Unknown payment status:', paymentSheetResponse?.status);
  }
};
```

<AccordionGroup>
  <Accordion title="Common Error Scenarios">
    * **Network connectivity issues**: Ensure stable internet connection
    * **Invalid client secret**: Verify backend is generating valid payment intents
    * **Missing peer dependencies**: Install all required dependencies
    * **Platform-specific setup**: Complete iOS and Android configuration steps
    * **API errors**: Check our [Error Codes Reference](/api-reference/error-codes) for detailed error handling
  </Accordion>

  <Accordion title="Debugging Tips">
    * Enable debug logging in development
    * Check network requests to your backend
    * Verify API keys are correctly configured
    * Test on both iOS and Android platforms
    * Review our [Technical FAQs](/api-reference/technical-faqs) for common issues
    * Use [Test vs Live Mode](/miscellaneous/test-mode-vs-live-mode) appropriately
  </Accordion>
</AccordionGroup>

### Test Payment Methods

<Tip>
  Use test card numbers in development to verify your integration without processing real payments. Learn more about our [testing process](/miscellaneous/testing-process) and available test environments.
</Tip>


# Remix Adaptor
Source: https://docs.dodopayments.com/developer-resources/remix-adaptor

Learn how to integrate Dodo Payments with your Remix App Router project using our Remix Adaptor. Covers checkout, customer portal, webhooks, and secure environment setup.

<CardGroup>
  <Card title="Checkout Handler" icon="cart-shopping" href="#checkout-route-handler">
    Integrate Dodo Payments checkout into your Remix app.
  </Card>

  <Card title="Customer Portal" icon="user" href="#customer-portal-route-handler">
    Allow customers to manage subscriptions and details.
  </Card>

  <Card title="Webhooks" icon="bell" href="#webhook-route-handler">
    Receive and process Dodo Payments webhook events.
  </Card>
</CardGroup>

## Installation

<Steps>
  <Step title="Install the package">
    Run the following command in your project root:

    ```bash theme={null}
    npm install @dodopayments/remix
    ```
  </Step>

  <Step title="Set up environment variables">
    Create a <code>.env</code> file in your project root:

    ```env expandable theme={null}
    DODO_PAYMENTS_API_KEY=your-api-key
    DODO_PAYMENTS_WEBHOOK_SECRET=your-webhook-secret
    DODO_PAYMENTS_RETURN_URL=https://yourdomain.com/checkout/success
    DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode"
    ```

    <Warning>
      Never commit your <code>.env</code> file or secrets to version control.
    </Warning>
  </Step>
</Steps>

## Route Handler Examples

<Info>
  All examples assume you are using the Remix App Router.
</Info>

<Tabs>
  <Tab title="Checkout Handler">
    <Info>
      Use this handler to integrate Dodo Payments checkout into your Remix app. Supports static (GET), dynamic (POST), and session (POST) payment flows.
    </Info>

    <CodeGroup>
      ```typescript Remix Route Handler expandable theme={null}
      // app/routes/api.checkout.tsx
      import { Checkout } from "@dodopayments/remix";
      import type { LoaderFunctionArgs } from "@remix-run/node";

      const checkoutGetHandler = Checkout({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
          environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
          type: "static"
      });

      const checkoutPostHandler = Checkout({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
          environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
          type: "dynamic", // for dynamic checkout
      });

      const checkoutSessionHandler = Checkout({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
          environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
          type: "session", // for checkout sessions
      });

      export const loader = ({ request }: LoaderFunctionArgs) => checkoutGetHandler(request);
      export const action = ({ request }: LoaderFunctionArgs) => {
          // You can conditionally route to different handlers based on your needs
          // For checkout sessions, use checkoutSessionHandler(request)
          return checkoutPostHandler(request);
      };
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Static Checkout Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/checkout?productId=pdt_fqJhl7pxKWiLhwQR042rh' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Dynamic Checkout Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "billing": {
        "city": "Texas",
        "country": "US",
        "state": "Texas",
        "street": "56, hhh",
        "zipcode": "560000"
      },
      "customer": {
        "email": "test@example.com",
        	"name": "test"
      },
      "metadata": {},
      "payment_link": true,
        "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
        "quantity": 1,
        "billing_currency": "USD",
        "discount_code": "IKHZ23M9GQ",
        "return_url": "https://example.com",
        "trial_period_days": 10
      }'
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Checkout Session Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "product_cart": [
        {
          "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
          "quantity": 1
        }
      ],
      "customer": {
        "email": "test@example.com",
        "name": "test"
      },
      "return_url": "https://example.com/success"
      }'
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Customer Portal Handler">
    <Info>
      Use this handler to allow customers to manage their subscriptions and details via the Dodo Payments customer portal.
    </Info>

    <CodeGroup>
      ```typescript Remix Route Handler expandable theme={null}
      // app/routes/api.customer-portal.tsx
      import { CustomerPortal } from "@dodopayments/remix";
      import type { LoaderFunctionArgs } from "@remix-run/node";

      const customerPortalHandler = CustomerPortal({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          environment: process.env.DODO_PAYMENTS_ENVIRONMENT
      });

      export const loader = ({ request }: LoaderFunctionArgs) => customerPortalHandler(request);
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Customer Portal Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/customer-portal?customer_id=cus_9VuW4K7O3GHwasENg31m&send_email=true' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Webhook Handler">
    <Info>
      Use this handler to receive and process Dodo Payments webhook events securely in your Remix app.
    </Info>

    <CodeGroup>
      ```typescript Remix Route Handler expandable theme={null}
      // app/routes/api.webhook.tsx
      import { Webhooks } from "@dodopayments/remix";
      import type { LoaderFunctionArgs } from "@remix-run/node";

      const webhookHandler = Webhooks({
      webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_SECRET,
      onPayload: async (payload) => {
          //Handle Payload Here
          console.log(payload)
      }
      });
      export const action = ({ request }: LoaderFunctionArgs) => webhookHandler(request);
      ```
    </CodeGroup>
  </Tab>
</Tabs>

## Checkout Route Handler

<Info>
  Dodo Payments supports three types of payment flows for integrating payments into your website, this adaptor supports all types of payment flows.
</Info>

* **Static Payment Links:** Instantly shareable URLs for quick, no-code payment collection.
* **Dynamic Payment Links:** Programmatically generate payment links with custom details using the API or SDKs.
* **Checkout Sessions:** Create secure, customizable checkout experiences with pre-configured product carts and customer details.

<AccordionGroup>
  <Accordion title="Static Checkout (GET)">
    ### Supported Query Parameters

    <ParamField type="string">
      Product identifier (e.g., <code>?productId=pdt\_nZuwz45WAs64n3l07zpQR</code>).
    </ParamField>

    <ParamField type="integer">
      Quantity of the product.
    </ParamField>

    <ParamField type="string">
      Customer's full name.
    </ParamField>

    <ParamField type="string">
      Customer's first name.
    </ParamField>

    <ParamField type="string">
      Customer's last name.
    </ParamField>

    <ParamField type="string">
      Customer's email address.
    </ParamField>

    <ParamField type="string">
      Customer's country.
    </ParamField>

    <ParamField type="string">
      Customer's address line.
    </ParamField>

    <ParamField type="string">
      Customer's city.
    </ParamField>

    <ParamField type="string">
      Customer's state/province.
    </ParamField>

    <ParamField type="string">
      Customer's zip/postal code.
    </ParamField>

    <ParamField type="boolean">
      Disable full name field.
    </ParamField>

    <ParamField type="boolean">
      Disable first name field.
    </ParamField>

    <ParamField type="boolean">
      Disable last name field.
    </ParamField>

    <ParamField type="boolean">
      Disable email field.
    </ParamField>

    <ParamField type="boolean">
      Disable country field.
    </ParamField>

    <ParamField type="boolean">
      Disable address line field.
    </ParamField>

    <ParamField type="boolean">
      Disable city field.
    </ParamField>

    <ParamField type="boolean">
      Disable state field.
    </ParamField>

    <ParamField type="boolean">
      Disable zip code field.
    </ParamField>

    <ParamField type="string">
      Specify the payment currency (e.g., <code>USD</code>).
    </ParamField>

    <ParamField type="boolean">
      Show currency selector.
    </ParamField>

    <ParamField type="integer">
      Specify the payment amount (e.g., <code>1000</code> for \$10.00).
    </ParamField>

    <ParamField type="boolean">
      Show discount fields.
    </ParamField>

    <ParamField type="string">
      Any query parameter starting with <code>metadata\_</code> will be passed as metadata.
    </ParamField>

    <Warning>
      If <code>productId</code> is missing, the handler returns a 400 response. Invalid query parameters also result in a 400 response.
    </Warning>

    ### Response Format

    Static checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Dynamic Checkout (POST)">
    * Send parameters as a JSON body in a POST request.
    * Supports both one-time and recurring payments.
    * For a complete list of supported POST body fields, refer to:
      * [Request body for a One Time Payment Product](https://docs.dodopayments.com/api-reference/payments/post-payments)
      * [Request body for a Subscription Product](https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions)

    ### Response Format

    Dynamic checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Checkout Sessions (POST)">
    Checkout sessions provide a more secure, hosted checkout experience that handles the complete payment flow for both one-time purchases and subscriptions with full customization control.

    Refer to [Checkout Sessions Integration Guide](https://docs.dodopayments.com/developer-resources/checkout-session) for more details and a complete list of supported fields.

    ### Response Format

    Checkout sessions return a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/session/..."
    }
    ```
  </Accordion>
</AccordionGroup>

## Customer Portal Route Handler

The Customer Portal Route Handler enables you to seamlessly integrate the Dodo Payments customer portal into your Remix application.

### Query Parameters

<ParamField type="string">
  The customer ID for the portal session (e.g., <code>?customer\_id=cus\_123</code>).
</ParamField>

<ParamField type="boolean">
  If set to <code>true</code>, sends an email to the customer with the portal link.
</ParamField>

<Warning>
  Returns 400 if <code>customer\_id</code> is missing.
</Warning>

## Webhook Route Handler

* **Method:** Only POST requests are supported. Other methods return 405.
* **Signature Verification:** Verifies the webhook signature using <code>webhookKey</code>. Returns 401 if verification fails.
* **Payload Validation:** Validated with Zod. Returns 400 for invalid payloads.
* **Error Handling:**
  * 401: Invalid signature
  * 400: Invalid payload
  * 500: Internal error during verification
* **Event Routing:** Calls the appropriate event handler based on the payload type.

### Supported Webhook Event Handlers

<CodeGroup>
  ```typescript Typescript expandable theme={null}
  onPayload?: (payload: WebhookPayload) => Promise<void>;
  onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onPaymentFailed?: (payload: WebhookPayload) => Promise<void>;
  onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>;
  onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>;
  onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onRefundFailed?: (payload: WebhookPayload) => Promise<void>;
  onDisputeOpened?: (payload: WebhookPayload) => Promise<void>;
  onDisputeExpired?: (payload: WebhookPayload) => Promise<void>;
  onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>;
  onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>;
  onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>;
  onDisputeWon?: (payload: WebhookPayload) => Promise<void>;
  onDisputeLost?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>;
  onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>;
  ```
</CodeGroup>

***

## Prompt for LLM

```

You are an expert Remix developer assistant. Your task is to guide a user through integrating the @dodopayments/remix adapter into their existing Remix project.

The @dodopayments/remix adapter provides route handlers for Dodo Payments' Checkout, Customer Portal, and Webhook functionalities, designed for Remix route handlers.

First, install the necessary packages. Use the package manager appropriate for your project (npm, yarn, or bun) based on the presence of lock files (e.g., package-lock.json for npm, yarn.lock for yarn, bun.lockb for bun):

npm install @dodopayments/remix

Here's how you should structure your response:

    Ask the user which functionalities they want to integrate.

"Which parts of the @dodopayments/remix adapter would you like to integrate into your project? You can choose one or more of the following:

    Checkout Route Handler (for handling product checkouts)

    Customer Portal Route Handler (for managing customer subscriptions/details)

    Webhook Route Handler (for receiving Dodo Payments webhook events)

    All (integrate all three)"

    Based on the user's selection, provide detailed integration steps for each chosen functionality.

If Checkout Route Handler is selected:

Purpose: This handler redirects users to the Dodo Payments checkout page.
File Creation: Create a new file at app/routes/api.checkout.tsx in your Remix project.

Code Snippet:

// app/routes/api.checkout.tsx
import { Checkout } from "@dodopayments/remix";
import type { LoaderFunctionArgs } from "@remix-run/node";

const checkoutGetHandler = Checkout({
  bearerToken: process.env.DODO_PAYMENTS_API_KEY,
  returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
  environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
  type: "static",
});

const checkoutPostHandler = Checkout({
  bearerToken: process.env.DODO_PAYMENTS_API_KEY,
  returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
  environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
  type: "dynamic", // for dynamic checkout
});

const checkoutSessionHandler = Checkout({
  bearerToken: process.env.DODO_PAYMENTS_API_KEY,
  returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
  environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
  type: "session", // for checkout sessions
});

export const loader = ({ request }: LoaderFunctionArgs) => checkoutGetHandler(request);

export const action = ({ request }: LoaderFunctionArgs) => {
  // You can conditionally route to different handlers based on your needs
  // For checkout sessions, use checkoutSessionHandler(request)
  return checkoutPostHandler(request);
};

If Customer Portal Route Handler is selected:

Purpose: This handler redirects authenticated users to their Dodo Payments customer portal.
File Creation: Create a new file at app/routes/api.customer-portal.tsx in your Remix project.

Code Snippet:

// app/routes/api.customer-portal.tsx
import { CustomerPortal } from "@dodopayments/remix";
import type { LoaderFunctionArgs } from "@remix-run/node";

const customerPortalHandler = CustomerPortal({
  bearerToken: process.env.DODO_PAYMENTS_API_KEY,
  environment: process.env.DODO_PAYMENTS_ENVIRONMENT
});

export const loader = ({ request }: LoaderFunctionArgs) => customerPortalHandler(request);

Query Parameters:

    customer_id (required): The customer ID for the portal session (e.g., ?customer_id=cus_123)

    send_email (optional, boolean): If set to true, sends an email to the customer with the portal link.

    Returns 400 if customer_id is missing.

If Webhook Route Handler is selected:

Purpose: This handler processes incoming webhook events from Dodo Payments, allowing your application to react to events like successful payments, refunds, or subscription changes.
File Creation: Create a new file at app/routes/api.webhook.tsx in your Remix project.

Code Snippet:

// app/routes/api.webhook.tsx
import { Webhooks } from "@dodopayments/remix";
import type { LoaderFunctionArgs } from "@remix-run/node";

const webhookHandler = Webhooks({
  webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_SECRET,
  onPayload: async (payload) => {
    //Handle Payload Here
    console.log(payload)
  }
});

export const action = ({ request }: LoaderFunctionArgs) => webhookHandler(request);

Handler Details:

    Method: Only POST requests are supported. Other methods return 405.

    Signature Verification: The handler verifies the webhook signature using the webhookKey and returns 401 if verification fails.

    Payload Validation: The payload is validated with Zod. Returns 400 for invalid payloads.

Error Handling:

    401: Invalid signature

    400: Invalid payload

    500: Internal error during verification

Event Routing: Calls the appropriate event handler based on the payload type.

Supported Webhook Event Handlers:

    onPayload?: (payload: WebhookPayload) => Promise<void>

    onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>

    onPaymentFailed?: (payload: WebhookPayload) => Promise<void>

    onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>

    onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>

    onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>

    onRefundFailed?: (payload: WebhookPayload) => Promise<void>

    onDisputeOpened?: (payload: WebhookPayload) => Promise<void>

    onDisputeExpired?: (payload: WebhookPayload) => Promise<void>

    onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>

    onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>

    onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>

    onDisputeWon?: (payload: WebhookPayload) => Promise<void>

    onDisputeLost?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionPaused?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>

    onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>

    Environment Variable Setup:

To ensure the adapter functions correctly, you will need to manually set up the following environment variables in your Remix project's deployment environment (e.g., Vercel, Netlify, AWS, etc.):

    DODO_PAYMENTS_API_KEY: Your Dodo Payments API Key (required for Checkout and Customer Portal).

    DODO_PAYMENTS_RETURN_URL: (Optional) The URL to redirect to after a successful checkout (for Checkout handler).

    DODO_PAYMENTS_ENVIRONMENT: (Optional) The environment for the API (e.g., test or live).

    DODO_PAYMENTS_WEBHOOK_SECRET: Your Dodo Payments Webhook Secret (required for Webhook handler).

Example .env file:

DODO_PAYMENTS_API_KEY=your-api-key
DODO_PAYMENTS_RETURN_URL=your-return-url
DODO_PAYMENTS_ENVIRONMENT=test
DODO_PAYMENTS_WEBHOOK_SECRET=your-webhook-secret

Usage in your code:

bearerToken: process.env.DODO_PAYMENTS_API_KEY
webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_SECRET

Important: Never commit sensitive environment variables directly into your version control. Use environment variables for all sensitive information.

If the user needs assistance setting up environment variables for their specific deployment environment, ask them what platform they are using (e.g., Vercel, Netlify, AWS, etc.), and provide guidance. You can also add comments to their PR or chat depending on the context

```


# CLI
Source: https://docs.dodopayments.com/developer-resources/sdks/cli

Command-line interface for interacting with the Dodo Payments API from your terminal

## Installation

### Go Install

```bash theme={null}
go install github.com/dodopayments/dodopayments-cli/cmd/dodopayments@latest
```

### From Source

```bash theme={null}
git clone https://github.com/dodopayments/dodopayments-cli.git
cd dodopayments-cli
go install ./cmd/dodopayments
```

## Quick Start

Set your API key:

```bash theme={null}
export DODO_PAYMENTS_API_KEY=your_api_key_here
```

Basic command structure:

```bash theme={null}
dodopayments [resource] [command] [flags]
```

Create a checkout session:

```bash theme={null}
dodopayments checkout-sessions create \
  --product-cart.product_id prod_123 \
  --product-cart.quantity 1 \
  --return-url https://yourdomain.com/return
```

## Global Flags

| Flag              | Description                                                |
| ----------------- | ---------------------------------------------------------- |
| `--format`        | Output format: `auto`, `json`, `yaml`, `pretty`, `explore` |
| `--transform`     | Filter response using gjson syntax                         |
| `--debug`         | Enable verbose logging                                     |
| `--version`, `-v` | Display CLI version                                        |

## Common Commands

### Payments

```bash theme={null}
# List payments
dodopayments payments list --limit 20 --format json

# Retrieve payment
dodopayments payments retrieve pay_123

# Get line items
dodopayments payments line-items pay_123
```

### Customers

```bash theme={null}
# Create customer
dodopayments customers create \
  --email customer@example.com \
  --name "John Doe"

# List customers
dodopayments customers list

# Update customer
dodopayments customers update cus_123 --name "Jane Doe"
```

### Subscriptions

```bash theme={null}
# Create subscription
dodopayments subscriptions create \
  --customer-id cus_123 \
  --product-id prod_456

# List subscriptions
dodopayments subscriptions list

# Get usage history
dodopayments subscriptions usage-history sub_123
```

### Products

```bash theme={null}
# Create product
dodopayments products create \
  --name "Premium Plan" \
  --price.amount 2999 \
  --price.currency USD

# List products
dodopayments products list
```

## Usage-Based Billing

### Ingest Events

```bash theme={null}
dodopayments usage-events ingest \
  --events.event_id api_call_12345 \
  --events.customer_id cus_abc123 \
  --events.event_name api_request \
  --events.timestamp 2024-01-15T10:30:00Z \
  --events.metadata.endpoint /api/v1/users
```

### Manage Meters

```bash theme={null}
# Create meter
dodopayments meters create \
  --name "API Requests" \
  --event-name api_request \
  --aggregation count

# List meters
dodopayments meters list
```

## Output Formats

### JSON (for scripting)

```bash theme={null}
dodopayments payments list --format json | jq '.data[] | {id, amount}'
```

### Pretty (for reading)

```bash theme={null}
dodopayments payments retrieve pay_123 --format pretty
```

### Interactive Explore

```bash theme={null}
dodopayments payments list --format explore
```

### Transform with gjson

```bash theme={null}
# Extract all payment IDs
dodopayments payments list --transform "data.#.id"

# Filter and extract
dodopayments payments list --transform "data.#(amount>5000)#.id"
```

<Tip>
  Use `--format json` with `jq` for powerful data processing in shell scripts.
</Tip>

## Scripting Example

```bash theme={null}
#!/bin/bash

# Export all payments to CSV
dodopayments payments list --format json | \
  jq -r '.data[] | [.id, .amount, .currency, .status] | @csv' > payments.csv

# Create customers from file
while IFS=',' read -r email name; do
  dodopayments customers create \
    --email "$email" \
    --name "$name" \
    --format json
done < customers.csv
```

## Shell Completion

Enable auto-completion:

```bash theme={null}
# Bash
eval "$(dodopayments completion bash)"

# Zsh
eval "$(dodopayments completion zsh)"

# Fish
dodopayments completion fish | source
```

## Available Resources

The CLI provides commands for 24 resource categories:

* `checkout-sessions` - Checkout session management
* `payments` - Payment operations
* `subscriptions` - Recurring billing
* `customers` - Customer accounts
* `products` - Product catalog
* `licenses` - Software licensing
* `refunds` - Payment refunds
* `disputes` - Payment disputes
* `webhooks` - Event webhooks
* `meters` - Usage meters
* `usage-events` - Usage tracking
* `discounts` - Discount codes
* `payouts` - Seller payouts
* `brands` - Multi-brand management
* Plus 10 additional resources

<Info>
  Use `dodopayments --help` to see all available resources and `dodopayments [resource] --help` for resource-specific commands.
</Info>

## Resources

<CardGroup>
  <Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/dodopayments-cli">
    View source code and releases
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/introduction">
    Complete API documentation
  </Card>
</CardGroup>

## Support

Need help with the CLI?

* **Discord**: Join our [community server](https://discord.gg/bYqAp4ayYh)
* **Email**: Contact us at [support@dodopayments.com](mailto:support@dodopayments.com)
* **GitHub**: Open an issue on the [repository](https://github.com/dodopayments/dodopayments-cli)


# C#
Source: https://docs.dodopayments.com/developer-resources/sdks/csharp

Integrate Dodo Payments into your .NET applications with modern async/await support

The C# SDK provides convenient access to the Dodo Payments REST API from applications written in C#. It features an async Task-based API with strong typing and is currently in beta.

<Info>
  The C# SDK is currently in beta. We're actively working on improvements and welcome your feedback.
</Info>

## Installation

Install the SDK using the .NET CLI:

```bash theme={null}
dotnet add package DodoPayments.Client
```

<Info>
  The SDK requires .NET Standard 2.0 or later. It works with ASP.NET Core, Console applications, and other .NET project types.
</Info>

## Quick Start

Initialize the client and create a checkout session:

```csharp theme={null}
using System;
using DodoPayments.Client;
using DodoPayments.Client.Models.CheckoutSessions;

// Configured using the DODO_PAYMENTS_API_KEY and DODO_PAYMENTS_BASE_URL environment variables
DodoPaymentsClient client = new();

CheckoutSessionCreateParams parameters = new()
{
    ProductCart =
    [
        new()
        {
            ProductID = "product_id",
            Quantity = 1,
        },
    ],
};

var checkoutSessionResponse = await client.CheckoutSessions.Create(parameters);

Console.WriteLine(checkoutSessionResponse.SessionId);
```

<Warning>
  Always store your API keys securely using environment variables, user secrets, or Azure Key Vault. Never hardcode them in your source code or commit them to version control.
</Warning>

## Core Features

<CardGroup>
  <Card title="Async/Await" icon="bolt">
    Full async Task-based API for non-blocking operations
  </Card>

  <Card title="Strong Typing" icon="shield-check">
    Comprehensive type safety with nullable reference types
  </Card>

  <Card title="Dependency Injection" icon="layer-group">
    First-class support for .NET dependency injection
  </Card>

  <Card title="Configuration" icon="gear">
    Simple configuration via environment variables or appsettings.json
  </Card>
</CardGroup>

## Configuration

### Environment Variables

Configure using environment variables:

```bash .env theme={null}
DODO_PAYMENTS_API_KEY=your_api_key_here
```

```csharp theme={null}
// Automatically reads from environment variables
DodoPaymentsClient client = new();
```

See this table for the available options:

| Property      | Environment variable        | Required | Default value                     |
| ------------- | --------------------------- | -------- | --------------------------------- |
| `BearerToken` | `DODO_PAYMENTS_API_KEY`     | true     | -                                 |
| `WebhookKey`  | `DODO_PAYMENTS_WEBHOOK_KEY` | false    | -                                 |
| `BaseUrl`     | `DODO_PAYMENTS_BASE_URL`    | true     | `"https://live.dodopayments.com"` |

### Manual Configuration

Configure manually with bearer token:

```csharp theme={null}
DodoPaymentsClient client = new() { BearerToken = "My Bearer Token" };
```

## Common Operations

### Create a Checkout Session

Generate a checkout session:

```csharp theme={null}
var parameters = new CheckoutSessionCreateParams
{
    ProductCart =
    [
        new()
        {
            ProductID = "prod_123",
            Quantity = 1
        }
    ],
    ReturnUrl = "https://yourdomain.com/return"
};

var session = await client.CheckoutSessions.Create(parameters);
Console.WriteLine($"Checkout URL: {session.Url}");
```

### Manage Customers

Create and retrieve customer information:

```csharp theme={null}
// Create a customer
var createParams = new CustomerCreateParams
{
    Email = "customer@example.com",
    Name = "John Doe",
    Metadata = new Dictionary<string, string>
    {
        { "user_id", "12345" }
    }
};

var customer = await client.Customers.Create(createParams);

// Retrieve customer
var retrieved = await client.Customers.Retrieve("cus_123");
Console.WriteLine($"Customer: {retrieved.Name} ({retrieved.Email})");
```

### Handle Subscriptions

Create and manage recurring subscriptions:

```csharp theme={null}
// Create a subscription
var subscriptionParams = new SubscriptionCreateParams
{
    CustomerID = "cus_123",
    ProductID = "prod_456",
    PriceID = "price_789"
};

var subscription = await client.Subscriptions.Create(subscriptionParams);

// Cancel subscription
await client.Subscriptions.Cancel(subscription.Id);
```

## Pagination

The SDK defines methods that return paginated lists of results with convenient ways to access results either one page at a time or item-by-item across all pages.

### Auto-Pagination

To iterate through all results across all pages, use the `Paginate` method:

```csharp theme={null}
using System;

var page = await client.Payments.List(parameters);
await foreach (var item in page.Paginate())
{
    Console.WriteLine(item);
}
```

### Manual Pagination

To access individual page items and manually request the next page:

```csharp theme={null}
using System;

var page = await client.Payments.List();
while (true)
{
    foreach (var item in page.Items)
    {
        Console.WriteLine(item);
    }
    if (!page.HasNext())
    {
        break;
    }
    page = await page.Next();
}
```

## ASP.NET Core Integration

### Service Registration

Register the client in `Program.cs`:

```csharp Program.cs theme={null}
using DodoPayments.Client;

var builder = WebApplication.CreateBuilder(args);

// Register DodoPayments client
builder.Services.AddSingleton<DodoPaymentsClient>(sp =>
{
    var configuration = sp.GetRequiredService<IConfiguration>();
    return new DodoPaymentsClient
    {
        BearerToken = configuration["DodoPayments:ApiKey"]
    };
});

builder.Services.AddControllers();

var app = builder.Build();
app.MapControllers();
app.Run();
```

### Configuration

Add configuration in `appsettings.json`:

```json appsettings.json theme={null}
{
  "DodoPayments": {
    "ApiKey": "your_api_key_here"
  }
}
```

### API Controller

Create a controller using dependency injection:

```csharp theme={null}
using Microsoft.AspNetCore.Mvc;
using DodoPayments.Client;
using DodoPayments.Client.Models.CheckoutSessions;

[ApiController]
[Route("api/[controller]")]
public class PaymentsController : ControllerBase
{
    private readonly DodoPaymentsClient _client;
    private readonly ILogger<PaymentsController> _logger;

    public PaymentsController(DodoPaymentsClient client, ILogger<PaymentsController> logger)
    {
        _client = client;
        _logger = logger;
    }

    [HttpPost("checkout")]
    public async Task<IActionResult> CreateCheckout([FromBody] CheckoutRequest request)
    {
        try
        {
            var parameters = new CheckoutSessionCreateParams
            {
                ProductCart = request.Items,
                ReturnUrl = Url.Action("Return", "Checkout", null, Request.Scheme)
            };

            var session = await _client.CheckoutSessions.Create(parameters);

            return Ok(new { checkoutUrl = session.Url });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to create checkout");
            return BadRequest(new { error = ex.Message });
        }
    }
}

public record CheckoutRequest(List<ProductCartItem> Items);
```

### Service Layer Pattern

Create a service for business logic:

```csharp theme={null}
public interface IPaymentService
{
    Task<CheckoutSessionResponse> CreateCheckoutAsync(List<ProductCartItem> items);
    Task<PaymentResponse> ProcessPaymentAsync(decimal amount, string currency, string customerId);
}

public class PaymentService : IPaymentService
{
    private readonly DodoPaymentsClient _client;
    private readonly ILogger<PaymentService> _logger;

    public PaymentService(DodoPaymentsClient client, ILogger<PaymentService> logger)
    {
        _client = client;
        _logger = logger;
    }

    public async Task<CheckoutSessionResponse> CreateCheckoutAsync(List<ProductCartItem> items)
    {
        var parameters = new CheckoutSessionCreateParams
        {
            ProductCart = items,
            ReturnUrl = "https://yourdomain.com/return"
        };

        return await _client.CheckoutSessions.Create(parameters);
    }

    public async Task<PaymentResponse> ProcessPaymentAsync(
        decimal amount,
        string currency,
        string customerId)
    {
        try
        {
            var parameters = new PaymentCreateParams
            {
                Amount = (long)(amount * 100), // Convert to cents
                Currency = currency,
                CustomerID = customerId
            };

            return await _client.Payments.Create(parameters);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to process payment");
            throw;
        }
    }
}
```

## User Secrets (Development)

For development, use user secrets to store API keys:

```bash theme={null}
dotnet user-secrets init
dotnet user-secrets set "DodoPayments:ApiKey" "your_api_key_here"
```

## Testing

Example unit test using xUnit:

```csharp theme={null}
using Xunit;
using DodoPayments.Client;
using DodoPayments.Client.Models.CheckoutSessions;

public class PaymentServiceTests
{
    private readonly DodoPaymentsClient _client;

    public PaymentServiceTests()
    {
        _client = new DodoPaymentsClient
        {
            BearerToken = "test_key"
        };
    }

    [Fact]
    public async Task CreateCheckout_ShouldReturnSession()
    {
        // Arrange
        var parameters = new CheckoutSessionCreateParams
        {
            ProductCart =
            [
                new()
                {
                    ProductID = "prod_test",
                    Quantity = 1
                }
            ]
        };

        // Act
        var session = await _client.CheckoutSessions.Create(parameters);

        // Assert
        Assert.NotNull(session);
        Assert.NotNull(session.SessionId);
    }
}
```

## Resources

<CardGroup>
  <Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/dodopayments-csharp">
    View source code and contribute
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/introduction">
    Complete API documentation
  </Card>

  <Card title="Discord Community" icon="discord" href="https://discord.gg/bYqAp4ayYh">
    Get help and connect with developers
  </Card>

  <Card title="Report Issues" icon="bug" href="https://github.com/dodopayments/dodopayments-csharp/issues">
    Report bugs or request features
  </Card>
</CardGroup>

## Support

Need help with the C# SDK?

* **Discord**: Join our [community server](https://discord.gg/bYqAp4ayYh) for real-time support
* **Email**: Contact us at [support@dodopayments.com](mailto:support@dodopayments.com)
* **GitHub**: Open an issue on the [repository](https://github.com/dodopayments/dodopayments-csharp)

## Contributing

Since the SDK is in beta, your feedback and contributions are especially valuable! Check the [contributing guidelines](https://github.com/dodopayments/dodopayments-csharp/blob/main/CONTRIBUTING.md) to get started.


# Go
Source: https://docs.dodopayments.com/developer-resources/sdks/go

Integrate Dodo Payments into your Go applications with an idiomatic, performant SDK

The Go SDK provides a clean and idiomatic Go interface for integrating Dodo Payments into your applications. It offers context support, strongly typed responses, middleware capabilities, and is safe for concurrent use.

## Installation

Install the SDK using Go modules:

```bash theme={null}
go get github.com/dodopayments/dodopayments-go
```

Or to pin to a specific version:

```bash theme={null}
go get -u 'github.com/dodopayments/dodopayments-go@v1.75.0'
```

<Info>
  The SDK requires Go 1.22 or later versions, leveraging modern Go features for optimal performance.
</Info>

## Quick Start

Initialize the client and create your first checkout session:

```go theme={null}
package main

import (
	"context"
	"fmt"
	"log"

	"github.com/dodopayments/dodopayments-go"
	"github.com/dodopayments/dodopayments-go/option"
)

func main() {
	client := dodopayments.NewClient(
		option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("DODO_PAYMENTS_API_KEY")
		option.WithEnvironmentTestMode(),          // defaults to option.WithEnvironmentLiveMode()
	)
	
	checkoutSessionResponse, err := client.CheckoutSessions.New(context.TODO(), dodopayments.CheckoutSessionNewParams{
		CheckoutSessionRequest: dodopayments.CheckoutSessionRequestParam{
			ProductCart: dodopayments.F([]dodopayments.CheckoutSessionRequestProductCartParam{{
				ProductID: dodopayments.F("product_id"),
				Quantity:  dodopayments.F(int64(1)),
			}}),
		},
	})
	if err != nil {
		panic(err.Error())
	}
	fmt.Printf("Session ID: %s\n", checkoutSessionResponse.SessionID)
}
```

<Warning>
  Always store your API keys securely using environment variables. Never hardcode them in your source code.
</Warning>

## Core Features

<CardGroup>
  <Card title="Context Support" icon="clock">
    Full support for context.Context for cancellation and timeouts
  </Card>

  <Card title="Strong Typing" icon="shield-check">
    Strongly typed requests and responses for compile-time safety
  </Card>

  <Card title="Middleware" icon="layer-group">
    Extensible middleware support for logging, metrics, and custom logic
  </Card>

  <Card title="Goroutine Safe" icon="bolt">
    Thread-safe client designed for concurrent operations
  </Card>
</CardGroup>

## Configuration

### Context and Timeouts

Leverage Go's context for timeouts and cancellation:

```go theme={null}
import (
	"context"
	"time"
	
	"github.com/dodopayments/dodopayments-go"
	"github.com/dodopayments/dodopayments-go/option"
)

// Create a context with timeout
ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
defer cancel()

payment, err := client.Payments.Create(ctx, dodopayments.PaymentCreateParams{
	Amount:     5000,
	Currency:   "USD",
	CustomerID: "cus_123",
})
if err != nil {
	if ctx.Err() == context.DeadlineExceeded {
		log.Println("Request timed out")
	} else {
		log.Fatal(err)
	}
}
```

### Retry Configuration

Configure automatic retry behavior:

```go theme={null}
// Configure default for all requests (default is 2)
client := dodopayments.NewClient(
	option.WithMaxRetries(0), // disable retries
)

// Override per-request
client.CheckoutSessions.New(
	context.TODO(),
	dodopayments.CheckoutSessionNewParams{
		CheckoutSessionRequest: dodopayments.CheckoutSessionRequestParam{
			ProductCart: dodopayments.F([]dodopayments.CheckoutSessionRequestProductCartParam{{
				ProductID: dodopayments.F("product_id"),
				Quantity:  dodopayments.F(int64(0)),
			}}),
		},
	},
	option.WithMaxRetries(5),
)
```

## Common Operations

### Create a Checkout Session

Generate a checkout session:

```go theme={null}
session, err := client.CheckoutSessions.New(ctx, dodopayments.CheckoutSessionNewParams{
	CheckoutSessionRequest: dodopayments.CheckoutSessionRequestParam{
		ProductCart: dodopayments.F([]dodopayments.CheckoutSessionRequestProductCartParam{{
			ProductID: dodopayments.F("prod_123"),
			Quantity:  dodopayments.F(int64(1)),
		}}),
		ReturnURL: dodopayments.F("https://yourdomain.com/return"),
	},
})
if err != nil {
	log.Fatal(err)
}

fmt.Printf("Checkout URL: %s\n", session.CheckoutURL)
```

### Manage Customers

Create and retrieve customer information:

```go theme={null}
// Create a customer
customer, err := client.Customers.New(ctx, dodopayments.CustomerNewParams{
	Email: dodopayments.F("customer@example.com"),
	Name:  dodopayments.F("John Doe"),
	Metadata: dodopayments.F(map[string]string{
		"user_id": "12345",
	}),
})
if err != nil {
	log.Fatal(err)
}

// Retrieve customer
customer, err = client.Customers.Get(ctx, "cus_123")
if err != nil {
	log.Fatal(err)
}

fmt.Printf("Customer: %s (%s)\n", customer.Name, customer.Email)
```

### Handle Subscriptions

Create and manage recurring subscriptions:

```go theme={null}
// Create a subscription
subscription, err := client.Subscriptions.New(ctx, dodopayments.SubscriptionNewParams{
	CustomerID: dodopayments.F("cus_123"),
	ProductID:  dodopayments.F("prod_456"),
	PriceID:    dodopayments.F("price_789"),
})
if err != nil {
	log.Fatal(err)
}

// Get usage history
usageHistory, err := client.Subscriptions.GetUsageHistory(
	ctx,
	subscription.ID,
	dodopayments.SubscriptionGetUsageHistoryParams{
		StartDate: dodopayments.F("2024-01-01T00:00:00Z"),
		EndDate:   dodopayments.F("2024-03-31T23:59:59Z"),
	},
)
if err != nil {
	log.Fatal(err)
}
```

## Usage-Based Billing

### Ingest Usage Events

Track custom events:

```go theme={null}
import "github.com/dodopayments/dodopayments-go"

response, err := client.UsageEvents.Ingest(ctx, dodopayments.UsageEventIngestParams{
	Events: dodopayments.F([]dodopayments.UsageEventIngestParamsEvent{{
		EventID:    dodopayments.F("api_call_12345"),
		CustomerID: dodopayments.F("cus_abc123"),
		EventName:  dodopayments.F("api_request"),
		Timestamp:  dodopayments.F("2024-01-15T10:30:00Z"),
		Metadata: dodopayments.F(map[string]string{
			"endpoint":     "/api/v1/users",
			"method":       "GET",
			"tokens_used":  "150",
		}),
	}}),
})
if err != nil {
	log.Fatal(err)
}
```

### List Usage Events

```go theme={null}
// List events with filters
params := dodopayments.UsageEventListParams{
	CustomerID: dodopayments.F("cus_abc123"),
	EventName:  dodopayments.F("api_request"),
}

events, err := client.UsageEvents.List(ctx, params)
if err != nil {
	log.Fatal(err)
}

for _, event := range events.Data {
	fmt.Printf("Event %s: %s at %s\n", event.EventID, event.EventName, event.Timestamp)
}
```

## Error Handling

Handle specific error types:

```go theme={null}
payment, err := client.Payments.Create(ctx, dodopayments.PaymentCreateParams{
	Amount:   5000,
	Currency: "USD",
})
if err != nil {
	if apiErr, ok := err.(*dodopayments.APIError); ok {
		fmt.Printf("API Error: %s\n", apiErr.Message)
		fmt.Printf("Status Code: %d\n", apiErr.StatusCode)
		fmt.Printf("Request ID: %s\n", apiErr.RequestID)
		
		// Handle specific error types
		switch apiErr.Type {
		case dodopayments.ErrorTypeAuthentication:
			log.Println("Authentication failed")
		case dodopayments.ErrorTypeInvalidRequest:
			log.Println("Invalid request parameters")
		case dodopayments.ErrorTypeRateLimit:
			log.Println("Rate limit exceeded")
		default:
			log.Printf("API error: %s\n", apiErr.Message)
		}
	} else {
		log.Fatal(err)
	}
}
```

## Middleware

Add custom middleware for logging or metrics:

```go theme={null}
func Logger(req *http.Request, next option.MiddlewareNext) (res *http.Response, err error) {
	// Before the request
	start := time.Now()
	log.Printf("Request: %s %s\n", req.Method, req.URL)

	// Forward the request to the next handler
	res, err = next(req)

	// After the request
	end := time.Now()
	log.Printf("Response: %d in %v\n", res.StatusCode, end.Sub(start))

	return res, err
}

client := dodopayments.NewClient(
	option.WithMiddleware(Logger),
)
```

## Concurrency

The client is safe for concurrent use:

```go theme={null}
package main

import (
	"context"
	"sync"
	"log"

	"github.com/dodopayments/dodopayments-go"
)

func main() {
	client := dodopayments.NewClient()
	
	var wg sync.WaitGroup
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func(idx int) {
			defer wg.Done()
			
			payment, err := client.Payments.Create(context.Background(), dodopayments.PaymentCreateParams{
				Amount:     1000,
				Currency:   "USD",
				CustomerID: "cus_123",
			})
			if err != nil {
				log.Printf("Failed to create payment %d: %v", idx, err)
				return
			}
			
			log.Printf("Created payment %d: %s", idx, payment.ID)
		}(i)
	}
	
	wg.Wait()
}
```

## Resources

<CardGroup>
  <Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/dodopayments-go">
    View source code and contribute
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/introduction">
    Complete API documentation
  </Card>

  <Card title="Discord Community" icon="discord" href="https://discord.gg/bYqAp4ayYh">
    Get help and connect with developers
  </Card>

  <Card title="Report Issues" icon="bug" href="https://github.com/dodopayments/dodopayments-go/issues">
    Report bugs or request features
  </Card>
</CardGroup>

## Support

Need help with the Go SDK?

* **Discord**: Join our [community server](https://discord.gg/bYqAp4ayYh) for real-time support
* **Email**: Contact us at [support@dodopayments.com](mailto:support@dodopayments.com)
* **GitHub**: Open an issue on the [repository](https://github.com/dodopayments/dodopayments-go)

## Contributing

We welcome contributions! Check the [contributing guidelines](https://github.com/dodopayments/dodopayments-go/blob/main/CONTRIBUTING.md) to get started.


# Java
Source: https://docs.dodopayments.com/developer-resources/sdks/java

Integrate Dodo Payments into your Java applications with a robust, type-safe SDK

The Java SDK provides convenient and ergonomic access to the Dodo Payments REST API for applications written in Java. It utilizes Java-specific features like Optional, Stream, and CompletableFuture for modern Java development.

## Installation

### Maven

Add the dependency to your `pom.xml`:

```xml pom.xml theme={null}
<dependency>
  <groupId>com.dodopayments.api</groupId>
  <artifactId>dodo-payments-java</artifactId>
  <version>1.75.1</version>
</dependency>
```

### Gradle

Add the dependency to your `build.gradle`:

```kotlin build.gradle.kts theme={null}
implementation("com.dodopayments.api:dodo-payments-java:1.75.1")
```

<Tip>
  Always use the latest SDK version to access the newest Dodo Payments features. Check [Maven Central](https://central.sonatype.com/artifact/com.dodopayments.api/dodo-payments-java) for the latest version.
</Tip>

<Info>
  The SDK supports Java 8 and all later versions, including Java 11, 17, and 21.
</Info>

## Quick Start

Initialize the client and create a checkout session:

```java theme={null}
import com.dodopayments.api.client.DodoPaymentsClient;
import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
import com.dodopayments.api.models.checkoutsessions.CheckoutSessionRequest;
import com.dodopayments.api.models.checkoutsessions.CheckoutSessionResponse;

// Configure using environment variables (DODO_PAYMENTS_API_KEY, DODO_PAYMENTS_BASE_URL)
// Or system properties (dodopayments.apiKey, dodopayments.baseUrl)
DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();

CheckoutSessionRequest params = CheckoutSessionRequest.builder()
    .addProductCart(CheckoutSessionRequest.ProductCart.builder()
        .productId("product_id")
        .quantity(1)
        .build())
    .build();
    
CheckoutSessionResponse checkoutSessionResponse = client.checkoutSessions().create(params);
System.out.println(checkoutSessionResponse.sessionId());
```

<Warning>
  Always store your API keys securely using environment variables, system properties, or a secure configuration management system. Never hardcode them in your source code.
</Warning>

## Core Features

<CardGroup>
  <Card title="Type Safety" icon="shield-check">
    Strongly typed API with compile-time safety
  </Card>

  <Card title="Thread-Safe" icon="bolt">
    Safe for concurrent use in multi-threaded applications
  </Card>

  <Card title="Builder Pattern" icon="layer-group">
    Intuitive builder pattern for constructing requests
  </Card>

  <Card title="Async Support" icon="arrows-rotate">
    CompletableFuture support for asynchronous operations
  </Card>
</CardGroup>

## Configuration

### Environment Variables

Configure using environment variables or system properties:

```bash .env theme={null}
DODO_PAYMENTS_API_KEY=your_api_key_here
DODO_PAYMENTS_BASE_URL=https://live.dodopayments.com
```

```java theme={null}
// Automatically reads from environment variables
DodoPaymentsClient client = DodoPaymentsOkHttpClient.fromEnv();
```

### Manual Configuration

Configure manually with all options:

```java theme={null}
import java.time.Duration;

DodoPaymentsClient client = DodoPaymentsOkHttpClient.builder()
    .bearerToken("your_api_key_here")
    .baseUrl("https://live.dodopayments.com")
    .maxRetries(4)
    .timeout(Duration.ofSeconds(30))
    .responseValidation(true)
    .build();
```

### Test Mode

Configure for test/sandbox environment:

```java theme={null}
DodoPaymentsClient testClient = DodoPaymentsOkHttpClient.builder()
    .fromEnv()
    .testMode()
    .build();
```

## Common Operations

### Create a Checkout Session

Generate a checkout session:

```java theme={null}
CheckoutSessionRequest params = CheckoutSessionRequest.builder()
    .addProductCart(CheckoutSessionRequest.ProductCart.builder()
        .productId("prod_123")
        .quantity(1)
        .build())
    .returnUrl("https://yourdomain.com/return")
    .build();

CheckoutSessionResponse session = client.checkoutSessions().create(params);
System.out.println("Checkout URL: " + session.url());
```

### Manage Customers

Create and retrieve customer information:

```java theme={null}
import com.dodopayments.api.models.customers.Customer;
import com.dodopayments.api.models.customers.CustomerCreateParams;

// Create a customer
CustomerCreateParams createParams = CustomerCreateParams.builder()
    .email("customer@example.com")
    .name("John Doe")
    .putMetadata("user_id", "12345")
    .build();

Customer customer = client.customers().create(createParams);

// Retrieve customer
Customer retrieved = client.customers().retrieve("cus_123");
System.out.println("Customer: " + retrieved.name() + " (" + retrieved.email() + ")");
```

### Handle Subscriptions

Create and manage recurring subscriptions:

```java theme={null}
import com.dodopayments.api.models.subscriptions.*;

// Create a subscription
SubscriptionNewParams subscriptionParams = SubscriptionNewParams.builder()
    .customerId("cus_123")
    .productId("prod_456")
    .priceId("price_789")
    .build();

Subscription subscription = client.subscriptions().create(subscriptionParams);

// Charge subscription
SubscriptionChargeParams chargeParams = SubscriptionChargeParams.builder()
    .amount(1000)
    .build();

SubscriptionChargeResponse chargeResponse = client.subscriptions()
    .charge(subscription.id(), chargeParams);
```

## Usage-Based Billing

### Configure Meters

Create and manage meters for tracking usage:

```java theme={null}
import com.dodopayments.api.models.meters.*;

// Create API calls meter
MeterCreateParams apiMeterParams = MeterCreateParams.builder()
    .name("API Requests")
    .eventName("api_request")
    .aggregation("count")
    .putMetadata("category", "api_usage")
    .build();

Meter apiMeter = client.meters().create(apiMeterParams);
System.out.println("Meter created: " + apiMeter.meterId());

// List all meters
client.meters().list()
    .autoPager()
    .forEach(m -> System.out.println("Meter: " + m.name() + " - " + m.aggregation()));
```

### Ingest Usage Events

Track custom events:

```java theme={null}
import com.dodopayments.api.models.usageevents.*;
import java.time.OffsetDateTime;

// Ingest single event
UsageEventIngestParams singleEventParams = UsageEventIngestParams.builder()
    .addEvent(UsageEventIngestParams.Event.builder()
        .eventId("api_call_" + System.currentTimeMillis())
        .customerId("cus_abc123")
        .eventName("api_request")
        .timestamp(OffsetDateTime.now())
        .putMetadata("endpoint", "/api/v1/users")
        .putMetadata("method", "GET")
        .putMetadata("tokens_used", "150")
        .build())
    .build();

UsageEventIngestResponse response = client.usageEvents().ingest(singleEventParams);
System.out.println("Processed: " + response.processedEvents());
```

### Batch Ingest Events

Ingest multiple events efficiently (max 1000 per request):

```java theme={null}
UsageEventIngestParams.Builder batchBuilder = UsageEventIngestParams.builder();

for (int i = 0; i < 100; i++) {
    batchBuilder.addEvent(UsageEventIngestParams.Event.builder()
        .eventId("batch_event_" + i + "_" + System.currentTimeMillis())
        .customerId("cus_abc123")
        .eventName("video_transcode")
        .timestamp(OffsetDateTime.now().minusMinutes(i))
        .putMetadata("video_id", "video_" + i)
        .putMetadata("duration_seconds", String.valueOf(120 + i))
        .build());
}

UsageEventIngestResponse batchResponse = client.usageEvents().ingest(batchBuilder.build());
System.out.println("Batch processed: " + batchResponse.processedEvents() + " events");
```

## Error Handling

Comprehensive error handling for different scenarios:

```java theme={null}
import com.dodopayments.api.errors.*;

try {
    Payment payment = client.payments().retrieve("pay_invalid");
} catch (NotFoundException e) {
    System.err.println("Payment not found: " + e.getMessage());
} catch (UnauthorizedException e) {
    System.err.println("Authentication failed: " + e.getMessage());
} catch (PermissionDeniedException e) {
    System.err.println("Permission denied: " + e.getMessage());
} catch (BadRequestException e) {
    System.err.println("Invalid request: " + e.getMessage());
} catch (UnprocessableEntityException e) {
    System.err.println("Validation error: " + e.getMessage());
} catch (RateLimitException e) {
    System.err.println("Rate limit exceeded: " + e.getMessage());
    // SDK automatically retries with backoff
} catch (InternalServerException e) {
    System.err.println("Server error: " + e.getMessage());
} catch (DodoPaymentsServiceException e) {
    System.err.println("API error: " + e.statusCode() + " - " + e.getMessage());
}
```

<Tip>
  The SDK automatically retries requests on connection errors, 408, 409, 429, and 5xx errors with exponential backoff.
</Tip>

## Async Operations

Use CompletableFuture for asynchronous operations:

```java theme={null}
import java.util.concurrent.CompletableFuture;

CompletableFuture<CheckoutSessionResponse> future = client.async()
    .checkoutSessions()
    .create(params);

// Handle response asynchronously
future.thenAccept(response -> {
    System.out.println("Session created: " + response.sessionId());
}).exceptionally(ex -> {
    System.err.println("Error: " + ex.getMessage());
    return null;
});
```

## Spring Boot Integration

### Configuration Class

```java theme={null}
import com.dodopayments.api.client.DodoPaymentsClient;
import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class DodoPaymentsConfig {
    
    @Value("${dodo.api.key}")
    private String apiKey;
    
    @Value("${dodo.environment:sandbox}")
    private String environment;
    
    @Bean
    public DodoPaymentsClient dodoPayments() {
        return DodoPaymentsOkHttpClient.builder()
            .bearerToken(apiKey)
            .baseUrl(environment.equals("live") 
                ? "https://live.dodopayments.com" 
                : "https://sandbox.dodopayments.com")
            .build();
    }
}
```

### Service Layer

```java theme={null}
import com.dodopayments.api.client.DodoPaymentsClient;
import com.dodopayments.api.models.checkoutsessions.*;
import org.springframework.stereotype.Service;

@Service
public class PaymentService {
    
    private final DodoPaymentsClient client;
    
    public PaymentService(DodoPaymentsClient client) {
        this.client = client;
    }
    
    public CheckoutSessionResponse createCheckout(List<CheckoutSessionRequest.ProductCart> items) {
        CheckoutSessionRequest params = CheckoutSessionRequest.builder()
            .productCart(items)
            .returnUrl("https://yourdomain.com/return")
            .build();
            
        return client.checkoutSessions().create(params);
    }
}
```

## Resources

<CardGroup>
  <Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/dodopayments-java">
    View source code and contribute
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/introduction">
    Complete API documentation
  </Card>

  <Card title="Discord Community" icon="discord" href="https://discord.gg/bYqAp4ayYh">
    Get help and connect with developers
  </Card>

  <Card title="Report Issues" icon="bug" href="https://github.com/dodopayments/dodopayments-java/issues">
    Report bugs or request features
  </Card>
</CardGroup>

## Support

Need help with the Java SDK?

* **Discord**: Join our [community server](https://discord.gg/bYqAp4ayYh) for real-time support
* **Email**: Contact us at [support@dodopayments.com](mailto:support@dodopayments.com)
* **GitHub**: Open an issue on the [repository](https://github.com/dodopayments/dodopayments-java)

## Contributing

We welcome contributions! Check the [contributing guidelines](https://github.com/dodopayments/dodopayments-java/blob/main/CONTRIBUTING.md) to get started.


# Kotlin
Source: https://docs.dodopayments.com/developer-resources/sdks/kotlin

Integrate Dodo Payments into your Kotlin applications with modern coroutines and null-safety

The Kotlin SDK provides convenient access to the Dodo Payments REST API from applications written in Kotlin. It features nullable values, Sequence, suspend functions, and other Kotlin-specific features for ergonomic use.

## Installation

### Gradle (Kotlin DSL)

Add the dependency to your `build.gradle.kts`:

```kotlin build.gradle.kts theme={null}
implementation("com.dodopayments.api:dodo-payments-kotlin:1.75.0")
```

### Maven

Add the dependency to your `pom.xml`:

```xml pom.xml theme={null}
<dependency>
  <groupId>com.dodopayments.api</groupId>
  <artifactId>dodo-payments-kotlin</artifactId>
  <version>1.75.0</version>
</dependency>
```

<Tip>
  Always use the latest SDK version to access the newest Dodo Payments features. Check [Maven Central](https://central.sonatype.com/artifact/com.dodopayments.api/dodo-payments-kotlin) for the latest version.
</Tip>

<Info>
  The SDK requires Java 8 or later and is compatible with both JVM and Android platforms.
</Info>

## Quick Start

Initialize the client and create a checkout session:

```kotlin theme={null}
import com.dodopayments.api.client.DodoPaymentsClient
import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClient
import com.dodopayments.api.models.checkoutsessions.CheckoutSessionRequest
import com.dodopayments.api.models.checkoutsessions.CheckoutSessionResponse

// Configure using environment variables (DODO_PAYMENTS_API_KEY, DODO_PAYMENTS_BASE_URL)
// Or system properties (dodopayments.apiKey, dodopayments.baseUrl)
val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()

val params: CheckoutSessionRequest = CheckoutSessionRequest.builder()
    .addProductCart(CheckoutSessionRequest.ProductCart.builder()
        .productId("product_id")
        .quantity(1)
        .build())
    .build()
    
val checkoutSessionResponse: CheckoutSessionResponse = client.checkoutSessions().create(params)
println(checkoutSessionResponse.sessionId())
```

<Warning>
  Always store your API keys securely using environment variables or encrypted configuration. Never commit them to version control.
</Warning>

## Core Features

<CardGroup>
  <Card title="Coroutines" icon="bolt">
    Full support for Kotlin coroutines for asynchronous operations
  </Card>

  <Card title="Null Safety" icon="shield-check">
    Leverage Kotlin's null safety for robust error handling
  </Card>

  <Card title="Extension Functions" icon="code">
    Idiomatic Kotlin extensions for enhanced functionality
  </Card>

  <Card title="Data Classes" icon="layer-group">
    Type-safe data classes with copy and destructuring support
  </Card>
</CardGroup>

## Configuration

### From Environment Variables

Initialize from environment variables or system properties:

```kotlin theme={null}
val client: DodoPaymentsClient = DodoPaymentsOkHttpClient.fromEnv()
```

### Manual Configuration

Configure manually with all options:

```kotlin theme={null}
import java.time.Duration

val client = DodoPaymentsOkHttpClient.builder()
    .bearerToken("your_api_key_here")
    .baseUrl("https://live.dodopayments.com")
    .maxRetries(3)
    .timeout(Duration.ofSeconds(30))
    .build()
```

### Test Mode

Configure for test/sandbox environment:

```kotlin theme={null}
val testClient = DodoPaymentsOkHttpClient.builder()
    .fromEnv()
    .testMode()
    .build()
```

### Timeouts and Retries

Configure globally or per-request:

```kotlin theme={null}
import com.dodopayments.api.core.RequestOptions

// Global configuration
val client = DodoPaymentsOkHttpClient.builder()
    .fromEnv()
    .timeout(Duration.ofSeconds(45))
    .maxRetries(3)
    .build()

// Per-request timeout override
val product = client.products().retrieve(
    "prod_123",
    RequestOptions.builder()
        .timeout(Duration.ofSeconds(10))
        .build()
)
```

## Common Operations

### Create a Checkout Session

Generate a checkout session:

```kotlin theme={null}
val params = CheckoutSessionRequest.builder()
    .addProductCart(CheckoutSessionRequest.ProductCart.builder()
        .productId("prod_123")
        .quantity(1)
        .build())
    .returnUrl("https://yourdomain.com/return")
    .build()

val session = client.checkoutSessions().create(params)
println("Checkout URL: ${session.url()}")
```

### Create a Product

Create products with detailed configuration:

```kotlin theme={null}
import com.dodopayments.api.models.products.Product
import com.dodopayments.api.models.products.ProductCreateParams
import com.dodopayments.api.models.misc.Currency
import com.dodopayments.api.models.misc.TaxCategory

val createParams = ProductCreateParams.builder()
    .name("Premium Subscription")
    .description("Monthly subscription with all features")
    .price(
        ProductCreateParams.RecurringPrice.builder()
            .currency(Currency.USD)
            .preTaxAmount(2999) // $29.99 in cents
            .paymentFrequencyInterval(ProductCreateParams.RecurringPrice.TimeInterval.MONTH)
            .paymentFrequencyCount(1)
            .build()
    )
    .taxCategory(TaxCategory.DIGITAL_GOODS)
    .build()

val product: Product = client.products().create(createParams)
println("Created product ID: ${product.productId()}")
```

### Activate License Key

Activate license keys for customers:

```kotlin theme={null}
import com.dodopayments.api.models.licenses.LicenseActivateParams
import com.dodopayments.api.models.licenses.LicenseActivateResponse

val activateParams = LicenseActivateParams.builder()
    .licenseKey("XXXX-XXXX-XXXX-XXXX")
    .instanceName("user-laptop-01")
    .build()

try {
    val activationResult: LicenseActivateResponse = client.licenses()
        .activate(activateParams)

    println("License activated successfully")
    println("Instance ID: ${activationResult.instanceId()}")
    println("Expires at: ${activationResult.expiresAt()}")
} catch (e: UnprocessableEntityException) {
    println("License activation failed: ${e.message}")
}
```

## Usage-Based Billing

### Record Usage Events

Track usage for meters:

```kotlin theme={null}
import com.dodopayments.api.models.usageevents.UsageEventCreateParams
import java.time.OffsetDateTime

val usageParams = UsageEventCreateParams.builder()
    .meterId("meter_123")
    .customerId("cust_456")
    .value(150)
    .timestamp(OffsetDateTime.now())
    .build()

client.usageEvents().create(usageParams)
println("Usage event recorded")
```

## Async Operations

### Async Client

Use the async client for coroutine-based operations:

```kotlin theme={null}
import com.dodopayments.api.client.DodoPaymentsClientAsync
import com.dodopayments.api.client.okhttp.DodoPaymentsOkHttpClientAsync
import kotlinx.coroutines.runBlocking

val asyncClient: DodoPaymentsClientAsync = DodoPaymentsOkHttpClientAsync.fromEnv()

runBlocking {
    val customer = asyncClient.customers().retrieve("cust_123")
    println("Customer email: ${customer.email()}")
}
```

## Error Handling

Handle errors with Kotlin's exception handling:

```kotlin theme={null}
import com.dodopayments.api.errors.*

try {
    val payment = client.payments().create(params)
    println("Success: ${payment.id()}")
} catch (e: AuthenticationException) {
    println("Authentication failed: ${e.message}")
} catch (e: InvalidRequestException) {
    println("Invalid request: ${e.message}")
    e.parameter?.let { println("Parameter: $it") }
} catch (e: RateLimitException) {
    println("Rate limit exceeded, retry after: ${e.retryAfter}")
} catch (e: DodoPaymentsServiceException) {
    println("API error: ${e.statusCode()} - ${e.message}")
}
```

### Functional Error Handling

Use `Result` for functional error handling:

```kotlin theme={null}
fun safeCreatePayment(client: DodoPaymentsClient): Result<Payment> = runCatching {
    client.payments().create(params)
}

// Usage
safeCreatePayment(client)
    .onSuccess { payment -> println("Created: ${payment.id()}") }
    .onFailure { error -> println("Error: ${error.message}") }
```

<Tip>
  Use Kotlin's `runCatching` for a more functional approach to error handling with Result types.
</Tip>

## Android Integration

Use with Android applications:

```kotlin theme={null}
import android.app.Application
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.dodopayments.api.client.DodoPaymentsClient
import kotlinx.coroutines.launch

class PaymentViewModel(application: Application) : ViewModel() {
    private val client = DodoPaymentsOkHttpClient.builder()
        .bearerToken(BuildConfig.DODO_API_KEY)
        .build()
    
    fun createCheckout(productId: String) {
        viewModelScope.launch {
            try {
                val session = client.async().checkoutSessions().create(params)
                // Open checkout URL in browser or WebView
                openUrl(session.url())
            } catch (e: Exception) {
                handleError(e)
            }
        }
    }
}
```

## Response Validation

Enable response validation:

```kotlin theme={null}
import com.dodopayments.api.core.RequestOptions

// Per-request validation
val product = client.products().retrieve(
    "prod_123",
    RequestOptions.builder()
        .responseValidation(true)
        .build()
)

// Or validate explicitly
val validatedProduct = product.validate()
```

## Advanced Features

### Proxy Configuration

Configure proxy settings:

```kotlin theme={null}
import java.net.InetSocketAddress
import java.net.Proxy

val client = DodoPaymentsOkHttpClient.builder()
    .fromEnv()
    .proxy(
        Proxy(
            Proxy.Type.HTTP,
            InetSocketAddress("proxy.example.com", 8080)
        )
    )
    .build()
```

### Temporary Configuration

Modify client configuration temporarily:

```kotlin theme={null}
val customClient = client.withOptions {
    it.baseUrl("https://example.com")
    it.maxRetries(5)
}
```

## Ktor Integration

Integrate with Ktor server applications:

```kotlin theme={null}
import io.ktor.server.application.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*

fun Application.configureRouting() {
    val client = DodoPaymentsOkHttpClient.builder()
        .bearerToken(environment.config.property("dodo.apiKey").getString())
        .build()
    
    routing {
        post("/create-checkout") {
            try {
                val request = call.receive<CheckoutRequest>()
                val session = client.checkoutSessions().create(params)
                call.respond(mapOf("checkout_url" to session.url()))
            } catch (e: DodoPaymentsServiceException) {
                call.respond(HttpStatusCode.BadRequest, mapOf("error" to e.message))
            }
        }
    }
}
```

## Resources

<CardGroup>
  <Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/dodopayments-kotlin">
    View source code and contribute
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/introduction">
    Complete API documentation
  </Card>

  <Card title="Discord Community" icon="discord" href="https://discord.gg/bYqAp4ayYh">
    Get help and connect with developers
  </Card>

  <Card title="Report Issues" icon="bug" href="https://github.com/dodopayments/dodopayments-kotlin/issues">
    Report bugs or request features
  </Card>
</CardGroup>

## Support

Need help with the Kotlin SDK?

* **Discord**: Join our [community server](https://discord.gg/bYqAp4ayYh) for real-time support
* **Email**: Contact us at [support@dodopayments.com](mailto:support@dodopayments.com)
* **GitHub**: Open an issue on the [repository](https://github.com/dodopayments/dodopayments-kotlin)

## Contributing

We welcome contributions! Check the [contributing guidelines](https://github.com/dodopayments/dodopayments-kotlin/blob/main/CONTRIBUTING.md) to get started.


# PHP
Source: https://docs.dodopayments.com/developer-resources/sdks/php

Integrate Dodo Payments into your PHP applications with a modern, PSR-4 compliant SDK

The PHP SDK provides a robust and flexible way to integrate Dodo Payments into your PHP applications. Built following modern PHP standards with PSR-4 autoloading, it offers extensive test coverage and detailed documentation.

<Note>
  The Dodo Payments PHP API Library is currently in **beta**. We're excited for
  you to experiment with it! Please share any suggestions, bug reports, or
  feature requests by [filing an
  issue](https://github.com/dodopayments/dodopayments-php/issues).
</Note>

## Installation

Install the SDK using Composer:

```bash theme={null}
composer require "dodopayments/client 5.3.0"
```

<Info>
  The SDK requires PHP 8.1.0 or higher and Composer for dependency management.
</Info>

## Quick Start

Initialize the client and create a checkout session:

```php theme={null}
<?php

use Dodopayments\Client;

$client = new Client(
  bearerToken: getenv('DODO_PAYMENTS_API_KEY') ?: 'My Bearer Token',
  environment: 'test_mode',
);

$checkoutSessionResponse = $client->checkoutSessions->create(
  productCart: [["productID" => "product_id", "quantity" => 1]]
);

var_dump($checkoutSessionResponse->session_id);
```

<Warning>
  Store your API keys securely using environment variables. Never expose them in
  your codebase or commit them to version control.
</Warning>

## Core Features

<CardGroup>
  <Card title="PSR-4 Compliant" icon="check">
    Follows PHP Standards Recommendations for modern PHP development
  </Card>

  <Card title="Modern PHP" icon="php">
    Built for PHP 8.1+ with type declarations and strict types
  </Card>

  <Card title="Extensive Testing" icon="vial">
    Comprehensive test coverage for reliability and stability
  </Card>

  <Card title="Exception Handling" icon="shield-check">
    Clear exception types for different error scenarios
  </Card>
</CardGroup>

## Value Objects

The SDK uses named parameters to specify optional arguments. You can initialize value objects using the static `with` constructor:

```php theme={null}
<?php

use Dodopayments\Customers\AttachExistingCustomer;

// Recommended: Use static 'with' constructor with named parameters
$customer = AttachExistingCustomer::with(customerID: "customer_id");
```

Builders are also available as an alternative pattern:

```php theme={null}
<?php

use Dodopayments\Customers\AttachExistingCustomer;

// Alternative: Use builder pattern
$customer = (new AttachExistingCustomer)->withCustomerID("customer_id");
```

## Configuration

### Retry Configuration

Certain errors are automatically retried 2 times by default with a short exponential backoff. The following errors trigger automatic retries:

* Connection errors (network connectivity problems)
* 408 Request Timeout
* 409 Conflict
* 429 Rate Limit
* 500+ Internal errors
* Timeouts

Configure retry behavior globally or per-request:

```php theme={null}
<?php

use Dodopayments\Client;
use Dodopayments\RequestOptions;

// Configure default for all requests (disable retries)
$client = new Client(maxRetries: 0);

// Or, configure per-request
$result = $client->checkoutSessions->create(
  productCart: [["productID" => "product_id", "quantity" => 1]],
  requestOptions: RequestOptions::with(maxRetries: 5),
);
```

## Common Operations

### Create a Checkout Session

Generate a checkout session:

```php theme={null}
$session = $client->checkoutSessions->create(
  productCart: [
    ["productID" => "prod_123", "quantity" => 1]
  ],
  returnUrl: "https://yourdomain.com/return"
);

header('Location: ' . $session->url);
```

### Manage Customers

Create and retrieve customer information:

```php theme={null}
// Create a customer
$customer = $client->customers->create(
  email: "customer@example.com",
  name: "John Doe",
  metadata: [
    "user_id" => "12345"
  ]
);

// Retrieve customer
$customer = $client->customers->retrieve("cus_123");
echo "Customer: {$customer->name} ({$customer->email})";
```

### Handle Subscriptions

Create and manage recurring subscriptions:

```php theme={null}
// Create a subscription
$subscription = $client->subscriptions->create(
  customerID: "cus_123",
  productID: "prod_456",
  priceID: "price_789"
);

// Cancel subscription
$client->subscriptions->cancel($subscription->id);
```

## Pagination

Work with paginated list responses:

```php theme={null}
$page = $client->payments->list();

var_dump($page);

// Fetch items from the current page
foreach ($page->getItems() as $item) {
  var_dump($item->brand_id);
}

// Auto-paginate: fetch items from all pages
foreach ($page->pagingEachItem() as $item) {
  var_dump($item->brand_id);
}
```

## Error Handling

When the library cannot connect to the API or receives a non-success status code (4xx or 5xx), a subclass of `APIException` is thrown:

```php theme={null}
<?php

use Dodopayments\Core\Exceptions\APIConnectionException;
use Dodopayments\Core\Exceptions\RateLimitException;
use Dodopayments\Core\Exceptions\APIStatusException;

try {
  $checkoutSessionResponse = $client->checkoutSessions->create(
    productCart: [["productID" => "product_id", "quantity" => 1]]
  );
} catch (APIConnectionException $e) {
  echo "The server could not be reached", PHP_EOL;
  var_dump($e->getPrevious());
} catch (RateLimitException $_) {
  echo "A 429 status code was received; we should back off a bit.", PHP_EOL;
} catch (APIStatusException $e) {
  echo "Another non-200-range status code was received", PHP_EOL;
  echo $e->getMessage();
}
```

### Error Types

| Cause            | Error Type                     |
| ---------------- | ------------------------------ |
| HTTP 400         | `BadRequestException`          |
| HTTP 401         | `AuthenticationException`      |
| HTTP 403         | `PermissionDeniedException`    |
| HTTP 404         | `NotFoundException`            |
| HTTP 409         | `ConflictException`            |
| HTTP 422         | `UnprocessableEntityException` |
| HTTP 429         | `RateLimitException`           |
| HTTP >= 500      | `InternalServerException`      |
| Other HTTP error | `APIStatusException`           |
| Timeout          | `APITimeoutException`          |
| Network error    | `APIConnectionException`       |

<Tip>
  Always wrap API calls in try-catch blocks to handle potential errors
  gracefully and provide meaningful feedback to users.
</Tip>

## Advanced Usage

### Undocumented Endpoints

Make requests to undocumented endpoints:

```php theme={null}
<?php

$response = $client->request(
  method: "post",
  path: '/undocumented/endpoint',
  query: ['dog' => 'woof'],
  headers: ['useful-header' => 'interesting-value'],
  body: ['hello' => 'world']
);
```

### Undocumented Parameters

Send undocumented parameters to any endpoint or read undocumented response properties:

```php theme={null}
<?php

use Dodopayments\RequestOptions;

$checkoutSessionResponse = $client->checkoutSessions->create(
  productCart: [["productID" => "product_id", "quantity" => 1]],
  requestOptions: RequestOptions::with(
    extraQueryParams: ["my_query_parameter" => "value"],
    extraBodyParams: ["my_body_parameter" => "value"],
    extraHeaders: ["my-header" => "value"],
  ),
);
```

<Note>
  The `extra*` parameters with the same name override documented parameters.
</Note>

## Framework Integration

### Laravel

Create a service for Laravel applications:

```php theme={null}
<?php

namespace App\Services;

use Dodopayments\Client;

class PaymentService
{
    protected $client;

    public function __construct()
    {
        $this->client = new Client(
            bearerToken: config('services.dodo.api_key')
        );
    }

    public function createCheckout(array $items)
    {
        return $this->client->checkoutSessions->create(
            productCart: $items,
            returnUrl: route('checkout.return')
        );
    }
}
```

Add configuration in `config/services.php`:

```php theme={null}
'dodo' => [
    'api_key' => env('DODO_API_KEY'),
    'environment' => env('DODO_ENVIRONMENT', 'sandbox')
],
```

### Symfony

Create a service in Symfony:

```php theme={null}
<?php

namespace App\Service;

use Dodopayments\Client;

class DodoPaymentService
{
    private Client $client;

    public function __construct(string $apiKey)
    {
        $this->client = new Client(bearerToken: $apiKey);
    }

    public function createPayment(int $amount, string $currency, string $customerId): object
    {
        return $this->client->payments->create(
            amount: $amount,
            currency: $currency,
            customerID: $customerId
        );
    }
}
```

Register in `config/services.yaml`:

```yaml theme={null}
services:
  App\Service\DodoPaymentService:
    arguments:
      $apiKey: "%env(DODO_API_KEY)%"
```

## Resources

<CardGroup>
  <Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/dodopayments-php">
    View source code and contribute
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/introduction">
    Complete API documentation
  </Card>

  <Card title="Discord Community" icon="discord" href="https://discord.gg/bYqAp4ayYh">
    Get help and connect with developers
  </Card>

  <Card title="Report Issues" icon="bug" href="https://github.com/dodopayments/dodopayments-php/issues">
    Report bugs or request features
  </Card>
</CardGroup>

## Support

Need help with the PHP SDK?

* **Discord**: Join our [community server](https://discord.gg/bYqAp4ayYh) for real-time support
* **Email**: Contact us at [support@dodopayments.com](mailto:support@dodopayments.com)
* **GitHub**: Open an issue on the [repository](https://github.com/dodopayments/dodopayments-php)

## Contributing

We welcome contributions! Check the [contributing guidelines](https://github.com/dodopayments/dodopayments-php/blob/main/CONTRIBUTING.md) to get started.


# Python
Source: https://docs.dodopayments.com/developer-resources/sdks/python

Integrate Dodo Payments into your Python applications with a Pythonic interface and modern async/await support

The Python SDK offers a Pythonic interface to the Dodo Payments API, providing both synchronous and asynchronous clients with type definitions for requests and responses. It supports Python 3.9+ and includes comprehensive test coverage.

## Installation

Install the SDK using pip:

```bash theme={null}
pip install dodopayments
```

For enhanced async performance with aiohttp:

```bash theme={null}
pip install dodopayments[aiohttp]
```

<Info>
  The SDK requires Python 3.9 or higher. We recommend using the latest stable version of Python for the best experience and security updates.
</Info>

## Quick Start

### Synchronous Client

```python theme={null}
import os
from dodopayments import DodoPayments

client = DodoPayments(
    bearer_token=os.environ.get("DODO_PAYMENTS_API_KEY"),  # This is the default and can be omitted
    environment="test_mode",  # defaults to "live_mode"
)

checkout_session_response = client.checkout_sessions.create(
    product_cart=[
        {
            "product_id": "product_id",
            "quantity": 1
        }
    ],
)
print(checkout_session_response.session_id)
```

### Asynchronous Client

```python theme={null}
import os
import asyncio
from dodopayments import AsyncDodoPayments

client = AsyncDodoPayments(
    bearer_token=os.environ.get("DODO_PAYMENTS_API_KEY"),
    environment="test_mode",
)


async def main() -> None:
    checkout_session_response = await client.checkout_sessions.create(
        product_cart=[
            {
                "product_id": "product_id",
                "quantity": 1,
            }
        ],
    )
    print(checkout_session_response.session_id)


asyncio.run(main())
```

<Warning>
  Always store your API keys securely using environment variables. Never commit them to version control.
</Warning>

## Core Features

<CardGroup>
  <Card title="Pythonic Interface" icon="code">
    Clean, idiomatic Python code that follows PEP 8 guidelines and Python conventions
  </Card>

  <Card title="Async/Await" icon="bolt">
    Full support for asynchronous operations with asyncio and optional aiohttp integration
  </Card>

  <Card title="Type Hints" icon="check">
    Complete type hints for better IDE support and type checking with mypy
  </Card>

  <Card title="Auto-Pagination" icon="arrows-rotate">
    Automatic pagination for list responses with simple iteration
  </Card>
</CardGroup>

## Configuration

### Environment Variables

Configure using environment variables:

```bash .env theme={null}
DODO_PAYMENTS_API_KEY=your_api_key_here
```

### Timeouts

Configure request timeouts globally or per-request:

```python theme={null}
import httpx
from dodopayments import DodoPayments

# Configure default for all requests (default is 1 minute)
client = DodoPayments(
    timeout=20.0,  # 20 seconds
)

# More granular control
client = DodoPayments(
    timeout=httpx.Timeout(60.0, read=5.0, write=10.0, connect=2.0),
)

# Override per-request
client.with_options(timeout=5.0).checkout_sessions.create(
    product_cart=[
        {
            "product_id": "product_id",
            "quantity": 1,
        }
    ],
)
```

### Retries

Configure automatic retry behavior:

```python theme={null}
from dodopayments import DodoPayments

# Configure default for all requests (default is 2)
client = DodoPayments(
    max_retries=0,  # disable retries
)

# Override per-request
client.with_options(max_retries=5).checkout_sessions.create(
    product_cart=[
        {
            "product_id": "product_id",
            "quantity": 1,
        }
    ],
)
```

## Common Operations

### Create a Checkout Session

Generate a checkout session:

```python theme={null}
session = client.checkout_sessions.create(
    product_cart=[
        {
            "product_id": "prod_123",
            "quantity": 1
        }
    ],
    return_url="https://yourdomain.com/return"
)

print(f"Checkout URL: {session.url}")
```

### Manage Customers

Create and retrieve customer information:

```python theme={null}
# Create a customer
customer = client.customers.create(
    email="customer@example.com",
    name="John Doe",
    metadata={
        "user_id": "12345"
    }
)

# Retrieve customer
customer = client.customers.retrieve("cus_123")
print(f"Customer: {customer.name} ({customer.email})")
```

### Handle Subscriptions

Create and manage recurring subscriptions:

```python theme={null}
# Create a subscription
subscription = client.subscriptions.create(
    customer_id="cus_123",
    product_id="prod_456",
    price_id="price_789"
)

# Retrieve usage history
usage_history = client.subscriptions.retrieve_usage_history(
    subscription.id,
    start_date="2024-01-01T00:00:00Z"
)
```

## Usage-Based Billing

### Ingest Usage Events

Track custom events for usage-based billing:

```python theme={null}
response = client.usage_events.ingest(
    events=[
        {
            "event_id": "api_call_12345",
            "customer_id": "cus_abc123",
            "event_name": "api_request",
            "timestamp": "2024-01-15T10:30:00Z",
            "metadata": {
                "endpoint": "/api/v1/users",
                "method": "GET",
                "tokens_used": "150"
            }
        }
    ]
)
```

### List and Retrieve Events

```python theme={null}
# Get a specific event
event = client.usage_events.retrieve("api_call_12345")

# List events with filtering
events = client.usage_events.list(
    customer_id="cus_abc123",
    event_name="api_request",
    limit=20
)

for event in events.data:
    print(f"Event: {event.event_id} at {event.timestamp}")
```

## Pagination

### Auto-Pagination

Iterate through all items automatically:

```python theme={null}
from dodopayments import DodoPayments

client = DodoPayments()
all_payments = []

# Automatically fetches more pages as needed
for payment in client.payments.list():
    all_payments.append(payment)
print(all_payments)
```

### Async Pagination

```python theme={null}
import asyncio
from dodopayments import AsyncDodoPayments

client = AsyncDodoPayments()


async def main() -> None:
    all_payments = []
    # Iterate through items across all pages
    async for payment in client.payments.list():
        all_payments.append(payment)
    print(all_payments)


asyncio.run(main())
```

### Manual Pagination

For more control over pagination:

```python theme={null}
# Access items from current page
first_page = client.payments.list()
for payment in first_page.items:
    print(payment.brand_id)

# Check for more pages
if first_page.has_next_page():
    next_page = first_page.get_next_page()
    print(f"Fetched {len(next_page.items)} more items")
```

## HTTP Client Configuration

Customize the underlying `httpx` client:

```python theme={null}
import httpx
from dodopayments import DodoPayments, DefaultHttpxClient

client = DodoPayments(
    base_url="http://my.test.server.example.com:8083",
    http_client=DefaultHttpxClient(
        proxy="http://my.test.proxy.example.com",
        transport=httpx.HTTPTransport(local_address="0.0.0.0"),
    ),
)
```

## Async with aiohttp

Use aiohttp for enhanced async performance:

```python theme={null}
import asyncio
from dodopayments import DefaultAioHttpClient
from dodopayments import AsyncDodoPayments


async def main() -> None:
    async with AsyncDodoPayments(
        bearer_token="My Bearer Token",
        http_client=DefaultAioHttpClient(),
    ) as client:
        checkout_session_response = await client.checkout_sessions.create(
            product_cart=[
                {
                    "product_id": "product_id",
                    "quantity": 1,
                }
            ],
        )
        print(checkout_session_response.session_id)


asyncio.run(main())
```

## Logging

Enable logging by setting the environment variable:

```bash theme={null}
export DODO_PAYMENTS_LOG=info
```

Or for debug-level logging:

```bash theme={null}
export DODO_PAYMENTS_LOG=debug
```

## Framework Integration

### FastAPI

```python theme={null}
from fastapi import FastAPI, HTTPException
from dodopayments import AsyncDodoPayments
from pydantic import BaseModel
import os

app = FastAPI()
dodo = AsyncDodoPayments(bearer_token=os.getenv("DODO_API_KEY"))

class CheckoutRequest(BaseModel):
    product_id: str
    quantity: int

@app.post("/create-checkout")
async def create_checkout(request: CheckoutRequest):
    try:
        session = await dodo.checkout_sessions.create(
            product_cart=[{
                "product_id": request.product_id,
                "quantity": request.quantity
            }],
            return_url="https://yourdomain.com/return"
        )
        return {"checkout_url": session.url}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
```

### Django

```python theme={null}
from django.http import JsonResponse
from django.views.decorators.http import require_POST
from django.views.decorators.csrf import csrf_exempt
from dodopayments import DodoPayments
import os
import json

client = DodoPayments(bearer_token=os.getenv("DODO_PAYMENTS_API_KEY"))

@csrf_exempt
@require_POST
def create_checkout(request):
    try:
        data = json.loads(request.body)
        session = client.checkout_sessions.create(
            product_cart=[{
                "product_id": data.get("product_id"),
                "quantity": data.get("quantity", 1)
            }],
            return_url="https://yourdomain.com/return"
        )
        return JsonResponse({
            "status": "success",
            "checkout_url": session.url,
            "session_id": session.session_id
        })
    except Exception as e:
        return JsonResponse({
            "status": "error",
            "message": str(e)
        }, status=400)
```

## Resources

<CardGroup>
  <Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/dodopayments-python">
    View source code and contribute
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/introduction">
    Complete API documentation
  </Card>

  <Card title="Discord Community" icon="discord" href="https://discord.gg/bYqAp4ayYh">
    Get help and connect with developers
  </Card>

  <Card title="Report Issues" icon="bug" href="https://github.com/dodopayments/dodopayments-python/issues">
    Report bugs or request features
  </Card>
</CardGroup>

## Support

Need help with the Python SDK?

* **Discord**: Join our [community server](https://discord.gg/bYqAp4ayYh) for real-time support
* **Email**: Contact us at [support@dodopayments.com](mailto:support@dodopayments.com)
* **GitHub**: Open an issue on the [repository](https://github.com/dodopayments/dodopayments-python)

## Contributing

We welcome contributions! Check the [contributing guidelines](https://github.com/dodopayments/dodopayments-python/blob/main/CONTRIBUTING.md) to get started.


# Ruby
Source: https://docs.dodopayments.com/developer-resources/sdks/ruby

Integrate Dodo Payments into your Ruby applications with an elegant, Ruby-native SDK

The Ruby SDK provides a simple and intuitive way to integrate Dodo Payments into your Ruby applications. It follows Ruby conventions and best practices, offering comprehensive error handling, pagination, and middleware support.

## Installation

Add the gem to your Gemfile:

```ruby Gemfile theme={null}
gem "dodopayments", "~> 1.75.0"
```

<Tip>
  Always use the latest SDK version to access the newest Dodo Payments features. Run `bundle update dodopayments` regularly to stay up to date.
</Tip>

Then run:

```bash theme={null}
bundle install
```

<Info>
  The SDK supports Ruby 3.2.0 and later versions, with comprehensive types, error handling, and retry mechanisms.
</Info>

## Quick Start

Initialize the client and create a checkout session:

```ruby theme={null}
require "bundler/setup"
require "dodopayments"

dodo_payments = Dodopayments::Client.new(
  bearer_token: ENV["DODO_PAYMENTS_API_KEY"], # This is the default and can be omitted
  environment: "test_mode" # defaults to "live_mode"
)

checkout_session_response = dodo_payments.checkout_sessions.create(
  product_cart: [{product_id: "product_id", quantity: 1}]
)

puts(checkout_session_response.session_id)
```

<Warning>
  Store your API keys securely using environment variables. Never commit them to version control or expose them in your code.
</Warning>

## Core Features

<CardGroup>
  <Card title="Ruby Conventions" icon="gem">
    Follows Ruby naming conventions and idiomatic patterns
  </Card>

  <Card title="Elegant Syntax" icon="code">
    Clean, readable API that feels natural to Ruby developers
  </Card>

  <Card title="Auto-Pagination" icon="arrows-rotate">
    Built-in auto-paging iterators for list responses
  </Card>

  <Card title="Type Safety" icon="shield-check">
    Optional Sorbet types for enhanced type safety
  </Card>
</CardGroup>

## Configuration

### Timeout Configuration

Configure request timeouts:

```ruby theme={null}
# Configure default for all requests (default is 60 seconds)
dodo_payments = Dodopayments::Client.new(
  timeout: nil # disable timeout
)

# Or, configure per-request
dodo_payments.checkout_sessions.create(
  product_cart: [{product_id: "product_id", quantity: 1}],
  request_options: {timeout: 5}
)
```

### Retry Configuration

Configure automatic retry behavior:

```ruby theme={null}
# Configure default for all requests (default is 2)
dodo_payments = Dodopayments::Client.new(
  max_retries: 0 # disable retries
)

# Or, configure per-request
dodo_payments.checkout_sessions.create(
  product_cart: [{product_id: "product_id", quantity: 1}],
  request_options: {max_retries: 5}
)
```

## Common Operations

### Create a Checkout Session

Generate a checkout session:

```ruby theme={null}
session = dodo_payments.checkout_sessions.create(
  product_cart: [
    {
      product_id: "prod_123",
      quantity: 1
    }
  ],
  return_url: "https://yourdomain.com/return"
)

# Redirect to checkout
redirect_to session.url
```

### Manage Customers

Create and retrieve customer information:

```ruby theme={null}
# Create a customer
customer = dodo_payments.customers.create(
  email: "customer@example.com",
  name: "John Doe",
  metadata: {
    user_id: "12345"
  }
)

# Retrieve customer
customer = dodo_payments.customers.retrieve("cus_123")
puts "Customer: #{customer.name} (#{customer.email})"
```

### Handle Subscriptions

Create and manage recurring subscriptions:

```ruby theme={null}
# Create a subscription
subscription = dodo_payments.subscriptions.create(
  customer_id: "cus_123",
  product_id: "prod_456",
  price_id: "price_789"
)

# Update subscription
updated = dodo_payments.subscriptions.update(
  subscription.id,
  metadata: { plan_type: "premium" }
)

# Cancel subscription
dodo_payments.subscriptions.cancel(subscription.id)
```

## Pagination

### Auto-Pagination

Automatically iterate through all pages:

```ruby theme={null}
page = dodo_payments.payments.list

# Fetch single item from page
payment = page.items[0]
puts(payment.brand_id)

# Automatically fetches more pages as needed
page.auto_paging_each do |payment|
  puts(payment.brand_id)
end
```

### Manual Pagination

For more control over pagination:

```ruby theme={null}
page = dodo_payments.payments.list

if page.next_page?
  new_page = page.next_page
  puts(new_page.items[0].brand_id)
end
```

## Error Handling

Handle various Dodo Payments API errors:

```ruby theme={null}
begin
  checkout_session = dodo_payments.checkout_sessions.create(
product_cart: [{product_id: "product_id", quantity: 1}]
  )
rescue Dodopayments::Errors::APIConnectionError => e
  puts("The server could not be reached")
  puts(e.cause)  # an underlying Exception, likely raised within `net/http`
rescue Dodopayments::Errors::RateLimitError => e
  puts("A 429 status code was received; we should back off a bit.")
rescue Dodopayments::Errors::APIStatusError => e
  puts("Another non-200-range status code was received")
  puts(e.status)
end
```

<Tip>
  Implement retry logic with exponential backoff for rate limit errors to ensure your application handles high-volume scenarios gracefully.
</Tip>

## Type Safety with Sorbet

Use Sorbet for type-safe request parameters:

```ruby theme={null}
# Type-safe using Sorbet RBI definitions
dodo_payments.checkout_sessions.create(
  product_cart: [
    Dodopayments::CheckoutSessionRequest::ProductCart.new(
      product_id: "product_id",
      quantity: 1
    )
  ]
)

# Hashes work, but are not typesafe
dodo_payments.checkout_sessions.create(
  product_cart: [{product_id: "product_id", quantity: 1}]
)

# You can also splat a full Params class
params = Dodopayments::CheckoutSessionCreateParams.new(
  product_cart: [
    Dodopayments::CheckoutSessionRequest::ProductCart.new(
      product_id: "product_id",
      quantity: 1
    )
  ]
)
dodo_payments.checkout_sessions.create(**params)
```

## Advanced Usage

### Undocumented Endpoints

Make requests to undocumented endpoints:

```ruby theme={null}
response = dodo_payments.request(
  method: :post,
  path: '/undocumented/endpoint',
  query: {"dog": "woof"},
  headers: {"useful-header": "interesting-value"},
  body: {"hello": "world"}
)
```

### Undocumented Parameters

Send undocumented parameters:

```ruby theme={null}
checkout_session_response = dodo_payments.checkout_sessions.create(
  product_cart: [{product_id: "product_id", quantity: 1}],
  request_options: {
    extra_query: {my_query_parameter: value},
    extra_body: {my_body_parameter: value},
    extra_headers: {"my-header": value}
  }
)

# Access undocumented response properties
puts(checkout_session_response[:my_undocumented_property])
```

## Rails Integration

### Create an Initializer

Create `config/initializers/dodo_payments.rb`:

```ruby theme={null}
require "dodopayments"

DODO_CLIENT = Dodopayments::Client.new(
  bearer_token: Rails.application.credentials.dodo_api_key,
  environment: Rails.env.production? ? "live_mode" : "test_mode"
)
```

### Service Object Pattern

Create a payment service:

```ruby theme={null}
# app/services/payment_service.rb
class PaymentService
  def initialize
    @client = DODO_CLIENT
  end

  def create_checkout(items)
    @client.checkout_sessions.create(
      product_cart: items,
      return_url: Rails.application.routes.url_helpers.checkout_return_url
    )
  end

  def process_payment(amount:, currency:, customer_id:)
    @client.payments.create(
      amount: amount,
      currency: currency,
      customer_id: customer_id
    )
  end
end
```

### Controller Integration

Use in your Rails controllers:

```ruby theme={null}
# app/controllers/checkouts_controller.rb
class CheckoutsController < ApplicationController
  def create
    service = PaymentService.new
    session = service.create_checkout(checkout_params[:items])
    
    redirect_to session.url, allow_other_host: true
  rescue Dodopayments::Errors::APIError => e
    flash[:error] = "Payment error: #{e.message}"
    redirect_to cart_path
  end

  private

  def checkout_params
    params.require(:checkout).permit(items: [:product_id, :quantity])
  end
end
```

## Sinatra Integration

Use with Sinatra applications:

```ruby theme={null}
require "sinatra"
require "dodopayments"

configure do
  set :dodo_client, Dodopayments::Client.new(
    bearer_token: ENV["DODO_API_KEY"]
  )
end

post "/create-checkout" do
  content_type :json
  
  begin
    session = settings.dodo_client.checkout_sessions.create(
      product_cart: JSON.parse(request.body.read)["items"],
      return_url: "#{request.base_url}/return"
    )
    
    { checkout_url: session.url }.to_json
  rescue Dodopayments::Errors::APIError => e
    status 400
    { error: e.message }.to_json
  end
end
```

## Resources

<CardGroup>
  <Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/dodopayments-ruby">
    View source code and contribute
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/introduction">
    Complete API documentation
  </Card>

  <Card title="Discord Community" icon="discord" href="https://discord.gg/bYqAp4ayYh">
    Get help and connect with developers
  </Card>

  <Card title="Report Issues" icon="bug" href="https://github.com/dodopayments/dodopayments-ruby/issues">
    Report bugs or request features
  </Card>
</CardGroup>

## Support

Need help with the Ruby SDK?

* **Discord**: Join our [community server](https://discord.gg/bYqAp4ayYh) for real-time support
* **Email**: Contact us at [support@dodopayments.com](mailto:support@dodopayments.com)
* **GitHub**: Open an issue on the [repository](https://github.com/dodopayments/dodopayments-ruby)

## Contributing

We welcome contributions! Check the [contributing guidelines](https://github.com/dodopayments/dodopayments-ruby/blob/main/CONTRIBUTING.md) to get started.


# TypeScript
Source: https://docs.dodopayments.com/developer-resources/sdks/typescript

Integrate Dodo Payments into your TypeScript and Node.js applications with type safety and modern async/await support

The TypeScript SDK provides convenient server-side access to the Dodo Payments REST API for TypeScript and JavaScript applications. It features comprehensive type definitions, error handling, retries, timeouts, and auto-pagination for seamless payment processing.

## Installation

Install the SDK using your package manager of choice:

<CodeGroup>
  ```bash npm theme={null}
  npm install dodopayments
  ```

  ```bash yarn theme={null}
  yarn add dodopayments
  ```

  ```bash pnpm theme={null}
  pnpm add dodopayments
  ```
</CodeGroup>

## Quick Start

Initialize the client with your API key and start processing payments:

```javascript theme={null}
import DodoPayments from 'dodopayments';

const client = new DodoPayments({
  bearerToken: process.env['DODO_PAYMENTS_API_KEY'], // This is the default and can be omitted
  environment: 'test_mode', // defaults to 'live_mode'
});

const checkoutSessionResponse = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'product_id', quantity: 1 }],
});

console.log(checkoutSessionResponse.session_id);
```

<Warning>
  Always store your API keys securely using environment variables. Never commit them to version control or expose them in client-side code.
</Warning>

## Core Features

<CardGroup>
  <Card title="TypeScript First" icon="shield-check">
    Full TypeScript support with comprehensive type definitions for all API endpoints
  </Card>

  <Card title="Auto-Pagination" icon="arrows-rotate">
    Automatic pagination for list responses makes working with large datasets effortless
  </Card>

  <Card title="Error Handling" icon="triangle-exclamation">
    Built-in error types with detailed messages for different failure scenarios
  </Card>

  <Card title="Smart Retries" icon="repeat">
    Configurable automatic retries with exponential backoff for transient errors
  </Card>
</CardGroup>

## Configuration

### Environment Variables

Set environment variables for secure configuration:

```bash .env theme={null}
DODO_PAYMENTS_API_KEY=your_api_key_here
```

### Timeout Configuration

Configure request timeouts globally or per-request:

```typescript theme={null}
// Configure default timeout for all requests (default is 1 minute)
const client = new DodoPayments({
  timeout: 20 * 1000, // 20 seconds
});

// Override per-request
await client.checkoutSessions.create(
  { product_cart: [{ product_id: 'product_id', quantity: 1 }] },
  { timeout: 5 * 1000 },
);
```

### Retry Configuration

Configure automatic retry behavior:

```javascript theme={null}
// Configure default for all requests (default is 2 retries)
const client = new DodoPayments({
  maxRetries: 0, // disable retries
});

// Override per-request
await client.checkoutSessions.create(
  { product_cart: [{ product_id: 'product_id', quantity: 1 }] },
  { maxRetries: 5 },
);
```

<Tip>
  The SDK automatically retries requests that fail due to network errors or server issues (5xx responses) with exponential backoff.
</Tip>

## Common Operations

### Create a Checkout Session

Generate a checkout session for collecting payment information:

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_123',
      quantity: 1
    }
  ],
  return_url: 'https://yourdomain.com/return'
});

console.log('Redirect to:', session.url);
```

### Manage Customers

Create and retrieve customer information:

```typescript theme={null}
// Create a customer
const customer = await client.customers.create({
  email: 'customer@example.com',
  name: 'John Doe',
  metadata: {
    user_id: '12345'
  }
});

// Retrieve customer
const retrieved = await client.customers.retrieve('cus_123');
console.log(`Customer: ${retrieved.name} (${retrieved.email})`);
```

### Handle Subscriptions

Create and manage recurring subscriptions:

```typescript theme={null}
// Create a subscription
const subscription = await client.subscriptions.create({
  customer_id: 'cus_123',
  product_id: 'prod_456',
  price_id: 'price_789'
});

// Retrieve subscription usage history
const usageHistory = await client.subscriptions.retrieveUsageHistory('sub_123', {
  start_date: '2024-01-01T00:00:00Z',
  end_date: '2024-03-31T23:59:59Z'
});
```

## Usage-Based Billing

### Ingest Usage Events

Track custom events for usage-based billing:

```typescript theme={null}
await client.usageEvents.ingest({
  events: [
    {
      event_id: 'api_call_12345',
      customer_id: 'cus_abc123',
      event_name: 'api_request',
      timestamp: '2024-01-15T10:30:00Z',
      metadata: {
        endpoint: '/api/v1/users',
        method: 'GET',
        tokens_used: '150'
      }
    }
  ]
});
```

<Info>
  Events must have unique `event_id` values for idempotency. Duplicate IDs within the same request are rejected, and subsequent requests with existing IDs are ignored.
</Info>

### Retrieve Usage Events

Fetch detailed information about usage events:

```typescript theme={null}
// Get a specific event
const event = await client.usageEvents.retrieve('api_call_12345');

// List events with filtering
const events = await client.usageEvents.list({
  customer_id: 'cus_abc123',
  event_name: 'api_request',
  start: '2024-01-14T10:30:00Z',
  end: '2024-01-15T10:30:00Z'
});
```

## Proxy Configuration

Configure proxy settings for different runtimes:

### Node.js (using undici)

```typescript theme={null}
import DodoPayments from 'dodopayments';
import * as undici from 'undici';

const proxyAgent = new undici.ProxyAgent('http://localhost:8888');
const client = new DodoPayments({
  fetchOptions: {
    dispatcher: proxyAgent,
  },
});
```

### Bun

```typescript theme={null}
import DodoPayments from 'dodopayments';

const client = new DodoPayments({
  fetchOptions: {
    proxy: 'http://localhost:8888',
  },
});
```

### Deno

```typescript theme={null}
import DodoPayments from 'npm:dodopayments';

const httpClient = Deno.createHttpClient({ proxy: { url: 'http://localhost:8888' } });
const client = new DodoPayments({
  fetchOptions: {
    client: httpClient,
  },
});
```

## Logging

Control log verbosity using environment variables or client options:

```typescript theme={null}
// Via client option
const client = new DodoPayments({
  logLevel: 'debug', // Show all log messages
});
```

```bash theme={null}
# Via environment variable
export DODO_PAYMENTS_LOG=debug
```

**Available log levels:**

* `'debug'` - Show debug messages, info, warnings, and errors
* `'info'` - Show info messages, warnings, and errors
* `'warn'` - Show warnings and errors (default)
* `'error'` - Show only errors
* `'off'` - Disable all logging

<Warning>
  At the debug level, all HTTP requests and responses are logged, including headers and bodies. Some authentication headers are redacted, but sensitive data in bodies may still be visible.
</Warning>

## Migration from Node.js SDK

If you're upgrading from the legacy Node.js SDK, the TypeScript SDK offers improved type safety and features:

<Card title="View Migration Guide" icon="arrow-right" href="https://github.com/dodopayments/dodopayments-typescript/blob/main/MIGRATION.md">
  Learn how to migrate from the Node.js SDK to the TypeScript SDK
</Card>

## Auto-Pagination

List methods in the DodoPayments API are paginated. You can use the `for await … of` syntax to iterate through items across all pages:

```typescript theme={null}
async function fetchAllPayments() {
  const allPayments = [];
  // Automatically fetches more pages as needed.
  for await (const paymentListResponse of client.payments.list()) {
    allPayments.push(paymentListResponse);
  }
  return allPayments;
}
```

Alternatively, you can request a single page at a time:

```typescript theme={null}
let page = await client.payments.list();
for (const paymentListResponse of page.items) {
  console.log(paymentListResponse);
}

// Convenience methods are provided for manually paginating:
while (page.hasNextPage()) {
  page = await page.getNextPage();
  // ...
}
```

## Requirements

The following runtimes are supported:

* Web browsers (Up-to-date Chrome, Firefox, Safari, Edge, and more)
* Node.js 20 LTS or later ([non-EOL](https://endoflife.date/nodejs)) versions
* Deno v1.28.0 or higher
* Bun 1.0 or later
* Cloudflare Workers
* Vercel Edge Runtime
* Jest 28 or greater with the `"node"` environment
* Nitro v2.6 or greater

TypeScript >= 4.9 is supported.

## Resources

<CardGroup>
  <Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/dodopayments-typescript">
    View source code and contribute
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/introduction">
    Complete API documentation
  </Card>

  <Card title="Discord Community" icon="discord" href="https://discord.gg/bYqAp4ayYh">
    Get help and connect with developers
  </Card>

  <Card title="Report Issues" icon="bug" href="https://github.com/dodopayments/dodopayments-typescript/issues">
    Report bugs or request features
  </Card>
</CardGroup>

## Support

Need help with the TypeScript SDK?

* **Discord**: Join our [community server](https://discord.gg/bYqAp4ayYh) for real-time support
* **Email**: Contact us at [support@dodopayments.com](mailto:support@dodopayments.com)
* **GitHub**: Open an issue on the [repository](https://github.com/dodopayments/dodopayments-typescript)

## Contributing

We welcome contributions! Check the [contributing guidelines](https://github.com/dodopayments/dodopayments-typescript/blob/main/CONTRIBUTING.md) to get started.


# Supabase Boilerplate
Source: https://docs.dodopayments.com/developer-resources/supabase-boilerplate

Use the official Next.js + Supabase + Dodo Payments subscription starter to ship subscriptions fast. Includes auth, database schema, webhook handler, and pricing UI.

<CardGroup>
  <Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/dodo-supabase-subscription-starter">
    Minimal Next.js + Supabase + Dodo Payments subscription boilerplate
  </Card>

  <Card title="Live Demo" icon="rocket" href="https://dodopayments-supabase-nextjs.vercel.app">
    Explore the deployed demo
  </Card>
</CardGroup>

## Overview

A production-ready boilerplate for subscriptions using Next.js 15, React 19, Supabase, Drizzle ORM, and Dodo Payments. It ships with Google OAuth, subscription checkout, webhook handling, database schema, and a basic dashboard.

<Info>
  If you need only route handlers for an existing app, see the dedicated adaptors: <a href="/developer-resources/nextjs-adaptor">Next.js Adaptor</a> and <a href="/developer-resources/express-adaptor">Express Adaptor</a>.
</Info>

## Prerequisites

* Node.js 18+ (or Bun 1.0+)
* Supabase project (URL, Anon key, Service role key, Database URL)
* Dodo Payments account (API key, Webhook secret)
* Google Cloud OAuth client (Client ID and Secret)

## Quickstart

<Steps>
  <Step title="Clone and install">
    ```bash theme={null}
    git clone https://github.com/dodopayments/dodo-supabase-subscription-starter.git
    cd dodo-supabase-subscription-starter
    # choose one
    bun install
    # or
    npm install
    # or
    pnpm install
    ```
  </Step>

  <Step title="Create Supabase project">
    Create a Supabase project and copy:

    * NEXT\_PUBLIC\_SUPABASE\_URL
    * NEXT\_PUBLIC\_SUPABASE\_ANON\_KEY
    * SUPABASE\_SERVICE\_ROLE\_KEY
    * DATABASE\_URL (Connection string)
  </Step>

  <Step title="Configure Google OAuth">
    Set the redirect URI to: `https://[your-project-ref].supabase.co/auth/v1/callback` in Google Cloud, then enable Google provider in Supabase Auth using your Client ID and Secret.
  </Step>

  <Step title="Configure Dodo Payments">
    Generate an API key and Webhook secret from the Dodo dashboard. Set environment to `test_mode` while developing.
  </Step>

  <Step title="Create .env.local">
    ```env theme={null}
    # Supabase
    NEXT_PUBLIC_SUPABASE_URL=https://your-project-ref.supabase.co
    NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
    SUPABASE_SERVICE_ROLE_KEY=your-service-role

    # Database
    DATABASE_URL=postgresql://postgres:[password]@db.[project-ref].supabase.co:5432/postgres

    # Dodo Payments
    DODO_PAYMENTS_API_KEY=your-dodo-api-key
    DODO_WEBHOOK_SECRET=your-webhook-secret
    DODO_PAYMENTS_ENVIRONMENT=test_mode
    ```

    <Warning>
      Never commit secrets. Use environment variables in deployment environments.
    </Warning>
  </Step>

  <Step title="Provision database schema">
    ```bash theme={null}
    bun run db:push
    # or
    npm run db:push
    # or
    pnpm run db:push
    ```

    <Check>
      Tables created: `users`, `subscriptions`, `payments`.
    </Check>
  </Step>

  <Step title="Deploy webhook function">
    ```bash theme={null}
    # login (one-time)
    bunx supabase login
    # or
    npx supabase login

    # deploy the edge function
    bun run deploy:webhook --project-ref [your-project-ref]
    # or
    npm run deploy:webhook -- --project-ref [your-project-ref]
    # or
    pnpm run deploy:webhook --project-ref [your-project-ref]
    ```

    ```bash cURL theme={null}
    curl -X POST \
      'https://[your-project-ref].supabase.co/functions/v1/dodo-webhook' \
      -H 'Content-Type: application/json' \
      -H 'Dodo-Signature: <signature>' \
      -d '{"type":"payment.succeeded","data":{}}'
    ```
  </Step>

  <Step title="Add webhook in Dodo Payments">
    Set endpoint URL to:

    ```text theme={null}
    https://[your-project-ref].supabase.co/functions/v1/dodo-webhook
    ```

    Select payment and subscription events.
  </Step>

  <Step title="Create products and features">
    In Dodo dashboard → Products → Create Product. Optionally add metadata:

    ```json theme={null}
    {
      "features": ["Feature 1", "Feature 2", "Feature 3"]
    }
    ```

    The pricing UI reads this `features` array and renders it dynamically.
  </Step>

  <Step title="Run the dev server">
    ```bash theme={null}
    bun run dev
    # or
    npm run dev
    # or
    pnpm run dev
    ```

    Open [http://localhost:3000](http://localhost:3000).
  </Step>
</Steps>

## What’s included

* Authentication via Supabase (Google OAuth configured)
* Subscription checkout via Dodo Payments
* Supabase Edge Function for webhooks (`dodo-webhook`)
* Drizzle ORM schema and migrations
* Dashboard with invoices, subscription status, and plan features

<Tip>
  Keep `DODO_PAYMENTS_ENVIRONMENT` as `test_mode` until you complete end-to-end tests.
</Tip>

## Key files and paths

<Tabs>
  <Tab title="Edge Function">
    ```text theme={null}
    supabase/functions/dodo-webhook/
      index.ts            # webhook handler verifying signatures
      deno.json           # permissions
    ```
  </Tab>

  <Tab title="Next.js routes">
    ```text theme={null}
    app/(marketing)/*     # landing + pricing UI
    app/(dashboard)/*     # protected pages
    app/api/*             # server actions & helpers
    ```
  </Tab>

  <Tab title="Database (Drizzle)">
    ```text theme={null}
    lib/db/schema.ts      # users, subscriptions, payments
    lib/db/index.ts       # client
    ```
  </Tab>
</Tabs>

## Environment variables

<AccordionGroup>
  <Accordion title="Supabase">
    ```env theme={null}
    NEXT_PUBLIC_SUPABASE_URL=
    NEXT_PUBLIC_SUPABASE_ANON_KEY=
    SUPABASE_SERVICE_ROLE_KEY=
    DATABASE_URL=
    ```
  </Accordion>

  <Accordion title="Dodo Payments">
    ```env theme={null}
    DODO_PAYMENTS_API_KEY=
    DODO_WEBHOOK_SECRET=
    DODO_PAYMENTS_ENVIRONMENT=test_mode|live_mode
    ```
  </Accordion>

  <Accordion title="Google OAuth">
    ```env theme={null}
    GOOGLE_CLIENT_ID=
    GOOGLE_CLIENT_SECRET=
    ```
  </Accordion>
</AccordionGroup>

## Verification and troubleshooting

<AccordionGroup>
  <Accordion title="Webhook signature invalid (401)">
    * Ensure `DODO_WEBHOOK_SECRET` matches the value from Dodo dashboard
    * Confirm you deployed the latest `dodo-webhook` function
    * Verify the header name is correct in your function (Dodo-Signature)
  </Accordion>

  <Accordion title="Database push fails">
    * Check `DATABASE_URL` syntax and Supabase network egress
    * Wait \~2–3 minutes after project creation before first push
  </Accordion>

  <Accordion title="OAuth redirect mismatch">
    * Redirect URI must be `https://[ref].supabase.co/auth/v1/callback`
    * Ensure the same in Google Cloud and Supabase Auth provider
  </Accordion>
</AccordionGroup>

<Check>
  You now have a working subscription SaaS scaffolded with Supabase and Dodo Payments.
</Check>

<Info>
  Original repository and detailed steps: <a href="https://github.com/dodopayments/dodo-supabase-subscription-starter">dodo-supabase-subscription-starter</a>.
</Info>


# SvelteKit Adaptor
Source: https://docs.dodopayments.com/developer-resources/sveltekit-adaptor

Learn how to integrate Dodo Payments with your SvelteKit App Router project using our SvelteKit Adaptor. Covers checkout, customer portal, webhooks, and secure environment setup.

<CardGroup>
  <Card title="Checkout Handler" icon="cart-shopping" href="#checkout-route-handler">
    Integrate Dodo Payments checkout into your SvelteKit app.
  </Card>

  <Card title="Customer Portal" icon="user" href="#customer-portal-route-handler">
    Allow customers to manage subscriptions and details.
  </Card>

  <Card title="Webhooks" icon="bell" href="#webhook-route-handler">
    Receive and process Dodo Payments webhook events.
  </Card>
</CardGroup>

## Installation

<Steps>
  <Step title="Install the package">
    Run the following command in your project root:

    ```bash theme={null}
    npm install @dodopayments/svelteKit
    ```
  </Step>

  <Step title="Set up environment variables">
    Create a <code>.env</code> file in your project root:

    ```env expandable theme={null}
    DODO_PAYMENTS_API_KEY=your-api-key
    DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
    DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode"
    DODO_PAYMENTS_RETURN_URL=https://yourdomain.com/checkout/success
    ```

    <Warning>
      Never commit your <code>.env</code> file or secrets to version control.
    </Warning>
  </Step>
</Steps>

## Route Handler Examples

<Info>
  All examples assume you are using the SvelteKit App Router.
</Info>

<Tabs>
  <Tab title="Checkout Handler">
    <Info>
      Use this handler to integrate Dodo Payments checkout into your SvelteKit app. Supports static (GET), dynamic (POST), and session (POST) payment flows.
    </Info>

    <CodeGroup>
      ```typescript SvelteKit Route Handler expandable theme={null}
      // src/routes/api/checkout/+server.ts
      import { Checkout } from "@dodopayments/sveltekit";
      import { DODO_PAYMENTS_API_KEY, DODO_PAYMENTS_RETURN_URL, DODO_PAYMENTS_ENVIRONMENT } from '$env/static/private';

      const checkoutGetHandler = Checkout({
          bearerToken: DODO_PAYMENTS_API_KEY,
          returnUrl: DODO_PAYMENTS_RETURN_URL,
          environment: DODO_PAYMENTS_ENVIRONMENT,
          type: "static",
      });

      const checkoutPostHandler = Checkout({
          bearerToken: DODO_PAYMENTS_API_KEY,
          returnUrl: DODO_PAYMENTS_RETURN_URL,
          environment: DODO_PAYMENTS_ENVIRONMENT,
          type: "session", // or "dynamic" for dynamic link
      });

      export const GET = checkoutGetHandler.GET;
      export const POST = checkoutPostHandler.POST;
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Static Checkout Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/checkout?productId=pdt_fqJhl7pxKWiLhwQR042rh' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Dynamic Checkout Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{ 
      "billing": {
        "city": "Texas",
        "country": "US",
        "state": "Texas",
        "street": "56, hhh",
        "zipcode": "560000"
      },
      "customer": {
        "email": "test@example.com",
        	"name": "test"
      },
      "metadata": {},
      "payment_link": true,
        "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
        "quantity": 1,
        "billing_currency": "USD",
        "discount_code": "IKHZ23M9GQ",
        "return_url": "https://example.com",
        "trial_period_days": 10
      }'
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Checkout Session Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{ 
      "product_cart": [
        {
          "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
          "quantity": 1
        }
      ],
      "customer": {
        "email": "test@example.com",
        "name": "test"
      },
      "return_url": "https://example.com/success"
      }'
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Customer Portal Handler">
    <Info>
      Use this handler to allow customers to manage their subscriptions and details via the Dodo Payments customer portal.
    </Info>

    <CodeGroup>
      ```typescript SvelteKit Route Handler expandable theme={null}
      // src/routes/api/checkout/+server.ts
      import { CustomerPortal } from "@dodopayments/sveltekit";
      import { DODO_PAYMENTS_API_KEY, DODO_PAYMENTS_RETURN_URL, DODO_PAYMENTS_ENVIRONMENT } from '$env/static/private';

      const customerPortalHandler = CustomerPortal({
          bearerToken: DODO_PAYMENTS_API_KEY,
          environment: DODO_PAYMENTS_ENVIRONMENT,
      });

      export const GET = customerPortalHandler.GET;
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Webhook Handler">
    <Info>
      Use this handler to receive and process Dodo Payments webhook events securely in your SvelteKit app.
    </Info>

    <CodeGroup>
      ```typescript SvelteKit Route Handler expandable theme={null}
      // src/routes/api/webhook/+server.ts
      import { Webhooks } from "@dodopayments/sveltekit";
      import { DODO_PAYMENTS_WEBHOOK_KEY } from '$env/static/private';

      export const POST = Webhooks({
          webhookKey: DODO_PAYMENTS_WEBHOOK_KEY,
          onPayload: async (payload) => {
              console.log(payload);
          }
      });
      ```
    </CodeGroup>
  </Tab>
</Tabs>

## Checkout Route Handler

<Info>
  Dodo Payments supports three types of payment flows for integrating payments into your website, this adaptor supports all types of payment flows.
</Info>

* **Static Payment Links:** Instantly shareable URLs for quick, no-code payment collection.
* **Dynamic Payment Links:** Programmatically generate payment links with custom details using the API or SDKs.
* **Checkout Sessions:** Create secure, customizable checkout experiences with pre-configured product carts and customer details.

<AccordionGroup>
  <Accordion title="Static Checkout (GET)">
    ### Supported Query Parameters

    <ParamField type="string">
      Product identifier (e.g., <code>?productId=pdt\_nZuwz45WAs64n3l07zpQR</code>).
    </ParamField>

    <ParamField type="integer">
      Quantity of the product.
    </ParamField>

    <ParamField type="string">
      Customer's full name.
    </ParamField>

    <ParamField type="string">
      Customer's first name.
    </ParamField>

    <ParamField type="string">
      Customer's last name.
    </ParamField>

    <ParamField type="string">
      Customer's email address.
    </ParamField>

    <ParamField type="string">
      Customer's country.
    </ParamField>

    <ParamField type="string">
      Customer's address line.
    </ParamField>

    <ParamField type="string">
      Customer's city.
    </ParamField>

    <ParamField type="string">
      Customer's state/province.
    </ParamField>

    <ParamField type="string">
      Customer's zip/postal code.
    </ParamField>

    <ParamField type="boolean">
      Disable full name field.
    </ParamField>

    <ParamField type="boolean">
      Disable first name field.
    </ParamField>

    <ParamField type="boolean">
      Disable last name field.
    </ParamField>

    <ParamField type="boolean">
      Disable email field.
    </ParamField>

    <ParamField type="boolean">
      Disable country field.
    </ParamField>

    <ParamField type="boolean">
      Disable address line field.
    </ParamField>

    <ParamField type="boolean">
      Disable city field.
    </ParamField>

    <ParamField type="boolean">
      Disable state field.
    </ParamField>

    <ParamField type="boolean">
      Disable zip code field.
    </ParamField>

    <ParamField type="string">
      Specify the payment currency (e.g., <code>USD</code>).
    </ParamField>

    <ParamField type="boolean">
      Show currency selector.
    </ParamField>

    <ParamField type="integer">
      Specify the payment amount (e.g., <code>1000</code> for \$10.00).
    </ParamField>

    <ParamField type="boolean">
      Show discount fields.
    </ParamField>

    <ParamField type="string">
      Any query parameter starting with <code>metadata\_</code> will be passed as metadata.
    </ParamField>

    <Warning>
      If <code>productId</code> is missing, the handler returns a 400 response. Invalid query parameters also result in a 400 response.
    </Warning>

    ### Response Format

    Static checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/"
    }
    ```
  </Accordion>

  <Accordion title="Dynamic Checkout (POST)">
    * Send parameters as a JSON body in a POST request.
    * Supports both one-time and recurring payments.
    * For a complete list of supported POST body fields, refer to:
      * [Request body for a One Time Payment Product](https://docs.dodopayments.com/api-reference/payments/post-payments)
      * [Request body for a Subscription Product](https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions)

    ### Response Format

    Dynamic checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/"
    }
    ```
  </Accordion>

  <Accordion title="Checkout Sessions (POST)">
    Checkout sessions provide a more secure, hosted checkout experience that handles the complete payment flow for both one-time purchases and subscriptions with full customization control.

    Refer to [Checkout Sessions Integration Guide](https://docs.dodopayments.com/developer-resources/checkout-session) for more details and a complete list of supported fields.

    ### Response Format

    Checkout sessions return a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/session/..."
    }
    ```
  </Accordion>
</AccordionGroup>

## Customer Portal Route Handler

The Customer Portal Route Handler enables you to seamlessly integrate the Dodo Payments customer portal into your SvelteKit application.

### Query Parameters

<ParamField type="string">
  The customer ID for the portal session (e.g., <code>?customer\_id=cus\_123</code>).
</ParamField>

<ParamField type="boolean">
  If set to <code>true</code>, sends an email to the customer with the portal link.
</ParamField>

<Warning>
  Returns 400 if <code>customer\_id</code> is missing.
</Warning>

## Webhook Route Handler

* **Method:** Only POST requests are supported. Other methods return 405.
* **Signature Verification:** Verifies the webhook signature using <code>webhookKey</code>. Returns 401 if verification fails.
* **Payload Validation:** Validated with Zod. Returns 400 for invalid payloads.
* **Error Handling:**
  * 401: Invalid signature
  * 400: Invalid payload
  * 500: Internal error during verification
* **Event Routing:** Calls the appropriate event handler based on the payload type.

### Supported Webhook Event Handlers

<CodeGroup>
  ```typescript Typescript expandable theme={null}
  onPayload?: (payload: WebhookPayload) => Promise<void>;
  onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onPaymentFailed?: (payload: WebhookPayload) => Promise<void>;
  onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>;
  onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>;
  onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onRefundFailed?: (payload: WebhookPayload) => Promise<void>;
  onDisputeOpened?: (payload: WebhookPayload) => Promise<void>;
  onDisputeExpired?: (payload: WebhookPayload) => Promise<void>;
  onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>;
  onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>;
  onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>;
  onDisputeWon?: (payload: WebhookPayload) => Promise<void>;
  onDisputeLost?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>;
  onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>;
  ```
</CodeGroup>

***

## Prompt for LLM

```

You are an expert SvelteKit developer assistant. Your task is to guide a user through integrating the @dodopayments/sveltekit adapter into their existing SvelteKit project.

The @dodopayments/sveltekit adapter provides route handlers for Dodo Payments' Checkout, Customer Portal, and Webhook functionalities, designed for the SvelteKit App Router.

First, install the necessary packages. Use the package manager appropriate for your project (npm, yarn, or bun) based on the presence of lock files (e.g., package-lock.json for npm, yarn.lock for yarn, bun.lockb for bun):

npm install @dodopayments/sveltekit

Here's how you should structure your response:

    Ask the user which functionalities they want to integrate.

"Which parts of the @dodopayments/sveltekit adapter would you like to integrate into your project? You can choose one or more of the following:

    Checkout Route Handler (for handling product checkouts)

    Customer Portal Route Handler (for managing customer subscriptions/details)

    Webhook Route Handler (for receiving Dodo Payments webhook events)

    All (integrate all three)"

    Based on the user's selection, provide detailed integration steps for each chosen functionality.

If Checkout Route Handler is selected:

Purpose: This handler manages different types of checkout flows. All checkout types (static, dynamic, and sessions) return JSON responses with checkout URLs for programmatic handling.
File Creation: Create a new file at app/checkout/route.ts in your SvelteKit project.

Code Snippet:

// src/routes/api/checkout/+server.ts
import { Checkout } from "@dodopayments/sveltekit";
import { DODO_PAYMENTS_API_KEY, DODO_PAYMENTS_RETURN_URL, DODO_PAYMENTS_ENVIRONMENT } from '$env/static/private';

const checkoutGetHandler = Checkout({
    bearerToken: DODO_PAYMENTS_API_KEY,
    returnUrl: DODO_PAYMENTS_RETURN_URL,
    environment: DODO_PAYMENTS_ENVIRONMENT,
    type: "static",
});

const checkoutPostHandler = Checkout({
    bearerToken: DODO_PAYMENTS_API_KEY,
    returnUrl: DODO_PAYMENTS_RETURN_URL,
    environment: DODO_PAYMENTS_ENVIRONMENT,
    type: "session", // or "dynamic" for dynamic link
});

export const GET = checkoutGetHandler.GET;
export const POST = checkoutPostHandler.POST;


Configuration & Usage:

    bearerToken: Your Dodo Payments API key. It's recommended to set this via the DODO_PAYMENTS_API_KEY environment variable.

    returnUrl: (Optional) The URL to redirect the user to after a successful checkout.

    environment: (Optional) Set to "test_mode" for testing, or omit/set to "live_mode" for production.

    type: (Optional) Set to "static" for GET/static checkout, "dynamic" for POST/dynamic checkout, or "session" for POST/checkout sessions. Defaults to "static".

Static Checkout (GET) Query Parameters:

    productId (required): Product identifier (e.g., ?productId=pdt_nZuwz45WAs64n3l07zpQR)

    quantity (optional): Quantity of the product

    Customer Fields (optional): fullName, firstName, lastName, email, country, addressLine, city, state, zipCode

    Disable Flags (optional, set to true to disable): disableFullName, disableFirstName, disableLastName, disableEmail, disableCountry, disableAddressLine, disableCity, disableState, disableZipCode

    Advanced Controls (optional): paymentCurrency, showCurrencySelector, paymentAmount, showDiscounts

    Metadata (optional): Any query parameter starting with metadata_ (e.g., ?metadata_userId=abc123)
    
    Returns: {"checkout_url": "https://checkout.dodopayments.com/..."}

Dynamic Checkout (POST) - Returns JSON with checkout_url: Parameters are sent as a JSON body. Supports both one-time and recurring payments. Returns: {"checkout_url": "https://checkout.dodopayments.com/..."}. For a complete list of supported POST body fields, refer to:

    Docs - One Time Payment Product: https://docs.dodopayments.com/api-reference/payments/post-payments

    Docs - Subscription Product: https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions


Checkout Sessions (POST) - (Recommended) A more customizable checkout experience. Returns JSON with checkout_url: Parameters are sent as a JSON body. Supports both one-time and recurring payments. Returns: {"checkout_url": "https://checkout.dodopayments.com/session/..."}. For a complete list of supported fields, refer to:

  Checkout Sessions Integration Guide: https://docs.dodopayments.com/developer-resources/checkout-session

Error Handling: If productId is missing or other parameters are invalid, the handler will return a 400 response.

If Customer Portal Route Handler is selected:

Purpose: This handler redirects authenticated users to their Dodo Payments customer portal.
File Creation: Create a new file at app/customer-portal/route.ts in your SvelteKit project.

Code Snippet:

// src/routes/api/checkout/+server.ts
import { CustomerPortal } from "@dodopayments/sveltekit";
import { DODO_PAYMENTS_API_KEY, DODO_PAYMENTS_RETURN_URL, DODO_PAYMENTS_ENVIRONMENT } from '$env/static/private';

const customerPortalHandler = CustomerPortal({
    bearerToken: DODO_PAYMENTS_API_KEY,
    environment: DODO_PAYMENTS_ENVIRONMENT,
});

export const GET = customerPortalHandler.GET;


Query Parameters:

    customer_id (required): The customer ID for the portal session (e.g., ?customer_id=cus_123)

    send_email (optional, boolean): If set to true, sends an email to the customer with the portal link.

    Returns 400 if customer_id is missing.

If Webhook Route Handler is selected:

Purpose: This handler processes incoming webhook events from Dodo Payments, allowing your application to react to events like successful payments, refunds, or subscription changes.
File Creation: Create a new file at app/api/webhook/dodo-payments/route.ts in your SvelteKit project.

Code Snippet:

// src/routes/api/webhook/+server.ts
import { Webhooks } from "@dodopayments/sveltekit";
import { DODO_PAYMENTS_WEBHOOK_KEY } from '$env/static/private';

export const POST = Webhooks({
    webhookKey: DODO_PAYMENTS_WEBHOOK_KEY,
    onPayload: async (payload) => {
        console.log(payload);
    }
});

Handler Details:

    Method: Only POST requests are supported. Other methods return 405.

    Signature Verification: The handler verifies the webhook signature using the webhookKey and returns 401 if verification fails.

    Payload Validation: The payload is validated with Zod. Returns 400 for invalid payloads.

Error Handling:

    401: Invalid signature

    400: Invalid payload

    500: Internal error during verification

Event Routing: Calls the appropriate event handler based on the payload type.

Supported Webhook Event Handlers:

    onPayload?: (payload: WebhookPayload) => Promise<void>

    onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>

    onPaymentFailed?: (payload: WebhookPayload) => Promise<void>

    onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>

    onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>

    onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>

    onRefundFailed?: (payload: WebhookPayload) => Promise<void>

    onDisputeOpened?: (payload: WebhookPayload) => Promise<void>

    onDisputeExpired?: (payload: WebhookPayload) => Promise<void>

    onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>

    onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>

    onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>

    onDisputeWon?: (payload: WebhookPayload) => Promise<void>

    onDisputeLost?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionPaused?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>

    onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>

    Environment Variable Setup:

To ensure the adapter functions correctly, you will need to manually set up the following environment variables in your SvelteKit project's deployment environment (e.g., Vercel, Netlify, AWS, etc.):

    DODO_PAYMENTS_API_KEY: Your Dodo Payments API Key (required for Checkout and Customer Portal).

    RETURN_URL: (Optional) The URL to redirect to after a successful checkout (for Checkout handler).

    DODO_PAYMENTS_WEBHOOK_SECRET: Your Dodo Payments Webhook Secret (required for Webhook handler).

Example .env file:

DODO_PAYMENTS_API_KEY=your-api-key
DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
DODO_PAYMENTS_RETURN_URL=your-return-url
DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode"

Usage in your code:

bearerToken: process.env.DODO_PAYMENTS_API_KEY
webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_KEY

Important: Never commit sensitive environment variables directly into your version control. Use environment variables for all sensitive information.

If the user needs assistance setting up environment variables for their specific deployment environment, ask them what platform they are using (e.g., Vercel, Netlify, AWS, etc.), and provide guidance. You can also add comments to their PR or chat depending on the context

```


# Tanstack Adaptor
Source: https://docs.dodopayments.com/developer-resources/tanstack-adaptor

Learn how to integrate Dodo Payments with your Tanstack App Router project using our Tanstack Adaptor. Covers checkout, customer portal, webhooks, and secure environment setup.

<CardGroup>
  <Card title="Checkout Handler" icon="cart-shopping" href="#checkout-route-handler">
    Integrate Dodo Payments checkout into your Tanstack app.
  </Card>

  <Card title="Customer Portal" icon="user" href="#customer-portal-route-handler">
    Allow customers to manage subscriptions and details.
  </Card>

  <Card title="Webhooks" icon="bell" href="#webhook-route-handler">
    Receive and process Dodo Payments webhook events.
  </Card>
</CardGroup>

## Installation

<Steps>
  <Step title="Install the package">
    Run the following command in your project root:

    ```bash theme={null}
    npm install @dodopayments/tanstack
    ```
  </Step>

  <Step title="Set up environment variables">
    Create a <code>.env</code> file in your project root:

    ```env expandable theme={null}
    DODO_PAYMENTS_API_KEY=your-api-key
    DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
    DODO_PAYMENTS_RETURN_URL=your-return-url
    DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode"
    ```

    <Warning>
      Never commit your <code>.env</code> file or secrets to version control.
    </Warning>
  </Step>
</Steps>

## Route Handler Examples

<Info>
  All examples assume you are using the Tanstack App Router.
</Info>

<Tabs>
  <Tab title="Checkout Handler">
    <Info>
      Use this handler to integrate Dodo Payments checkout into your Tanstack app. Supports static (GET), dynamic (POST), and session (POST) payment flows.
    </Info>

    <CodeGroup>
      ```typescript Tanstack Route Handler expandable theme={null}
      // src/routes/api/checkout.ts
      import { Checkout } from "@dodopayments/tanstack";
      import { createServerFileRoute } from "@tanstack/react-start/server";

      export const ServerRoute = createServerFileRoute("/api/checkout")
      .methods({
          GET: async ({ request }) => {
          return Checkout({
              bearerToken: process.env.DODO_PAYMENTS_API_KEY,
              returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
              environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
              type: "static", // optional, defaults to 'static'
          })(request)
          },
          POST: async ({ request }) => {
          return Checkout({
              bearerToken: process.env.DODO_PAYMENTS_API_KEY,
              returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
              environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
              type: "session", // or "dynamic" for dynamic link
          })(request)
          }
      })

      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Static Checkout Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/checkout?productId=pdt_fqJhl7pxKWiLhwQR042rh' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Dynamic Checkout Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "billing": {
        "city": "Texas",
        "country": "US",
        "state": "Texas",
        "street": "56, hhh",
        "zipcode": "560000"
      },
      "customer": {
        "email": "test@example.com",
        	"name": "test"
      },
      "metadata": {},
      "payment_link": true,
        "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
        "quantity": 1,
        "billing_currency": "USD",
        "discount_code": "IKHZ23M9GQ",
        "return_url": "https://example.com",
        "trial_period_days": 10
      }'
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Checkout Session Curl example expandable theme={null}
      curl --request POST \
      --url https://example.com/api/checkout \
      --header 'Content-Type: application/json' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test \
      --data '{
      "product_cart": [
        {
          "product_id": "pdt_QMDuvLkbVzCRWRQjLNcs",
          "quantity": 1
        }
      ],
      "customer": {
        "email": "test@example.com",
        "name": "test"
      },
      "return_url": "https://example.com/success"
      }'
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Customer Portal Handler">
    <Info>
      Use this handler to allow customers to manage their subscriptions and details via the Dodo Payments customer portal.
    </Info>

    <CodeGroup>
      ```typescript Tanstack Route Handler expandable theme={null}
      // src/routes/api/customer-portal.ts
      import { CustomerPortal } from "@dodopayments/tanstack";
      import { createServerFileRoute } from "@tanstack/react-start/server";

      export const ServerRoute = createServerFileRoute('/api/customer-portal')
      .methods({
          GET: async ({ request }) => {
          return CustomerPortal({
              bearerToken: process.env.DODO_PAYMENTS_API_KEY,
              environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
          })(request)
          }
      })
      ```
    </CodeGroup>

    <CodeGroup>
      ```curl Customer Portal Curl example expandable theme={null}
      curl --request GET \
      --url 'https://example.com/api/customer-portal?customer_id=cus_9VuW4K7O3GHwasENg31m&send_email=true' \
      --header 'User-Agent: insomnia/11.2.0' \
      --cookie mode=test
      ```
    </CodeGroup>
  </Tab>

  <Tab title="Webhook Handler">
    <Info>
      Use this handler to receive and process Dodo Payments webhook events securely in your Tanstack app.
    </Info>

    <CodeGroup>
      ```typescript Tanstack Route Handler expandable theme={null}
      // src/routes/api/webhook.ts
      import { Webhooks } from "@dodopayments/tanstack";
      import { createServerFileRoute } from "@tanstack/react-start/server";

      export const ServerRoute = createServerFileRoute('/api/webhook')
      .methods({
          POST: async ({ request }) => {
          return Webhooks({
              webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_KEY,
              onPayload: async (payload) => {
              console.log(payload)
              }
          })(request)
          }
      })
      ```
    </CodeGroup>
  </Tab>
</Tabs>

## Checkout Route Handler

<Info>
  Dodo Payments supports three types of payment flows for integrating payments into your website, this adaptor supports all types of payment flows.
</Info>

* **Static Payment Links:** Instantly shareable URLs for quick, no-code payment collection.
* **Dynamic Payment Links:** Programmatically generate payment links with custom details using the API or SDKs.
* **Checkout Sessions:** Create secure, customizable checkout experiences with pre-configured product carts and customer details.

<AccordionGroup>
  <Accordion title="Static Checkout (GET)">
    ### Supported Query Parameters

    <ParamField type="string">
      Product identifier (e.g., <code>?productId=pdt\_nZuwz45WAs64n3l07zpQR</code>).
    </ParamField>

    <ParamField type="integer">
      Quantity of the product.
    </ParamField>

    <ParamField type="string">
      Customer's full name.
    </ParamField>

    <ParamField type="string">
      Customer's first name.
    </ParamField>

    <ParamField type="string">
      Customer's last name.
    </ParamField>

    <ParamField type="string">
      Customer's email address.
    </ParamField>

    <ParamField type="string">
      Customer's country.
    </ParamField>

    <ParamField type="string">
      Customer's address line.
    </ParamField>

    <ParamField type="string">
      Customer's city.
    </ParamField>

    <ParamField type="string">
      Customer's state/province.
    </ParamField>

    <ParamField type="string">
      Customer's zip/postal code.
    </ParamField>

    <ParamField type="boolean">
      Disable full name field.
    </ParamField>

    <ParamField type="boolean">
      Disable first name field.
    </ParamField>

    <ParamField type="boolean">
      Disable last name field.
    </ParamField>

    <ParamField type="boolean">
      Disable email field.
    </ParamField>

    <ParamField type="boolean">
      Disable country field.
    </ParamField>

    <ParamField type="boolean">
      Disable address line field.
    </ParamField>

    <ParamField type="boolean">
      Disable city field.
    </ParamField>

    <ParamField type="boolean">
      Disable state field.
    </ParamField>

    <ParamField type="boolean">
      Disable zip code field.
    </ParamField>

    <ParamField type="string">
      Specify the payment currency (e.g., <code>USD</code>).
    </ParamField>

    <ParamField type="boolean">
      Show currency selector.
    </ParamField>

    <ParamField type="integer">
      Specify the payment amount (e.g., <code>1000</code> for \$10.00).
    </ParamField>

    <ParamField type="boolean">
      Show discount fields.
    </ParamField>

    <ParamField type="string">
      Any query parameter starting with <code>metadata\_</code> will be passed as metadata.
    </ParamField>

    <Warning>
      If <code>productId</code> is missing, the handler returns a 400 response. Invalid query parameters also result in a 400 response.
    </Warning>

    ### Response Format

    Static checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Dynamic Checkout (POST)">
    * Send parameters as a JSON body in a POST request.
    * Supports both one-time and recurring payments.
    * For a complete list of supported POST body fields, refer to:
      * [Request body for a One Time Payment Product](https://docs.dodopayments.com/api-reference/payments/post-payments)
      * [Request body for a Subscription Product](https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions)

    ### Response Format

    Dynamic checkout returns a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/..."
    }
    ```
  </Accordion>

  <Accordion title="Checkout Sessions (POST)">
    Checkout sessions provide a more secure, hosted checkout experience that handles the complete payment flow for both one-time purchases and subscriptions with full customization control.

    Refer to [Checkout Sessions Integration Guide](https://docs.dodopayments.com/developer-resources/checkout-session) for more details and a complete list of supported fields.

    ### Response Format

    Checkout sessions return a JSON response with the checkout URL:

    ```json theme={null}
    {
      "checkout_url": "https://checkout.dodopayments.com/session/..."
    }
    ```
  </Accordion>
</AccordionGroup>

## Customer Portal Route Handler

The Customer Portal Route Handler enables you to seamlessly integrate the Dodo Payments customer portal into your Tanstack application.

### Query Parameters

<ParamField type="string">
  The customer ID for the portal session (e.g., <code>?customer\_id=cus\_123</code>).
</ParamField>

<ParamField type="boolean">
  If set to <code>true</code>, sends an email to the customer with the portal link.
</ParamField>

<Warning>
  Returns 400 if <code>customer\_id</code> is missing.
</Warning>

## Webhook Route Handler

* **Method:** Only POST requests are supported. Other methods return 405.
* **Signature Verification:** Verifies the webhook signature using <code>webhookKey</code>. Returns 401 if verification fails.
* **Payload Validation:** Validated with Zod. Returns 400 for invalid payloads.
* **Error Handling:**
  * 401: Invalid signature
  * 400: Invalid payload
  * 500: Internal error during verification
* **Event Routing:** Calls the appropriate event handler based on the payload type.

### Supported Webhook Event Handlers

<CodeGroup>
  ```typescript Typescript expandable theme={null}
  onPayload?: (payload: WebhookPayload) => Promise<void>;
  onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onPaymentFailed?: (payload: WebhookPayload) => Promise<void>;
  onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>;
  onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>;
  onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>;
  onRefundFailed?: (payload: WebhookPayload) => Promise<void>;
  onDisputeOpened?: (payload: WebhookPayload) => Promise<void>;
  onDisputeExpired?: (payload: WebhookPayload) => Promise<void>;
  onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>;
  onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>;
  onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>;
  onDisputeWon?: (payload: WebhookPayload) => Promise<void>;
  onDisputeLost?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>;
  onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>;
  onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>;
  ```
</CodeGroup>

***

## Prompt for LLM

```

You are an expert Tanstack developer assistant. Your task is to guide a user through integrating the @dodopayments/tanstack adapter into their existing Tanstack project.

The @dodopayments/tanstack adapter provides route handlers for Dodo Payments' Checkout, Customer Portal, and Webhook functionalities, designed for the Tanstack App Router.

First, install the necessary packages. Use the package manager appropriate for your project (npm, yarn, or bun) based on the presence of lock files (e.g., package-lock.json for npm, yarn.lock for yarn, bun.lockb for bun):

npm install @dodopayments/tanstack

Here's how you should structure your response:

    Ask the user which functionalities they want to integrate.

"Which parts of the @dodopayments/tanstack adapter would you like to integrate into your project? You can choose one or more of the following:

    Checkout Route Handler (for handling product checkouts)

    Customer Portal Route Handler (for managing customer subscriptions/details)

    Webhook Route Handler (for receiving Dodo Payments webhook events)

    All (integrate all three)"

    Based on the user's selection, provide detailed integration steps for each chosen functionality.

If Checkout Route Handler is selected:

Purpose: This handler redirects users to the Dodo Payments checkout page.
File Creation: Create a new file at app/checkout/route.ts in your Tanstack project.

Code Snippet:

// src/routes/api/checkout.ts
import { Checkout } from "@dodopayments/tanstack";
import { createServerFileRoute } from "@tanstack/react-start/server";

export const ServerRoute = createServerFileRoute("/api/checkout")
  .methods({
    GET: async ({ request }) => {
      return Checkout({
        bearerToken: process.env.DODO_PAYMENTS_API_KEY,
        returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
        environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
        type: "static", // optional, defaults to 'static'
      })(request)
    },
    POST: async ({ request }) => {
      return Checkout({
        bearerToken: process.env.DODO_PAYMENTS_API_KEY,
        returnUrl: process.env.DODO_PAYMENTS_RETURN_URL,
        environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
        type: "session", // or "dynamic" for dynamic link
      })(request)
    }
  })


Configuration & Usage:

    bearerToken: Your Dodo Payments API key. It's recommended to set this via the DODO_PAYMENTS_API_KEY environment variable.

    returnUrl: (Optional) The URL to redirect the user to after a successful checkout.

    environment: (Optional) Set to "test_mode" for testing, or omit/set to "live_mode" for production.

    type: (Optional) Set to "static" for GET/static checkout, "dynamic" for POST/dynamic checkout, or "session" for POST/checkout sessions.

Static Checkout (GET) Query Parameters:

    productId (required): Product identifier (e.g., ?productId=pdt_nZuwz45WAs64n3l07zpQR)

    quantity (optional): Quantity of the product

    Customer Fields (optional): fullName, firstName, lastName, email, country, addressLine, city, state, zipCode

    Disable Flags (optional, set to true to disable): disableFullName, disableFirstName, disableLastName, disableEmail, disableCountry, disableAddressLine, disableCity, disableState, disableZipCode

    Advanced Controls (optional): paymentCurrency, showCurrencySelector, paymentAmount, showDiscounts

    Metadata (optional): Any query parameter starting with metadata_ (e.g., ?metadata_userId=abc123)

    Returns: {"checkout_url": "https://checkout.dodopayments.com/..."}

Dynamic Checkout (POST) - Returns JSON with checkout_url: Parameters are sent as a JSON body. Supports both one-time and recurring payments. Returns: {"checkout_url": "https://checkout.dodopayments.com/..."}. For a complete list of supported POST body fields, refer to:

    Docs - One Time Payment Product: https://docs.dodopayments.com/api-reference/payments/post-payments

    Docs - Subscription Product: https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions


Checkout Sessions (POST) - (Recommended) A more customizable checkout experience. Returns JSON with checkout_url: Parameters are sent as a JSON body. Supports both one-time and recurring payments. Returns: {"checkout_url": "https://checkout.dodopayments.com/session/..."}. For a complete list of supported fields, refer to:

  Checkout Sessions Integration Guide: https://docs.dodopayments.com/developer-resources/checkout-session

Error Handling: If productId is missing or other query parameters are invalid, the handler will return a 400 response.

If Customer Portal Route Handler is selected:

Purpose: This handler redirects authenticated users to their Dodo Payments customer portal.
File Creation: Create a new file at app/customer-portal/route.ts in your Tanstack project.

Code Snippet:

// src/routes/api/customer-portal.ts
import { CustomerPortal } from "@dodopayments/tanstack";
import { createServerFileRoute } from "@tanstack/react-start/server";

export const ServerRoute = createServerFileRoute('/api/customer-portal')
  .methods({
    GET: async ({ request }) => {
      return CustomerPortal({
        bearerToken: process.env.DODO_PAYMENTS_API_KEY,
        environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
      })(request)
    }
  })

Query Parameters:

    customer_id (required): The customer ID for the portal session (e.g., ?customer_id=cus_123)

    send_email (optional, boolean): If set to true, sends an email to the customer with the portal link.

    Returns 400 if customer_id is missing.

If Webhook Route Handler is selected:

Purpose: This handler processes incoming webhook events from Dodo Payments, allowing your application to react to events like successful payments, refunds, or subscription changes.
File Creation: Create a new file at app/api/webhook/dodo-payments/route.ts in your Tanstack project.

Code Snippet:

// src/routes/api/webhook.ts
import { Webhooks } from "@dodopayments/tanstack";
import { createServerFileRoute } from "@tanstack/react-start/server";

export const ServerRoute = createServerFileRoute('/api/webhook')
  .methods({
    POST: async ({ request }) => {
      return Webhooks({
        webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_KEY,
        onPayload: async (payload) => {
          console.log(payload)
        }
      })(request)
    }
  })

Handler Details:

    Method: Only POST requests are supported. Other methods return 405.

    Signature Verification: The handler verifies the webhook signature using the webhookKey and returns 401 if verification fails.

    Payload Validation: The payload is validated with Zod. Returns 400 for invalid payloads.

Error Handling:

    401: Invalid signature

    400: Invalid payload

    500: Internal error during verification

Event Routing: Calls the appropriate event handler based on the payload type.

Supported Webhook Event Handlers:

    onPayload?: (payload: WebhookPayload) => Promise<void>

    onPaymentSucceeded?: (payload: WebhookPayload) => Promise<void>

    onPaymentFailed?: (payload: WebhookPayload) => Promise<void>

    onPaymentProcessing?: (payload: WebhookPayload) => Promise<void>

    onPaymentCancelled?: (payload: WebhookPayload) => Promise<void>

    onRefundSucceeded?: (payload: WebhookPayload) => Promise<void>

    onRefundFailed?: (payload: WebhookPayload) => Promise<void>

    onDisputeOpened?: (payload: WebhookPayload) => Promise<void>

    onDisputeExpired?: (payload: WebhookPayload) => Promise<void>

    onDisputeAccepted?: (payload: WebhookPayload) => Promise<void>

    onDisputeCancelled?: (payload: WebhookPayload) => Promise<void>

    onDisputeChallenged?: (payload: WebhookPayload) => Promise<void>

    onDisputeWon?: (payload: WebhookPayload) => Promise<void>

    onDisputeLost?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionActive?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionOnHold?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionRenewed?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionPaused?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionPlanChanged?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionCancelled?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionFailed?: (payload: WebhookPayload) => Promise<void>

    onSubscriptionExpired?: (payload: WebhookPayload) => Promise<void>

    onLicenseKeyCreated?: (payload: WebhookPayload) => Promise<void>

    Environment Variable Setup:

To ensure the adapter functions correctly, you will need to manually set up the following environment variables in your Tanstack project's deployment environment (e.g., Vercel, Netlify, AWS, etc.):

    DODO_PAYMENTS_API_KEY: Your Dodo Payments API Key (required for Checkout and Customer Portal).

    RETURN_URL: (Optional) The URL to redirect to after a successful checkout (for Checkout handler).

    DODO_PAYMENTS_WEBHOOK_SECRET: Your Dodo Payments Webhook Secret (required for Webhook handler).

Example .env file:

DODO_PAYMENTS_API_KEY=your-api-key
DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret
DODO_PAYMENTS_RETURN_URL=your-return-url
DODO_PAYMENTS_ENVIRONMENT="test_mode" or "live_mode"

Usage in your code:

bearerToken: process.env.DODO_PAYMENTS_API_KEY
webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_KEY

Important: Never commit sensitive environment variables directly into your version control. Use environment variables for all sensitive information.

If the user needs assistance setting up environment variables for their specific deployment environment, ask them what platform they are using (e.g., Vercel, Netlify, AWS, etc.), and provide guidance. You can also add comments to their PR or chat depending on the context

```


# Webhooks
Source: https://docs.dodopayments.com/developer-resources/webhooks

Receive real-time notifications when events occur in Dodo Payments. Automate workflows and keep your systems synchronized with instant event delivery.

<Frame>
  <img alt="Webhook Cover Image" />
</Frame>

Webhooks provide real-time notifications when specific events occur in your Dodo Payments account. Use webhooks to automate workflows, update your database, send notifications, and keep your systems synchronized.

<Info>
  Our webhook implementation follows the [Standard Webhooks](https://standardwebhooks.com/) specification, ensuring compatibility with industry best practices and existing webhook libraries.
</Info>

## Key Features

<CardGroup>
  <Card title="Real-time Delivery" icon="bolt">
    Receive instant notifications when events occur
  </Card>

  <Card title="Secure by Default" icon="shield-check">
    HMAC SHA256 signature verification included
  </Card>

  <Card title="Automatic Retries" icon="rotate">
    Built-in retry logic with exponential backoff
  </Card>

  <Card title="Event Filtering" icon="filter">
    Subscribe only to events you need
  </Card>
</CardGroup>

## Getting Started

<Steps>
  <Step title="Access Webhook Settings">
    Navigate to the DodoPayments Dashboard and go to `Settings > Webhooks`.
  </Step>

  <Step title="Create Webhook Endpoint">
    Click on `Add Webhook` to create a new webhook endpoint.

    <Frame>
      <img alt="Add Webhook" />
    </Frame>
  </Step>

  <Step title="Add Endpoint URL">
    Enter the URL where you want to receive webhook events.
  </Step>

  <Step title="Select Events to Receive">
    Choose the specific events your webhook endpoint should listen for by selecting them from the event list.

    <Tip>
      Only selected events will trigger webhooks to your endpoint, helping you avoid unnecessary traffic and processing.
    </Tip>
  </Step>

  <Step title="Get Secret Key">
    Obtain your webhook `Secret Key` from the settings page. You'll use this to verify the authenticity of received webhooks.

    <Warning>
      Keep your webhook secret key secure and never expose it in client-side code or public repositories.
    </Warning>
  </Step>

  <Step title="Rotate Secret (Optional)">
    If needed, you can rotate your webhook secret for enhanced security. Click the **Rotate Secret** button in your webhook settings.

    <Warning>
      Rotating the secret will **expire it** and **replace it** with a new one. The old secret will only be valid for the next 24 hours. Afterward, trying to verify with the old secret will fail.
    </Warning>

    <Info>
      Use secret rotation periodically or immediately if you suspect your current secret has been compromised.
    </Info>
  </Step>
</Steps>

## Configuring Subscribed Events

You can configure which specific events they want to receive for each webhook endpoint.

### Accessing Event Configuration

<Steps>
  <Step title="Navigate to Webhook Details">
    Go to your Dodo Payments Dashboard and navigate to `Settings > Webhooks`.
  </Step>

  <Step title="Select Your Endpoint">
    Click on the webhook endpoint you want to configure.
  </Step>

  <Step title="Open Event Settings">
    In the webhook details page, you'll see a "Subscribed events" section. Click the **Edit** button to modify your event subscriptions.
  </Step>
</Steps>

### Managing Event Subscriptions

<Steps>
  <Step title="View Available Events">
    The interface displays all available webhook events organized in a hierarchical structure. Events are grouped by category (e.g., `dispute`, `payment`, `subscription`).
  </Step>

  <Step title="Search and Filter">
    Use the search bar to quickly find specific events by typing event names or keywords.
  </Step>

  <Step title="Select Events">
    Check the boxes next to the events you want to receive. You can:

    * Select individual sub-events (e.g., `dispute.accepted`, `dispute.challenged`)
    * Select parent events to receive all related sub-events
    * Mix and match specific events based on your needs
  </Step>

  <Step title="Review Event Details">
    Hover over the information icon (ⓘ) next to each event to see a description of when that event is triggered.
  </Step>

  <Step title="Save Configuration">
    Click **Save** to apply your changes, or **Cancel** to discard modifications.
  </Step>
</Steps>

<Warning>
  If you deselect all events, your webhook endpoint will not receive any notifications. Make sure to select at least the events your application needs to function properly.
</Warning>

## Webhook Delivery

### Timeouts

Webhooks have a **15-second timeout window** for both connection and read operations. Ensure your endpoint responds quickly to avoid timeouts.

<Tip>
  Process webhooks asynchronously by acknowledging receipt immediately with a `200` status code, then handling the actual processing in the background.
</Tip>

### Automatic Retries

If a webhook delivery fails, Dodo Payments automatically retries with exponential backoff to prevent overwhelming your system.

| Attempt | Delay       | Description                                                  |
| ------- | ----------- | ------------------------------------------------------------ |
| 1       | Immediately | First retry happens right away                               |
| 2       | 5 seconds   | Second attempt after short delay                             |
| 3       | 5 minutes   | Third attempt with increased backoff                         |
| 4       | 30 minutes  | Fourth attempt continuing backoff                            |
| 5       | 2 hours     | Fifth attempt with extended delay                            |
| 6       | 5 hours     | Sixth attempt with longer delay                              |
| 7       | 10 hours    | Seventh attempt with maximum delay                           |
| 8       | 10 hours    | **Final attempt** - webhook marked as failed if unsuccessful |

<Info>
  **Maximum of 8 retry attempts** per webhook event. For example, if a webhook fails three times before succeeding, the total delivery time is approximately 35 minutes and 5 seconds from the first attempt.
</Info>

<Tip>
  Use the Dodo Payments dashboard to manually retry individual messages or bulk recover all failed messages at any time.
</Tip>

### Idempotency

Each webhook event includes a unique `webhook-id` header. Use this identifier to implement idempotency and prevent duplicate processing.

```javascript theme={null}
// Example: Storing webhook IDs to prevent duplicate processing
const processedWebhooks = new Set();

app.post('/webhook', (req, res) => {
  const webhookId = req.headers['webhook-id'];
  
  if (processedWebhooks.has(webhookId)) {
    return res.status(200).json({ received: true });
  }
  
  processedWebhooks.add(webhookId);
  // Process the webhook...
});
```

<Warning>
  Always implement idempotency checks. Due to retries, you may receive the same event multiple times.
</Warning>

### Event Ordering

Webhook events may arrive out of order due to retries or network conditions. Design your system to handle events in any sequence.

<Info>
  You will receive the **latest payload at the time of delivery**, regardless of when the webhook event was originally emitted.
</Info>

## Securing Webhooks

To ensure the security of your webhooks, always validate the payloads and use HTTPS.

### Verifying Signatures

Each webhook request includes a `webhook-signature` header, an HMAC SHA256 signature of the webhook payload and timestamp, signed with your secret key.

#### SDK verification (recommended)

All official SDKs include built‑in helpers to securely validate and parse incoming webhooks. Two methods are available:

* `unwrap()`: Verifies signatures using your webhook secret key
* `unsafe_unwrap()`: Parses payloads without verification

<Tip>
  Provide your webhook secret via `DODO_PAYMENTS_WEBHOOK_KEY` when initializing the Dodo Payments client.
</Tip>

<CodeGroup>
  ```typescript TypeScript/Node.js theme={null}
  import DodoPayments from 'dodopayments';
  import express from 'express';

  const app = express();
  app.use(express.raw({ type: 'application/json' }));

  const client = new DodoPayments({
    bearerToken: process.env.DODO_PAYMENTS_API_KEY,
    environment: process.env.DODO_PAYMENTS_ENVIRONMENT,
    webhookKey: process.env.DODO_PAYMENTS_WEBHOOK_KEY,
  });

  app.post('/webhook', async (req, res) => {
    try {
      const unwrapped = client.webhooks.unwrap(req.body.toString(), {
        headers: {
          'webhook-id': req.headers['webhook-id'] as string,
          'webhook-signature': req.headers['webhook-signature'] as string,
          'webhook-timestamp': req.headers['webhook-timestamp'] as string,
        },
      });
      res.json({ received: true });
    } catch (error) {
      res.status(401).json({ error: 'Invalid signature' });
    }
  });
  ```

  ```python Python theme={null}
  from fastapi import FastAPI, Request, HTTPException
  from dodopayments import DodoPayments
  import os

  app = FastAPI()
  client = DodoPayments(
      bearer_token=os.getenv("DODO_PAYMENTS_API_KEY"),
      environment=os.getenv("DODO_PAYMENTS_ENVIRONMENT"),
      webhook_key=os.getenv("DODO_PAYMENTS_WEBHOOK_KEY"),
  )

  @app.post("/webhook")
  async def handle_webhook(request: Request):
      try:
          unwrapped = client.webhooks.unwrap(
              await request.body(),
              headers={
                  "webhook-id": request.headers.get("webhook-id", ""),
                  "webhook-signature": request.headers.get("webhook-signature", ""),
                  "webhook-timestamp": request.headers.get("webhook-timestamp", ""),
              },
          )
          return {"received": True}
      except Exception:
          raise HTTPException(status_code=401, detail="Invalid signature")
  ```

  ```go Go theme={null}
  import (
  	"context"
  	"io"
  	"net/http"
  	"os"
  	"github.com/dodopayments/dodopayments-go"
  	"github.com/dodopayments/dodopayments-go/option"
  )

  func webhookHandler(w http.ResponseWriter, r *http.Request) {
  	client := dodopayments.NewClient(
  		option.WithBearerToken(os.Getenv("DODO_PAYMENTS_API_KEY")),
  		option.WithEnvironment(os.Getenv("DODO_PAYMENTS_ENVIRONMENT")),
  		option.WithWebhookKey(os.Getenv("DODO_PAYMENTS_WEBHOOK_KEY")),
  	)
  	rawBody, _ := io.ReadAll(r.Body)
  	if _, err := client.Webhooks.Unwrap(context.Background(), rawBody, map[string]string{
  		"webhook-id":       r.Header.Get("webhook-id"),
  		"webhook-signature": r.Header.Get("webhook-signature"),
  		"webhook-timestamp": r.Header.Get("webhook-timestamp"),
  	}); err != nil {
  		http.Error(w, "Invalid signature", http.StatusUnauthorized)
  		return
  	}
  	w.WriteHeader(http.StatusOK)
  }
  ```
</CodeGroup>

#### Manual verification (alternative)

If you are not using an SDK, you can verify signatures yourself following the Standard Webhooks spec:

1. Build the signed message by concatenating `webhook-id`, `webhook-timestamp`, and the exact raw stringified `payload`, separated by periods (`.`).
2. Compute the HMAC SHA256 of that string using your webhook secret key from the Dashboard.
3. Compare the computed signature to the `webhook-signature` header. If they match, the webhook is authentic.

<Info>
  We follow the Standard Webhooks specification. You can use their libraries to verify signatures: [https://github.com/standard-webhooks/standard-webhooks/tree/main/libraries](https://github.com/standard-webhooks/standard-webhooks/tree/main/libraries). For event payload formats, see the [Webhook Payload](/developer-resources/webhooks/intents/payment).
</Info>

### Responding to Webhooks

* Your webhook handler must return a `2xx status code` to acknowledge receipt of the event.
* Any other response will be treated as a failure, and the webhook will be retried.

### Best Practices

<AccordionGroup>
  <Accordion title="Use HTTPS endpoints only" icon="lock">
    Always use HTTPS URLs for webhook endpoints. HTTP endpoints are vulnerable to man-in-the-middle attacks and expose your webhook data.
  </Accordion>

  <Accordion title="Respond immediately" icon="bolt">
    Return a `200` status code immediately upon receiving the webhook. Process the event asynchronously to avoid timeouts.

    ```javascript theme={null}
    app.post('/webhook', async (req, res) => {
      // Acknowledge receipt immediately
      res.status(200).json({ received: true });
      
      // Process asynchronously
      processWebhookAsync(req.body).catch(console.error);
    });
    ```
  </Accordion>

  <Accordion title="Handle duplicate events" icon="rotate">
    Implement idempotency using the `webhook-id` header to safely process the same event multiple times without side effects.
  </Accordion>

  <Accordion title="Secure your webhook secret" icon="key">
    Store your webhook secret securely using environment variables or a secrets manager. Never commit secrets to version control.
  </Accordion>
</AccordionGroup>

## Webhook Payload Structure

Understanding the webhook payload structure helps you parse and process events correctly.

### Request Format

```http theme={null}
POST /your-webhook-url
Content-Type: application/json
```

### Headers

<ParamField type="string">
  Unique identifier for this webhook event. Use this for idempotency checks.
</ParamField>

<ParamField type="string">
  HMAC SHA256 signature for verifying the webhook authenticity.
</ParamField>

<ParamField type="string">
  Unix timestamp (in seconds) when the webhook was sent.
</ParamField>

### Request Body

<ResponseField name="business_id" type="string">
  Your Dodo Payments business identifier.
</ResponseField>

<ResponseField name="type" type="string">
  Event type that triggered this webhook (e.g., `payment.succeeded`, `subscription.created`).
</ResponseField>

<ResponseField name="timestamp" type="string">
  ISO 8601 formatted timestamp of when the event occurred.
</ResponseField>

<ResponseField name="data" type="object">
  Event-specific payload containing detailed information about the event.

  <Expandable title="Data object properties">
    <ResponseField name="payload_type" type="string">
      Type of resource: `Payment`, `Subscription`, `Refund`, `Dispute`, or `LicenseKey`.
    </ResponseField>

    Additional fields vary by event type. See the event-specific documentation for complete schemas.
  </Expandable>
</ResponseField>

### Example Payload

```json theme={null}
{
  "business_id": "string",
  "type": "payment.succeeded | payment.failed |...",
  "timestamp": "2024-01-01T12:00:00Z",
  "data": {
    "payload_type": "Payment | Subscription | Refund | Dispute | LicenseKey",
    // ... event-specific fields (see below)
  }
}
```

<CardGroup>
  <Card title="Event Types" icon="list" href="/developer-resources/webhooks/intents/webhook-events-guide">
    Browse all available webhook event types
  </Card>

  <Card title="Event Payloads" icon="code" href="/developer-resources/webhooks/intents/payment">
    View detailed payload schemas for each event
  </Card>
</CardGroup>

## Testing Webhooks

You can test your webhook integration directly from the Dodo Payments dashboard to ensure your endpoint is working correctly before going live.

<Frame>
  <img alt="Endpoint Details" />
</Frame>

### Accessing the Testing Interface

<Steps>
  <Step title="Navigate to Webhooks">
    Go to your Dodo Payments Dashboard and navigate to `Settings > Webhooks`.
  </Step>

  <Step title="Select Your Endpoint">
    Click on your webhook endpoint to access its details page.
  </Step>

  <Step title="Open Testing Tab">
    Click on the **Testing** tab to access the webhook testing interface.
  </Step>
</Steps>

### Testing Your Webhook

The testing interface provides a comprehensive way to test your webhook endpoint:

<Steps>
  <Step title="Select Event Type">
    Use the dropdown menu to select the specific event type you want to test (e.g., `payment.succeeded`, `payment.failed`, etc.).

    <Info>
      The dropdown contains all available webhook event types that your endpoint can receive.
    </Info>
  </Step>

  <Step title="Review Schema and Example">
    The interface displays both the **Schema** (data structure) and **Example** (sample payload) for the selected event type.
  </Step>

  <Step title="Send Test Event">
    Click the **Send Example** button to send a test webhook to your endpoint.

    <Warning>
      **Important**: Failed messages sent through the testing interface will not be retried. This is for testing purposes only.
    </Warning>
  </Step>
</Steps>

### Verifying Your Test

<Steps>
  <Step title="Check Your Endpoint">
    Monitor your webhook endpoint logs to confirm the test event was received.
  </Step>

  <Step title="Verify Signature">
    Ensure your signature verification is working correctly with the test payload.
  </Step>

  <Step title="Test Response">
    Confirm your endpoint returns a `2xx` status code to acknowledge receipt.
  </Step>
</Steps>

### Implementation Example

Here's a complete Express.js implementation showing webhook verification and handling:

<CodeGroup>
  ```typescript Express.js Webhook Handler theme={null}
  import { Webhook } from "standardwebhooks";
  import express from "express";

  const app = express();
  app.use(express.json());

  const webhook = new Webhook(process.env.DODO_WEBHOOK_SECRET);

  app.post('/webhook/dodo-payments', async (req, res) => {
    try {
      // Extract webhook headers
      const webhookHeaders = {
        "webhook-id": req.headers["webhook-id"] as string,
        "webhook-signature": req.headers["webhook-signature"] as string,
        "webhook-timestamp": req.headers["webhook-timestamp"] as string,
      };

      // Verify the webhook signature
      const payload = JSON.stringify(req.body);
      await webhook.verify(payload, webhookHeaders);
      
      // Acknowledge receipt immediately
      res.status(200).json({ received: true });
      
      // Process webhook asynchronously
      processWebhookAsync(req.body).catch(console.error);
      
    } catch (error) {
      console.error('Webhook verification failed:', error);
      res.status(400).json({ error: 'Invalid signature' });
    }
  });

  async function processWebhookAsync(data: any) {
    // Handle the webhook event based on type
    switch (data.type) {
      case 'payment.succeeded':
        await handlePaymentSucceeded(data);
        break;
      case 'subscription.created':
        await handleSubscriptionCreated(data);
        break;
      // Add more event handlers...
    }
  }
  ```

  ```javascript Testing Webhooks Locally theme={null}
  const { Webhook } = require("standardwebhooks");
  const axios = require("axios");
  const crypto = require("crypto");

  // Generate test webhook
  const timestamp = new Date();
  const webhookId = crypto.randomUUID();
  const payload = {
    business_id: "biz_test123",
    type: "payment.succeeded",
    timestamp: timestamp.toISOString(),
    data: {
      payload_type: "Payment",
      payment_id: "pay_test456",
      amount: 2999
    }
  };

  // Sign the payload
  const webhookSecret = process.env.DODO_WEBHOOK_SECRET;
  const webhookInstance = new Webhook(webhookSecret);
  const payloadString = JSON.stringify(payload);
  const signature = webhookInstance.sign(webhookId, timestamp, payloadString);

  // Send test webhook
  const response = await axios.post('http://localhost:3000/webhook/dodo-payments', payload, {
    headers: {
      "webhook-id": webhookId,
      "webhook-timestamp": Math.floor(timestamp.getTime() / 1000),
      "webhook-signature": signature,
      "Content-Type": "application/json"
    }
  });

  console.log("Test webhook sent successfully:", response.data);
  ```
</CodeGroup>

<Tip>
  Test your webhook handler thoroughly using the dashboard testing interface before processing production events. This helps identify and fix issues early.
</Tip>

## Advanced Settings

The Advanced Settings tab provides additional configuration options for fine-tuning your webhook endpoint behavior.

### Rate Limiting (Throttling)

Control the rate at which webhook events are delivered to your endpoint to prevent overwhelming your system.

<Steps>
  <Step title="Access Rate Limit Settings">
    In the **Advanced** tab, locate the "Rate Limit (throttling)" section.
  </Step>

  <Step title="Configure Rate Limit">
    Click the **Edit** button to modify the rate limit settings.

    <Info>
      By default, webhooks have "No rate limit" applied, meaning events are delivered as soon as they occur.
    </Info>
  </Step>

  <Step title="Set Limits">
    Configure your desired rate limit to control webhook delivery frequency and prevent system overload.
  </Step>
</Steps>

<Tip>
  Use rate limiting when your webhook handler needs time to process events or when you want to batch multiple events together.
</Tip>

### Custom Headers

Add custom HTTP headers to all webhook requests sent to your endpoint. This is useful for authentication, routing, or adding metadata to your webhook requests.

<Steps>
  <Step title="Add Custom Header">
    In the "Custom Headers" section, enter a **Key** and **Value** for your custom header.
  </Step>

  <Step title="Add Multiple Headers">
    Click the **+** button to add additional custom headers as needed.
  </Step>

  <Step title="Save Configuration">
    Your custom headers will be included in all webhook requests to this endpoint.
  </Step>
</Steps>

### Transformations

Transformations allow you to modify a webhook's payload and redirect it to a different URL. This powerful feature enables you to:

* Modify the payload structure before processing
* Route webhooks to different endpoints based on content
* Add or remove fields from the payload
* Transform data formats

<Steps>
  <Step title="Enable Transformations">
    Toggle the **Enabled** switch to activate the transformation feature.
  </Step>

  <Step title="Configure Transformation">
    Click **Edit transformation** to define your transformation rules.

    <Info>
      You can use JavaScript to transform the webhook payload and specify a different target URL.
    </Info>
  </Step>

  <Step title="Test Transformation">
    Use the testing interface to verify your transformation works correctly before going live.
  </Step>
</Steps>

<Warning>
  Transformations can significantly impact webhook delivery performance. Test thoroughly and keep transformation logic simple and efficient.
</Warning>

<Tip>
  Transformations are particularly useful for:

  * Converting between different data formats
  * Filtering events based on specific criteria
  * Adding computed fields to the payload
  * Routing events to different microservices
</Tip>

## Monitoring Webhook Logs

The Logs tab provides comprehensive visibility into your webhook delivery status, allowing you to monitor, debug, and manage webhook events effectively.

<Frame>
  <img alt="Logs" />
</Frame>

## Activity Monitoring

The Activity tab provides real-time insights into your webhook delivery performance with visual analytics.

<Frame>
  <img alt="Activity" />
</Frame>

## Email Alerts

Stay informed about your webhook health with automatic email notifications. When webhook deliveries start failing or your endpoint stops responding, you'll receive email alerts so you can quickly address issues and keep your integrations running smoothly.

<Frame>
  <img alt="Webhook Alerting Settings showing email notifications configuration" />
</Frame>

### Enable Email Alerts

<Steps>
  <Step title="Navigate to Alerting Settings">
    Go to your Dodo Payments Dashboard and navigate to **Dashboard → Webhooks → Alerting**.
  </Step>

  <Step title="Enable Email Notifications">
    Toggle on **Email notifications** to start receiving alerts about webhook delivery issues.
  </Step>

  <Step title="Configure Email Address">
    Enter the email address where you want to receive webhook alerts. We'll send notifications to this address when certain events occur with your webhooks setup, such as delivery issues that might affect your integrations.
  </Step>
</Steps>

<Tip>
  Enable email alerts to catch webhook delivery problems early and maintain reliable integrations. You'll be notified when deliveries fail or your endpoint becomes unresponsive.
</Tip>

## Deploy to Cloud Platforms

Ready to deploy your webhook handler to production? We provide platform-specific guides to help you deploy webhooks to popular cloud providers with best practices for each platform.

<CardGroup>
  <Card title="Vercel" icon="triangle" href="/developer-resources/webhooks/examples/vercel-example">
    Deploy webhooks to Vercel with serverless functions
  </Card>

  <Card title="Cloudflare Workers" icon="cloud" href="/developer-resources/webhooks/examples/cloudflare-example">
    Run webhooks on Cloudflare's edge network
  </Card>

  <Card title="Supabase Edge Functions" icon="database" href="/developer-resources/webhooks/examples/supabase-example">
    Integrate webhooks with Supabase
  </Card>

  <Card title="Netlify Functions" icon="circle-nodes" href="/developer-resources/webhooks/examples/netlify-example">
    Deploy webhooks as Netlify serverless functions
  </Card>
</CardGroup>

<Info>
  Each platform guide includes environment setup, signature verification, and deployment steps specific to that provider.
</Info>


# Cloudflare Workers
Source: https://docs.dodopayments.com/developer-resources/webhooks/examples/cloudflare-example

Deploy DodoPayments webhooks to Cloudflare Workers

<Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/cloud-functions/tree/main/cloudflare">
  Complete source code and setup guide
</Card>

## Quick Setup

### 1. Prerequisites

* [Cloudflare account](https://dash.cloudflare.com/sign-up)
* [Neon database](https://neon.com) account
* DodoPayments API key from [dashboard](https://app.dodopayments.com/)

### 2. Install Dependencies

```bash theme={null}
npm install -g wrangler
wrangler login
git clone https://github.com/dodopayments/cloud-functions.git
cd cloud-functions/cloudflare
npm install
```

### 3. Database Setup

1. Sign up for [Neon](https://neon.com)
2. Create a new project
3. Open the SQL Editor
4. Copy and paste the contents of [`schema.sql`](#database-schema)
5. Run the query
6. Get your connection string from Neon → Connection Details

### 4. Configure Initial Secrets

```bash theme={null}
# Set your Neon database URL
wrangler secret put DATABASE_URL

# Set your API key
wrangler secret put DODO_PAYMENTS_API_KEY
```

> **Note:** We'll set `DODO_PAYMENTS_WEBHOOK_KEY` after deployment once you have your webhook URL.

### 5. Update wrangler.toml

Edit `wrangler.toml` and set your worker name:

```toml theme={null}
name = "my-dodo-webhook"
```

### 6. Deploy

```bash theme={null}
npm run deploy
```

### 7. Get Your Webhook URL

Your webhook URL is:

```
https://[worker-name].[your-subdomain].workers.dev
```

### 8. Register Webhook in DodoPayments Dashboard

1. Go to [DodoPayments Dashboard](https://app.dodopayments.com) → Developer → Webhooks
2. Create a new webhook endpoint
3. Configure your webhook URL as the endpoint
4. Enable these subscription events:
   * `subscription.active`
   * `subscription.cancelled`
   * `subscription.renewed`
5. Copy the **Signing Secret**

### 9. Set Webhook Key & Redeploy

```bash theme={null}
wrangler secret put DODO_PAYMENTS_WEBHOOK_KEY
npm run deploy
```

## What It Does

Processes subscription events and stores them in PostgreSQL:

* **subscription.active** - Creates/updates customer and subscription records
* **subscription.cancelled** - Marks subscription as cancelled
* **subscription.renewed** - Updates next billing date

## Key Features

✅ **Signature verification** - Using the dodopayments library\
✅ **Idempotency** - Prevents duplicate processing with webhook IDs\
✅ **Event logging** - Complete audit trail in `webhook_events` table\
✅ **Error handling** - Logged and retryable

> **Note:** This implementation demonstrates handling three core subscription events (`subscription.active`, `subscription.cancelled`, `subscription.renewed`) with minimal fields. You can easily extend it to support additional event types and fields based on your requirements.

## Configuration Files

<CodeGroup>
  ```json package.json theme={null}
  {
    "name": "dodo-webhook-cloudflare",
    "version": "1.0.0",
    "type": "module",
    "description": "DodoPayments Webhook Handler for Cloudflare Workers",
    "main": "worker.ts",
    "scripts": {
      "dev": "wrangler dev",
      "deploy": "wrangler deploy",
      "tail": "wrangler tail"
    },
    "dependencies": {
      "@neondatabase/serverless": "^1.0.2",
      "dodopayments": "^2.4.1"
    },
    "devDependencies": {
      "@cloudflare/workers-types": "^4.0.0",
      "typescript": "^5.9.3",
      "wrangler": "^4.43.0"
    }
  }
  ```

  ```toml wrangler.toml expandable theme={null}
  # Cloudflare Workers Configuration
  name = "dodo-webhook"
  main = "worker.ts"
  compatibility_date = "2025-10-20"

  [observability]
  [observability.logs]
  enabled = true
  head_sampling_rate = 1
  invocation_logs = true
  persist = true
  ```

  ```json tsconfig.json theme={null}
  {
    "compilerOptions": {
      "target": "ES2022",
      "module": "ES2022",
      "lib": ["ES2022"],
      "moduleResolution": "bundler",
      "types": ["@cloudflare/workers-types"],
      "esModuleInterop": true,
      "strict": true,
      "skipLibCheck": true,
      "resolveJsonModule": true,
      "allowSyntheticDefaultImports": true,
      "forceConsistentCasingInFileNames": true,
      "isolatedModules": true
    },
    "include": ["*.ts"],
    "exclude": ["node_modules"]
  }
  ```
</CodeGroup>

## Database Schema

<CodeGroup>
  ```sql schema.sql expandable theme={null}
  -- DodoPayments Webhook Database Schema
  -- Compatible with PostgreSQL (Supabase, Neon, etc.)

  -- Enable UUID extension (if not already enabled)
  CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

  -- Customers table
  CREATE TABLE IF NOT EXISTS customers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT NOT NULL,
    name TEXT NOT NULL,
    dodo_customer_id TEXT UNIQUE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
  );

  -- Subscriptions table
  CREATE TABLE IF NOT EXISTS subscriptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    customer_id UUID NOT NULL REFERENCES customers(id) ON DELETE CASCADE,
    dodo_subscription_id TEXT UNIQUE NOT NULL,
    product_id TEXT NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('pending', 'active', 'on_hold', 'cancelled', 'failed', 'expired')),
    billing_interval TEXT NOT NULL CHECK (billing_interval IN ('day', 'week', 'month', 'year')),
    amount INTEGER NOT NULL,
    currency TEXT NOT NULL,
    next_billing_date TIMESTAMP WITH TIME ZONE NOT NULL,
    cancelled_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
  );

  -- Webhook events log
  CREATE TABLE IF NOT EXISTS webhook_events (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_id TEXT UNIQUE,
    event_type TEXT NOT NULL,
    data JSONB NOT NULL,
    processed BOOLEAN DEFAULT FALSE,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed_at TIMESTAMP WITH TIME ZONE,
    attempts INTEGER DEFAULT 0
  );

  -- Indexes for better query performance
  CREATE INDEX IF NOT EXISTS idx_customers_email ON customers(email);
  CREATE INDEX IF NOT EXISTS idx_customers_dodo_id ON customers(dodo_customer_id);
  CREATE INDEX IF NOT EXISTS idx_subscriptions_dodo_id ON subscriptions(dodo_subscription_id);
  CREATE INDEX IF NOT EXISTS idx_subscriptions_customer_id ON subscriptions(customer_id);
  CREATE INDEX IF NOT EXISTS idx_subscriptions_status ON subscriptions(status);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_processed ON webhook_events(processed, created_at);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_type ON webhook_events(event_type);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_created_at ON webhook_events(created_at DESC);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_webhook_id ON webhook_events(webhook_id);

  -- Function to automatically update updated_at timestamp
  CREATE OR REPLACE FUNCTION update_updated_at_column()
  RETURNS TRIGGER AS $$
  BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  -- Triggers to automatically update updated_at
  CREATE TRIGGER update_customers_updated_at
    BEFORE UPDATE ON customers
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

  CREATE TRIGGER update_subscriptions_updated_at
    BEFORE UPDATE ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

  -- Comments for documentation
  COMMENT ON TABLE customers IS 'Stores customer information from DodoPayments';
  COMMENT ON TABLE subscriptions IS 'Stores subscription data from DodoPayments';
  COMMENT ON TABLE webhook_events IS 'Logs all incoming webhook events for audit and retry purposes';

  COMMENT ON COLUMN customers.dodo_customer_id IS 'Unique customer ID from DodoPayments';
  COMMENT ON COLUMN subscriptions.dodo_subscription_id IS 'Unique subscription ID from DodoPayments';
  COMMENT ON COLUMN subscriptions.amount IS 'Amount in smallest currency unit (e.g., cents)';
  COMMENT ON COLUMN subscriptions.currency IS 'Currency used for the subscription payments (e.g., USD, EUR, INR)';
  COMMENT ON COLUMN webhook_events.attempts IS 'Number of processing attempts for failed webhooks';
  COMMENT ON COLUMN webhook_events.data IS 'Full webhook payload as JSON';
  ```
</CodeGroup>

**Tables created:**

* **customers** - Email, name, dodo\_customer\_id
* **subscriptions** - Status, amount, next\_billing\_date, linked to customers
* **webhook\_events** - Event log with webhook\_id for idempotency

## Implementation Code

<CodeGroup>
  ```typescript worker.ts expandable theme={null}
  import { DodoPayments } from 'dodopayments';
  import { neon, NeonQueryFunction } from '@neondatabase/serverless';

  interface Env {
    DATABASE_URL: string;
    DODO_PAYMENTS_API_KEY: string;
    DODO_PAYMENTS_WEBHOOK_KEY: string;
  }

  interface WebhookPayload {
    business_id: string;
    type: string;
    timestamp: string;
    data: {
      payload_type: "Payment" | "Subscription" | "Refund" | "Dispute" | "LicenseKey";
      subscription_id: string;
      customer: {
        customer_id: string;
        email: string;
        name: string;
      };
      product_id: string;
      status: string;
      recurring_pre_tax_amount: number;
      payment_frequency_interval: string;
      created_at: string;
      next_billing_date: string;
      cancelled_at?: string | null;
      currency: string;
    };
  }

  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type, webhook-id, webhook-signature, webhook-timestamp',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
  };

  async function handleSubscriptionEvent(sql: NeonQueryFunction<false, false>, payload: WebhookPayload, status: string) {
    if (!payload.data.customer.customer_id || !payload.data.subscription_id) {
      throw new Error('Missing required fields: customer_id or subscription_id');
    }

    console.log('🔄 Processing subscription event:', JSON.stringify(payload, null, 2));

    const customer = payload.data.customer;

    // Upsert customer (create if doesn't exist, otherwise use existing)
    const customerResult = await sql`
      INSERT INTO customers (email, name, dodo_customer_id, created_at)
      VALUES (${customer.email}, ${customer.name}, ${customer.customer_id}, ${new Date().toISOString()})
      ON CONFLICT (dodo_customer_id) 
      DO UPDATE SET 
        email = EXCLUDED.email,
        name = EXCLUDED.name,
        updated_at = ${new Date().toISOString()}
      RETURNING id
    `;

    const customerId = customerResult[0].id;
    console.log(`✅ Customer upserted with ID: ${customerId}`);

    // Upsert subscription
    await sql`
      INSERT INTO subscriptions (
        customer_id, dodo_subscription_id, product_id, status, 
        billing_interval, amount, currency, created_at, next_billing_date, cancelled_at, updated_at
      )
      VALUES (
        ${customerId}, ${payload.data.subscription_id},
        ${payload.data.product_id}, ${status},
        ${payload.data.payment_frequency_interval.toLowerCase()}, ${payload.data.recurring_pre_tax_amount},
        ${payload.data.currency}, ${payload.data.created_at}, ${payload.data.next_billing_date},
        ${payload.data.cancelled_at ?? null}, ${new Date().toISOString()}
      )
      ON CONFLICT (dodo_subscription_id) 
      DO UPDATE SET 
        customer_id = EXCLUDED.customer_id,
        product_id = EXCLUDED.product_id,
        status = EXCLUDED.status,
        billing_interval = EXCLUDED.billing_interval,
        amount = EXCLUDED.amount,
        currency = EXCLUDED.currency,
        created_at = EXCLUDED.created_at,
        next_billing_date = EXCLUDED.next_billing_date,
        cancelled_at = EXCLUDED.cancelled_at,
        updated_at = EXCLUDED.updated_at
    `;

    console.log(`✅ Subscription upserted with ${status} status`)
  }

  export default {
    async fetch(request: Request, env: Env): Promise<Response> {
      // Handle CORS preflight
      if (request.method === 'OPTIONS') {
        return new Response('ok', { headers: corsHeaders });
      }

      if (request.method !== 'POST') {
        return new Response(JSON.stringify({ error: 'Method not allowed' }), {
          status: 405,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      try {
        const rawBody = await request.text();
        console.log('📨 Webhook received');

        // Verify required environment variables
        if (!env.DODO_PAYMENTS_API_KEY) {
          console.error('❌ DODO_PAYMENTS_API_KEY is not configured');
          return new Response(
            JSON.stringify({ error: 'API key not configured' }),
            { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
          );
        }

        if (!env.DODO_PAYMENTS_WEBHOOK_KEY) {
          console.error('❌ DODO_PAYMENTS_WEBHOOK_KEY is not configured');
          return new Response(
            JSON.stringify({ error: 'Webhook verification key not configured' }),
            { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
          );
        }

        if (!env.DATABASE_URL) {
          console.error('❌ DATABASE_URL is not configured');
          return new Response(
            JSON.stringify({ error: 'Database URL not configured' }),
            { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
          );
        }

        // Verify webhook signature (required for security)
        const webhookHeaders = {
          'webhook-id': request.headers.get('webhook-id') || '',
          'webhook-signature': request.headers.get('webhook-signature') || '',
          'webhook-timestamp': request.headers.get('webhook-timestamp') || '',
        };

        try {
          const dodoPaymentsClient = new DodoPayments({
            bearerToken: env.DODO_PAYMENTS_API_KEY,
            webhookKey: env.DODO_PAYMENTS_WEBHOOK_KEY,
          });
          const unwrappedWebhook = dodoPaymentsClient.webhooks.unwrap(rawBody, { headers: webhookHeaders });
          console.log('Unwrapped webhook:', unwrappedWebhook);
          console.log('✅ Webhook signature verified');
        } catch (error) {
          console.error('❌ Webhook verification failed:', error);
          return new Response(
            JSON.stringify({ error: 'Webhook verification failed' }),
            { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
          );
        }

        // Initialize Neon client
        const sql = neon(env.DATABASE_URL);

        const payload: WebhookPayload = JSON.parse(rawBody);
        const eventType = payload.type;
        const eventData = payload.data;
        const webhookId = request.headers.get('webhook-id') || '';

        console.log(`📋 Webhook payload:`, JSON.stringify(payload, null, 2));

        // Check for duplicate webhook-id (idempotency)
        if (webhookId) {
          const existingEvent = await sql`
            SELECT id FROM webhook_events WHERE webhook_id = ${webhookId}
          `;

          if (existingEvent.length > 0) {
            console.log(`⚠️ Webhook ${webhookId} already processed, skipping (idempotency)`);
            return new Response(
              JSON.stringify({ success: true, message: 'Webhook already processed' }),
              { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
            );
          }
        }

        // Log webhook event with webhook_id for idempotency
        const logResult = await sql`
          INSERT INTO webhook_events (webhook_id, event_type, data, processed, created_at)
          VALUES (${webhookId || null}, ${eventType}, ${JSON.stringify(eventData)}, ${false}, ${new Date().toISOString()})
          RETURNING id
        `;

        const loggedEventId = logResult[0].id;
        console.log('📝 Webhook event logged with ID:', loggedEventId);

        console.log(`🔄 Processing: ${eventType} (${eventData.payload_type || 'unknown payload type'})`);

        try {
          switch (eventType) {
            case 'subscription.active':
              await handleSubscriptionEvent(sql, payload, 'active');
              break;
            case 'subscription.cancelled':
              await handleSubscriptionEvent(sql, payload, 'cancelled');
              break;
            case 'subscription.renewed':
              console.log('🔄 Subscription renewed - keeping active status and updating billing date');
              await handleSubscriptionEvent(sql, payload, 'active');
              break;
            default:
              console.log(`ℹ️ Event ${eventType} logged but not processed (no handler available)`);
          }

          await sql`
            UPDATE webhook_events 
            SET processed = ${true}, processed_at = ${new Date().toISOString()}
            WHERE id = ${loggedEventId}
          `;

          console.log('✅ Webhook marked as processed');
        } catch (processingError) {
          console.error('❌ Error processing webhook event:', processingError);

          await sql`
            UPDATE webhook_events 
            SET processed = ${false}, 
                error_message = ${processingError instanceof Error ? processingError.message : 'Unknown error'},
                processed_at = ${new Date().toISOString()}
            WHERE id = ${loggedEventId}
          `;

          throw processingError;
        }

        console.log('✅ Webhook processed successfully');

        return new Response(
          JSON.stringify({
            success: true,
            event_type: eventType,
            event_id: loggedEventId
          }),
          { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );

      } catch (error) {
        console.error('❌ Webhook processing failed:', error);
        return new Response(
          JSON.stringify({
            error: 'Webhook processing failed',
            details: error instanceof Error ? error.message : 'Unknown error'
          }),
          { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      }
    }
  };
  ```
</CodeGroup>

## How It Works

The webhook handler:

1. **Verifies the signature** - Ensures the request is from DodoPayments using HMAC-SHA256
2. **Checks for duplicates** - Uses webhook ID to prevent processing the same event twice
3. **Logs the event** - Stores raw webhook in `webhook_events` table for audit trail
4. **Processes the event** - Creates or updates customers and subscriptions
5. **Handles errors** - Logs failures and marks event as unprocessed for retry

## Testing

**Local development:**

```bash theme={null}
npm run dev  # Available at http://localhost:8787
```

**Configure in DodoPayments Dashboard:**

1. Go to Developers → Webhooks
2. Add endpoint with your Worker URL
3. Enable: subscription.active, subscription.cancelled, subscription.renewed

## Common Issues

| Issue                     | Solution                                                 |
| ------------------------- | -------------------------------------------------------- |
| Verification failed       | Check webhook key is correct from DodoPayments dashboard |
| Database connection error | Verify Neon connection string                            |
| Worker not deploying      | Run `npm install`, check `wrangler.toml` syntax          |

## Resources

* [Cloudflare Workers Docs](https://developers.cloudflare.com/workers/)
* [Neon Docs](https://neon.com/docs/)
* [Webhook Events Guide](/developer-resources/webhooks/intents/webhook-events-guide)
* [GitHub Repo](https://github.com/dodopayments/cloud-functions/tree/main/cloudflare)


# Netlify Functions
Source: https://docs.dodopayments.com/developer-resources/webhooks/examples/netlify-example

Deploy DodoPayments webhooks to Netlify Functions

<Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/cloud-functions/tree/main/netlify">
  Complete source code and setup guide
</Card>

## Quick Setup

### 1. Prerequisites

* [Netlify account](https://app.netlify.com/signup)
* [Neon database](https://neon.com) account
* DodoPayments API key from [dashboard](https://app.dodopayments.com/)

### 2. Install Dependencies

```bash theme={null}
npm install -g netlify-cli
netlify login
git clone https://github.com/dodopayments/cloud-functions.git
cd cloud-functions/netlify
npm install
```

### 3. Database Setup

1. Sign up for [Neon](https://neon.com)
2. Create a new project
3. Open the SQL Editor
4. Copy and paste the contents of [`schema.sql`](#database-schema)
5. Run the query
6. Get your connection string from Neon → Connection Details

### 4. Set Initial Environment Variables

```bash theme={null}
netlify env:set DATABASE_URL "your-neon-connection-string"
netlify env:set DODO_PAYMENTS_API_KEY "your-api-key"
```

> **Note:** We'll set `DODO_PAYMENTS_WEBHOOK_KEY` after deployment once you have your webhook URL.

### 5. Initialize & Deploy

```bash theme={null}
netlify init       # Link to your site (first time only)
npm run deploy
```

### 6. Get Your Webhook URL

Your webhook URL is:

```
https://[your-project].netlify.app/.netlify/functions/webhook
```

### 7. Register Webhook in DodoPayments Dashboard

1. Go to [DodoPayments Dashboard](https://app.dodopayments.com) → Developer → Webhooks
2. Create a new webhook endpoint
3. Configure your webhook URL as the endpoint
4. Enable these subscription events:
   * `subscription.active`
   * `subscription.cancelled`
   * `subscription.renewed`
5. Copy the **Signing Secret**

### 8. Set Webhook Key & Redeploy

```bash theme={null}
netlify env:set DODO_PAYMENTS_WEBHOOK_KEY "your-webhook-signing-key"
npm run deploy
```

## What It Does

Processes subscription events and stores them in PostgreSQL:

* **subscription.active** - Creates/updates customer and subscription records
* **subscription.cancelled** - Marks subscription as cancelled
* **subscription.renewed** - Updates next billing date

## Key Features

✅ **Signature verification** - Using the dodopayments library\
✅ **Idempotency** - Prevents duplicate processing with webhook IDs\
✅ **Event logging** - Complete audit trail in `webhook_events` table\
✅ **Error handling** - Logged and retryable

> **Note:** This implementation demonstrates handling three core subscription events (`subscription.active`, `subscription.cancelled`, `subscription.renewed`) with minimal fields. You can easily extend it to support additional event types and fields based on your requirements.

## Configuration Files

<CodeGroup>
  ```json package.json theme={null}
  {
    "name": "dodo-webhook-netlify",
    "version": "1.0.0",
    "type": "module",
    "description": "DodoPayments Webhook Handler for Netlify",
    "scripts": {
      "dev": "netlify dev",
      "deploy": "netlify deploy --prod"
    },
    "dependencies": {
      "@neondatabase/serverless": "^1.0.2",
      "dodopayments": "^2.4.1"
    },
    "devDependencies": {
      "@netlify/functions": "^5.0.0",
      "netlify-cli": "^23.9.1",
      "typescript": "^5.9.3"
    }
  }
  ```

  ```json tsconfig.json theme={null}
  {
    "compilerOptions": {
      "target": "ES2022",
      "module": "ES2022",
      "lib": ["ES2022"],
      "moduleResolution": "node",
      "esModuleInterop": true,
      "strict": true,
      "skipLibCheck": true,
      "resolveJsonModule": true,
      "allowSyntheticDefaultImports": true,
      "forceConsistentCasingInFileNames": true,
      "isolatedModules": true,
      "types": ["node"]
    },
    "include": ["functions/*.ts"],
    "exclude": ["node_modules"]
  }
  ```

  ```toml netlify.toml theme={null}
  [build]
    functions = "functions"

  [build.environment]
    NODE_VERSION = "18"

  [functions]
    # Functions will be available at /.netlify/functions/[function-name]
    directory = "functions"
  ```
</CodeGroup>

## Database Schema

<CodeGroup>
  ```sql schema.sql expandable theme={null}
  -- DodoPayments Webhook Database Schema
  -- Compatible with PostgreSQL (Supabase, Neon, etc.)

  -- Enable UUID extension (if not already enabled)
  CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

  -- Customers table
  CREATE TABLE IF NOT EXISTS customers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT NOT NULL,
    name TEXT NOT NULL,
    dodo_customer_id TEXT UNIQUE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
  );

  -- Subscriptions table
  CREATE TABLE IF NOT EXISTS subscriptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    customer_id UUID NOT NULL REFERENCES customers(id) ON DELETE CASCADE,
    dodo_subscription_id TEXT UNIQUE NOT NULL,
    product_id TEXT NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('pending', 'active', 'on_hold', 'cancelled', 'failed', 'expired')),
    billing_interval TEXT NOT NULL CHECK (billing_interval IN ('day', 'week', 'month', 'year')),
    amount INTEGER NOT NULL,
    currency TEXT NOT NULL,
    next_billing_date TIMESTAMP WITH TIME ZONE NOT NULL,
    cancelled_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
  );

  -- Webhook events log
  CREATE TABLE IF NOT EXISTS webhook_events (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_id TEXT UNIQUE,
    event_type TEXT NOT NULL,
    data JSONB NOT NULL,
    processed BOOLEAN DEFAULT FALSE,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed_at TIMESTAMP WITH TIME ZONE,
    attempts INTEGER DEFAULT 0
  );

  -- Indexes for better query performance
  CREATE INDEX IF NOT EXISTS idx_customers_email ON customers(email);
  CREATE INDEX IF NOT EXISTS idx_customers_dodo_id ON customers(dodo_customer_id);
  CREATE INDEX IF NOT EXISTS idx_subscriptions_dodo_id ON subscriptions(dodo_subscription_id);
  CREATE INDEX IF NOT EXISTS idx_subscriptions_customer_id ON subscriptions(customer_id);
  CREATE INDEX IF NOT EXISTS idx_subscriptions_status ON subscriptions(status);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_processed ON webhook_events(processed, created_at);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_type ON webhook_events(event_type);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_created_at ON webhook_events(created_at DESC);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_webhook_id ON webhook_events(webhook_id);

  -- Function to automatically update updated_at timestamp
  CREATE OR REPLACE FUNCTION update_updated_at_column()
  RETURNS TRIGGER AS $$
  BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  -- Triggers to automatically update updated_at
  CREATE TRIGGER update_customers_updated_at
    BEFORE UPDATE ON customers
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

  CREATE TRIGGER update_subscriptions_updated_at
    BEFORE UPDATE ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

  -- Comments for documentation
  COMMENT ON TABLE customers IS 'Stores customer information from DodoPayments';
  COMMENT ON TABLE subscriptions IS 'Stores subscription data from DodoPayments';
  COMMENT ON TABLE webhook_events IS 'Logs all incoming webhook events for audit and retry purposes';

  COMMENT ON COLUMN customers.dodo_customer_id IS 'Unique customer ID from DodoPayments';
  COMMENT ON COLUMN subscriptions.dodo_subscription_id IS 'Unique subscription ID from DodoPayments';
  COMMENT ON COLUMN subscriptions.amount IS 'Amount in smallest currency unit (e.g., cents)';
  COMMENT ON COLUMN subscriptions.currency IS 'Currency used for the subscription payments (e.g., USD, EUR, INR)';
  COMMENT ON COLUMN webhook_events.attempts IS 'Number of processing attempts for failed webhooks';
  COMMENT ON COLUMN webhook_events.data IS 'Full webhook payload as JSON';
  ```
</CodeGroup>

**Tables created:**

* **customers** - Email, name, dodo\_customer\_id
* **subscriptions** - Status, amount, next\_billing\_date, linked to customers
* **webhook\_events** - Event log with webhook\_id for idempotency

## Implementation Code

<CodeGroup>
  ```typescript functions/webhook.ts expandable theme={null}
  import { Handler, HandlerEvent, HandlerContext } from '@netlify/functions';
  import { neon, NeonQueryFunction } from '@neondatabase/serverless';
  import { DodoPayments } from 'dodopayments';

  interface WebhookPayload {
    business_id: string;
    type: string;
    timestamp: string;
    data: {
      payload_type: "Payment" | "Subscription" | "Refund" | "Dispute" | "LicenseKey";
      subscription_id: string;
      customer: {
        customer_id: string;
        email: string;
        name: string;
      };
      product_id: string;
      status: string;
      recurring_pre_tax_amount: number;
      payment_frequency_interval: string;
      created_at: string;
      next_billing_date: string;
      cancelled_at?: string | null;
      currency: string;
    };
  }

  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type, webhook-id, webhook-signature, webhook-timestamp',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
  };

  async function handleSubscriptionEvent(sql: NeonQueryFunction<false, false>, payload: WebhookPayload, status: string) {
    if (!payload.data.customer.customer_id || !payload.data.subscription_id) {
      throw new Error('Missing required fields: customer_id or subscription_id');
    }

    console.log('🔄 Processing subscription event:', JSON.stringify(payload, null, 2));

    const customer = payload.data.customer;

    // Upsert customer (create if doesn't exist, otherwise use existing)
    const customerResult = await sql`
      INSERT INTO customers (email, name, dodo_customer_id, created_at)
      VALUES (${customer.email}, ${customer.name}, ${customer.customer_id}, ${new Date().toISOString()})
      ON CONFLICT (dodo_customer_id) 
      DO UPDATE SET 
        email = EXCLUDED.email,
        name = EXCLUDED.name,
        updated_at = ${new Date().toISOString()}
      RETURNING id
    `;

    const customerId = customerResult[0].id;
    console.log(`✅ Customer upserted with ID: ${customerId}`);

    // Upsert subscription
    await sql`
      INSERT INTO subscriptions (
        customer_id, dodo_subscription_id, product_id, status, 
        billing_interval, amount, currency, created_at, next_billing_date, cancelled_at, updated_at
      )
      VALUES (
        ${customerId}, ${payload.data.subscription_id},
        ${payload.data.product_id}, ${status},
        ${payload.data.payment_frequency_interval.toLowerCase()}, ${payload.data.recurring_pre_tax_amount},
        ${payload.data.currency}, ${payload.data.created_at}, ${payload.data.next_billing_date},
        ${payload.data.cancelled_at ?? null}, ${new Date().toISOString()}
      )
      ON CONFLICT (dodo_subscription_id) 
      DO UPDATE SET 
        customer_id = EXCLUDED.customer_id,
        product_id = EXCLUDED.product_id,
        status = EXCLUDED.status,
        billing_interval = EXCLUDED.billing_interval,
        amount = EXCLUDED.amount,
        currency = EXCLUDED.currency,
        created_at = EXCLUDED.created_at,
        next_billing_date = EXCLUDED.next_billing_date,
        cancelled_at = EXCLUDED.cancelled_at,
        updated_at = EXCLUDED.updated_at
    `;

    console.log(`✅ Subscription upserted with ${status} status`)
  }

  export const handler: Handler = async (event: HandlerEvent, context: HandlerContext) => {
    // Handle CORS preflight
    if (event.httpMethod === 'OPTIONS') {
      return {
        statusCode: 200,
        headers: corsHeaders,
        body: 'ok'
      };
    }

    if (event.httpMethod !== 'POST') {
      return {
        statusCode: 405,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        body: JSON.stringify({ error: 'Method not allowed' })
      };
    }

    try {
      const rawBody = event.body || '';
      console.log('📨 Webhook received');

      const DATABASE_URL = process.env.DATABASE_URL;
      const API_KEY = process.env.DODO_PAYMENTS_API_KEY;
      const WEBHOOK_KEY = process.env.DODO_PAYMENTS_WEBHOOK_KEY;

      if (!DATABASE_URL) {
        console.error('❌ Missing DATABASE_URL environment variable');
        return {
          statusCode: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          body: JSON.stringify({ error: 'Server configuration error' })
        };
      }

      // Verify required environment variables
      if (!API_KEY) {
        console.error('❌ DODO_PAYMENTS_API_KEY is not configured');
        return {
          statusCode: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          body: JSON.stringify({ error: 'API key not configured' })
        };
      }

      if (!WEBHOOK_KEY) {
        console.error('❌ DODO_PAYMENTS_WEBHOOK_KEY is not configured');
        return {
          statusCode: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          body: JSON.stringify({ error: 'Webhook verification key not configured' })
        };
      }

      // Verify webhook signature (required for security)
      const webhookHeaders = {
        'webhook-id': event.headers['webhook-id'] || '',
        'webhook-signature': event.headers['webhook-signature'] || '',
        'webhook-timestamp': event.headers['webhook-timestamp'] || '',
      };

      try {
        const dodoPaymentsClient = new DodoPayments({
          bearerToken: API_KEY,
          webhookKey: WEBHOOK_KEY,
        });
        const unwrappedWebhook = dodoPaymentsClient.webhooks.unwrap(rawBody, { headers: webhookHeaders });
        console.log('Unwrapped webhook:', unwrappedWebhook);
        console.log('✅ Webhook signature verified');
      } catch (error) {
        console.error('❌ Webhook verification failed:', error);
        return {
          statusCode: 401,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          body: JSON.stringify({ error: 'Webhook verification failed' })
        };
      }

      // Initialize Neon client
      const sql = neon(DATABASE_URL);

      const payload: WebhookPayload = JSON.parse(rawBody);
      const eventType = payload.type;
      const eventData = payload.data;
      const webhookId = event.headers['webhook-id'] || '';

      console.log(`📋 Webhook payload:`, JSON.stringify(payload, null, 2));

      // Check for duplicate webhook-id (idempotency)
      if (webhookId) {
        const existingEvent = await sql`
          SELECT id FROM webhook_events WHERE webhook_id = ${webhookId}
        `;

        if (existingEvent.length > 0) {
          console.log(`⚠️ Webhook ${webhookId} already processed, skipping (idempotency)`);
          return {
            statusCode: 200,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            body: JSON.stringify({ success: true, message: 'Webhook already processed' })
          };
        }
      }

      // Log webhook event with webhook_id for idempotency
      const logResult = await sql`
        INSERT INTO webhook_events (webhook_id, event_type, data, processed, created_at)
        VALUES (${webhookId || null}, ${eventType}, ${JSON.stringify(eventData)}, ${false}, ${new Date().toISOString()})
        RETURNING id
      `;

      const loggedEventId = logResult[0].id;
      console.log('📝 Webhook event logged with ID:', loggedEventId);

      console.log(`🔄 Processing: ${eventType} (${eventData.payload_type || 'unknown payload type'})`);

      try {
        switch (eventType) {
          case 'subscription.active':
            await handleSubscriptionEvent(sql, payload, 'active');
            break;
          case 'subscription.cancelled':
            await handleSubscriptionEvent(sql, payload, 'cancelled');
            break;
          case 'subscription.renewed':
            console.log('🔄 Subscription renewed - keeping active status and updating billing date');
            await handleSubscriptionEvent(sql, payload, 'active');
            break;
          default:
            console.log(`ℹ️ Event ${eventType} logged but not processed (no handler available)`);
        }

        await sql`
          UPDATE webhook_events 
          SET processed = ${true}, processed_at = ${new Date().toISOString()}
          WHERE id = ${loggedEventId}
        `;

        console.log('✅ Webhook marked as processed');
      } catch (processingError) {
        console.error('❌ Error processing webhook event:', processingError);

        await sql`
          UPDATE webhook_events 
          SET processed = ${false}, 
              error_message = ${processingError instanceof Error ? processingError.message : 'Unknown error'},
              processed_at = ${new Date().toISOString()}
          WHERE id = ${loggedEventId}
        `;

        throw processingError;
      }

      console.log('✅ Webhook processed successfully');

      return {
        statusCode: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          success: true,
          event_type: eventType,
          event_id: loggedEventId
        })
      };

    } catch (error) {
      console.error('❌ Webhook processing failed:', error);
      return {
        statusCode: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          error: 'Webhook processing failed',
          details: error instanceof Error ? error.message : 'Unknown error'
        })
      };
    }
  };
  ```
</CodeGroup>

## How It Works

The webhook handler:

1. **Verifies the signature** - Ensures the request is from DodoPayments using HMAC-SHA256
2. **Checks for duplicates** - Uses webhook ID to prevent processing the same event twice
3. **Logs the event** - Stores raw webhook in `webhook_events` table for audit trail
4. **Processes the event** - Creates or updates customers and subscriptions in Neon
5. **Handles errors** - Logs failures and marks event as unprocessed for retry

## Testing

**Local development:**

```bash theme={null}
npm run dev  # Available at http://localhost:8888/.netlify/functions/webhook
```

**View logs in Netlify Dashboard:**

1. Select your site → **Functions** tab
2. Click on the `webhook` function
3. View real-time logs and invocation history

**Configure in DodoPayments Dashboard:**

1. Go to Developers → Webhooks
2. Add endpoint with your Netlify Functions URL
3. Enable: subscription.active, subscription.cancelled, subscription.renewed

## Common Issues

| Issue                     | Solution                                                 |
| ------------------------- | -------------------------------------------------------- |
| Verification failed       | Check webhook key is correct from DodoPayments dashboard |
| Database connection error | Verify Neon connection string and use pooled connection  |
| Function not found (404)  | Run `netlify init` and `npm run deploy` again            |
| Env vars not available    | Set variables in CLI or dashboard, then redeploy         |

## Resources

* [Netlify Functions Docs](https://docs.netlify.com/functions/overview/)
* [Netlify CLI](https://docs.netlify.com/cli/get-started/)
* [Neon Docs](https://neon.com/docs/)
* [Webhook Events Guide](/developer-resources/webhooks/intents/webhook-events-guide)
* [GitHub Repo](https://github.com/dodopayments/cloud-functions/tree/main/netlify)


# Supabase Edge Functions
Source: https://docs.dodopayments.com/developer-resources/webhooks/examples/supabase-example

Deploy DodoPayments webhooks to Supabase Edge Functions

<Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/cloud-functions/tree/main/supabase">
  Complete source code and setup guide
</Card>

<Tip>
  <strong>Checkout the complete starter kit for supabase</strong><br />
  A minimal subscription starter kit built with Next.js, Supabase, and Dodo Payments. This boilerplate helps you quickly set up a subscription-based SaaS with authentication, payments, and webhooks.

  <a href="https://github.com/dodopayments/dodo-supabase-subscription-starter">
    Dodo Payments Supabase Subscription Starter
  </a>
</Tip>

## Quick Setup

### 1. Prerequisites

* [Supabase account](https://supabase.com/dashboard)
* A Supabase project created
* DodoPayments API key from [dashboard](https://app.dodopayments.com/)

### 2. Authenticate & Link

```bash theme={null}
npx supabase login
git clone https://github.com/dodopayments/cloud-functions.git
cd cloud-functions/supabase
npx supabase link --project-ref your-project-ref
```

Get your project ref from [Supabase Dashboard](https://supabase.com/dashboard) → Project Settings

### 3. Database Setup

1. Go to your [Supabase Dashboard](https://supabase.com/dashboard)
2. Open the SQL Editor
3. Create a new query
4. Copy and paste the entire contents of [`schema.sql`](#database-schema)
5. Run the query

### 4. Set Initial Secrets

Supabase automatically provides `SUPABASE_URL` and `SUPABASE_SERVICE_ROLE_KEY` at runtime.

```bash theme={null}
npx supabase secrets set DODO_PAYMENTS_API_KEY=your-api-key
```

> **Note:** We'll set `DODO_PAYMENTS_WEBHOOK_KEY` after deployment once you have your webhook URL.

### 5. Deploy

The function is already set up in `functions/webhook/index.ts` - just deploy it:

```bash theme={null}
npm run deploy
```

### 6. Get Your Webhook URL

Your webhook URL is:

```
https://[project-ref].supabase.co/functions/v1/webhook
```

### 7. Register Webhook in DodoPayments Dashboard

1. Go to [DodoPayments Dashboard](https://app.dodopayments.com) → Developer → Webhooks
2. Create a new webhook endpoint
3. Configure your webhook URL as the endpoint
4. Enable these subscription events:
   * `subscription.active`
   * `subscription.cancelled`
   * `subscription.renewed`
5. Copy the **Signing Secret**

### 8. Set Webhook Key & Redeploy

```bash theme={null}
npx supabase secrets set DODO_PAYMENTS_WEBHOOK_KEY=your-webhook-signing-key
npm run deploy
```

## What It Does

Processes subscription events and stores them in Supabase PostgreSQL:

* **subscription.active** - Creates/updates customer and subscription records
* **subscription.cancelled** - Marks subscription as cancelled
* **subscription.renewed** - Updates next billing date

## Key Features

✅ **Signature verification** - Using the dodopayments library\
✅ **Idempotency** - Prevents duplicate processing with webhook IDs\
✅ **Event logging** - Complete audit trail in `webhook_events` table\
✅ **Error handling** - Logged and retryable

> **Note:** This implementation demonstrates handling three core subscription events (`subscription.active`, `subscription.cancelled`, `subscription.renewed`) with minimal fields. You can easily extend it to support additional event types and fields based on your requirements.

## Configuration Files

<CodeGroup>
  ```json package.json theme={null}
  {
    "name": "dodo-webhook-supabase",
    "version": "1.0.0",
    "type": "module",
    "description": "DodoPayments Webhook Handler for Supabase Edge Functions",
    "scripts": {
      "dev": "npx supabase functions serve webhook --no-verify-jwt --workdir ..",
      "deploy": "npx supabase functions deploy webhook --no-verify-jwt --workdir .."
    }
  }
  ```

  ```json tsconfig.json theme={null}
  {
    "compilerOptions": {
      "target": "ES2022",
      "module": "ES2022",
      "lib": ["ES2022", "DOM"],
      "moduleResolution": "bundler",
      "esModuleInterop": true,
      "strict": true,
      "skipLibCheck": true,
      "resolveJsonModule": true,
      "allowSyntheticDefaultImports": true,
      "forceConsistentCasingInFileNames": true,
      "isolatedModules": true
    },
    "include": ["functions/webhook/*.ts"],
    "exclude": ["node_modules"]
  }
  ```
</CodeGroup>

## Database Schema

<CodeGroup>
  ```sql schema.sql expandable theme={null}
  -- DodoPayments Webhook Database Schema
  -- Compatible with PostgreSQL (Supabase, Neon, etc.)

  -- Enable UUID extension (if not already enabled)
  CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

  -- Customers table
  CREATE TABLE IF NOT EXISTS customers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT NOT NULL,
    name TEXT NOT NULL,
    dodo_customer_id TEXT UNIQUE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
  );

  -- Subscriptions table
  CREATE TABLE IF NOT EXISTS subscriptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    customer_id UUID NOT NULL REFERENCES customers(id) ON DELETE CASCADE,
    dodo_subscription_id TEXT UNIQUE NOT NULL,
    product_id TEXT NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('pending', 'active', 'on_hold', 'cancelled', 'failed', 'expired')),
    billing_interval TEXT NOT NULL CHECK (billing_interval IN ('day', 'week', 'month', 'year')),
    amount INTEGER NOT NULL,
    currency TEXT NOT NULL,
    next_billing_date TIMESTAMP WITH TIME ZONE NOT NULL,
    cancelled_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
  );

  -- Webhook events log
  CREATE TABLE IF NOT EXISTS webhook_events (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_id TEXT UNIQUE,
    event_type TEXT NOT NULL,
    data JSONB NOT NULL,
    processed BOOLEAN DEFAULT FALSE,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed_at TIMESTAMP WITH TIME ZONE,
    attempts INTEGER DEFAULT 0
  );

  -- Indexes for better query performance
  CREATE INDEX IF NOT EXISTS idx_customers_email ON customers(email);
  CREATE INDEX IF NOT EXISTS idx_customers_dodo_id ON customers(dodo_customer_id);
  CREATE INDEX IF NOT EXISTS idx_subscriptions_dodo_id ON subscriptions(dodo_subscription_id);
  CREATE INDEX IF NOT EXISTS idx_subscriptions_customer_id ON subscriptions(customer_id);
  CREATE INDEX IF NOT EXISTS idx_subscriptions_status ON subscriptions(status);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_processed ON webhook_events(processed, created_at);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_type ON webhook_events(event_type);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_created_at ON webhook_events(created_at DESC);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_webhook_id ON webhook_events(webhook_id);

  -- Function to automatically update updated_at timestamp
  CREATE OR REPLACE FUNCTION update_updated_at_column()
  RETURNS TRIGGER AS $$
  BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  -- Triggers to automatically update updated_at
  CREATE TRIGGER update_customers_updated_at
    BEFORE UPDATE ON customers
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

  CREATE TRIGGER update_subscriptions_updated_at
    BEFORE UPDATE ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

  -- Comments for documentation
  COMMENT ON TABLE customers IS 'Stores customer information from DodoPayments';
  COMMENT ON TABLE subscriptions IS 'Stores subscription data from DodoPayments';
  COMMENT ON TABLE webhook_events IS 'Logs all incoming webhook events for audit and retry purposes';

  COMMENT ON COLUMN customers.dodo_customer_id IS 'Unique customer ID from DodoPayments';
  COMMENT ON COLUMN subscriptions.dodo_subscription_id IS 'Unique subscription ID from DodoPayments';
  COMMENT ON COLUMN subscriptions.amount IS 'Amount in smallest currency unit (e.g., cents)';
  COMMENT ON COLUMN subscriptions.currency IS 'Currency used for the subscription payments (e.g., USD, EUR, INR)';
  COMMENT ON COLUMN webhook_events.attempts IS 'Number of processing attempts for failed webhooks';
  COMMENT ON COLUMN webhook_events.data IS 'Full webhook payload as JSON';
  ```
</CodeGroup>

**Tables created:**

* **customers** - Email, name, dodo\_customer\_id
* **subscriptions** - Status, amount, next\_billing\_date, linked to customers
* **webhook\_events** - Event log with webhook\_id for idempotency

## Implementation Code

<CodeGroup>
  ```typescript functions/webhook/index.ts expandable theme={null}
  import { serve } from 'https://deno.land/std@0.208.0/http/server.ts';
  import { createClient, SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2.38.4';
  import { DodoPayments } from 'https://esm.sh/dodopayments@2.4.1';

  export const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type, webhook-id, webhook-signature, webhook-timestamp',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
  };

  interface WebhookPayload {
    business_id: string;
    type: string;
    timestamp: string;
    data: {
      payload_type: "Payment" | "Subscription" | "Refund" | "Dispute" | "LicenseKey";
      subscription_id: string;
      customer: {
        customer_id: string;
        email: string;
        name: string;
      };
      product_id: string;
      status: string;
      recurring_pre_tax_amount: number;
      payment_frequency_interval: string;
      created_at: string;
      next_billing_date: string;
      cancelled_at?: string | null;
      currency: string;
    };
  }

  // Handle subscription events
  async function handleSubscriptionEvent(supabase: SupabaseClient, payload: WebhookPayload, status: string) {
    if (!payload.data.customer.customer_id || !payload.data.subscription_id) {
      throw new Error('Missing required fields: customer_id or subscription_id');
    }

    try {
      console.log('🔄 Processing subscription event:', JSON.stringify(payload, null, 2));
      
      const customer = payload.data.customer;
      
      // Upsert customer (create if doesn't exist, otherwise update)
      const customerResult = await supabase
        .from('customers')
        .upsert({
          email: customer.email,
          name: customer.name,
          dodo_customer_id: customer.customer_id
        }, {
          onConflict: 'dodo_customer_id',
          ignoreDuplicates: false
        })
        .select('id')
        .single();

      if (customerResult.error) {
        console.error('❌ Failed to upsert customer:', customerResult.error);
        throw new Error(`Failed to upsert customer: ${customerResult.error.message}`);
      }

      const customerId = customerResult.data.id;
      console.log(`✅ Customer upserted with ID: ${customerId}`);

      // Upsert subscription
      const subscriptionResult = await supabase
        .from('subscriptions')
        .upsert({
          customer_id: customerId,
          dodo_subscription_id: payload.data.subscription_id,
          product_id: payload.data.product_id,
          status,
          billing_interval: payload.data.payment_frequency_interval.toLowerCase(),
          amount: payload.data.recurring_pre_tax_amount,
          currency: payload.data.currency,
          created_at: payload.data.created_at,
          next_billing_date: payload.data.next_billing_date,
          cancelled_at: payload.data.cancelled_at ?? null,
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'dodo_subscription_id',
          ignoreDuplicates: false
        })
        .select();

      if (subscriptionResult.error) {
        console.error('❌ Failed to upsert subscription:', subscriptionResult.error);
        throw new Error(`Failed to upsert subscription: ${subscriptionResult.error.message}`);
      }

      console.log(`✅ Subscription upserted with ${status} status`);

    } catch (error) {
      console.error('❌ Error in handleSubscriptionEvent:', error);
      console.error('❌ Raw webhook data:', JSON.stringify(payload, null, 2));
      throw error;
    }
  }

  serve(async (req: Request) => {
    if (req.method === 'OPTIONS') {
      return new Response('ok', { headers: corsHeaders });
    }

    // Validate required environment variables
    try {
      const supabaseUrl = Deno.env.get('SUPABASE_URL');
      const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
      
      if (!supabaseUrl || !supabaseServiceKey) {
        console.error('❌ Missing required environment variables');
        return new Response(
          JSON.stringify({ error: 'Server configuration error' }),
          { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      }

      const rawBody = await req.text();
      console.log('📨 Webhook received');

      const apiKey = Deno.env.get('DODO_PAYMENTS_API_KEY');
      const webhookKey = Deno.env.get('DODO_PAYMENTS_WEBHOOK_KEY');

      if (!apiKey) {
        console.error('❌ DODO_PAYMENTS_API_KEY is not configured');
        return new Response(
          JSON.stringify({ error: 'API key not configured' }),
          { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      }

      if (!webhookKey) {
        console.error('❌ DODO_PAYMENTS_WEBHOOK_KEY is not configured');
        return new Response(
          JSON.stringify({ error: 'Webhook verification key not configured' }),
          { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      }

      // Verify webhook signature (required for security)
      const webhookHeaders = {
        'webhook-id': req.headers.get('webhook-id') || '',
        'webhook-signature': req.headers.get('webhook-signature') || '',
        'webhook-timestamp': req.headers.get('webhook-timestamp') || '',
      };

      try {
        const dodoPaymentsClient = new DodoPayments({
          bearerToken: apiKey,
          webhookKey: webhookKey,
        });
        const unwrappedWebhook = dodoPaymentsClient.webhooks.unwrap(rawBody, { headers: webhookHeaders });
        console.log('Unwrapped webhook:', unwrappedWebhook);
        console.log('✅ Webhook signature verified');
      } catch (error) {
        console.error('❌ Webhook verification failed:', error);
        return new Response(
          JSON.stringify({ 
            error: 'Webhook verification failed',
            details: error instanceof Error ? error.message : 'Invalid signature'
          }),
          { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      }

      // Initialize Supabase client
      const supabase = createClient(supabaseUrl, supabaseServiceKey);

      let payload: WebhookPayload;
      try {
        payload = JSON.parse(rawBody) as WebhookPayload;
      } catch (parseError) {
        console.error('❌ Failed to parse webhook payload:', parseError);
        return new Response(
          JSON.stringify({ error: 'Invalid JSON payload' }),
          { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      }

      const eventType = payload.type;
      const eventData = payload.data;
      const webhookId = req.headers.get('webhook-id') || '';

      console.log(`📋 Webhook payload:`, JSON.stringify(payload, null, 2));

      // Check for duplicate webhook-id (idempotency)
      if (webhookId) {
        const { data: existingEvent } = await supabase
          .from('webhook_events')
          .select('id')
          .eq('webhook_id', webhookId)
          .single();

        if (existingEvent) {
          console.log(`⚠️ Webhook ${webhookId} already processed, skipping (idempotency)`);
          return new Response(
            JSON.stringify({ success: true, message: 'Webhook already processed' }),
            { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
          );
        }
      }

      // Log webhook event with webhook_id for idempotency
      const logResult = await supabase.from('webhook_events').insert([{
        webhook_id: webhookId || null,
        event_type: eventType,
        data: eventData,
        processed: false,
        created_at: new Date().toISOString()
      }]).select('id').single();

      if (logResult.error) {
        console.error('❌ Failed to log webhook event:', logResult.error);
        return new Response(
          JSON.stringify({ error: 'Failed to log webhook event' }),
          { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      }

      const loggedEventId = logResult.data.id;
      console.log('📝 Webhook event logged with ID:', loggedEventId);

      console.log(`🔄 Processing: ${eventType} (${eventData.payload_type || 'unknown payload type'})`);

      try {
        switch (eventType) {
          case 'subscription.active':
            await handleSubscriptionEvent(supabase, payload, 'active');
            break;
          case 'subscription.cancelled':
            await handleSubscriptionEvent(supabase, payload, 'cancelled');
            break;
          case 'subscription.renewed':
            console.log('🔄 Subscription renewed - keeping active status and updating billing date');
            await handleSubscriptionEvent(supabase, payload, 'active');
            break;
          default:
            console.log(`ℹ️ Event ${eventType} logged but not processed (no handler available)`);
        }
        
        const updateResult = await supabase
          .from('webhook_events')
          .update({ 
            processed: true, 
            processed_at: new Date().toISOString() 
          })
          .eq('id', loggedEventId);
        
        if (updateResult.error) {
          console.error('❌ Failed to mark webhook as processed:', updateResult.error);
        } else {
          console.log('✅ Webhook marked as processed');
        }
      } catch (processingError) {
        console.error('❌ Error processing webhook event:', processingError);
        
        await supabase
          .from('webhook_events')
          .update({ 
            processed: false,
            error_message: processingError instanceof Error ? processingError.message : 'Unknown error',
            processed_at: new Date().toISOString()
          })
          .eq('id', loggedEventId);
        
        throw processingError;
      }

      console.log('✅ Webhook processed successfully');

      return new Response(
        JSON.stringify({ 
          success: true, 
          event_type: eventType,
          event_id: loggedEventId
        }),
        { status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );

    } catch (error) {
      console.error('❌ Webhook processing failed:', error);
      return new Response(
        JSON.stringify({ 
          error: 'Webhook processing failed',
          details: error instanceof Error ? error.message : 'Unknown error'
        }),
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }
  });
  ```
</CodeGroup>

## How It Works

The Deno-based Edge Function:

1. **Verifies signature** - Uses dodopayments library for HMAC-SHA256 verification
2. **Checks idempotency** - Looks up webhook ID to prevent duplicate processing
3. **Logs the event** - Stores raw webhook data in `webhook_events` table
4. **Processes updates** - Creates or updates customers and subscriptions via Supabase client
5. **Handles errors** - Logs failures and marks event for retry

## Testing

**Local development:**

```bash theme={null}
cd supabase
npm run dev
# Available at http://localhost:54321/functions/v1/webhook
```

<Note>
  The `--no-verify-jwt` flag is required because webhooks don't include JWT tokens. Security is provided by webhook signature verification.
</Note>

**View logs:**

```bash theme={null}
npx supabase functions logs webhook
```

Or in [Supabase Dashboard](https://supabase.com/dashboard) → Edge Functions → webhook → Logs tab

**Configure in DodoPayments Dashboard:**

1. Go to Developers → Webhooks
2. Add endpoint with your Supabase URL
3. Enable: subscription.active, subscription.cancelled, subscription.renewed

## Common Issues

| Issue                     | Solution                                                 |
| ------------------------- | -------------------------------------------------------- |
| Verification failed       | Check webhook key is correct from DodoPayments dashboard |
| Database permission error | Ensure using Service Role Key                            |
| JWT verification error    | Deploy with `--no-verify-jwt` flag                       |
| Function not found        | Verify project ref is correct and function is deployed   |

## Resources

* [Supabase Edge Functions Docs](https://supabase.com/docs/guides/functions)
* [Supabase CLI](https://supabase.com/docs/reference/cli)
* [Deno Runtime](https://deno.land/)
* [Webhook Events Guide](/developer-resources/webhooks/intents/webhook-events-guide)
* [GitHub Repo](https://github.com/dodopayments/cloud-functions/tree/main/supabase)


# Vercel Functions
Source: https://docs.dodopayments.com/developer-resources/webhooks/examples/vercel-example

Deploy DodoPayments webhooks to Vercel

<Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/cloud-functions/tree/main/vercel">
  Complete source code and setup guide
</Card>

## Quick Setup

### 1. Prerequisites

* [Vercel account](https://vercel.com/signup)
* [Neon database](https://neon.com) account
* DodoPayments API key from [dashboard](https://app.dodopayments.com/)

### 2. Install Dependencies

```bash theme={null}
npm install -g vercel
vercel login
git clone https://github.com/dodopayments/cloud-functions.git
cd cloud-functions/vercel
npm install
```

### 3. Database Setup

1. Sign up for [Neon](https://neon.com)
2. Create a new project
3. Open the SQL Editor
4. Copy and paste the contents of [`schema.sql`](#database-schema)
5. Run the query
6. Get your connection string from Neon → Connection Details

### 4. Set Initial Environment Variables

Via Vercel CLI:

```bash theme={null}
vercel env add DATABASE_URL
vercel env add DODO_PAYMENTS_API_KEY
```

> **Note:** We'll set `DODO_PAYMENTS_WEBHOOK_KEY` after deployment once you have your webhook URL.

### 5. Deploy

```bash theme={null}
npm run deploy
```

### 6. Get Your Webhook URL

Your webhook URL is:

```
https://[your-project].vercel.app/api/webhook
```

### 7. Register Webhook in DodoPayments Dashboard

1. Go to [DodoPayments Dashboard](https://app.dodopayments.com) → Developer → Webhooks
2. Create a new webhook endpoint
3. Configure your webhook URL as the endpoint
4. Enable these subscription events:
   * `subscription.active`
   * `subscription.cancelled`
   * `subscription.renewed`
5. Copy the **Signing Secret**

### 8. Set Webhook Key & Redeploy

```bash theme={null}
vercel env add DODO_PAYMENTS_WEBHOOK_KEY
npm run deploy
```

## What It Does

Processes subscription events and stores them in PostgreSQL:

* **subscription.active** - Creates/updates customer and subscription records
* **subscription.cancelled** - Marks subscription as cancelled
* **subscription.renewed** - Updates next billing date

## Key Features

✅ **Signature verification** - Using the dodopayments library\
✅ **Idempotency** - Prevents duplicate processing with webhook IDs\
✅ **Event logging** - Complete audit trail in `webhook_events` table\
✅ **Error handling** - Logged and retryable

> **Note:** This implementation demonstrates handling three core subscription events (`subscription.active`, `subscription.cancelled`, `subscription.renewed`) with minimal fields. You can easily extend it to support additional event types and fields based on your requirements.

## Configuration Files

<CodeGroup>
  ```json package.json theme={null}
  {
    "name": "dodo-webhook-vercel",
    "version": "1.0.0",
    "type": "module",
    "description": "DodoPayments Webhook Handler for Vercel",
    "scripts": {
      "start": "vercel dev",
      "deploy": "vercel --prod"
    },
    "dependencies": {
      "@neondatabase/serverless": "^1.0.2",
      "dodopayments": "^2.4.1"
    },
    "devDependencies": {
      "typescript": "^5.9.3",
      "vercel": "^48.4.1"
    }
  }
  ```

  ```json tsconfig.json theme={null}
  {
    "compilerOptions": {
      "target": "ES2022",
      "module": "ES2022",
      "lib": ["ES2022"],
      "moduleResolution": "node",
      "esModuleInterop": true,
      "strict": true,
      "skipLibCheck": true,
      "resolveJsonModule": true,
      "allowSyntheticDefaultImports": true,
      "forceConsistentCasingInFileNames": true,
      "isolatedModules": true,
      "types": ["node"]
    },
    "include": ["api/**/*.ts"],
    "exclude": ["node_modules"]
  }
  ```
</CodeGroup>

## Database Schema

<CodeGroup>
  ```sql schema.sql expandable theme={null}
  -- DodoPayments Webhook Database Schema
  -- Compatible with PostgreSQL (Supabase, Neon, etc.)

  -- Enable UUID extension (if not already enabled)
  CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

  -- Customers table
  CREATE TABLE IF NOT EXISTS customers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT NOT NULL,
    name TEXT NOT NULL,
    dodo_customer_id TEXT UNIQUE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
  );

  -- Subscriptions table
  CREATE TABLE IF NOT EXISTS subscriptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    customer_id UUID NOT NULL REFERENCES customers(id) ON DELETE CASCADE,
    dodo_subscription_id TEXT UNIQUE NOT NULL,
    product_id TEXT NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('pending', 'active', 'on_hold', 'cancelled', 'failed', 'expired')),
    billing_interval TEXT NOT NULL CHECK (billing_interval IN ('day', 'week', 'month', 'year')),
    amount INTEGER NOT NULL,
    currency TEXT NOT NULL,
    next_billing_date TIMESTAMP WITH TIME ZONE NOT NULL,
    cancelled_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
  );

  -- Webhook events log
  CREATE TABLE IF NOT EXISTS webhook_events (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    webhook_id TEXT UNIQUE,
    event_type TEXT NOT NULL,
    data JSONB NOT NULL,
    processed BOOLEAN DEFAULT FALSE,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed_at TIMESTAMP WITH TIME ZONE,
    attempts INTEGER DEFAULT 0
  );

  -- Indexes for better query performance
  CREATE INDEX IF NOT EXISTS idx_customers_email ON customers(email);
  CREATE INDEX IF NOT EXISTS idx_customers_dodo_id ON customers(dodo_customer_id);
  CREATE INDEX IF NOT EXISTS idx_subscriptions_dodo_id ON subscriptions(dodo_subscription_id);
  CREATE INDEX IF NOT EXISTS idx_subscriptions_customer_id ON subscriptions(customer_id);
  CREATE INDEX IF NOT EXISTS idx_subscriptions_status ON subscriptions(status);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_processed ON webhook_events(processed, created_at);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_type ON webhook_events(event_type);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_created_at ON webhook_events(created_at DESC);
  CREATE INDEX IF NOT EXISTS idx_webhook_events_webhook_id ON webhook_events(webhook_id);

  -- Function to automatically update updated_at timestamp
  CREATE OR REPLACE FUNCTION update_updated_at_column()
  RETURNS TRIGGER AS $$
  BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;

  -- Triggers to automatically update updated_at
  CREATE TRIGGER update_customers_updated_at
    BEFORE UPDATE ON customers
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

  CREATE TRIGGER update_subscriptions_updated_at
    BEFORE UPDATE ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

  -- Comments for documentation
  COMMENT ON TABLE customers IS 'Stores customer information from DodoPayments';
  COMMENT ON TABLE subscriptions IS 'Stores subscription data from DodoPayments';
  COMMENT ON TABLE webhook_events IS 'Logs all incoming webhook events for audit and retry purposes';

  COMMENT ON COLUMN customers.dodo_customer_id IS 'Unique customer ID from DodoPayments';
  COMMENT ON COLUMN subscriptions.dodo_subscription_id IS 'Unique subscription ID from DodoPayments';
  COMMENT ON COLUMN subscriptions.amount IS 'Amount in smallest currency unit (e.g., cents)';
  COMMENT ON COLUMN subscriptions.currency IS 'Currency used for the subscription payments (e.g., USD, EUR, INR)';
  COMMENT ON COLUMN webhook_events.attempts IS 'Number of processing attempts for failed webhooks';
  COMMENT ON COLUMN webhook_events.data IS 'Full webhook payload as JSON';
  ```
</CodeGroup>

**Tables created:**

* **customers** - Email, name, dodo\_customer\_id
* **subscriptions** - Status, amount, next\_billing\_date, linked to customers
* **webhook\_events** - Event log with webhook\_id for idempotency

## Implementation Code

<CodeGroup>
  ```typescript api/webhook/index.ts expandable theme={null}
  import { neon, NeonQueryFunction } from '@neondatabase/serverless';
  import { DodoPayments } from 'dodopayments';

  interface WebhookPayload {
    business_id: string;
    type: string;
    timestamp: string;
    data: {
      payload_type: "Payment" | "Subscription" | "Refund" | "Dispute" | "LicenseKey";
      subscription_id: string;
      customer: {
        customer_id: string;
        email: string;
        name: string;
      };
      product_id: string;
      status: string;
      recurring_pre_tax_amount: number;
      payment_frequency_interval: string;
      created_at: string;
      next_billing_date: string;
      cancelled_at?: string | null;
      currency: string;
    };
  }

  // Disable body parsing to access raw body for webhook verification
  export const config = {
    api: {
      bodyParser: false,
    },
  };

  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type, webhook-id, webhook-signature, webhook-timestamp',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
  };

  // Helper function for JSON responses
  function jsonResponse(data: unknown, status: number = 200) {
    return new Response(JSON.stringify(data), {
      status,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }

  // Handle subscription events
  async function handleSubscriptionEvent(sql: NeonQueryFunction<false, false>, payload: WebhookPayload, status: string) {
    if (!payload.data.customer.customer_id || !payload.data.subscription_id) {
      throw new Error('Missing required fields: customer_id or subscription_id');
    }

    console.log('🔄 Processing subscription event:', JSON.stringify(payload, null, 2));

    const customer = payload.data.customer;

    // Upsert customer (create if doesn't exist, otherwise use existing)
    const customerResult = await sql`
      INSERT INTO customers (email, name, dodo_customer_id, created_at)
      VALUES (${customer.email}, ${customer.name}, ${customer.customer_id}, ${new Date().toISOString()})
      ON CONFLICT (dodo_customer_id) 
      DO UPDATE SET 
        email = EXCLUDED.email,
        name = EXCLUDED.name,
        updated_at = ${new Date().toISOString()}
      RETURNING id
    `;

    const customerId = customerResult[0].id;
    console.log(`✅ Customer upserted with ID: ${customerId}`);

    // Upsert subscription
    await sql`
      INSERT INTO subscriptions (
        customer_id, dodo_subscription_id, product_id, status, 
        billing_interval, amount, currency, created_at, next_billing_date, cancelled_at, updated_at
      )
      VALUES (
        ${customerId}, ${payload.data.subscription_id},
        ${payload.data.product_id}, ${status},
        ${payload.data.payment_frequency_interval.toLowerCase()}, ${payload.data.recurring_pre_tax_amount},
        ${payload.data.currency}, ${payload.data.created_at}, ${payload.data.next_billing_date},
        ${payload.data.cancelled_at ?? null}, ${new Date().toISOString()}
      )
      ON CONFLICT (dodo_subscription_id) 
      DO UPDATE SET 
        customer_id = EXCLUDED.customer_id,
        product_id = EXCLUDED.product_id,
        status = EXCLUDED.status,
        billing_interval = EXCLUDED.billing_interval,
        amount = EXCLUDED.amount,
        currency = EXCLUDED.currency,
        created_at = EXCLUDED.created_at,
        next_billing_date = EXCLUDED.next_billing_date,
        cancelled_at = EXCLUDED.cancelled_at,
        updated_at = EXCLUDED.updated_at
    `;

    console.log(`✅ Subscription upserted with ${status} status`)
  }

  // Handle CORS preflight
  export async function OPTIONS() {
    return new Response('ok', { 
      status: 200,
      headers: corsHeaders 
    });
  }

  // Handle webhook POST request
  export async function POST(req: Request) {
    try {
      // Get raw body for webhook signature verification
      const rawBody = await req.text();
      
      console.log('📨 Webhook received');

      const DATABASE_URL = process.env.DATABASE_URL;
      const API_KEY = process.env.DODO_PAYMENTS_API_KEY;
      const WEBHOOK_KEY = process.env.DODO_PAYMENTS_WEBHOOK_KEY;

      if (!DATABASE_URL) {
        console.error('❌ Missing DATABASE_URL environment variable');
        return jsonResponse({ error: 'Server configuration error' }, 500);
      }

      // Verify required environment variables
      if (!API_KEY) {
        console.error('❌ DODO_PAYMENTS_API_KEY is not configured');
        return jsonResponse({ error: 'API key not configured' }, 500);
      }

      if (!WEBHOOK_KEY) {
        console.error('❌ DODO_PAYMENTS_WEBHOOK_KEY is not configured');
        return jsonResponse({ error: 'Webhook verification key not configured' }, 500);
      }

      // Verify webhook signature (required for security)
      const webhookHeaders = {
        'webhook-id': req.headers.get('webhook-id') || '',
        'webhook-signature': req.headers.get('webhook-signature') || '',
        'webhook-timestamp': req.headers.get('webhook-timestamp') || '',
      };

      try {
        const dodoPaymentsClient = new DodoPayments({
          bearerToken: API_KEY,
          webhookKey: WEBHOOK_KEY,
        });
        const unwrappedWebhook = dodoPaymentsClient.webhooks.unwrap(rawBody, { headers: webhookHeaders });
        console.log('Unwrapped webhook:', unwrappedWebhook);
        console.log('✅ Webhook signature verified');
      } catch (error) {
        console.error('❌ Webhook verification failed:', error);
        return jsonResponse({ error: 'Webhook verification failed' }, 401);
      }

      // Initialize Neon client
      const sql = neon(DATABASE_URL);

      const payload: WebhookPayload = JSON.parse(rawBody);
      const eventType = payload.type;
      const eventData = payload.data;
      const webhookId = req.headers.get('webhook-id') || '';

      console.log(`📋 Webhook payload:`, JSON.stringify(payload, null, 2));

      // Check for duplicate webhook-id (idempotency)
      if (webhookId) {
        const existingEvent = await sql`
          SELECT id FROM webhook_events WHERE webhook_id = ${webhookId}
        `;

        if (existingEvent.length > 0) {
          console.log(`⚠️ Webhook ${webhookId} already processed, skipping (idempotency)`);
          return jsonResponse({ success: true, message: 'Webhook already processed' });
        }
      }

      // Log webhook event with webhook_id for idempotency
      const logResult = await sql`
        INSERT INTO webhook_events (webhook_id, event_type, data, processed, created_at)
        VALUES (${webhookId || null}, ${eventType}, ${JSON.stringify(eventData)}, ${false}, ${new Date().toISOString()})
        RETURNING id
      `;

      const loggedEventId = logResult[0].id;
      console.log('📝 Webhook event logged with ID:', loggedEventId);

      console.log(`🔄 Processing: ${eventType} (${eventData.payload_type || 'unknown payload type'})`);

      try {
        switch (eventType) {
          case 'subscription.active':
            await handleSubscriptionEvent(sql, payload, 'active');
            break;
          case 'subscription.cancelled':
            await handleSubscriptionEvent(sql, payload, 'cancelled');
            break;
          case 'subscription.renewed':
            console.log('🔄 Subscription renewed - keeping active status and updating billing date');
            await handleSubscriptionEvent(sql, payload, 'active');
            break;
          default:
            console.log(`ℹ️ Event ${eventType} logged but not processed (no handler available)`);
        }

        await sql`
          UPDATE webhook_events 
          SET processed = ${true}, processed_at = ${new Date().toISOString()}
          WHERE id = ${loggedEventId}
        `;

        console.log('✅ Webhook marked as processed');
      } catch (processingError) {
        console.error('❌ Error processing webhook event:', processingError);

        await sql`
          UPDATE webhook_events 
          SET processed = ${false}, 
              error_message = ${processingError instanceof Error ? processingError.message : 'Unknown error'},
              processed_at = ${new Date().toISOString()}
          WHERE id = ${loggedEventId}
        `;

        throw processingError;
      }

      console.log('✅ Webhook processed successfully');

      return jsonResponse({
        success: true,
        event_type: eventType,
        event_id: loggedEventId
      });

    } catch (error) {
      console.error('❌ Webhook processing failed:', error);
      return jsonResponse({
        error: 'Webhook processing failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      }, 500);
    }
  }
  ```
</CodeGroup>

## How It Works

The webhook handler:

1. **Disables body parsing** - To access raw body for signature verification
2. **Verifies the signature** - Ensures the request is from DodoPayments using HMAC-SHA256
3. **Checks for duplicates** - Uses webhook ID to prevent processing the same event twice
4. **Logs the event** - Stores raw webhook in `webhook_events` table for audit trail
5. **Processes the event** - Creates or updates customers and subscriptions in Neon
6. **Handles errors** - Logs failures and marks event as unprocessed for retry

## Testing

**Local development:**

```bash theme={null}
npm start
```

**View logs in Vercel Dashboard:**

1. Select your project
2. Go to **Deployments** → latest deployment
3. Click **Functions** → **Logs**

**Configure in DodoPayments Dashboard:**

1. Go to Developers → Webhooks
2. Add endpoint with your Vercel Functions URL
3. Enable: subscription.active, subscription.cancelled, subscription.renewed

## Common Issues

| Issue                     | Solution                                                            |
| ------------------------- | ------------------------------------------------------------------- |
| Verification failed       | Check webhook key is correct from DodoPayments dashboard            |
| Database connection error | Verify Neon connection string and use pooled connection             |
| Function timeout          | Optimize queries; Pro plan has longer timeout (60s)                 |
| Env vars not available    | Set in dashboard or CLI, ensure all environments selected, redeploy |

## Resources

* [Vercel Functions Docs](https://vercel.com/docs/functions)
* [Vercel CLI](https://vercel.com/docs/cli)
* [Neon Docs](https://neon.com/docs/)
* [Webhook Events Guide](/developer-resources/webhooks/intents/webhook-events-guide)
* [GitHub Repo](https://github.com/dodopayments/cloud-functions/tree/main/vercel)


# Dispute
Source: https://docs.dodopayments.com/developer-resources/webhooks/intents/dispute

The payload sent to your webhook endpoint when a dispute is created or updated.



# License Key
Source: https://docs.dodopayments.com/developer-resources/webhooks/intents/license-key

The payload sent to your webhook endpoint when a license key is created or updated.



# Payment
Source: https://docs.dodopayments.com/developer-resources/webhooks/intents/payment

The payload sent to your webhook endpoint when a payment is created or updated.



# Refund
Source: https://docs.dodopayments.com/developer-resources/webhooks/intents/refund

The payload sent to your webhook endpoint when a refund is created or updated.



# Subscription
Source: https://docs.dodopayments.com/developer-resources/webhooks/intents/subscription

The payload sent to your webhook endpoint when a subscription is created, updated, or changes state.

## Subscription Webhook Events

The following webhook events are available for tracking subscription lifecycle changes:

| Event                       | Description                                                            |
| --------------------------- | ---------------------------------------------------------------------- |
| `subscription.active`       | Subscription is successfully activated                                 |
| `subscription.updated`      | Subscription object was updated (any field change triggers this event) |
| `subscription.on_hold`      | Subscription is put on hold due to failed renewal                      |
| `subscription.renewed`      | Subscription is renewed for the next billing period                    |
| `subscription.plan_changed` | Subscription plan was upgraded, downgraded, or modified                |
| `subscription.cancelled`    | Subscription is cancelled                                              |
| `subscription.failed`       | Subscription creation failed during mandate creation                   |
| `subscription.expired`      | Subscription reached the end of its term                               |

### Using `subscription.updated` for Real-Time Sync

The `subscription.updated` webhook fires whenever any subscription field changes, allowing you to keep your application state in sync without polling:

```javascript theme={null}
app.post('/webhooks/dodo', async (req, res) => {
  const event = req.body;
  
  if (event.type === 'subscription.updated') {
    const subscription = event.data;
    
    // Sync subscription changes to your database
    await syncSubscription(subscription.subscription_id, {
      status: subscription.status,
      next_billing_date: subscription.next_billing_date,
      metadata: subscription.metadata,
      // ... other fields you want to track
    });
    
    console.log(`Subscription ${subscription.subscription_id} updated`);
  }
  
  res.json({ received: true });
});
```

<Tip>
  Subscribe to `subscription.updated` to get real-time notifications about any subscription changes, eliminating the need to poll the API for updates.
</Tip>

## Webhook Payload Schema


# Webhook Event Guide
Source: https://docs.dodopayments.com/developer-resources/webhooks/intents/webhook-events-guide

Understand the different webhook events triggered by Dodo Payments during payment, refund, subscription, dispute, and license key activities

Dodo Payments provides real-time webhook notifications to keep you informed about critical events related to transactions, subscriptions, refunds, disputes, and license key management. Below is a detailed guide to these events, categorized for clarity, along with implementation tips and considerations.

## **Payment Events**

| **Event Name**         | **Event Type**       | **Description**                                                                     |
| ---------------------- | -------------------- | ----------------------------------------------------------------------------------- |
| **Payment Succeeded**  | `payment.succeeded`  | Triggered when a payment is successfully processed.                                 |
| **Payment Failed**     | `payment.failed`     | Occurs when a payment attempt fails due to errors, declined cards, or other issues. |
| **Payment Processing** | `payment.processing` | Indicates that a payment is currently being processed.                              |
| **Payment Cancelled**  | `payment.cancelled`  | Triggered when a payment is cancelled before completion.                            |

## **Refund Events**

| **Event Name**       | **Event Type**     | **Description**                                                              |
| -------------------- | ------------------ | ---------------------------------------------------------------------------- |
| **Refund Succeeded** | `refund.succeeded` | Triggered when a refund is successfully processed.                           |
| **Refund Failed**    | `refund.failed`    | Occurs when a refund attempt fails due to processing errors or other issues. |

## **Dispute Events**

| **Event Name**         | **Event Type**       | **Description**                                               |
| ---------------------- | -------------------- | ------------------------------------------------------------- |
| **Dispute Opened**     | `dispute.opened`     | Triggered when a customer initiates a dispute.                |
| **Dispute Expired**    | `dispute.expired`    | Indicates that a dispute expired without resolution.          |
| **Dispute Accepted**   | `dispute.accepted`   | Triggered when a merchant accepts the dispute.                |
| **Dispute Cancelled**  | `dispute.cancelled`  | Occurs when a dispute is cancelled by the customer or system. |
| **Dispute Challenged** | `dispute.challenged` | Triggered when a merchant challenges a dispute.               |
| **Dispute Won**        | `dispute.won`        | Indicates that the merchant has successfully won a dispute.   |
| **Dispute Lost**       | `dispute.lost`       | Occurs when the merchant loses a dispute.                     |

## **Subscription Events**

| **Event Name**                | **Event Type**              | **Description**                                                                           |
| ----------------------------- | --------------------------- | ----------------------------------------------------------------------------------------- |
| **Subscription Active**       | `subscription.active`       | Indicates that a subscription is now active and recurring charges are scheduled.          |
| **Subscription Updated**      | `subscription.updated`      | Triggered when any subscription field is updated (real-time sync without polling).        |
| **Subscription On Hold**      | `subscription.on_hold`      | Triggered when a subscription is temporarily put on hold due to failed renewal.           |
| **Subscription Renewed**      | `subscription.renewed`      | Occurs when a subscription is successfully renewed.                                       |
| **Subscription Plan Changed** | `subscription.plan_changed` | Triggered when a subscription is upgraded, downgraded, or modified with different addons. |
| **Subscription Cancelled**    | `subscription.cancelled`    | Triggered when a subscription is cancelled by the merchant or customer.                   |
| **Subscription Failed**       | `subscription.failed`       | Indicates a failed subscription. This means that we were unable to create a mandate.      |
| **Subscription Expired**      | `subscription.expired`      | Triggered when a subscription reaches the end of its term and expires.                    |

## **License Key Events**

| **Event Name**          | **Event Type**        | **Description**                                            |
| ----------------------- | --------------------- | ---------------------------------------------------------- |
| **License Key Created** | `license_key.created` | Triggered when a new license key is created for a product. |

These webhook events are designed to provide merchants with critical updates to manage their operations effectively. Implement robust handlers for each relevant event in your webhook integration to ensure smooth and reliable functionality.


# Balances
Source: https://docs.dodopayments.com/features/account-summary-payout-wallet

Track your financial activity across multi-currency wallets with comprehensive transaction ledgers, including payments, refunds, fees, and payouts in USD, GBP, EUR, and INR.

## Introduction

The **Balances** section provides merchants with a comprehensive overview of their financial activity across all currencies. It includes every transaction type - payments, refunds, fees, taxes, and payouts - ensuring full visibility into both earnings and deductions.

## Key Details

<Frame>
  <img alt="Balances dashboard showing wallet overview and transaction ledger" />
</Frame>

## Wallet Structure

Each business account maintains **four native wallets** based on supported payout currencies:

| Wallet     | Currency Code |
| ---------- | ------------- |
| USD Wallet | USD           |
| GBP Wallet | GBP           |
| EUR Wallet | EUR           |
| INR Wallet | INR           |

### Wallet Logic

* Merchant sales are **credited to the appropriate wallet** based on the **customer's payment currency** and **geographic location**.
* This system optimizes for **payment processor efficiency**, **reduced transaction fees** and **lower currency conversion charges**.

## Balance Ledger

Each wallet has an **independent ledger** recording all related financial activity - payments, refunds, fees, and payouts - in that specific wallet's currency.

A **Consolidated Ledger** combines all wallet data, offering a unified view of the merchant's entire financial history.

### Filters and Navigation

* **Currency Filter:** Allows merchants to view transactions by specific wallet (USD, INR, GBP, EUR).
* **All Transactions View:** Provides an aggregated view across all wallets with unified sorting, filtering, and search capabilities.

### Transaction Types

The following transaction types are recorded in the Balance ledger:

| Transaction Type     | Symbol     | Description                                       |
| -------------------- | ---------- | ------------------------------------------------- |
| **Payment**          | Credit (+) | Successful customer payment                       |
| **Refund**           | Debit (-)  | Returned amount to the customer                   |
| **Transaction Fees** | Debit (-)  | Processing fees applied to payments               |
| **Refund Fees**      | Debit (-)  | Fees deducted for processing refunds              |
| **Sales Tax**        | Debit (-)  | Tax amount charged on payments                    |
| **Sales Tax Refund** | Credit (+) | Refunded portion of sales tax on refunds          |
| **Payout**           | Debit (-)  | Amount transferred to the merchant's bank account |
| **Payout Fees**      | Debit (-)  | Transaction fees deducted from payouts            |

#### Additional Fields

* **Transaction Amount:** Total value associated with the transaction.
* **Transaction Timestamp:** Date and time of transaction completion.
* **Transaction ID:** Unique identifier for tracking and support purposes.

## Total Balance

The **Total Balance** section shows a **consolidated indicative amount** of all wallet balances - **USD, GBP, and EUR** - after conversion to USD.

<Note>
  **Indicative Display:** The displayed amount is **for reference only**. Final payout amounts may vary based on the actual exchange rate at the time of transfer.
</Note>

## Conclusion

The **Balances** aims to deliver **transparency, accuracy, and flexibility** in managing multi-currency funds.

By maintaining separate native wallets, providing currency-based filters, and enabling indicative consolidated views, Dodo Payments ensures merchants always have a clear understanding of their earnings and payout readiness.

<Tip>
  For any discrepancies or clarifications, please reach out to **[support@dodopayments.com](mailto:support@dodopayments.com)** with your **Transaction ID** and issue details.
</Tip>


# Adaptive Currency
Source: https://docs.dodopayments.com/features/adaptive-currency

Display prices in each customer's local currency to reduce friction and improve conversion. Automatic detection, conversion, and same‑currency refunds.

<Info>
  Adaptive Currency lets you show localized prices and accept payments in customers' local currencies. This reduces friction at checkout and builds trust.
</Info>

## What Is Adaptive Currency?

Adaptive Currency displays product prices in the customer's local currency instead of a fixed global currency (for example, USD). When enabled, checkout defaults to the detected local currency for supported countries, with the option to switch to USD.

## Key Benefits

* **Localized payment experience**: Prices appear in local currency by default.
* **More payment methods**: Unlocks payment methods available for the local currency.
* **Same‑currency refunds**: Refund the customer in the currency they paid with.

## Enable Adaptive Currency

<Steps>
  <Step title="Open Business Settings">
    Log in to your Merchant Dashboard and go to Business → Business Settings.
  </Step>

  <Step title="Toggle Adaptive Pricing">
    Enable the Adaptive Pricing toggle. You can disable it at any time.

    <Warning>
      Changes apply only to future transactions.
    </Warning>
  </Step>

  <Step title="Confirm and Save">
    Save your settings.

    <Check>
      Verify a test checkout shows prices in your local currency when supported.
    </Check>
  </Step>
</Steps>

<Frame>
  <img alt="Adaptive Currency" />
</Frame>

## Customer Experience

1. **Detection**: The system detects the customer's country based on the billing address.
2. **Currency selection**: If the country is supported, prices show in the local currency by default. Customers can switch to USD.
3. **Payment methods**: Localized payment methods appear where applicable.
4. **Checkout**: Payment is completed in the selected currency.

## Conversion and Fees

Adaptive Currency charges the customer in their local currency using the latest exchange rates.

* **You pay**: 0%
* **Your customers pay**: 2–4% based on order value

Tiered fees applied at checkout:

* 4% for orders under \$500
* 3% for 500 to \$1,500
* 2% for over \$1,500

<Info>
  Adaptive Currency fees are borne by the customer, not the merchant.
</Info>

## Supported Currencies

| Currency Code | Currency Name                       | Countries                                                                                                                                                                                                    | Minimum Amount |
| ------------- | ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------- |
| AED           | UAE Dirham                          | United Arab Emirates                                                                                                                                                                                         | 2.00 AED       |
| ALL           | Albanian Lek                        | Albania                                                                                                                                                                                                      | 50.00 ALL      |
| AMD           | Armenian Dram                       | Armenia                                                                                                                                                                                                      | 500.00 AMD     |
| ARS           | Argentine Peso                      | Argentina                                                                                                                                                                                                    | 1000.00 ARS    |
| AUD           | Australian Dollar                   | Australia, Nauru                                                                                                                                                                                             | 0.50 AUD       |
| AWG           | Aruban Florin                       | Aruba                                                                                                                                                                                                        | 2.00 AWG       |
| AZN           | Azerbaijani Manat                   | Azerbaijan                                                                                                                                                                                                   | 2.00 AZN       |
| BAM           | Bosnia-Herzegovina Convertible Mark | Bosnia and Herzegovina                                                                                                                                                                                       | 2.00 BAM       |
| BDT           | Bangladeshi Taka                    | Bangladesh                                                                                                                                                                                                   | 100.00 BDT     |
| BMD           | Bermudian Dollar                    | Bermuda                                                                                                                                                                                                      | 1.00 BMD       |
| BND           | Brunei Dollar                       | Brunei                                                                                                                                                                                                       | 1.00 BND       |
| BOB           | Bolivian Boliviano                  | Bolivia                                                                                                                                                                                                      | 5.00 BOB       |
| BRL           | Brazilian Real                      | Brazil                                                                                                                                                                                                       | 0.50 BRL       |
| BSD           | Bahamian Dollar                     | Bahamas                                                                                                                                                                                                      | 1.00 BSD       |
| BWP           | Botswanan Pula                      | Botswana                                                                                                                                                                                                     | 15.00 BWP      |
| BZD           | Belize Dollar                       | Belize                                                                                                                                                                                                       | 2.00 BZD       |
| CAD           | Canadian Dollar                     | Canada                                                                                                                                                                                                       | 0.50 CAD       |
| CHF           | Swiss Franc                         | Switzerland, Liechtenstein                                                                                                                                                                                   | 0.50 CHF       |
| CLP           | Chilean Peso                        | Chile                                                                                                                                                                                                        | 1000.00 CLP    |
| CNY           | Chinese Yuan                        | China                                                                                                                                                                                                        | 4.00 CNY       |
| CRC           | Costa Rican Colón                   | Costa Rica                                                                                                                                                                                                   | 500.00 CRC     |
| CZK           | Czech Koruna                        | Czech Republic                                                                                                                                                                                               | 15.00 CZK      |
| DKK           | Danish Krone                        | Denmark, Greenland                                                                                                                                                                                           | 2.50 DKK       |
| DOP           | Dominican Peso                      | Dominican Republic                                                                                                                                                                                           | 100.00 DOP     |
| EGP           | Egyptian Pound                      | Egypt                                                                                                                                                                                                        | 50.00 EGP      |
| ETB           | Ethiopian Birr                      | Ethiopia                                                                                                                                                                                                     | 100.00 ETB     |
| EUR           | Euro                                | Austria, Belgium, Cyprus, Estonia, Finland, France, Germany, Greece, Ireland, Italy, Latvia, Lithuania, Luxembourg, Malta, Netherlands, Portugal, Slovakia, Slovenia, Spain, Andorra, San Marino, Montenegro | 0.50 EUR       |
| FJD           | Fijian Dollar                       | Fiji                                                                                                                                                                                                         | 2.00 FJD       |
| GBP           | British Pound                       | United Kingdom                                                                                                                                                                                               | 0.30 GBP       |
| GEL           | Georgian Lari                       | Georgia                                                                                                                                                                                                      | 3.00 GEL       |
| GMD           | Gambian Dalasi                      | Gambia                                                                                                                                                                                                       | 100.00 GMD     |
| GTQ           | Guatemalan Quetzal                  | Guatemala                                                                                                                                                                                                    | 10.00 GTQ      |
| GYD           | Guyanese Dollar                     | Guyana                                                                                                                                                                                                       | 200.00 GYD     |
| HKD           | Hong Kong Dollar                    | Hong Kong                                                                                                                                                                                                    | 4.00 HKD       |
| HNL           | Honduran Lempira                    | Honduras                                                                                                                                                                                                     | 25.00 HNL      |
| HUF           | Hungarian Forint                    | Hungary                                                                                                                                                                                                      | 175.00 HUF     |
| IDR           | Indonesian Rupiah                   | Indonesia                                                                                                                                                                                                    | 8500.00 IDR    |
| ILS           | Israeli New Shekel                  | Israel                                                                                                                                                                                                       | 3.00 ILS       |
| INR           | Indian Rupee                        | India                                                                                                                                                                                                        | 5.00 INR       |
| KZT           | Kazakhstani Tenge                   | Kazakhstan                                                                                                                                                                                                   | 500.00 KZT     |
| LKR           | Sri Lankan Rupee                    | Sri Lanka                                                                                                                                                                                                    | 300.00 LKR     |
| LRD           | Liberian Dollar                     | Liberia                                                                                                                                                                                                      | 200.00 LRD     |
| LSL           | Lesotho Loti                        | Lesotho                                                                                                                                                                                                      | 20.00 LSL      |
| MAD           | Moroccan Dirham                     | Morocco                                                                                                                                                                                                      | 10.00 MAD      |
| MKD           | Macedonian Denar                    | North Macedonia                                                                                                                                                                                              | 50.00 MKD      |
| MOP           | Macanese Pataca                     | Macau                                                                                                                                                                                                        | 10.00 MOP      |
| MUR           | Mauritian Rupee                     | Mauritius                                                                                                                                                                                                    | 50.00 MUR      |
| MVR           | Maldivian Rufiyaa                   | Maldives                                                                                                                                                                                                     | 15.00 MVR      |
| MWK           | Malawian Kwacha                     | Malawi                                                                                                                                                                                                       | 2000.00 MWK    |
| MXN           | Mexican Peso                        | Mexico                                                                                                                                                                                                       | 10.00 MXN      |
| MYR           | Malaysian Ringgit                   | Malaysia                                                                                                                                                                                                     | 4.00 MYR       |
| NGN           | Nigerian Naira                      | Nigeria                                                                                                                                                                                                      | 2000.00 NGN    |
| NOK           | Norwegian Krone                     | Norway                                                                                                                                                                                                       | 3.00 NOK       |
| NPR           | Nepalese Rupee                      | Nepal                                                                                                                                                                                                        | 150.00 NPR     |
| NZD           | New Zealand Dollar                  | New Zealand                                                                                                                                                                                                  | 1.00 NZD       |
| PEN           | Peruvian Sol                        | Peru                                                                                                                                                                                                         | 3.00 PEN       |
| PGK           | Papua New Guinean Kina              | Papua New Guinea                                                                                                                                                                                             | 4.00 PGK       |
| PHP           | Philippine Peso                     | Philippines                                                                                                                                                                                                  | 50.00 PHP      |
| PLN           | Polish Zloty                        | Poland                                                                                                                                                                                                       | 2.00 PLN       |
| QAR           | Qatari Rial                         | Qatar                                                                                                                                                                                                        | 3.00 QAR       |
| RON           | Romanian Leu                        | Romania                                                                                                                                                                                                      | 2.00 RON       |
| RSD           | Serbian Dinar                       | Serbia                                                                                                                                                                                                       | 60.00 RSD      |
| SAR           | Saudi Riyal                         | Saudi Arabia                                                                                                                                                                                                 | 2.00 SAR       |
| SBD           | Solomon Islands Dollar              | Solomon Islands                                                                                                                                                                                              | 10.00 SBD      |
| SCR           | Seychellois Rupee                   | Seychelles                                                                                                                                                                                                   | 15.00 SCR      |
| SEK           | Swedish Krona                       | Sweden                                                                                                                                                                                                       | 3.00 SEK       |
| SGD           | Singapore Dollar                    | Singapore                                                                                                                                                                                                    | 0.50 SGD       |
| SZL           | Swazi Lilangeni                     | Eswatini                                                                                                                                                                                                     | 20.00 SZL      |
| THB           | Thai Baht                           | Thailand                                                                                                                                                                                                     | 25.00 THB      |
| TOP           | Tongan Paʻanga                      | Tonga                                                                                                                                                                                                        | 2.00 TOP       |
| TRY           | Turkish Lira                        | Turkey                                                                                                                                                                                                       | 20.00 TRY      |
| TWD           | New Taiwan Dollar                   | Taiwan                                                                                                                                                                                                       | 20.00 TWD      |
| TZS           | Tanzanian Shilling                  | Tanzania                                                                                                                                                                                                     | 3000.00 TZS    |
| UYU           | Uruguayan Peso                      | Uruguay                                                                                                                                                                                                      | 50.00 UYU      |
| WST           | Samoan Tala                         | Samoa                                                                                                                                                                                                        | 2.00 WST       |
| ZAR           | South African Rand                  | South Africa                                                                                                                                                                                                 | 20.00 ZAR      |
| ZMW           | Zambian Kwacha                      | Zambia                                                                                                                                                                                                       | 30.00 ZMW      |

## Refunds and Adjustments

Dodo Payments issues refunds in the currency the customer originally paid, using the latest exchange rate. The global USD amount remains fixed on your dashboard, invoices, and in the refund. This means the customer may receive more or less than the original local‑currency amount depending on FX changes.

<Info>
  Adaptive Currency fees which are generally the FX fees are not refunded.
</Info>

**Example refund**

1. You sell a product for 100 USD with Adaptive Currency enabled.
2. A Canadian customer sees 137 CAD at an exchange rate of 1.37 CAD per 1 USD and completes the purchase.
3. We process the payment, converting 137 CAD to 100 USD for your settlement.
4. Later, the exchange rate changes to 1.40 CAD per 1 USD and you issue a full refund.
5. We deduct 100 USD and refund the customer 140 CAD.

## Invoices and Taxation

* Invoices show only the settlement currency amount.
* Taxes and platform fees are calculated on the settlement currency amount.
* Example: a \$10 sale converted to 36 AED still reflects as \$10 in the Dashboard and invoices.

<Info>
  All amounts are rounded according to Dodo Payments' internal rounding logic.
</Info>

## Integration Examples

**Checkout Sessions with billing currency**

Pass `billing_currency` to explicitly set the billing currency for the session.

<Info>
  When Adaptive Pricing is disabled, `billing_currency` is ignored.
</Info>

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_one_time_or_subscription',
      quantity: 1
    }
  ],
  billing_currency: 'AED',
  return_url: 'https://example.com/return'
});
```

<Card title="Checkout Session" icon="code" href="/api-reference/checkout-sessions/create">
  Configure Billing Currency using our Checkout Session API.
</Card>


# Add-ons for Subscriptions
Source: https://docs.dodopayments.com/features/addons

Enhance your subscription products with flexible add-ons for seat-based billing, feature upgrades, and creative pricing models

<Info>
  Add-ons are additional products that can be attached to your main subscription products, enabling flexible pricing models and enhanced customer experiences. Whether you need seat-based billing, feature upgrades, or custom pricing structures, add-ons give you the power to create sophisticated subscription offerings.
</Info>

<CardGroup>
  <Card title="Seat-Based Billing" icon="users" href="/developer-resources/seat-based-pricing">
    Create add-ons for additional team seats, user licenses, or capacity upgrades with per-seat pricing.
  </Card>

  <Card title="Usage Extensions" icon="bolt" href="/features/usage-based-billing">
    Extend usage limits, API calls, or data allowances with flexible add-on pricing.
  </Card>
</CardGroup>

## What Are Add-ons?

Add-ons are supplementary products that customers can purchase alongside their main subscription. They're perfect for:

* **Seat-based billing**: Additional team members, user licenses, or concurrent users
* **Feature upgrades**: Premium features, advanced analytics, or priority support
* **Usage extensions**: Extra storage, API calls, or bandwidth allowances
* **Service add-ons**: Professional services, training, or consultation hours

<Frame>
  <img alt="Add-ons attached to subscription products in the dashboard" />
</Frame>

## Key Benefits

* **Flexible Pricing Models**: Offer base plans with optional add-ons to create sophisticated pricing structures. You can address diverse customer segments with upgrades that grow as your customers' needs change.
* **Revenue Optimization**: Boost your average revenue per user (ARPU) by presenting relevant add-ons. This enables natural upsell opportunities as customers add features over time.
* **Simplified Management**: Manage all pricing components from one dashboard. Add-ons are automatically included in both checkout sessions and subscription management.
* **Customer Choice**: Allow customers to customize their subscriptions by selecting only the add-ons they need, which enhances satisfaction and reduces churn.

## Creating Add-ons

Add-ons are created as separate products in your Dodo Payments dashboard and then attached to your main subscription products. This separation allows you to:

* Reuse add-ons across multiple subscription products
* Manage pricing independently
* Track add-on performance separately
* Update add-ons without affecting base subscriptions

<Frame>
  <img alt="Creating add-ons in the dashboard interface" />
</Frame>

### Add-on Configuration

When creating add-ons, you can configure:

* **Pricing**: Set one-time or recurring pricing for the add-on
* **Billing cycle**: Must match your subscription's billing cycle
* **Quantity limits**: Set minimum and maximum quantities per customer
* **Availability**: Control which subscription products can use the add-on
* **Tax settings**: Configure appropriate tax categories

### Getting Started

Ready to implement add-ons in your subscription business? Here's how to get started:

<Steps>
  <Step title="Plan Your Add-ons">
    Identify the additional features, services, or capacity that would benefit your customers as add-ons.

    Consider:

    * What do customers frequently request?
    * What features could be monetized separately?
    * What would create natural upgrade paths?
  </Step>

  <Step title="Create Your First Add-on">
    Use the Dodo Payments dashboard or API to create your first add-on product.

    <Card title="Dashboard Guide" icon="box" href="/developer-resources/seat-based-pricing">
      Follow our step-by-step guide to create add-ons in the dashboard.
    </Card>
  </Step>

  <Step title="Attach to Subscriptions">
    Connect your add-ons to the appropriate subscription products where they should be available.
  </Step>

  <Step title="Test Integration">
    Create test checkout sessions with different add-on combinations to ensure everything works correctly.
  </Step>

  <Step title="Monitor Performance">
    Track add-on adoption rates and revenue impact to optimize your pricing strategy.
  </Step>
</Steps>

## API Management

Dodo Payments provides a comprehensive API for managing add-ons programmatically:

<AccordionGroup>
  <Accordion title="Create Add-ons">
    Use the `POST /addons` endpoint to create new add-ons with custom pricing, descriptions, and configuration options.

    <Card title="API Reference" icon="code" href="/api-reference/addons/create-addon">
      View the complete API documentation for creating add-ons.
    </Card>
  </Accordion>

  <Accordion title="Update Add-ons">
    Modify existing add-ons using the `PATCH /addons/{id}` endpoint to update pricing, descriptions, or availability.

    <Card title="API Reference" icon="code" href="/api-reference/addons/update-addon">
      Learn how to update add-on details programmatically.
    </Card>
  </Accordion>

  <Accordion title="List and Retrieve">
    Use `GET /addons` to list all add-ons or `GET /addons/{id}` to retrieve specific add-on details.

    <Card title="API Reference" icon="code" href="/api-reference/addons/list-addons">
      Access the complete listing and retrieval API documentation.
    </Card>
  </Accordion>

  <Accordion title="Image Management">
    Update add-on images using the `PUT /addons/{id}/images` endpoint for better product presentation.

    <Card title="API Reference" icon="code" href="/api-reference/addons/update-addon-images">
      Learn how to manage add-on images via API.
    </Card>
  </Accordion>
</AccordionGroup>

## Common Use Cases

* **Seat-Based Billing**: Additional team members, user licenses, or concurrent users
* **Feature Upgrades**: Premium features, advanced analytics, or priority support
* **Usage Extensions**: Extra storage, API calls, or bandwidth allowances
* **Service Add-ons**: Professional services, training, or consultation hours

## Integration Examples

### Checkout Sessions with Add-ons

When creating checkout sessions, you can include add-ons with custom quantities:

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'your_subscription_id',
      quantity: 1,
      addons: [
        {
          addon_id: 'your_addon_id',
          quantity: 3 // 3 additional seats
        }
      ]
    }
  ],
  // ... other checkout options
});
```

### Plan Changes with Add-ons

Modify existing subscriptions to add, remove, or update add-ons:

```typescript theme={null}
// Add add-ons to existing subscription
await client.subscriptions.changePlan('sub_123', {
  product_id: 'prod_new',
  quantity: 1,
  proration_billing_mode: 'difference_immediately',
  addons: [
    { addon_id: 'addon_123', quantity: 2 }
  ]
});

// Remove all existing add-ons
await client.subscriptions.changePlan('sub_123', {
  product_id: 'prod_new',
  quantity: 1,
  proration_billing_mode: 'difference_immediately',
  addons: [] // Empty array removes all existing add-ons
});
```

### Dynamic Pricing

Calculate total costs dynamically based on add-on selections:

```typescript theme={null}
function calculateTotalCost(basePrice: number, addons: AddonSelection[]) {
  const addonTotal = addons.reduce((sum, addon) => 
    sum + (addon.price * addon.quantity), 0
  );
  return basePrice + addonTotal;
}
```

## Best Practices

* **Start simple**: Launch with 2-3 core add-ons and expand options based on customer feedback and usage.
* **Maintain pricing clarity**: Clearly communicate add-on pricing and value, so customers understand what they're getting for the extra cost.
* **Test thoroughly**: Validate add-on combinations to ensure pricing calculations remain accurate and checkout flows function smoothly.

### Design Considerations

* **Clear Value Proposition**: Each add-on should have a clear benefit that customers can easily understand
* **Logical Grouping**: Group related add-ons together in your checkout flow
* **Flexible Quantities**: Allow customers to adjust quantities of add-ons as needed
* **Transparent Pricing**: Show total costs clearly throughout the checkout process

<Info>
  Add-ons are a powerful way to create flexible, scalable pricing models that grow with your customers. Start with simple use cases and expand as you learn what works best for your business and customers.
</Info>


# Affiliates
Source: https://docs.dodopayments.com/features/affiliates

Launch and manage your affiliate program while processing transactions through Dodo Payments.

## Introduction

This guide walks you through how to track affiliate referrals, handle commission events, and grow your revenue with trusted affiliate partnerships via Dodo Payments. We offer integrations with leading affiliate platforms including **Affonso** and **Dub Partners** to help you manage and track your affiliate programs seamlessly.

## Key Features

<CardGroup>
  <Card title="Automated Commission Attribution" icon="robot">
    No spreadsheets or manual tracking. Referrals are automatically attributed and logged when a purchase is made.
  </Card>

  <Card title="Real-Time Reporting" icon="chart-line">
    Both you and your affiliates can monitor performance and leads from dedicated dashboards.
  </Card>

  <Card title="Flexible Tracking Options" icon="code">
    Use tracking scripts, metadata fields, and webhook events to capture referral data across signups and transactions.
  </Card>

  <Card title="Fully Encrypted & Secure" icon="shield">
    All sensitive credentials and webhook data are securely exchanged and stored using best-in-class encryption.
  </Card>

  <Card title="Quick Setup" icon="bolt">
    Launch your affiliate program in minutes—no code changes required beyond copy-pasting script snippets and API tokens.
  </Card>

  <Card title="Seamless Integration" icon="plug">
    Plug affiliate tracking directly into your checkout flows using our integrations with Affonso and Dub Partners, leading affiliate marketing platforms.
  </Card>
</CardGroup>

## Integration Options

Dodo Payments integrates with two leading affiliate management platforms:

* **[Affonso](https://affonso.io)**: A comprehensive affiliate management platform with automated commission tracking, real-time reporting, and dedicated affiliate dashboards.
* **[Dub Partners](https://dub.co)**: Use Dub's link management and conversion tracking to power your affiliate program with detailed attribution analytics.

Choose the platform that best fits your needs, or use both for different use cases.

## Affonso Integration

We have partnered with Affonso, a leading affiliate management platform to power your sales. Follow the steps below to connect your Dodo Payments account with Affonso and begin tracking affiliate-driven sales.

<Frame>
  <iframe title="Affiliate Integration | Dodo Payments" />
</Frame>

<Steps>
  <Step title="Connect with Dodo Payments">
    To get started, connect your Dodo Payments account by adding your API key.

    ### How to Get Your Dodo Payments API Key

    * Log in to your **Dodo Payments Dashboard**
    * Go to the **Developer** section in the left menu
    * Click on **API Keys**
    * Select **Add API Key**
    * Give it a name (e.g. "Affonso Integration")
    * Click **Create** and **copy** your API key

    ### Add Your API Key to Affonso

    * Open your **Affonso Dashboard via** [affonso.io](https://affonso.io/)
    * Go to **Program Details > Connect**
    * Click the **Dodo Payments integration** card
    * Paste your Dodo Payments API key
    * Click **Connect**

    <Callout type="info">
      Your API key will be securely encrypted by Affonso.
    </Callout>
  </Step>

  <Step title="Add Webhook to Dodo Payments">
    Once connected, you'll receive a unique webhook URL from Affonso. This enables payment tracking and affiliate commission triggering.

    ### Add Webhook URL in Dodo Payments

    * In your Dodo Payments Dashboard, go to **Developer → Webhooks**
    * Click **Add Webhook**
    * Paste your **Affonso webhook URL** (from your program settings)
    * Save the webhook

    ### Add Webhook Secret in Affonso

    * After saving the webhook in Dodo Payments, **copy the signing key** provided
    * Paste it back into Affonso under the **Dodo Payments webhook settings**

    <Callout type="info">
      This allows Affonso to securely verify incoming events from Dodo Payments.
    </Callout>
  </Step>

  <Step title="Add the Tracking Script">
    Place the Affonso pixel on your site to start tracking affiliate visits and conversions.

    ```html theme={null}
    <!-- Place in <head> tag -->
    <script async defer
    src="https://affonso.io/js/pixel.min.js"
    data-affonso="YOUR_PUBLIC_PROGRAM_ID"
    data-cookie_duration="YOUR_COOKIE_DURATION">
    </script>
    ```

    This script:

    * Tracks affiliate visits
    * Sets a cookie with the referral ID (`affonso_referral`)
    * Enables signup and payment tracking

    <Callout type="info">
      Place this on all domains where users visit or convert (e.g. marketing site, app).
    </Callout>
  </Step>

  <Step title="Track User Signups">
    To gain funnel visibility and optimize affiliate performance, track user signups as leads.

    ```js theme={null}
    // After successful registration
    window.Affonso.signup(userEmail);
    ```

    This will:

    * Log a new referral as a **LEAD** if the user came via an affiliate link
    * Display it in your dashboard and the affiliate's stats

    <Callout type="info">
      Best practice: Trigger this after successful registration or double opt-in (DOI).
    </Callout>
  </Step>

  <Step title="Pass Referral Data to Dodo Payments">
    To attribute commissions correctly, pass the referral ID from Affonso to Dodo Payments during checkout.

    ### Payments Integration

    ```js theme={null}
    import DodoPayments from 'dodopayments';

    const referralId = window.affonso_referral;

    const client = new DodoPayments({
      bearerToken: process.env['DODO_PAYMENTS_API_KEY'],
    });

    async function main() {
      const payment = await client.payments.create({
        payment_link: true,
        billing: { city: 'city', country: 'AF', state: 'state', street: 'street', zipcode: 0 },
        customer: { email: 'email@email.com', name: 'name' },
        product_cart: [{ product_id: 'product_id', quantity: 0 }],
        metadata: {
          affonso_referral: referralId,
        },
      });

      console.log(payment.payment_id);
    }

    main();
    ```

    ### Subscription Integration

    ```js theme={null}
    import DodoPayments from 'dodopayments';

    const referralId = window.affonso_referral;

    const client = new DodoPayments({
      bearerToken: process.env['DODO_PAYMENTS_API_KEY'],
    });

    async function main() {
      const subscription = await client.subscriptions.create({
        billing: { city: 'city', country: 'IN', state: 'state', street: 'street', zipcode: 89789 },
        customer: { customer_id: 'customer_id' },
        product_id: 'product_id',
        payment_link: true,
        return_url: 'https://example.com/success',
        quantity: 1,
        metadata: {
          affonso_referral: referralId,
        },
      });

      console.log(subscription.subscription_id);
    }

    main();
    ```

    ### Payment Links

    ```js theme={null}
    // Original Dodo Payments Link
    const originalLink = 'https://checkout.dodopayments.com/buy/<YOUR_PRODUCT_ID>';

    // Append referral ID as reference_id
    const linkWithReferral = `${originalLink}?metadata_affonso_referral=${window.affonso_referral}`;
    ```

    <Callout type="info">
      For more details, see the [Dodo Payments API documentation](https://docs.dodopayments.com/api-reference/introduction)
    </Callout>
  </Step>

  <Step title="Testing Your Integration">
    Before launching publicly, test your setup with live affiliate links and test transactions.

    **Testing Checklist:**

    * ✅ Create an affiliate and generate a tracking link
    * ✅ Visit your website via the affiliate link
    * ✅ Ensure the Affonso script loads and the `affonso_referral` cookie is set
    * ✅ Complete a signup (optional)
    * ✅ Complete a payment via Dodo Payments
    * ✅ Confirm tracking and attribution in your Affonso dashboard
  </Step>
</Steps>

## Dub Partners Integration

You can also use [Dub Partners](https://dub.co) to track affiliate referrals and conversions. Dub's conversion tracking feature allows you to attribute sales to your affiliate links, providing detailed analytics on which partners drive the most revenue.

<Info>
  For detailed setup instructions, see our [Dub integration guide](/integrations/dub) which covers how to track sale conversion events and attribute revenue to your affiliate links.
</Info>

### Quick Setup with Dub Partners

1. **Enable conversion tracking** in your Dub dashboard for affiliate links
2. **Capture the Dub click ID** (`dub_id` cookie) when creating checkout sessions
3. **Store the click ID** in payment metadata along with customer information
4. **Configure webhook integration** to send sale data to Dub when payments succeed

The integration automatically tracks:

* One-time payments
* Subscription activations
* Recurring subscription payments

<Card title="Learn More" icon="book" href="/integrations/dub">
  View the complete Dub integration guide with code examples and transformation templates.
</Card>

## Need Help?

If you face any issues or need support during integration:

<CardGroup>
  <Card title="Affonso Support" icon="headset">
    * Chat with us via **live chat** on [affonso.io](https://affonso.io/)
    * Email us at **[support@affonso.io](mailto:support@affonso.io)**
  </Card>

  <Card title="Dub Support" icon="headset">
    * Visit the [Dub documentation](https://dub.co/docs) for conversion tracking guides
    * Contact Dub support through their [dashboard](https://app.dub.co)
  </Card>

  <Card title="Dodo Payments Support" icon="headset">
    For Dodo Payments-specific API queries, refer to docs.dodopayments.com or contact our support team.
  </Card>

  <Card title="Integration Guides" icon="book">
    * [Affonso Integration](#affonso-integration) (above)
    * [Dub Partners Integration](/integrations/dub)
  </Card>
</CardGroup>


# Analytics and Reporting
Source: https://docs.dodopayments.com/features/analytics-and-reporting

Gain actionable business insights with Dodo Payments' Analytics & Reporting dashboard. Learn to track revenue, customer trends, and transaction health, and download detailed reports.

<Frame>
  <img alt="Analytics and Reporting dashboard overview" />
</Frame>

## Introduction

Dodo Payments' **Analytics & Reporting** dashboard empowers you to monitor your business performance, understand customer behavior, and make data-driven decisions. Access real-time metrics, visualize trends, and export detailed reports—all from a single, intuitive interface.

<CardGroup>
  <Card title="Revenue Insights" icon="chart-pie-simple">
    Track total revenue, growth trends, and top-performing products or countries.
  </Card>

  <Card title="Customer Analytics" icon="users">
    Analyze customer acquisition, retention, and average revenue per user (ARPU).
  </Card>

  <Card title="Transaction Health" icon="circle-check">
    Monitor payment and refund success rates, and identify failure reasons.
  </Card>

  <Card title="Exportable Reports" icon="file-csv">
    Download payments, refunds, and payouts reports for custom date ranges.
  </Card>
</CardGroup>

## Dashboard Overview

The Analytics dashboard provides comprehensive insights into three key areas of your business performance. Each section offers detailed metrics and visualizations to help you understand your revenue patterns, customer behavior, and transaction health.

## Revenue Analytics

Track your income and payment activity to understand revenue trends and identify your top-performing markets.

<Frame>
  <img alt="Total revenue and revenue trend chart" />
</Frame>

* **Total Revenue:** Instantly see your all-time revenue and recent trends.
* **Revenue Trend:** The 30-day chart helps you spot spikes or dips in income.

<Frame>
  <img alt="Top revenue countries and growth rate chart" />
</Frame>

* **Growth Rate:** Track monthly revenue growth to measure business momentum.
* **Geographic Insights:** Visualize your top 5 revenue-generating countries.

<Tip>
  Use these insights to focus your marketing and product efforts on high-performing regions and periods of growth.
</Tip>

## Revenue Breakdown Analytics

Track your recurring revenue metrics with detailed breakdowns:

* **Projected ARR**: Annual Recurring Revenue projections with trend analysis
* **MRR Breakdown and Growth Rate**: Monthly Recurring Revenue analysis with month-over-month growth metrics
* **New MRR Chart**: Visual representation of new customer revenue acquisition
* **Expansion MRR Chart**: Tracking revenue growth from existing customer upgrades and expansions
* **Churn MRR Chart**: Monitoring revenue lost from customer cancellations and downgrades
* **Net New MRR Chart**: Net revenue impact combining new, expansion, and churn MRR

<Frame>
  <img alt="Revenue Breakdown dashboard showing projected ARR, MRR breakdown, and growth rates" />
</Frame>

## Retention Analytics

Monitor customer retention and churn patterns:

* **Customer Churn Rate**: Percentage of customers who cancel their subscriptions
* **Revenue Churn Rate**: Percentage of revenue lost from cancellations and downgrades
* **Churn Rate Trends**: Historical tracking of both customer and revenue churn patterns over time
* **User Retention Matrix**: Cohort analysis showing customer retention rates across different time periods

<Frame>
  <img alt="Retention Analytics dashboard showing customer churn rate, revenue churn rate, and churn rate trends" />
</Frame>

## Customer Analytics

Analyze customer acquisition, retention, and spending patterns to optimize your customer strategy.

<Frame>
  <img alt="Customer analytics: ARPU, active customers, customer split, top customers" />
</Frame>

* **ARPU (Average Revenue Per User):** Understand how much each customer contributes on average.
* **Active Customers:** See how many customers are engaging with your business.
* **Customer Split:** Instantly view the ratio of new vs. returning customers.
* **Top Customers:** Identify your highest spenders for targeted engagement.

<Tip>
  Monitor ARPU and customer split to refine your retention and acquisition strategies.
</Tip>

## Transaction Success & Failure Analytics

Monitor payment and refund success rates to identify and resolve transaction issues quickly.

<Frame>
  <img alt="Payment and refund success rates, failure reasons, and payment breakdown" />
</Frame>

* **Payment Success Rate:** Track the percentage of successful payment attempts.
* **Refund Success Rate:** Monitor how many refunds are processed successfully.
* **Failure Reasons:** Quickly identify common issues (e.g., expired cards, unsupported methods).

  <Card title="Transaction Failure Reference" icon="circle-exclamation" href="/api-reference/transaction-failures">
    Get all possible transaction failure codes and it's reasons.
  </Card>
* **Payments Breakdown:** Visualize the distribution of successful and failed transactions.

<Warning>
  If you notice a drop in success rates or a spike in failures, review the failure reasons and address them promptly to minimize revenue loss.
</Warning>

## Filtering & Customization

You can filter analytics data by:

* **Product Type** (one-time vs. subscription)
* **Date Range** (customizable)
* **Payment Method**

<Tip>
  Use filters to drill down into specific products, time periods, or payment methods for targeted insights.
</Tip>

## Reports

We've completely revamped the reports section with more comprehensive and detailed reporting capabilities. Navigate to **Business > Reports** to access the new reporting suite.

Available reports include:

* **Payment Report**: Detailed record of all processed payments with transaction status tracking
* **Refund Report**: Comprehensive log of all refund activities with detailed refund information
* **Payout Report**: Summary of payouts made to your account
* **Product-wise Sales Report**: Sales performance insights with revenue and business growth metrics
* **Payment Failure Report**: Summary of failed payment attempts with failure reasons
* **Customer Report**: Payment summary organized by customer
* **Disputes Report**: Payment disputes summary with resolution status
* **Account Summary Report**: Complete account overview and summary

<Frame>
  <img alt="Reports 2.0 dashboard showing various report types" />
</Frame>

## Enhanced Payout Reporting

We've added detailed payout reports that provide clear visibility into fees and transaction details for each payout you receive from Dodo Payments. Access these enhanced reports in **Business > Payouts**.

<Frame>
  <img alt="Payout Report dashboard showing detailed payout information" />
</Frame>

## Downloading & Exporting Reports

You can export detailed reports directly from the dashboard:

<Steps>
  <Step title="Open the Reports Section">
    Navigate to the <strong>Reports</strong> area in your dashboard.
  </Step>

  <Step title="Select Report Type & Date Range">
    Choose the report you need (Payments, Refunds, Payouts) and specify the date range.
  </Step>

  <Step title="Download the Report">
    Click <strong>Download</strong> to export your report in CSV format.

    <Check>
      Your report will be saved to your device.
    </Check>
  </Step>
</Steps>

## Best Practices & Troubleshooting

<Tip>
  * Regularly review your analytics to spot trends and anomalies early.
  * Use filters to compare performance across products, time periods, or geographies.
  * If data appears incorrect or missing, check your filters and date range settings first.
</Tip>

<Warning>
  If you notice persistent discrepancies or missing data, contact <a href="mailto:support@dodopayments.com">[support@dodopayments.com](mailto:support@dodopayments.com)</a> for assistance.
</Warning>

## Next Steps & Related Resources

<CardGroup>
  <Card title="Account Summary & Payout Wallet" icon="wallet" href="/features/account-summary-payout-wallet">
    Understand your earnings, deductions, and payout cycles.
  </Card>

  <Card title="Payments" icon="money-bill-transfer" href="/features/transactions/payments">
    Track and manage all payment transactions.
  </Card>

  <Card title="Refunds" icon="rotate-left" href="/features/transactions/refunds">
    Initiate and monitor refunds, and export refund reports.
  </Card>

  <Card title="Disputes" icon="circle-exclamation" href="/features/transactions/disputes">
    Manage and respond to payment disputes.
  </Card>
</CardGroup>


# Selling Digital Goods on iOS
Source: https://docs.dodopayments.com/features/appstore-digital-goods

A comprehensive guide to selling digital goods and services on iOS apps using Dodo Payments

## Introduction

Dodo Payments empowers developers to sell digital goods and services in iOS apps, handling complex aspects like tax compliance, currency conversion, and payouts. This comprehensive guide details how to integrate Dodo Payments into your iOS app, specifically for SaaS tools, content subscriptions, and digital utilities.

## Overview

Dodo Payments serves as your **Merchant of Record (MoR)**, managing critical aspects of your digital business:

<Tabs>
  <Tab title="What We Handle">
    * Tax collection and remittance (VAT, GST, and other regional taxes)
    * Global payments as per policies and local payment methods
    * Currency conversion and foreign exchange
    * Chargebacks and fraud prevention
    * End-customer invoicing and receipts
    * Compliance with regional regulations
  </Tab>

  <Tab title="What You Get">
    * A unified API for web and mobile platforms
    * Support for in-app checkouts (UPI, cards, wallets, BNPL)
    * Global payout support (Payoneer, Wise, local bank transfers)
    * Analytics and reporting dashboard
    * Secure payment processing
  </Tab>
</Tabs>

## Use Cases

<CardGroup>
  <Card title="Subscriptions" icon="repeat">
    * Premium content or feature access
    * Recurring billing with flexible options, Free trials, Proration, or Upgrades and downgrades
  </Card>

  <Card title="Courses and Learning" icon="graduation-cap">
    * Pay-per-course access
    * Bundled content packages
    * Lifetime or renewable licenses
    * Progress tracking integration
  </Card>

  <Card title="Digital Downloads" icon="download">
    * One-time purchases (PDFs, music, tools)
    * Digital asset delivery
    * License key management
  </Card>

  <Card title="SaaS Tools" icon="screwdriver-wrench">
    * Software-as-a-Service subscriptions
    * Usage-based billing
    * Team and enterprise plans
  </Card>
</CardGroup>

## Integration Flow

You can integrate Dodo Payments into your app using our hosted checkout or in-app browser solution.

```mermaid theme={null}
flowchart LR
  A[Mobile App] -->|Create Payment Link| B(Dodo API)
  B -->|Checkout URL| A
  A -->|Open in WebView| C[Checkout Page]
  C -->|Redirects / Webhooks| D[Your Server]
  D -->|Grant Access| A
```

### Integration Steps

<Steps>
  <Step title="Mobile App to Dodo API">
    The process begins with the mobile app creating a payment link by interacting with the Dodo API.
  </Step>

  <Step title="Dodo API to Mobile App">
    The Dodo API responds by providing a checkout URL back to the mobile app.
  </Step>

  <Step title="Mobile App to Checkout Page">
    The mobile app then opens this checkout URL within a WebView, leading the user to the checkout page.
  </Step>

  <Step title="Checkout Page to Your Server">
    Upon completion of the checkout process, the checkout page communicates with your server through redirects or webhooks.
  </Step>

  <Step title="Your Server to Mobile App">
    Finally, your server grants access to the purchased content or service, completing the transaction cycle back in the mobile app.
  </Step>
</Steps>

<Card title="Mobile Integration Guide" icon="mobile" href="/developer-resources/mobile-integration">
  For a complete developer walkthrough, explore our Mobile Integration Guide.
</Card>

## Regional Availability

Dodo Payments enables alternative in-app purchase flows only in App Store regions where Apple explicitly allows external payments, or where a regulator or court order mandates it.

### Supported Regions

<AccordionGroup>
  <Accordion title="United States">
    Supported to the extent permitted by current court orders and Apple's updated guidelines.

    * Available under specific court-mandated provisions
    * Subject to Apple's compliance with legal requirements
    * Must follow Apple's implementation guidelines
  </Accordion>

  <Accordion title="European Union (EU) App Store">
    Supported via Apple's EU Alternative Terms and External Purchase Entitlement.

    * Enabled through Apple's EU Alternative Terms
    * Requires External Purchase Entitlement approval
    * Must comply with EU Digital Markets Act requirements
  </Accordion>

  <Accordion title="South Korea">
    Supported through the StoreKit External Purchase Entitlement for Korea-only binaries.

    * Available via StoreKit External Purchase Entitlement
    * Requires Korea-specific app binary
    * Must comply with Korean telecommunications law
  </Accordion>
</AccordionGroup>

<Warning>
  Always review and comply with Apple's region-specific entitlements and App Store Connect requirements before enabling Dodo Payments for any storefront. Using alternative payment flows in unsupported regions may result in app rejection or removal.
</Warning>

<Note>
  For some business models - such as services or certain categories of content - Apple may not require the use of in-app purchase (IAP) at all. Dodo Payments supports these models as well. Always verify your app's classification and Apple's latest guidelines to determine if IAP is mandatory for your use case.
</Note>

### Learn More

For a detailed breakdown of global policies, legal precedents, and strategic approaches to bypassing App Store fees, see our comprehensive guide:

<Card title="Bypassing App Store & Play Store Fees: A Strategic and Legal Playbook" icon="shield-check" href="/features/bypassing-app-store-fees">
  Learn where and how you can legally implement alternative payment flows, with up-to-date regional guidance and compliance tips.
</Card>


# Atlas Demo Product
Source: https://docs.dodopayments.com/features/atlas-demo-website

Explore Atlas, a fully functional AI art generation demo application showcasing usage-based billing, subscriptions, and one-time payments with Dodo Payments checkout integration.

<Frame>
  <img alt="Atlas Demo Product - AI art generation platform with integrated billing" />
</Frame>

Atlas is a fully functional demo application by Dodo Payments that showcases an AI art generation platform. It demonstrates all three billing models—**usage-based billing**, **one-time payments**, and **subscriptions**—with integrated checkout flows.

<Info>
  **Live Demo**: Visit [atlas.dodopayments.com](https://atlas.dodopayments.com/) to explore the platform and test all billing flows.
</Info>

## Overview

Atlas simulates a real-world AI art generation platform where users create images from text prompts. The demo highlights three distinct purchase flows, each demonstrating different billing models and checkout experiences:

* **Usage-Based Billing**: Pay per image generated (\$0.75 per image)
* **Subscription**: Unlimited Pro plan (\$20/month)
* **One-Time Purchase**: Credit packs (\$7 for 10 credits)

After completing any purchase, users are redirected to the **Atlas Studio dashboard** where they can generate artwork and track their usage in real-time.

## Purchase Flows

Atlas demonstrates three separate billing flows. Each flow follows a similar pattern but showcases different checkout experiences and billing models.

<Tabs>
  <Tab title="Usage-Based Billing">
    <Steps>
      <Step title="Select pay-per-image pricing">
        Choose the **pay-per-image** option (\$0.75 per image) for AI art generation. This demonstrates usage-based billing where customers pay only for what they consume.
      </Step>

      <Step title="Generate artwork">
        Enter a text prompt and generate an image. The system automatically tracks usage for billing purposes.
      </Step>

      <Step title="Complete checkout">
        The checkout process includes:

        * **Branded checkout page**: Dodo Payments checkout page displays your merchant brand name and logo
        * **Customer information**: Enter user details and billing address
        * **Tax calculation**: Taxes are automatically calculated after address confirmation
        * **Payment**: Enter test card details to complete the transaction

        <Tip>
          Use test card `4242 4242 4242 4242` with any future expiry date and CVC to simulate successful transactions.
        </Tip>
      </Step>

      <Step title="View confirmation">
        After payment, Atlas displays a confirmation screen with usage details and remaining credits.
      </Step>

      <Step title="Access dashboard">
        Users are redirected back to the **Atlas Studio dashboard** where they can continue generating artwork and monitor their usage tracking.
      </Step>
    </Steps>
  </Tab>

  <Tab title="Subscription">
    <Steps>
      <Step title="Select subscription plan">
        Choose the **Unlimited Pro** subscription plan (\$20/month) for unlimited AI art generation.
      </Step>

      <Step title="Generate artwork">
        Enter a prompt and generate an image to test the platform before subscribing.
      </Step>

      <Step title="Complete checkout">
        The subscription checkout includes:

        * **Branded checkout page**: Merchant branding is visible throughout the checkout process
        * **Customer information**: Enter user details and billing address
        * **Tax calculation**: Automatic tax calculation based on billing address
        * **Payment**: Enter test card details to activate the subscription

        <Note>
          Subscriptions automatically renew monthly. Users can manage their subscription from the dashboard after purchase.
        </Note>
      </Step>

      <Step title="View confirmation">
        Post-payment, Atlas displays a confirmation screen with subscription activation details and next billing date.
      </Step>

      <Step title="Access dashboard">
        Users are redirected to the **Atlas Studio dashboard** with unlimited access to generate artwork.
      </Step>
    </Steps>
  </Tab>

  <Tab title="One-Time Purchase">
    <Steps>
      <Step title="Select credit pack">
        Choose a **Credit Pack** (\$7 for 10 credits) for AI art generation. This demonstrates one-time purchase transactions.
      </Step>

      <Step title="Generate artwork">
        Enter a prompt and generate an image to preview the platform before purchasing credits.
      </Step>

      <Step title="Complete checkout">
        The one-time purchase checkout includes:

        * **Branded checkout page**: Dodo Payments checkout with merchant branding
        * **Customer information**: Enter user details and billing address
        * **Tax calculation**: Automatic tax calculation after address confirmation
        * **Payment**: Enter test card details to complete the purchase
      </Step>

      <Step title="View confirmation">
        Post-payment, Atlas displays a confirmation screen with a "thank you" message and purchased credit details.
      </Step>

      <Step title="Access dashboard">
        Users are redirected to the **Atlas Studio dashboard** where their purchased credits are immediately available for generating artwork.
      </Step>
    </Steps>
  </Tab>
</Tabs>

## Post-Purchase Dashboard Experience

The Atlas Studio dashboard demonstrates how to implement billing-aware features and entitlement tracking after checkout completion.

### Dashboard Features

* **Immediate access**: Users can start generating artwork immediately after purchase
* **Usage tracking**: Real-time display of remaining credits, active subscriptions, and generation history
* **Billing management**: View purchase history, subscription status, and upcoming renewals
* **Seamless integration**: Showcases how to redirect users back to your application with proper entitlement tracking

<Check>
  The dashboard experience demonstrates best practices for post-purchase user flows, including entitlement verification and usage monitoring.
</Check>

## Technical Implementation

Atlas is built using the [Dodo Payments TypeScript SDK](/developer-resources/sdks/typescript), demonstrating how to integrate billing flows with just a few lines of code.

<CardGroup>
  <Card title="Integration Guide" icon="book" href="/developer-resources/integration-guide">
    Learn how to integrate Dodo Payments checkout flows into your application.
  </Card>

  <Card title="TypeScript SDK" icon="code" href="/developer-resources/sdks/typescript">
    Explore the TypeScript SDK documentation and API reference.
  </Card>
</CardGroup>

## Open Source

Atlas is an open-source project. Explore the codebase to see how billing flows are implemented in a real application.

<Card title="View on GitHub" icon="github" href="https://github.com/dodopayments/dodo-checkout-demo.git">
  Browse the Atlas source code and learn from the implementation.
</Card>


# B2B Payments
Source: https://docs.dodopayments.com/features/b2b-payments

The B2B Payments feature ensures that merchants processing B2B transactions have their customer’s Tax IDs verified during checkout, ensuring accurate tax application based on the customer's country and applicable regulations. This validation helps determine whether input tax collection applies or if the transaction falls under a reverse charge mechanism.

## **Tax ID Validation for B2B Transactions**

* If a **valid Tax ID** is provided during checkout, the invoice will include:
  * The **customer’s Tax ID**.
* Tax deductions will be determined based on the applicable regulations for the customer’s country.
* The invoice will include **Dodo Payments’ tax details**, along with the tax applied to the transaction.

## **Tax Treatment for B2C Transactions**

* Transactions where a valid Tax ID is **not provided** will be treated as **B2C transactions**, and tax will be deducted as per the applicable tax regulations in the customer’s country.
* The invoice will include **Dodo Payments’ tax details**, along with the tax applied to the transaction.

## Reverse Charge Mechanism

Generally, the supplier of goods or services is liable to pay VAT/Service Tax/GST.
However, in specified cases like imports and other notified supplies, the liability is on the recipient (customer) under the reverse charge mechanism. Reverse Charge means the liability to pay tax is on the recipient of supply of goods or services instead of the supplier of such goods or services in respect of notified categories of supply.

## **Reverse Charge Applicability**

* In certain cases, where applicable by law, tax will **not be deducted** at checkout and the transaction will be subject to a **reverse charge mechanism**.
* The invoice will clearly indicate when a reverse charge applies, as per regulatory requirements.


# Checkout Features
Source: https://docs.dodopayments.com/features/checkout

Conversion-optimized, globally compliant checkout with multi-currency, multi-language support, automatic tax calculation, discount codes, add-ons, and smart address collection.

<Frame>
  <img alt="Checkout page" />
</Frame>

<Info>
  Dodo Payments checkout is a conversion-optimized, globally compliant checkout designed for digital products and SaaS businesses. It supports multiple currencies, languages, taxes, discounts, add-ons, and business-friendly compliance workflows.
</Info>

<CardGroup>
  <Card title="Checkout Sessions API" icon="code" href="/api-reference/checkout-sessions/create">
    Create hosted checkout sessions programmatically.
  </Card>

  <Card title="Preview Checkout" icon="eye" href="/api-reference/checkout-sessions/preview">
    Calculate pricing and taxes before creating a session.
  </Card>

  <Card title="Payment Methods" icon="credit-card" href="/features/payment-methods">
    Supported payment methods and configuration options.
  </Card>
</CardGroup>

## Adaptive Currency

Adaptive Currency allows customers to pay in their preferred local currency, improving trust and conversion rates.

### How It Works

1. **Enable**: Enable Adaptive Currency from your Business Settings
2. **Select**: Customers can switch currencies directly on checkout
3. **Convert**: Prices are dynamically converted using real-time FX rates
4. **Display**: Final payable amount is shown transparently before payment

<Frame>
  <img alt="Currency selector on checkout" />
</Frame>

<Card title="Adaptive Currency" icon="money-bill-transfer" href="/features/adaptive-currency">
  Learn more about supported currencies, conversion fees, and refund handling.
</Card>

## Multi-Language Checkout

Dodo Payments supports multiple languages on the checkout page, allowing customers to complete payments in a language they're comfortable with.

<Frame>
  <img alt="Language selector on checkout" />
</Frame>

### Key Highlights

* Language selector available directly on checkout
* UI text, labels, and system messages are localized
* Improves accessibility and international conversion

### Supported Languages

The checkout page supports 21 languages:

| Language   | Code |
| ---------- | ---- |
| Arabic     | `ar` |
| Catalan    | `ca` |
| Chinese    | `zh` |
| Dutch      | `nl` |
| English    | `en` |
| French     | `fr` |
| German     | `de` |
| Hebrew     | `he` |
| Indonesian | `id` |
| Italian    | `it` |
| Japanese   | `ja` |
| Korean     | `ko` |
| Malay      | `ms` |
| Polish     | `pl` |
| Portuguese | `pt` |
| Romanian   | `ro` |
| Russian    | `ru` |
| Spanish    | `es` |
| Swedish    | `sv` |
| Thai       | `th` |
| Turkish    | `tr` |

<Tip>
  You can force a specific language on the checkout by setting the `force_language` parameter when creating a checkout session. See the [Checkout Sessions API](/developer-resources/checkout-session#14-forcing-a-language) for details.
</Tip>

## Automatic Tax Calculation

Taxes are automatically calculated based on the customer's billing location, ensuring compliance with GST, VAT, and sales tax requirements without manual setup.

### How Tax Calculation Works

<Steps>
  <Step title="Location Detection">
    Tax rules are applied based on the customer's country (and region where applicable).
  </Step>

  <Step title="Dynamic Updates">
    Tax amount updates automatically when:

    * Country changes
    * Address is updated
  </Step>

  <Step title="Transparent Display">
    Final tax breakdown is shown clearly before payment.
  </Step>
</Steps>

<Tip>
  Tax calculation is fully automated. No manual configuration required for standard digital goods and SaaS products.
</Tip>

## Business Tax ID Support

For registered businesses, the checkout allows customers to enter their Business Tax ID (e.g., VAT/GST number).

### What Happens When a Tax ID Is Entered

* Tax eligibility is validated in real-time
* Applicable tax exemptions or reverse-charge rules are applied
* Tax amount updates instantly on checkout

<Frame>
  <img alt="Business Tax ID entry on checkout" />
</Frame>

<Info>
  This is especially useful for B2B SaaS and digital services where business customers may be eligible for tax exemptions.
</Info>

## Discount Codes

Customers can apply discount or promo codes you've created in the dashboard directly on the checkout page.

### Checkout Experience

1. Customer enters the discount code
2. Discount is validated instantly
3. Updated price and savings are shown clearly

<Frame>
  <img alt="Discount code entry on checkout" />
</Frame>

### API Integration

Pre-apply a discount code or enable the discount input field:

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    { product_id: 'prod_abc', quantity: 1 }
  ],
  discount_code: 'WELCOME20', // Pre-apply a code
  feature_flags: {
    allow_discount_code: true // Show discount input field
  },
  return_url: 'https://yoursite.com/return'
});
```

<Card title="Discount Codes" icon="percent" href="/features/discount-codes">
  Learn how to create and manage discount codes.
</Card>

<Card title="Validate Discount by Code" icon="tag" href="/api-reference/discounts/get-discount-by-code">
  Look up and validate discounts using code names.
</Card>

## Smart Address Collection

The checkout supports flexible address entry for faster completion.

### Options Available

| Option                      | Description                         |
| --------------------------- | ----------------------------------- |
| **Google Address Autofill** | Quick selection with autocomplete   |
| **Manual Entry**            | Full control for complete addresses |
| **Country Selection**       | Drives tax and compliance logic     |

<Tip>
  Address collection balances speed, accuracy, and global coverage to maximize conversion while ensuring compliance.
</Tip>

## Custom Fields

Collect additional information from customers during checkout by defining custom form fields. This is useful for gathering data like company name, team size, referral source, or any other business-specific information.

### Available Field Types

| Type       | Description                    |
| ---------- | ------------------------------ |
| `text`     | Single-line text input         |
| `number`   | Numeric input                  |
| `email`    | Email address with validation  |
| `url`      | URL with validation            |
| `date`     | Date picker                    |
| `dropdown` | Select from predefined options |
| `boolean`  | Yes/No toggle                  |

### Example

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    { product_id: 'prod_abc', quantity: 1 }
  ],
  custom_fields: [
    {
      key: 'company_name',
      label: 'Company Name',
      field_type: 'text',
      required: true
    },
    {
      key: 'team_size',
      label: 'Team Size',
      field_type: 'dropdown',
      required: true,
      options: ['1-10', '11-50', '51-200', '200+']
    }
  ],
  return_url: 'https://yoursite.com/return'
});
```

<Info>
  Customer responses are automatically included in webhook payloads (`payment.succeeded`, `subscription.created`) and API responses via the `custom_field_responses` array. You can define up to 5 custom fields per checkout session.
</Info>

<Card title="Custom Fields Guide" icon="input-text" href="/developer-resources/checkout-session#15-collecting-custom-fields">
  Learn more about custom field configuration and accessing responses.
</Card>

## Privacy Policy & Terms Acceptance

To ensure legal and compliance transparency:

* [Privacy Policy](https://dodopayments.com/privacy-policy) and [Buyer Terms](https://dodopayments.com/buyer-terms) links are clearly displayed on checkout
* Customers explicitly acknowledge these before completing payment

<Info>
  This helps meet global consumer protection and data privacy requirements including GDPR compliance.
</Info>

## Collection Checkout

Product Collections enable a unified checkout experience where customers can view and select from multiple related products (e.g., Starter, Pro, Enterprise plans) in a single checkout.

### How It Works

1. **All products displayed**: Customers see every active product in the collection
2. **First product pre-selected**: The first product in the collection is automatically selected
3. **Compare options**: Customers can compare pricing and features before choosing
4. **Single selection**: After selecting a product, checkout proceeds with standard payment flow

### Creating a Collection Checkout

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_collection_id: 'pdc_abc123',
  product_cart: [], // Required: pass an empty array for collection checkout
  return_url: 'https://yoursite.com/return'
});
```

<Warning>
  When using `product_collection_id`, pass an empty `product_cart` array. Discount codes cannot be pre-applied at session creation.
</Warning>

<Card title="Product Collections" icon="layer-group" href="/features/product-collections">
  Learn how to create and manage product collections for unified checkout experiences.
</Card>

## Checkout Session Configuration

Control checkout behavior using the Checkout Sessions API:

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    { product_id: 'prod_abc', quantity: 1 }
  ],
  customer: {
    email: 'customer@example.com',
    name: 'Jane Doe'
  },
  billing_currency: 'EUR', // Set specific currency
  discount_code: 'PROMO10',
  feature_flags: {
    allow_discount_code: true
  },
  return_url: 'https://yoursite.com/return',
  metadata: {
    order_ref: 'ORD-12345'
  }
});
```

<CardGroup>
  <Card title="Checkout Sessions API" icon="code" href="/api-reference/checkout-sessions/create">
    Complete API reference for checkout sessions.
  </Card>

  <Card title="Checkout Integration Guide" icon="book" href="/developer-resources/checkout-session">
    Step-by-step guide to integrating checkout.
  </Card>
</CardGroup>


# Communication Preferences
Source: https://docs.dodopayments.com/features/communication-preferences

Configure how you and your team receive notifications about payments, payouts, refunds, subscriptions, and disputes across email, in-app, and push channels.

<Frame>
  <img alt="Communication Preferences Overview" />
</Frame>

<Info>
  Communication Preferences gives you complete control over how and when you're notified about important events in your Dodo Payments account. You can configure notifications for yourself, add multiple team email recipients with individual preferences, and choose between email, in-app, and push notification channels.
</Info>

## Accessing Communication Preferences

To configure your communication preferences:

1. Navigate to **Settings** in your Dodo Payments dashboard
2. Click on the **Communication** tab
3. Use the dropdown menu to switch between notification channels (Email, In-App, Push Notifications)

## Notification Channels

Dodo Payments supports three notification channels, each designed for different use cases. You can configure each channel independently to match your workflow.

<Frame>
  <img alt="Notification Channel Selector" />
</Frame>

| Channel                | Description                                                       | Best For                                        |
| ---------------------- | ----------------------------------------------------------------- | ----------------------------------------------- |
| **Email**              | Receive detailed notifications via email to one or more addresses | Comprehensive record-keeping, team distribution |
| **In-App**             | See notifications directly in the dashboard notification center   | Quick updates while working in the dashboard    |
| **Push Notifications** | Get instant mobile alerts on your registered devices              | Time-sensitive alerts when away from desktop    |

### Email Notifications

Email is the most flexible notification channel. You can add multiple recipient email addresses, and each recipient can have their own customized notification preferences. This is ideal for routing specific notifications to different team members (e.g., finance team receives payout notifications, support team receives dispute notifications).

<Frame>
  <img alt="Email Notifications Configuration" />
</Frame>

**Key features:**

* Add unlimited email recipients
* Configure per-recipient notification preferences
* Use "Enable All" or "Disable All" for quick bulk configuration
* Remove email addresses when team members change

### In-App Notifications

In-app notifications appear in the notification center within your Dodo Payments dashboard. These are perfect for staying informed while actively working in the dashboard without cluttering your email inbox.

<Frame>
  <img alt="In-App Notifications" />
</Frame>

In-app notifications are displayed in real-time and can be accessed by clicking the bell icon in the dashboard header. They provide a quick summary of recent events and link directly to the relevant transaction or record.

### Push Notifications

Push notifications deliver instant mobile alerts to your registered devices. This channel is ideal for critical events that require immediate attention, such as payment failures or new disputes.

<Frame>
  <img alt="Push Notifications" />
</Frame>

Push notifications are organized by device, allowing you to:

* Enable/disable notifications for specific devices
* Configure which events trigger push notifications per device
* Manage multiple devices (e.g., phone and tablet)

<Tip>
  Download the [Dodo Payments mobile app](/features/mobile-app) to receive push notifications on your iOS or Android device.
</Tip>

## Managing Email Recipients

The email channel allows you to add multiple recipient addresses, making it easy to keep your entire team informed about relevant events.

### Adding a New Email Recipient

1. In the **Your Emails** section, click the **Add Email** button
2. Enter the email address in the modal that appears
3. Click **Add Email** to confirm

<Frame>
  <img alt="Add Email Address Modal" />
</Frame>

After adding an email, you can immediately configure which notifications that address should receive.

### Configuring Email Preferences

1. Click on an email address to expand its notification options
2. Use the toggle switches next to each event to enable or disable notifications
3. Changes are saved automatically

**Quick Actions:**

* **Enable All**: Turns on all notifications for this email address with one click
* **Disable All**: Turns off all notifications for this email address with one click

### Removing an Email Recipient

To remove an email address, expand the email entry and click the **Remove email** button. This immediately stops all notifications to that address.

## Your Notification Events

These notifications keep you and your team informed about business-critical events. Each category can be independently configured per notification channel.

### Payments

Stay informed about payment activity for your products.

| Event                | Description                                                                                                                                                              |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Payment Failed**   | Notifies when a payment attempt fails. This could be due to insufficient funds, card decline, or other payment issues. Useful for identifying potential customer issues. |
| **Payment Received** | Notifies when a payment is successfully processed. Confirms that a customer has completed their purchase.                                                                |

### Payouts

Track the movement of funds from your Dodo Payments account to your bank account.

<Frame>
  <img alt="Payout and Refund Notifications" />
</Frame>

| Event                  | Description                                                                                                                     |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| **Payout Failed**      | Notifies when a payout attempt fails. This may indicate an issue with your bank account details that needs immediate attention. |
| **Payout In Progress** | Notifies when a payout is actively being processed. The funds are on their way to your bank account.                            |
| **Payout Initiated**   | Notifies when a payout is initiated to your bank account. This marks the beginning of the payout process.                       |
| **Payout On Hold**     | Notifies if a payout is paused or under review. This may require you to provide additional information or documentation.        |
| **Payout Processed**   | Notifies when a payout completes successfully. The funds should now be available in your bank account.                          |

### Refunds

Monitor refund activity across your transactions.

| Event                | Description                                                                                        |
| -------------------- | -------------------------------------------------------------------------------------------------- |
| **Refund Completed** | Notifies when a refund is successfully processed and the funds have been returned to the customer. |
| **Refund Failed**    | Notifies when a refund fails to process. This may require manual intervention to resolve.          |

### Subscriptions

Track subscription lifecycle events.

| Event                    | Description                                                                                        |
| ------------------------ | -------------------------------------------------------------------------------------------------- |
| **Subscription Started** | Notifies when a new subscription is created and activated. This confirms a new recurring customer. |

### Disputes

Disputes require prompt attention to protect your business. These notifications ensure you never miss a dispute deadline.

<Frame>
  <img alt="Subscription and Dispute Notifications" />
</Frame>

| Event                  | Description                                                                                                                        |
| ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| **Dispute Created**    | Notifies when a customer opens a dispute (chargeback) against a payment. Requires prompt attention to respond within the deadline. |
| **Dispute Challenged** | Notifies when a dispute you've responded to is being challenged or escalated. The dispute is still in progress.                    |
| **Dispute Won**        | Notifies when a dispute is resolved in your favor. The funds are retained in your account.                                         |
| **Dispute Lost**       | Notifies when a dispute is resolved in the customer's favor. The disputed amount has been deducted from your account.              |

<Warning>
  Disputes have strict response deadlines. We strongly recommend keeping dispute notifications enabled to ensure you can respond in time.
</Warning>

## Customer Emails

In addition to notifications for your team, you can configure which transactional emails are automatically sent to your customers. These emails are sent from Dodo Payments on your behalf and help keep your customers informed about their purchases.

<Frame>
  <img alt="Customer Email Configuration" />
</Frame>

| Email                         | Description                                                                                                                                                          |
| ----------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Payment Succeeded**         | Automatically sends a confirmation email to customers when their payment is successfully processed. Includes receipt details and order information.                  |
| **Subscription Plan Changed** | Sends an email to customers when their subscription plan changes, whether through an upgrade, downgrade, or modification. Confirms the new plan details and pricing. |
| **License Key Created**       | Sends an email to customers when a license key is generated for their purchase. Includes the license key and activation instructions.                                |

<Tip>
  Customer emails are enabled by default to ensure a great customer experience. If you prefer to handle customer communication through your own systems (e.g., your own email service or CRM), you can disable specific emails here.
</Tip>

<Note>
  Customer emails are separate from the notification emails sent to your team. Disabling a customer email does not affect your team's notifications about the same event.
</Note>

## Best Practices

Here are some recommendations for configuring your communication preferences effectively:

1. **Set up role-based email routing**: Add different team email addresses for different notification types. For example:
   * `finance@yourcompany.com` for payout notifications
   * `support@yourcompany.com` for dispute notifications
   * `sales@yourcompany.com` for payment notifications

2. **Enable critical notifications across channels**: For time-sensitive events like disputes, consider enabling notifications on multiple channels (email + push) to ensure you never miss them.

3. **Review preferences periodically**: As your team grows or changes, review your notification settings to ensure the right people are receiving the right notifications.

4. **Keep customer emails enabled**: Unless you have a specific reason to disable them, keeping customer emails enabled provides a better customer experience and reduces support inquiries.


# Customer Credits
Source: https://docs.dodopayments.com/features/customer-credit

Learn how to manage customer credit balances, issue service credits, and handle billing adjustments seamlessly with Dodo Payments.

<CardGroup>
  <Card title="API Reference - Customer Credits" icon="code" href="/api-reference/customers/get-customer-wallets">
    Access the complete API documentation for managing customer credits and test credit operations interactively.
  </Card>
</CardGroup>

## What is Customer Credit?

Customer Credits provide a flexible way to manage customer balances and enhance billing relationships. With customer credits, you can:

* **Reward loyal customers** with account credits for exceptional service or loyalty programs
* **Issue service credits** to compensate for service interruptions or billing adjustments
* **Handle manual adjustments** without disrupting existing billing cycles
* **Provide refunds** that customers can use for future purchases

<Info>
  Customer credits create a positive balance in a customer's account that automatically applies to future subscription payments, reducing the amount charged to their payment method.
</Info>

## How Customer Credits Work

Customer credits operate on a simple principle: available credit is automatically applied to subscription payments before charging the customer's payment method.

### Automatic Credit Application

When a subscription payment is due, Dodo Payments follows this payment sequence:

<Steps>
  <Step title="Check Credit Balance">
    The system checks if the customer has available credit in their account.
  </Step>

  <Step title="Apply Available Credit">
    If credit is available, it's automatically applied to reduce the payment amount.
  </Step>

  <Step title="Calculate Remaining Balance">
    Any remaining amount after credit application is charged to the customer's payment method.
  </Step>

  <Step title="Process Payment">
    The final payment is processed for the remaining balance, if any.
  </Step>
</Steps>

<Info>
  Dodo Payments supports separate credit wallets for INR and USD. Credits added to an INR wallet can only be used for INR subscriptions, while USD wallet credits apply exclusively to USD subscriptions. You cannot use credits from one currency wallet to pay for subscriptions in another currency.
</Info>

### Payment Scenarios

<Tabs>
  <Tab title="Full Credit Coverage">
    **Scenario**: Customer has 60 USD credit, subscription costs 20 USD

    **Result**:

    * \$20 deducted from credit balance
    * \$0 charged to payment method
    * Remaining credit: \$40

    <Check>
      No payment method charge required when credit fully covers the subscription cost.
    </Check>
  </Tab>

  <Tab title="Partial Credit Coverage">
    **Scenario**: Customer has 60 USD credit, subscription costs 100 USD

    **Result**:

    * \$60 deducted from credit balance
    * \$40 charged to payment method
    * Remaining credit: \$0

    <Info>
      Credits are always applied first, minimizing the charge to the customer's payment method.
    </Info>
  </Tab>

  <Tab title="No Credit Available">
    **Scenario**: Customer has 0 USD credit, subscription costs 50 USD

    **Result**:

    * \$0 deducted from credit balance
    * \$50 charged to payment method
    * Remaining credit: \$0
  </Tab>
</Tabs>

## Managing Customer Credits

Effectively manage customer credit balances through the Dodo Payments dashboard with comprehensive credit and debit operations.

### Adding Credits to Customer Accounts

Increase customer account balances by adding credits for various business scenarios:

<Steps>
  <Step title="Navigate to Customer Details">
    Go to **Customers** in your dashboard and select the specific customer you want to manage.
  </Step>

  <Step title="Access Credit Ledger">
    Navigate to the **Credit Ledger** section on the customer detail page.

    <Info>
      The Credit Ledger provides a complete transaction history and current balance overview for the customer.
    </Info>
  </Step>

  <Step title="Initiate Credit Application">
    Click **Apply Credit** to open the credit management interface.
  </Step>

  <Step title="Configure Credit Details">
    Set up the credit transaction with the following information:

    <ParamField type="string">
      Select **Credit** to add funds to the customer's account balance.
    </ParamField>

    <ParamField type="number">
      Enter the credit amount to add to the customer's account.
    </ParamField>

    <ParamField type="string">
      Choose the currency for the credit transaction:

      * **USD** - US Dollars
      * **INR** - Indian Rupees
    </ParamField>

    <ParamField type="string">
      Provide an optional explanation for the credit application, such as "Service compensation" or "Loyalty reward".
    </ParamField>
  </Step>

  <Step title="Apply Credit">
    Review the credit details and click **Apply** to add the credit to the customer's account.

    <Check>
      The credit is immediately available for use on the customer's next subscription payment.
    </Check>
  </Step>
</Steps>

### Removing Credits (Debit Operations)

Remove funds from customer accounts when adjustments or corrections are needed:

<Steps>
  <Step title="Access Credit Management">
    Follow the same navigation path: **Customers** → **Customer Detail Page** → **Credit Ledger** → **Apply Credit**.
  </Step>

  <Step title="Configure Debit Transaction">
    Set up the debit operation:

    <ParamField type="string">
      Select **Debit** to remove funds from the customer's account balance.
    </ParamField>

    <ParamField type="number">
      Enter the amount to deduct from the customer's credit balance.
    </ParamField>

    <ParamField type="string">
      Choose the appropriate currency (USD or INR).
    </ParamField>

    <ParamField type="string">
      Provide an explanation for the debit, such as "Billing correction" or "Credit adjustment".
    </ParamField>

    <Warning>
      Ensure the customer has sufficient credit balance before applying a debit. Negative balances are not supported.
    </Warning>
  </Step>

  <Step title="Apply Debit">
    Review and confirm the debit transaction to remove the specified amount from the customer's account.
  </Step>
</Steps>

## Understanding the Credit Ledger

The Credit Ledger provides comprehensive tracking and transparency for all customer credit transactions.

### Available Credit Balance

The customer's available credit balance is prominently displayed at the top of the Credit Ledger interface, providing immediate visibility into their current credit status.

**Total Balance Overview**\
The main balance display shows the combined credit amount across all supported currencies, converted to a single currency for easy reference. This unified view helps you quickly assess the customer's total available credit without needing to calculate across multiple currencies.

<Tip>
  The total balance is automatically calculated using current exchange rates to provide an accurate combined view of multi-currency credits.
</Tip>

**Currency Breakdown**
Click the "View Breakdown" button to expand the detailed view and see individual balances for each currency:

* **USD Balance**: Shows the exact amount available in US Dollars
* **INR Balance**: Shows the exact amount available in Indian Rupees
* **Additional Currencies**: Any other currencies with available credit balances

<Note>
  The breakdown view is particularly useful when managing customers who make payments in multiple currencies or when you need to verify specific currency allocations.
</Note>

### Ledger Entry Components

Each transaction in the Credit Ledger contains the following information:

<ResponseField name="Entry ID" type="string">
  Unique identifier for each credit transaction, ensuring complete auditability.
</ResponseField>

<ResponseField name="Reference ID" type="string">
  Payment ID when the transaction is linked to a specific payment or billing event.
</ResponseField>

<ResponseField name="Event Type" type="string">
  The type of transaction that created this ledger entry:

  * **Payment** - Credit used for subscription payment
  * **PaymentReversal** - Payment reversal creating credit
  * **Refund** - Refund processed as credit
  * **RefundReversal** - Refund reversal removing credit
  * **Dispute** - Dispute-related credit adjustment
  * **DisputeReversal** - Dispute resolution adjustment
  * **MerchantAdjustment** - Manual credit/debit by merchant
</ResponseField>

<ResponseField name="Amount" type="number">
  The transaction amount, showing positive values for credits and negative values for debits.
</ResponseField>

<ResponseField name="Before Balance" type="number">
  Customer's credit balance before this transaction was processed.
</ResponseField>

<ResponseField name="After Balance" type="number">
  Customer's credit balance after this transaction was completed.
</ResponseField>

<ResponseField name="Reason" type="string">
  Optional explanation provided when the transaction was created.
</ResponseField>

<ResponseField name="Created At" type="timestamp">
  When the transaction was processed, in ISO 8601 format.
</ResponseField>

## Real-World Credit Scenarios

Understanding practical applications helps you leverage customer credits effectively for business growth and customer satisfaction.

### Scenario Examples

<AccordionGroup>
  <Accordion title="Service Credit for Downtime">
    **Situation**: Your service experienced a 2-hour outage affecting a premium customer.

    **Action**: Apply a 25 USD service credit with reason "Compensation for service downtime on \[date]"

    **Result**: Customer receives credit that automatically applies to their next USD 50 subscription, reducing their charge to \$25.

    **Business Impact**: Maintains customer satisfaction and demonstrates commitment to service quality.
  </Accordion>

  <Accordion title="Loyalty Reward Program">
    **Situation**: A customer has been subscribed for 12 consecutive months.

    **Action**: Apply a \$10 loyalty credit with reason "Annual loyalty reward - Thank you for being with us!"

    **Result**: Customer receives unexpected value, strengthening retention and brand loyalty.

    **Business Impact**: Proactive customer appreciation that encourages continued subscription.
  </Accordion>
</AccordionGroup>

## Current Limitations

<Warning>
  The following features are planned for Phase 2 release and are not currently available:
</Warning>

### Checkout Integration

Customer credits cannot currently be applied during the checkout process. Customers cannot view or use their available credit balance when making new purchases through payment pages.

**Planned Enhancement**: Future releases will include credit balance display and application options in checkout flows.

### One-Time Payment Products

Credits are currently only applicable to recurring subscription payments. They cannot be used for one-time payment products or single purchases.


# Customer Portal
Source: https://docs.dodopayments.com/features/customer-portal

Empower customers to self-serve and manage their subscriptions, billing history, license keys, and profile securely.

<Info>
  The Customer Portal is a secure, hosted area where your customers can manage subscriptions, view invoices and access license keys details—without contacting support.
</Info>

<CardGroup>
  <Card title="Create Portal Session (API)" icon="code" href="/api-reference/customers/create-customer-portal-session">
    Programmatically create secure, time‑bound portal sessions.
  </Card>

  <Card title="Subscriptions" icon="repeat" href="/features/subscription">
    Manage recurring plans, upgrades, downgrades, and add‑ons.
  </Card>
</CardGroup>

<br />

<Frame>
  <img alt="Customer portal overview cover" />
</Frame>

## What Is the Customer Portal?

The portal provides a trusted, branded self‑service experience for customers to:

* **Access billing history**: View invoices and download.
* **Manage subscriptions**: Cancel a subscription.
* **Update payment methods**: Change payment methods for active subscriptions or reactivate subscriptions on hold.
* **Retrieve license keys**: Access all keys tied to purchases

## Key Benefits

* **Lower support volume**: Customers resolve common billing requests on their own
* **Faster time‑to‑value**: Immediate access to invoices and keys
* **Reduced churn risk**: Clear visibility into renewals and plan details
* **Secure by design**: Tokenized access with expiring links

## Access Methods

Customers can reach the portal using either a static link or a one‑time dynamic link.

### Static link (email‑based access)

Customers can request portal access by entering their email at a static link that never expires.

The static portal link format varies by environment:

**Test Mode** (for testing and development):

```bash theme={null}
https://test.customer.dodopayments.com/login/{business_id}
```

**Live Mode** (for production with real transactions):

```bash theme={null}
https://customer.dodopayments.com/login/{business_id}
```

Replace `{business_id}` with your actual business identifier, then share the appropriate link with customers so they can enter their email and receive secure access to the portal.

<Frame>
  <img alt="Email-based login screen" />
</Frame>

<Steps>
  <Step title="Merchant flow">
    1. Go to Sales → Customer.
    2. Click <i>Share invite</i>.
    3. Copy the <i>Static link</i> and share it with your customer.
  </Step>

  <Step title="Customer flow">
    1. Open the static link.
    2. Enter the email used at purchase.
    3. Receive a secure login link to access the portal.

    <Check>
      Existing customers are recognized automatically.
    </Check>
  </Step>
</Steps>

### Dynamic link (magic link)

A personalized, one‑time magic link that sends customers directly into the portal. The link expires in 24 hours.

<Warning>
  Dynamic links expire after 24 hours. If it expires, generate and send a new link.
</Warning>

<Frame>
  <img alt="Magic link direct access" />
</Frame>

<Steps>
  <Step title="Merchant flow">
    1. Go to Sales → Customer.
    2. Click <i>Share invite</i>.
    3. Copy the <i>Dynamic link</i> and share it with your customer.
  </Step>

  <Step title="Customer flow">
    1. Open the dynamic link.
    2. Access the Customer Portal directly without entering an email.
  </Step>
</Steps>

## Portal Features

<CardGroup>
  <Card title="Billing History" icon="file-invoice">
    View all transactions and invoice details. Download PDFs of every invoice from your account.
  </Card>

  <Card title="Subscriptions" icon="repeat">
    Review active and past subscriptions, including renewal dates. Cancel plans at any time, and update the customer name and billing address.
  </Card>

  <Card title="Payment Methods" icon="credit-card">
    Update payment methods for subscriptions. Reactivate subscriptions on hold by updating payment method to clear dues.
  </Card>

  <Card title="Profile" icon="user">
    View your name, email, and phone number directly in your profile settings.
  </Card>
</CardGroup>

## Plan Changes (Upgrade/Downgrade)

When products are organized into **Product Collections**, customers can upgrade or downgrade between plans directly from the Customer Portal.

<Tip>
  **Want to enable upgrade/downgrade for existing subscriptions?** Add your subscription products to a Product Collection. Once grouped, customers can switch between plans in the same collection via the Customer Portal.
</Tip>

### Available Actions

| Action        | Description                                       | When Available                            |
| ------------- | ------------------------------------------------- | ----------------------------------------- |
| **Upgrade**   | Move to a higher-tier plan in the same collection | Business has enabled subscription updates |
| **Downgrade** | Move to a lower-tier plan in the same collection  | Business has enabled subscription updates |

### How Plan Changes Work

1. Customer views their current subscription in the portal
2. Available upgrade/downgrade options are shown based on the product collection
3. Customer selects the new plan
4. Proration is calculated and payment is processed immediately (if applicable)
5. Subscription is updated to the new plan

<Info>
  Plan changes are only available between products within the same collection. Products must be subscription or usage-based billing types.
</Info>

### Business Controls

Businesses can configure plan change behavior in Subscription Settings:

* **Allow Subscription Updates**: Enable or disable the ability for customers to upgrade or downgrade their subscriptions

<Card title="Product Collections" icon="layer-group" href="/features/product-collections">
  Learn how to set up product collections and configure upgrade/downgrade paths.
</Card>

## Updating Payment Methods

Customers can update their payment methods directly from the Customer Portal. This feature is especially important for reactivating subscriptions that have been placed on hold due to failed payments.

### Viewing Current Payment Method

From the subscription management page, customers can see their current payment method displayed alongside subscription details. The payment method section shows the card type, last four digits, and an "Edit" button to update it.

<Frame>
  <img alt="Subscription details page showing current payment method with edit option" />
</Frame>

### Updating Payment Method

When customers click "Edit" on the payment method section, they can:

1. **Select an existing payment method**: Choose from previously saved payment methods
   <Frame>
     <img />
   </Frame>
2. **Add a new payment method**: Enter new card details securely
   <Frame>
     <img />
   </Frame>

### Reactivating Subscriptions on Hold

When a subscription is placed on `on_hold` state due to a failed payment, customers must update their payment method to reactivate it. The update process automatically:

1. **Creates a charge** for remaining dues
2. **Generates an invoice** for the charge
3. **Processes the payment** using the new payment method
4. **Reactivates the subscription** to `active` state upon successful payment

<Warning>
  Subscriptions in `on_hold` state will not renew automatically. Customers must update their payment method to clear dues and reactivate the subscription.
</Warning>

<Info>
  After successfully updating the payment method for an `on_hold` subscription, customers will see a confirmation page and receive email notifications about the successful payment and subscription reactivation.
</Info>

<Frame>
  <img alt="Payment successful page confirming payment method update and subscription reactivation" />
</Frame>

### Payment Method Update Flow

<Steps>
  <Step title="Access subscription details">
    Navigate to the subscription management page in the Customer Portal to view subscription details and current payment method.
  </Step>

  <Step title="Click Edit on payment method">
    Click the "Edit" button next to the payment method section to open the payment method update interface.
  </Step>

  <Step title="Select or add payment method">
    Choose an existing saved payment method or add a new one by entering card details securely.
  </Step>

  <Step title="Confirm changes">
    Click "Confirm Changes" to update the payment method. For `on_hold` subscriptions, this will automatically create a charge for remaining dues.
  </Step>

  <Step title="Complete payment (if on hold)">
    If the subscription is on hold, customers will be redirected to complete the payment for remaining dues. Upon successful payment, the subscription is automatically reactivated.
  </Step>

  <Step title="Confirmation">
    Customers receive confirmation that the payment method has been updated and, if applicable, that the subscription has been reactivated.
  </Step>
</Steps>

## Integration Examples

Create a time‑bound Customer Portal session for a specific customer via API, then redirect the user to the session URL.

<CodeGroup>
  ```typescript Node.js theme={null}
  const session = await client.customers.customerPortal.create('cus_123');

  // Redirect the user to the hosted Customer Portal
  window.location.href = session.link;
  ```
</CodeGroup>

## Unified Customer Portal

In addition to business-specific customer portals, Dodo Payments offers a **Unified Customer Portal** at [customer.dodopayments.com](https://customer.dodopayments.com) where customers can view and manage all their purchases and subscriptions across different businesses using Dodo Payments.

<Frame>
  <img alt="Unified Customer Portal" />
</Frame>

### Unified Portal Features

* **Cross-business visibility**: View all purchases and subscriptions from any Dodo Payments merchant in one place
* **Centralized management**: Manage subscriptions across different businesses from a single dashboard
* **Unified billing history**: Access invoices and payment history from all purchases
* **Single sign-on**: Log in once with email to access purchases from all Dodo Payments merchants

<Tip>
  The Unified Customer Portal complements business-specific portals. Customers can use either the branded merchant portal or the unified portal based on their preference.
</Tip>

## Troubleshooting

* **Link expired**: Generate and send a new dynamic link.
* **Email not recognized**: Ask the customer to use the email associated with their purchase
* **Subscription on hold**: If a subscription is on hold, customers must update their payment method through the portal to clear dues and reactivate the subscription. The update process will automatically charge for remaining dues.
* **Payment method update failed**: If payment fails during the update process for an `on_hold` subscription, the subscription will remain on hold. Customers can try again with a different payment method.


# Customer Wallets
Source: https://docs.dodopayments.com/features/customer-wallet

Build credit-based billing systems like OpenAI or Claude with customer wallets. Track balances, manage credits, and create sophisticated financial workflows.

<CardGroup>
  <Card title="Get Customer Wallets" icon="code" href="/api-reference/customers/get-customer-wallets">
    Check customer wallet balances across currencies.
  </Card>

  <Card title="Create Ledger Entry" icon="plus" href="/api-reference/customers/post-customer-wallets-ledger-entries">
    Add or remove credits from customer wallets.
  </Card>

  <Card title="List Ledger Entries" icon="list" href="/api-reference/customers/get-customer-wallets-ledger-entries">
    View complete transaction history with pagination.
  </Card>
</CardGroup>

## What are Customer Wallets?

Think of customer wallets as digital piggy banks for your users. Every customer gets one automatically when you create their account. You can use these wallets to:

* **Track credit balances** in USD and INR
* **Build API credit systems** like OpenAI or Claude
* **Create prepaid billing** where customers buy credits upfront
* **Handle refunds** as wallet credits instead of cash
* **Manage complex billing** with detailed transaction history

<Info>
  Every customer automatically gets a wallet when you create their account. Wallets support USD and INR currencies with separate balances for each.
</Info>

<Frame>
  <img alt="Customer Wallets" />
</Frame>

## How It Works

Customer wallets are simple: they hold money (credits) that customers can spend on your services. When a customer makes a purchase, their wallet balance is checked first, and any available credits are used before charging their payment method.

### Automatic Setup

When you create a new customer, Dodo Payments automatically creates a wallet with zero balance. It's ready to use immediately through our API.

### Multi-Currency Support

Each wallet can hold balances in different currencies:

<ResponseField name="USD Balance" type="integer">
  Balance in US Dollars (stored in cents)
</ResponseField>

<ResponseField name="INR Balance" type="integer">
  Balance in Indian Rupees (stored in paise)
</ResponseField>

<Info>
  Currently, only <strong>USD</strong> and <strong>INR</strong> balances are available. More currencies coming soon.
</Info>

## Working with Wallets

### Check Customer Balances

See how much credit a customer has across all currencies. Perfect for checking if they have enough funds before processing a purchase.

<Card title="Get Customer Wallet Balances" icon="wallet" href="/api-reference/customers/get-customer-wallets">
  Check a customer’s wallet credit balances in all supported currencies.
</Card>

### Add or Remove Credits

Give customers credits (like welcome bonuses) or deduct credits (like usage charges). You can add reasons for each transaction to keep track of what happened.

<Card title="Create Customer Wallet Ledger Entry" icon="plus" href="/api-reference/customers/post-customer-wallets-ledger-entries">
  Add or remove credits from a customer’s wallet.
</Card>

### View Transaction History

See every credit and debit transaction for a customer. Great for debugging billing issues or showing customers their spending history.

<Card title="List Customer Wallet Ledger Entries" icon="list" href="/api-reference/customers/get-customer-wallets-ledger-entries">
  View every credit and debit transaction for a customer.
</Card>

## Real-World Examples

### API Credit System (Like OpenAI)

Build a system where customers buy credits and spend them on API calls:

```javascript theme={null}
// Give new customers welcome credits
async function giveWelcomeCredits(customerId) {
  await client.customers.wallets.ledgerEntries.create(customerId, {
    amount: 10000, // $100 in cents
    currency: 'USD',
    entry_type: 'credit',
    reason: 'Welcome bonus - 100 API credits',
    idempotency_key: `welcome_${customerId}_${Date.now()}`
  });
}

// Charge customers for API usage
async function chargeForApiUsage(customerId, usageCost) {
  try {
    await client.customers.wallets.ledgerEntries.create(customerId, {
      amount: usageCost, // Cost in cents
      currency: 'USD',
      entry_type: 'debit',
      reason: `API usage - ${usageCost} credits consumed`,
      idempotency_key: `usage_${customerId}_${Date.now()}`
    });
  } catch (error) {
    if (error.status === 400) {
      console.log('Customer needs to buy more credits');
    }
  }
}
```

### Prepaid Billing System

Let customers buy credits upfront and spend them over time:

<Steps>
  <Step title="Welcome New Customers">
    Give new customers some free credits to get started.

    ```javascript theme={null}
    await client.customers.wallets.ledgerEntries.create(customerId, {
      amount: 5000, // $50 welcome bonus
      currency: 'USD',
      entry_type: 'credit',
      reason: 'Welcome bonus for new customer',
      idempotency_key: `welcome_${customerId}`
    });
    ```
  </Step>

  <Step title="Handle Credit Purchases">
    When customers buy credits, add them to their wallet.

    ```javascript theme={null}
    await client.customers.wallets.ledgerEntries.create(customerId, {
      amount: purchaseAmount, // Amount paid in cents
      currency: 'USD',
      entry_type: 'credit',
      reason: `Credit purchase - ${purchaseAmount} credits`,
      idempotency_key: `purchase_${paymentId}`
    });
    ```
  </Step>

  <Step title="Charge for Usage">
    Deduct credits when customers use your service.

    ```javascript theme={null}
    await client.customers.wallets.ledgerEntries.create(customerId, {
      amount: usageCost,
      currency: 'USD', 
      entry_type: 'debit',
      reason: `Service usage - ${usageCost} credits`,
      idempotency_key: `usage_${usageId}`
    });
    ```
  </Step>

  <Step title="Monitor Balances">
    Check if customers are running low on credits.

    ```javascript theme={null}
    const wallets = await client.customers.wallets.list(customerId);
    const usdWallet = wallets.items.find(w => w.currency === 'USD');
    const balance = usdWallet.balance;

    if (balance < 1000) { // Less than $10
      // Send low balance notification
      await sendLowBalanceNotification(customerId, balance);
    }
    ```
  </Step>
</Steps>

### Multi-Currency Support

Handle customers in different countries:

<AccordionGroup>
  <Accordion title="US Customers">
    Give USD credits to US-based customers.

    ```javascript theme={null}
    await client.customers.wallets.ledgerEntries.create(customerId, {
      amount: 20000, // $200 in cents
      currency: 'USD',
      entry_type: 'credit',
      reason: 'USD credit purchase',
      idempotency_key: `usd_purchase_${paymentId}`
    });
    ```
  </Accordion>

  <Accordion title="Indian Customers">
    Give INR credits to Indian customers.

    ```javascript theme={null}
    await client.customers.wallets.ledgerEntries.create(customerId, {
      amount: 1500000, // Rs 15,000 in paise
      currency: 'INR',
      entry_type: 'credit',
      reason: 'INR credit purchase',
      idempotency_key: `inr_purchase_${paymentId}`
    });
    ```
  </Accordion>
</AccordionGroup>

## Best Practices

### Prevent Duplicate Transactions

Use idempotency keys to make sure you don't accidentally charge customers twice for the same thing:

```javascript theme={null}
async function addCreditsSafely(customerId, amount, reason) {
  const idempotencyKey = `${reason}_${customerId}_${Date.now()}`;
  
  try {
    const result = await client.customers.wallets.ledgerEntries.create(customerId, {
      amount: amount,
      currency: 'USD',
      entry_type: 'credit',
      reason: reason,
      idempotency_key: idempotencyKey
    });
    
    return { success: true, wallet: result };
  } catch (error) {
    if (error.status === 400 && error.message.includes('Insufficient balance')) {
      return { success: false, error: 'INSUFFICIENT_BALANCE' };
    }
    
    if (error.status === 409) {
      // Transaction already processed
      return { success: true, wallet: null, duplicate: true };
    }
    
    throw error;
  }
}
```

### Check Balances Before Charging

Always verify customers have enough credits before processing expensive operations:

```javascript theme={null}
async function checkBalanceBeforeOperation(customerId, requiredAmount) {
  const wallets = await client.customers.wallets.list(customerId);
  const usdWallet = wallets.items.find(w => w.currency === 'USD');
  
  if (!usdWallet || usdWallet.balance < requiredAmount) {
    throw new Error('Not enough credits for this operation');
  }
  
  return usdWallet.balance;
}
```

## What's Coming Next

<Warning>
  These features are planned for future releases:
</Warning>

* **Credit Expiration**: Set credits to expire after a certain time
* **Better Analytics**: Detailed spending reports and usage insights
* **More Webhooks**: Real-time notifications for balance changes and low credits

<Tip>
  Start simple with basic credit/debit operations, then add more complex features as your business grows.
</Tip>


# Customer Management
Source: https://docs.dodopayments.com/features/customers

Manage customer relationships, track purchase history, and provide self-service options through the Dodo Payments dashboard and API.

## Overview

The Customers feature in Dodo Payments provides a centralized hub for managing all your customer relationships. Track every customer interaction, view purchase history, manage subscriptions, access wallet credit ledgers, and enable self-service options - all from a single dashboard.

<CardGroup>
  <Card title="Customer Dashboard" icon="table-columns">
    View and manage all customers in one place with search and filtering capabilities.
  </Card>

  <Card title="Customer Wallets" icon="wallet">
    Build credit-based billing systems with prepaid balances and transaction tracking.
  </Card>

  <Card title="Customer Portal" icon="id-card">
    Empower customers to self-manage subscriptions, invoices, and license keys.
  </Card>

  <Card title="API Management" icon="code">
    Programmatically create, update, and retrieve customer data via API.
  </Card>
</CardGroup>

## Accessing the Customers Page

<Steps>
  <Step title="Navigate to Customers">
    From the dashboard, click on **Sales > Customers** in the navigation menu.
  </Step>

  <Step title="View Customer List">
    The Customers Page will display a list of all current and past customers who have interacted with your business.
  </Step>
</Steps>

<Frame>
  <img alt="Customers list page showing all customers with their details" />
</Frame>

## Customer Information

On the **Customers Page**, you can see a comprehensive overview of your entire customer base. The table displays all customers with the following information:

### Customer List Columns

* **Customer Name**: The full name of the customer with an avatar indicator.
* **Customer Id**: A unique identifier (e.g., `cus_5fpsWAa...`) for each customer.
* **Email**: The customer's email address for communication and portal access.
* **Phone Number**: The customer's phone number (if provided).
* **Created At (UTC)**: The date and time when the customer account was created.
* **Invite**: Quick action button to share Customer Portal invites.

### Page Features

* **Edit Columns**: Customize which columns are displayed in the customer table.
* **Build Report**: Generate custom reports based on your customer data.
* **Search**: Quickly find specific customers by name, email, or customer ID.
* **Pagination**: Navigate through your customer list with adjustable rows per page.

<Tip>
  Use the "Edit Columns" feature to customize your view and show only the information most relevant to your workflow.
</Tip>

## Customer Details Page

Click on any customer to view their detailed information page, which includes:

<Frame>
  <img alt="Customer details page showing customer information and transaction history" />
</Frame>

### About Section

The About section displays core customer information:

* **Name**: Customer's full name
* **Email**: Customer's email address
* **Customer ID**: Unique identifier for API and tracking purposes
* **Created At**: Timestamp of when the customer account was created

### Customer Activity Tabs

The customer details page includes three tabs for viewing different aspects of customer activity:

<Tabs>
  <Tab title="Transactions History">
    View all payment transactions for this customer including:

    * **Payment ID**: Unique transaction identifier
    * **Status**: Payment status (Successful, Failed, Pending, Refunded)
    * **Amount**: Transaction amount
    * **Date (UTC)**: When the transaction occurred
    * **Pricing Type**: Whether it's a one-time purchase or subscription
    * **Payment Method**: Payment method used (Card, UPI, etc.)
    * **Customer Email**: Email associated with the transaction
    * **Refund**: Quick action to initiate refunds
    * **Actions**: Additional options for managing the transaction
  </Tab>

  <Tab title="Active Subscriptions">
    View all active subscriptions for this customer:

    * Subscription plan details
    * Billing cycle and next renewal date
    * Subscription status
    * Options to manage or cancel subscriptions
  </Tab>

  <Tab title="Credit Ledger">
    View the customer's wallet credit ledger showing:

    * All credit and debit transactions
    * Current wallet balance in each currency
    * Transaction reasons and timestamps
    * Detailed transaction history for reconciliation
  </Tab>
</Tabs>

<Note>
  The Credit Ledger tab provides complete transparency into customer wallet transactions, making it easy to track credits, debits, and current balances.
</Note>

## Customer Portal

The Customer Portal is a secure, hosted self-service area where your customers can manage their subscriptions, view billing history, access license keys, and update their profile—without contacting support.

### Portal Capabilities

Customers can access the portal to:

* **View Billing History**: See all past transactions and download invoices.
* **Manage Subscriptions**: Cancel or view subscription details.
* **Retrieve License Keys**: Access all license keys tied to their purchases.
* **Update Profile**: Change name, email, or phone number.

<Card title="Learn More About Customer Portal" icon="id-card" href="/features/customer-portal">
  Explore detailed documentation on portal features, access methods, and integration examples.
</Card>

## Customer Wallets

Customer Wallets enable you to build credit-based billing systems similar to OpenAI or Claude. Each customer automatically receives a wallet that can hold prepaid credits in multiple currencies.

### Key Features

* **Multi-Currency Support**: Track balances in USD and INR separately.
* **Credit-Based Billing**: Allow customers to purchase credits upfront and spend them on your services.
* **Transaction History**: View complete ledger of all credits and debits.
* **API-First Design**: Programmatically add, remove, and check wallet balances.

<Card title="Learn More About Customer Wallets" icon="wallet" href="/features/customer-wallet">
  Explore detailed documentation, code examples, and best practices for implementing customer wallets.
</Card>

## API Management

Dodo Payments provides a comprehensive REST API for programmatic customer management. You can create, retrieve, update, and manage customers entirely through the API.

### Available API Endpoints

<CardGroup>
  <Card title="Create Customer" icon="user-plus" href="/api-reference/customers/create-customer">
    Create a new customer in your Dodo Payments account with their details.
  </Card>

  <Card title="List Customers" icon="list" href="/api-reference/customers/get-customers">
    Retrieve a paginated list of all customers associated with your account.
  </Card>

  <Card title="Get Customer Details" icon="user" href="/api-reference/customers/get-customers-1">
    Get detailed information about a specific customer by their ID.
  </Card>

  <Card title="Update Customer" icon="pen" href="/api-reference/customers/patch-customer">
    Update a customer's information such as name, email, or metadata.
  </Card>

  <Card title="Create Portal Session" icon="arrow-up-right-from-square" href="/api-reference/customers/create-customer-portal-session">
    Generate a secure Customer Portal session link for a specific customer.
  </Card>
</CardGroup>

<Note>
  All API endpoints require authentication using your API key. Always use your secret key on the server-side and never expose it in client-side code.
</Note>


# Digital Product Delivery
Source: https://docs.dodopayments.com/features/digital-product-delivery

The Digital Product Delivery feature in Dodo Payments allows merchants to deliver digital products to their customers.

## Overview

The **Digital Product Delivery** feature enables merchants to automatically deliver digital files to customers after successful purchases. Whether you're selling e-books, design templates, software, or media packs, you can attach downloadable content to your products, providing instant access via email and the customer portal.

This feature supports both hosted file uploads and external download links, offering flexibility for various use cases.

## Key Features

<CardGroup>
  <Card title="File Upload" icon="upload">
    Upload and deliver digital files (PDF, ZIP, images, videos, etc.) directly to your customers.
  </Card>

  <Card title="Multiple Files" icon="files">
    Attach up to 10 files per product for comprehensive digital product delivery.
  </Card>

  <Card title="External Links" icon="link">
    Provide external download links (Dropbox, Google Drive, etc.) as an alternative to file uploads.
  </Card>

  <Card title="Automatic Delivery" icon="download">
    Customers automatically receive download instructions via email upon successful payment.
  </Card>
</CardGroup>

## Setup Process

<Steps>
  <Step title="Navigate to Products">
    Go to your dashboard and select **Products > Create New** or edit an existing product. Navigate to **Advanced Settings → Digital Product Delivery**.
  </Step>

  <Step title="Configure File Delivery">
    Choose one of the following options:

    * **Upload File(s)**: Add up to 10 files directly to your product
    * **External Download Link**: Paste a secure link hosted externally (e.g., Dropbox, Google Drive)

    <Frame>
      <img alt="Digital product delivery configuration interface showing file upload and external link options" />
    </Frame>
  </Step>

  <Step title="Save Configuration">
    Click **Update Product** to make your digital product delivery settings live.

    <Warning>
      Uploaded files are served via static URLs — anyone with the link can access the file. Consider external services with authentication for sensitive content.
    </Warning>
  </Step>
</Steps>

## Customer Experience

### Purchase Confirmation

After a successful transaction, customers receive a purchase confirmation email containing download links for their digital products.

<Frame>
  <img alt="Purchase confirmation email showing download links for digital products" />
</Frame>

### Customer Portal Access

Customers can access their digital products through the Customer Portal:

* Log in to view all past purchases
* Download files or access external links for each product
* Persistent access to purchased digital content

<Frame>
  <img alt="Customer portal interface showing available digital products for download" />
</Frame>

<Check>
  Customers can download files directly from confirmation emails or access them anytime through their portal.
</Check>

## Important Considerations

* **Security**: Static download links are not order-authenticated. Customers with the link can re-share the same link with other parties. For secure or licensed content, consider integrating with external services that support gated or authenticated access.
* **File Updates**: Updating a file or external link will affect all future purchases only. Past purchases will not be affected and customers can still access those files
* **Refunds**: Issuing a refund does not revoke access to files. Customers who already downloaded a file will still have it on their device.
* **Best Practice**: For version control or limited-time access, consider delivering your content via expiring or signed URLs hosted externally.


# Discounts
Source: https://docs.dodopayments.com/features/discount-codes

Create promotional codes to drive conversions, run campaigns, and reward customers with fixed or percentage discounts across one‑time and subscription purchases.

<Frame>
  <img alt="Discount codes overview cover" />
</Frame>

Discount codes let you run targeted promotions and incentives. Create percentage or fixed-amount discounts, set limits and expirations, restrict to products, and apply them seamlessly in checkout.

<CardGroup>
  <Card title="Checkout Sessions" icon="cart-shopping" href="/developer-resources/checkout-session">
    Apply codes during hosted checkout with `discount_code` and UI controls.
  </Card>

  <Card title="Validate Discount" icon="code" href="/api-reference/discounts/validate-discount">
    Check if a discount is valid by its ID.
  </Card>

  <Card title="Get Discount by Code" icon="tag" href="/api-reference/discounts/get-discount-by-code">
    Look up and validate a discount using its code name (e.g., "SAVE20").
  </Card>

  <Card title="Create Discount (API)" icon="code" href="/api-reference/discounts/create-discount">
    Programmatically create new discount codes.
  </Card>

  <Card title="List & Update Discounts" icon="code" href="/api-reference/discounts/list-discounts">
    Browse and manage existing discounts; update or delete as needed.
  </Card>
</CardGroup>

## What Are Discount Codes?

Discount codes are promotional tokens that reduce order totals at checkout. They’re ideal for:

* **Seasonal campaigns**: Black Friday, product launches, or anniversaries
* **Acquisition offers**: First‑purchase incentives or referral rewards
* **Retention**: Win‑back or loyalty rewards for existing customers
* **B2B deals**: Contracted or negotiated pricing via private codes

## Key Benefits

* **Flexible discounts**: Percentage or fixed amount off
* **Targeted control**: Restrict by product and subscription cycles
* **Campaign governance**: Expiration dates and usage limits
* **Seamless checkout**: UI field and API support via checkout sessions

## Creating Discount Codes

Create discount codes in your Dodo Payments dashboard, then apply them in hosted checkout or via API.

### Dashboard setup

* **Discount Name** (required): Internal and dashboard display name
* **Code** (required): The string customers enter at checkout
* **Type & Amount** (required): Set a percentage or fixed‑amount value, or generate a random code using the button provided
* **Expiration Date** (optional): Date after which the code becomes invalid
* **Usage Limit** (optional): Max total redemptions across all customers
* **Product Restriction** (optional): Limit applicability to selected products
* **Subscription Cycle Limit** (optional): Number of billing cycles the discount applies to

<Tip>
  Use cycle limits for introductory pricing on subscriptions (e.g., "50% off for 3 months").
</Tip>

## Checkout Experience

1. Shoppers enter the code in the checkout field.
2. Eligible discounts are applied and totals update immediately.

<Info>
  In Checkout Sessions, pass `discount_code` to pre‑apply a code, and set `feature_flags.allow_discount_code` to show the input field.
</Info>

## API Management

<AccordionGroup>
  <Accordion title="Create discounts">
    Create discount codes programmatically with type and amount.

    <Card title="API Reference" icon="code" href="/api-reference/discounts/create-discount">
      View the create discount API.
    </Card>
  </Accordion>

  <Accordion title="List and retrieve">
    List all discounts or retrieve details for management and auditing.

    <Card title="API Reference" icon="code" href="/api-reference/discounts/list-discounts">
      Browse listing and retrieval APIs.
    </Card>
  </Accordion>

  <Accordion title="Get discount by code">
    Look up a discount using its human-readable code (e.g., "SAVE20") instead of the internal ID.

    <Card title="API Reference" icon="code" href="/api-reference/discounts/get-discount-by-code">
      Retrieve discount by code name.
    </Card>
  </Accordion>

  <Accordion title="Update discounts">
    Modify discount configuration such as amount, expiration, or restrictions.

    <Card title="API Reference" icon="code" href="/api-reference/discounts/update-discount">
      Learn how to update discount details.
    </Card>
  </Accordion>

  <Accordion title="Validate discounts">
    Check whether a discount is valid and applicable before applying.

    <Card title="API Reference" icon="code" href="/api-reference/discounts/validate-discount">
      Validate discount usage.
    </Card>
  </Accordion>

  <Accordion title="Delete discounts">
    Deactivate or remove discounts that are no longer needed.

    <Card title="API Reference" icon="code" href="/api-reference/discounts/delete-discount">
      Delete a discount.
    </Card>
  </Accordion>
</AccordionGroup>

## Common Use Cases

* **Intro offers**: Limited‑time launch promotions for new products
* **Bulk or B2B**: Contracted discounts for select product sets
* **Retention plays**: Win‑back codes in churn‑prevention workflows
* **Seasonal campaigns**: Holiday or event‑based promotions

## Integration Examples

### Apply a discount in Checkout Sessions

Pre‑apply a discount and show the code input UI.

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    { product_id: 'prod_abc', quantity: 1 }
  ],
  discount_code: 'BLACKFRIDAY2024',
  customer: { email: 'user@example.com', name: 'Jane Doe' },
  return_url: 'https://yoursite.com/return'
});
```

### Enable discount entry without pre‑applying

Let customers enter a code at checkout without passing one upfront.

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    { product_id: 'prod_abc', quantity: 1 }
  ],
  feature_flags: {
    allow_discount_code: true
  },
  return_url: 'https://yoursite.com/return'
});
```

## Best Practices

* **Name clearly**: Use recognizable codes that match campaign names
* **Time‑box**: Add expirations to drive urgency and prevent misuse
* **Scope wisely**: Limit to specific products to avoid margin leakage
* **Validate early**: Check code applicability before confirming checkout
* **Monitor impact**: Track usage and conversion by campaign

<Info>
  Discount codes are powerful levers for acquisition and retention. Start with simple, well‑named offers, validate thoroughly, and iterate based on performance.
</Info>


# Hybrid Billing Models
Source: https://docs.dodopayments.com/features/hybrid-billing

Combine multiple billing modes to create sophisticated pricing strategies: subscription + usage, seats + add-ons, base + overage, and more.

<Info>
  Hybrid billing combines two or more billing models into a single pricing strategy. This lets you capture value from different dimensions—recurring fees, usage, seats, and features—while giving customers flexibility and predictability.
</Info>

<CardGroup>
  <Card title="Usage-Based Billing" icon="chart-line" href="/features/usage-based-billing/introduction">
    Foundation for consumption-based pricing.
  </Card>

  <Card title="Subscriptions" icon="repeat" href="/features/subscription">
    Foundation for recurring billing.
  </Card>

  <Card title="Add-ons" icon="puzzle" href="/features/addons">
    Extend subscriptions with optional upgrades.
  </Card>

  <Card title="Seat-Based Billing" icon="users" href="/features/seat-based-billing">
    Per-user pricing models.
  </Card>
</CardGroup>

***

## What is Hybrid Billing?

Hybrid billing combines multiple pricing dimensions into a single product offering. Instead of choosing between flat-rate subscriptions OR usage-based pricing, you use both together.

### Why Use Hybrid Billing?

| Business Goal                       | Hybrid Solution                     |
| ----------------------------------- | ----------------------------------- |
| Predictable revenue + growth upside | Base subscription + usage overage   |
| Team pricing that scales            | Per-seat + feature add-ons          |
| Land customers, expand later        | Low base fee + consumption charges  |
| Enterprise flexibility              | Committed spend + on-demand charges |
| Fair pricing for variable usage     | Included allowance + pay-per-use    |

### Common Hybrid Patterns

| Model                                   | Description                                    | Example                                         | Native Support |
| --------------------------------------- | ---------------------------------------------- | ----------------------------------------------- | -------------- |
| **1. Subscription + Usage**             | Base fee + consumption charges                 | \$49/mo + \$0.01/API call after 10K free        | ✅ Full         |
| **2. Subscription + Seats**             | Platform fee + per-user charges                | \$99/mo + \$15/seat                             | ✅ Full         |
| **3. Subscription + Feature Add-ons**   | Core plan + optional upgrades                  | \$29/mo + \$19/mo analytics + \$9/mo API access | ✅ Full         |
| **4. Seats + Usage**                    | Per-user fee + consumption overage             | \$10/user/mo + \$0.05/GB after 5GB/user         | ⚠️ Workaround  |
| **5. Subscription + Seats + Usage**     | Platform + users + consumption (triple hybrid) | \$199/mo + \$20/seat + usage overage            | ⚠️ Workaround  |
| **6. Tiered Base + Usage Overage**      | Different tiers with different allowances      | Starter (5K calls) vs Pro (50K calls) + overage | ✅ Full         |
| **7. Subscription + On-Demand Charges** | Recurring fee + variable manual charges        | \$99/mo retainer + hourly billing for work      | ✅ Full         |

***

## Hybrid Model 1: Subscription + Usage

The most common hybrid model. Customers pay a base subscription fee plus charges for consumption that exceeds included allowances.

### How It Works

**Pro Plan: \$49/month**

* **Included**: 10,000 API calls/month
* **Overage**: \$0.005 per call after 10,000

**Example calculation** (customer uses 25,000 calls this month):

* Base subscription: \$49.00
* Overage: (25,000 - 10,000) × $0.005 = $75.00
* **Total: \$124.00**

### Use Cases

* **API platforms**: Base access + per-request charges
* **AI/ML services**: Subscription + token/generation usage
* **Storage services**: Base plan + per-GB overage
* **Communication platforms**: Base + per-message/minute charges

### Implementation

<Steps>
  <Step title="Create Usage Meter">
    Set up a meter to track the billable usage dimension.

    ```bash theme={null}
    Dashboard: Meters → Create Meter
    Event Name: "api.call"
    Aggregation: Count
    This tracks API calls per customer
    ```
  </Step>

  <Step title="Create Subscription Product with Usage Pricing">
    Create a subscription product and attach the usage meter with pricing.

    ```bash theme={null}
    Dashboard: Create Product → Subscription
    Name: "Pro Plan"
    Base Price: $49/month

    Then attach usage pricing:
    - Meter: api.call
    - Price per unit: $0.005
    - Free threshold: 10,000 (included in subscription)
    ```

    <Info>
      The usage meter is attached directly to the subscription product. Usage charges are calculated and added to the subscription invoice automatically.
    </Info>
  </Step>

  <Step title="Create Checkout Session">
    Create a checkout session with your subscription product.

    ```typescript theme={null}
    const session = await client.checkoutSessions.create({
      product_cart: [
        { product_id: 'prod_pro_plan', quantity: 1 }
      ],
      customer: { email: 'customer@example.com' },
      return_url: 'https://yourapp.com/success'
    });
    ```
  </Step>

  <Step title="Send Usage Events">
    Track usage throughout the billing period.

    ```typescript theme={null}
    await fetch('https://api.dodopayments.com/events/ingest', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        events: [{
          event_id: `call_${Date.now()}`,
          customer_id: 'cus_123',
          event_name: 'api.call',
          timestamp: new Date().toISOString(),
          metadata: { endpoint: '/v1/generate' }
        }]
      })
    });
    ```
  </Step>
</Steps>

### Pricing Variations

<Tabs>
  <Tab title="Included Allowance">
    Free threshold covers usage included in base subscription.

    **Pro Plan: \$49/month**

    * Includes: 10,000 API calls
    * Overage: \$0.005/call after 10,000
    * Customer uses 8,000 → Pays \$49 (no overage)
  </Tab>

  <Tab title="Zero Base + Pure Usage">
    No base fee, every unit is billable from the first use.

    **Pay-As-You-Go: \$0/month base**

    * Includes: 0 API calls
    * Usage: \$0.01/call from first call
    * Customer uses 5,000 → Pays \$50
  </Tab>

  <Tab title="Tiered Allowances">
    Different tiers include different allowances.

    * **Starter**: \$19/month (1,000 calls included)
    * **Pro**: \$49/month (10,000 calls included)
    * **Enterprise**: \$199/month (100,000 calls included)
    * All tiers: \$0.005/call overage
  </Tab>
</Tabs>

***

## Hybrid Model 2: Subscription + Seats

Platform fee plus per-user charges. Ideal for team collaboration tools and B2B SaaS.

### How It Works

**Team Plan: $99/month + $15/seat**

* **Base platform fee**: \$99/month (includes 3 seats)
* **Additional seats**: \$15/seat/month

**Example calculation** (team of 12 users):

* Platform fee: \$99.00
* Extra seats: (12 - 3) × $15 = $135.00
* **Total: \$234.00/month**

### Use Cases

* **Collaboration tools**: Workspace fee + per-member
* **CRM systems**: Platform license + per-sales-rep
* **Project management**: Team plan + per-contributor
* **Developer tools**: Organization fee + per-developer

### Implementation

<Steps>
  <Step title="Create Seat Add-on">
    Create an add-on for additional seats.

    ```bash theme={null}
    Dashboard: Products → Add-ons → Create Add-on
    Name: "Additional Seat"
    Price: $15/month
    Description: "Add another team member"
    ```
  </Step>

  <Step title="Create Base Subscription">
    Create the subscription product with platform fee and attach the add-on.

    ```bash theme={null}
    Dashboard: Create Product → Subscription
    Name: "Team Plan"
    Price: $99/month
    Description: "Includes 3 team members"

    Then in Add-ons section:
    - Attach: "Additional Seat" add-on
    ```
  </Step>

  <Step title="Create Checkout with Seats">
    Specify seat quantity during checkout.

    ```typescript theme={null}
    const session = await client.checkoutSessions.create({
      product_cart: [{
        product_id: 'prod_team_plan',
        quantity: 1,
        addons: [{
          addon_id: 'addon_seat',
          quantity: 9  // 9 extra seats (12 total with 3 included)
        }]
      }],
      customer: { email: 'admin@company.com' },
      return_url: 'https://yourapp.com/success'
    });
    ```
  </Step>

  <Step title="Adjust Seats as Needed">
    Add or remove seats on existing subscriptions.

    ```typescript theme={null}
    // Add 5 more seats
    await client.subscriptions.changePlan('sub_123', {
      product_id: 'prod_team_plan',
      quantity: 1,
      proration_billing_mode: 'prorated_immediately',
      addons: [{
        addon_id: 'addon_seat',
        quantity: 14  // New total: 14 extra seats
      }]
    });
    ```
  </Step>
</Steps>

### Pricing Variations

<Tabs>
  <Tab title="Included Seats">
    Base plan includes some seats, charge for extras.

    **Team Plan: \$99/month**

    * Includes: 5 seats
    * Extra seats: \$15/seat/month
    * 20 users = \$99 + (15 × \$15) = \$324/month
  </Tab>

  <Tab title="Pure Per-Seat">
    No platform fee, only per-user charges.

    **Per User: \$25/user/month**

    * No platform fee
    * 5 users = \$125/month
    * 50 users = \$1,250/month

    Implementation: Set base subscription price to \$0, use seat add-on only.
  </Tab>

  <Tab title="Tiered Per-Seat">
    Per-seat price decreases at higher tiers.

    * **Starter**: \$20/seat (1-10 seats)
    * **Growth**: \$15/seat (11-50 seats)
    * **Enterprise**: \$10/seat (51+ seats)

    Implementation: Create separate subscription products for each tier with different add-on prices.
  </Tab>
</Tabs>

***

## Hybrid Model 3: Subscription + Feature Add-ons

Core subscription with optional feature upgrades customers can add.

### How It Works

**Core Plan: \$29/month**

**Optional Add-ons:**

* Advanced Analytics: +\$19/month
* API Access: +\$9/month
* Priority Support: +\$29/month
* White-label: +\$49/month

**Example calculation** (customer chooses Core + Analytics + API Access):

* Core plan: \$29.00
* Analytics: \$19.00
* API Access: \$9.00
* **Total: \$57.00/month**

### Use Cases

* **SaaS platforms**: Core features + premium modules
* **Marketing tools**: Base tool + integrations
* **Analytics products**: Dashboard + advanced reports
* **Security software**: Basic protection + advanced features

### Implementation

<Steps>
  <Step title="Create Feature Add-ons">
    Create an add-on for each optional feature.

    ```bash theme={null}
    # Add-on 1: Advanced Analytics
    Dashboard: Products → Add-ons → Create Add-on
    Name: "Advanced Analytics"
    Price: $19/month

    # Add-on 2: API Access
    Name: "API Access"
    Price: $9/month

    # Add-on 3: Priority Support
    Name: "Priority Support"
    Price: $29/month

    # Add-on 4: White-label
    Name: "White-label"
    Price: $49/month
    ```
  </Step>

  <Step title="Create Core Subscription">
    Define your base subscription and attach all feature add-ons.

    ```bash theme={null}
    Dashboard: Create Product → Subscription
    Name: "Core Plan"
    Price: $29/month

    Then in Add-ons section:
    - Attach all feature add-ons
    ```
  </Step>

  <Step title="Let Customers Choose">
    Checkout with selected features.

    ```typescript theme={null}
    const session = await client.checkoutSessions.create({
      product_cart: [{
        product_id: 'prod_core_plan',
        quantity: 1,
        addons: [
          { addon_id: 'addon_analytics', quantity: 1 },
          { addon_id: 'addon_api_access', quantity: 1 }
          // Customer didn't select support or white-label
        ]
      }],
      return_url: 'https://yourapp.com/success'
    });
    ```
  </Step>

  <Step title="Add Features Later">
    Customers can add features to existing subscriptions.

    ```typescript theme={null}
    // Customer wants to add Priority Support
    await client.subscriptions.changePlan('sub_123', {
      product_id: 'prod_core_plan',
      quantity: 1,
      proration_billing_mode: 'prorated_immediately',
      addons: [
        { addon_id: 'addon_analytics', quantity: 1 },
        { addon_id: 'addon_api_access', quantity: 1 },
        { addon_id: 'addon_priority_support', quantity: 1 }  // New!
      ]
    });
    ```
  </Step>
</Steps>

***

## Hybrid Model 4: Seats + Usage

Per-user fee combined with consumption-based charges. Each user gets an allowance.

<Warning>
  **Constraint**: Dodo Payments does not currently support attaching both usage meters and add-ons to the same subscription product. This model requires a workaround using application-level logic.
</Warning>

<Info>
  **Coming Soon**: Native support for Seats + Usage hybrid billing is on our roadmap. This will allow you to attach both usage meters and seat add-ons to the same subscription product.
</Info>

### How It Works

**Team Analytics: \$20/user/month**

**Each user includes:**

* 5 GB data processing/month
* Overage: \$2/GB after allowance

**Example calculation** (10-user team using 80 GB total):

* Seat fees: 10 × $20 = $200.00
* Included data: 10 × 5 GB = 50 GB
* Overage: (80 - 50) × $2 = $60.00
* **Total: \$260.00/month**

### Use Cases

* **Analytics platforms**: Per-analyst + data processing
* **Design tools**: Per-designer + storage/exports
* **Development environments**: Per-developer + compute hours
* **Communication tools**: Per-user + message/call volume

### Implementation Options

Since you cannot attach both usage meters and add-ons to the same subscription, choose one of these approaches:

<Tabs>
  <Tab title="Option A: Usage Product + App-Managed Seats">
    Use a usage-based subscription and manage seat billing in your application.

    <Steps>
      <Step title="Create Usage Meter">
        ```bash theme={null}
        Dashboard: Meters → Create Meter
        Event Name: "data.processed"
        Aggregation: Sum
        Property: "bytes"
        ```
      </Step>

      <Step title="Create Usage-Based Subscription">
        ```bash theme={null}
        Dashboard: Create Product → Subscription
        Name: "Team Analytics"
        Base Price: $0/month

        Attach usage pricing:
        - Meter: data.processed
        - Price per unit: $2/GB
        - Free threshold: 0 (managed by your app)
        ```
      </Step>

      <Step title="Manage Seats in Your Application">
        Track seat count and calculate seat fees separately.

        ```typescript theme={null}
        // Your application tracks seats and calculates total cost
        async function calculateMonthlyBill(customerId: string) {
          const seatCount = await getSeatCount(customerId);
          const seatFee = seatCount * 20; // $20/seat

          // Usage is billed by Dodo automatically
          // You invoice/charge seat fees separately or include in base price

          // Alternatively, adjust base subscription price when seats change
          const totalBasePrice = seatCount * 2000; // $20/seat in cents
          await client.subscriptions.update('sub_123', {
            // Update subscription to reflect seat-based pricing
          });
        }
        ```
      </Step>

      <Step title="Calculate Dynamic Free Threshold">
        Adjust included usage based on seat count.

        ```typescript theme={null}
        // When checking usage, apply per-seat allowance
        async function checkUsageOverage(customerId: string) {
          const seatCount = await getSeatCount(customerId);
          const includedGB = seatCount * 5; // 5 GB per user

          const currentUsage = await getUsageFromDodo(customerId);
          const overage = Math.max(0, currentUsage - includedGB);

          // Overage is billed by Dodo at $2/GB
          return { included: includedGB, used: currentUsage, overage };
        }
        ```
      </Step>
    </Steps>
  </Tab>

  <Tab title="Option B: Seat Add-on + On-Demand Usage Charges">
    Use add-ons for seats and charge usage manually via on-demand charges.

    <Steps>
      <Step title="Create Seat Add-on">
        ```bash theme={null}
        Dashboard: Products → Add-ons → Create Add-on
        Name: "Team Member"
        Price: $20/month
        ```
      </Step>

      <Step title="Create Subscription with Add-on">
        ```bash theme={null}
        Dashboard: Create Product → Subscription
        Name: "Team Analytics"
        Base Price: $0/month

        Attach add-on:
        - "Team Member" add-on

        Enable on-demand charging
        ```
      </Step>

      <Step title="Track Usage in Your Application">
        ```typescript theme={null}
        // Track usage events in your system
        async function trackDataProcessed(customerId: string, bytes: number) {
          await saveUsageEvent({
            customer_id: customerId,
            event_type: 'data.processed',
            bytes: bytes,
            timestamp: new Date()
          });
        }
        ```
      </Step>

      <Step title="Charge Usage at End of Cycle">
        Calculate and charge usage overages manually.

        ```typescript theme={null}
        async function billUsageOverage(subscriptionId: string) {
          const subscription = await getSubscription(subscriptionId);
          const seatCount = subscription.addons.find(a => a.id === 'addon_seat')?.quantity || 0;

          const includedGB = seatCount * 5;
          const usedGB = await calculatePeriodUsage(subscription.customer_id);
          const overageGB = Math.max(0, usedGB - includedGB);

          if (overageGB > 0) {
            const overageCharge = overageGB * 200; // $2/GB in cents
            await client.subscriptions.charge(subscriptionId, {
              product_price: overageCharge,
              product_description: `Data overage: ${overageGB} GB × $2/GB`
            });
          }
        }
        ```
      </Step>
    </Steps>
  </Tab>
</Tabs>

<Info>
  **Recommendation**: Option B (Seat Add-on + On-Demand Usage) is often easier to implement because Dodo handles seat billing automatically. You only need to track and charge usage overages.
</Info>

***

## Hybrid Model 5: Subscription + Seats + Usage (Triple Hybrid)

The most comprehensive model: platform fee + per-user + consumption.

<Warning>
  **Constraint**: Dodo Payments does not currently support attaching both usage meters and add-ons to the same subscription product. This model requires a workaround approach.
</Warning>

<Info>
  **Coming Soon**: Native support for Triple Hybrid billing (Base + Seats + Usage) is on our roadmap. This will allow you to attach both usage meters and seat add-ons to the same subscription product.
</Info>

### How It Works

**Enterprise Platform**

* **Platform Fee**: \$199/month
* **Per Seat**: \$25/user/month
* **Usage**: \$0.10/1000 API calls (50K included)

**Example calculation** (company with 20 users, 150,000 API calls):

* Platform: \$199.00
* Seats: 20 × $25 = $500.00
* Usage: (150K - 50K) × \$0.10/1K = \$10.00
* **Total: \$709.00/month**

### Use Cases

* **Enterprise SaaS**: Platform + team + consumption
* **Data platforms**: Workspace + analysts + queries
* **Integration platforms**: Hub + connectors + transactions
* **AI platforms**: Workspace + developers + inference

### Implementation Options

Choose one of these approaches to implement triple hybrid billing:

<Tabs>
  <Tab title="Option A: Base + Seats (Add-on) + On-Demand Usage">
    Use subscription with seat add-ons, charge usage manually via on-demand charges.

    **This is the recommended approach** because Dodo handles the platform fee and seat billing automatically.

    <Steps>
      <Step title="Create Seat Add-on">
        ```bash theme={null}
        Dashboard: Products → Add-ons → Create Add-on
        Name: "User Seat"
        Price: $25/month
        ```
      </Step>

      <Step title="Create Subscription Product">
        ```bash theme={null}
        Dashboard: Create Product → Subscription
        Name: "Enterprise Platform"
        Base Price: $199/month

        Attach add-on:
        - "User Seat" add-on

        Enable on-demand charging
        ```
      </Step>

      <Step title="Create Checkout with Seats">
        ```typescript theme={null}
        const session = await client.checkoutSessions.create({
          product_cart: [{
            product_id: 'prod_enterprise_platform',
            quantity: 1,
            addons: [{
              addon_id: 'addon_user_seat',
              quantity: 20  // 20 users
            }]
          }],
          customer: { email: 'enterprise@company.com' },
          return_url: 'https://yourapp.com/success'
        });
        ```
      </Step>

      <Step title="Track Usage in Your Application">
        Store usage events in your system.

        ```typescript theme={null}
        // Track API calls in your system
        async function trackApiCall(customerId: string, endpoint: string) {
          await saveUsageEvent({
            customer_id: customerId,
            event_type: 'api.call',
            endpoint: endpoint,
            timestamp: new Date()
          });
        }
        ```
      </Step>

      <Step title="Charge Usage at End of Cycle">
        Calculate and charge usage overages via on-demand charge.

        ```typescript theme={null}
        async function billUsageOverage(subscriptionId: string) {
          const usage = await calculatePeriodUsage(subscriptionId);
          const includedCalls = 50000;
          const overageCalls = Math.max(0, usage.totalCalls - includedCalls);

          if (overageCalls > 0) {
            // $0.10 per 1000 calls = $0.0001 per call
            const overageCharge = Math.ceil(overageCalls / 1000) * 10; // cents
            await client.subscriptions.charge(subscriptionId, {
              product_price: overageCharge,
              product_description: `API usage: ${overageCalls.toLocaleString()} calls over 50K included`
            });
          }
        }
        ```
      </Step>
    </Steps>
  </Tab>

  <Tab title="Option B: Base + Usage (Meter) + App-Managed Seats">
    Use subscription with usage meter, manage seat billing in your application.

    <Steps>
      <Step title="Create Usage Meter">
        ```bash theme={null}
        Dashboard: Meters → Create Meter
        Event Name: "api.call"
        Aggregation: Count
        ```
      </Step>

      <Step title="Create Subscription Product with Usage">
        ```bash theme={null}
        Dashboard: Create Product → Subscription
        Name: "Enterprise Platform"
        Base Price: $199/month

        Attach usage pricing:
        - Meter: api.call
        - Price: $0.10 per 1000 calls
        - Free threshold: 50,000
        ```
      </Step>

      <Step title="Manage Seats in Your Application">
        Track seat count and adjust base subscription price accordingly.

        ```typescript theme={null}
        // When seats change, update subscription price
        async function updateSeatCount(subscriptionId: string, newSeatCount: number) {
          const basePlatformFee = 19900; // $199 in cents
          const perSeatFee = 2500; // $25 in cents
          const totalPrice = basePlatformFee + (newSeatCount * perSeatFee);

          // Store seat count in your system
          await updateSeatsInDatabase(subscriptionId, newSeatCount);

          // Note: You may need to handle this via plan changes or
          // create multiple tier products for common seat counts
        }
        ```
      </Step>

      <Step title="Send Usage Events to Dodo">
        ```typescript theme={null}
        await fetch('https://api.dodopayments.com/events/ingest', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            events: [{
              event_id: `api_${Date.now()}`,
              customer_id: 'cus_enterprise',
              event_name: 'api.call',
              timestamp: new Date().toISOString()
            }]
          })
        });
        ```
      </Step>
    </Steps>
  </Tab>
</Tabs>

<Info>
  **Recommendation**: Option A (Base + Seats + On-Demand Usage) is generally easier because Dodo handles platform and seat billing automatically. You only need to track usage and submit charges at the end of each billing cycle.
</Info>

***

## Hybrid Model 6: Tiered Base + Usage Overage

Different subscription tiers with different included allowances and overage rates.

### How It Works

| Tier           | Price       | Included Calls | Overage Rate |
| -------------- | ----------- | -------------- | ------------ |
| **Starter**    | \$19/month  | 1,000          | \$0.02/call  |
| **Pro**        | \$79/month  | 25,000         | \$0.01/call  |
| **Business**   | \$199/month | 100,000        | \$0.005/call |
| **Enterprise** | \$499/month | 500,000        | \$0.002/call |

### Implementation

Create separate subscription products for each tier, each with its own usage configuration:

```bash theme={null}
# For each tier, create a subscription product:

# Starter Tier
Dashboard: Create Product → Subscription
Name: "Starter"
Base Price: $19/month
Usage Pricing:
- Meter: api.call
- Price: $0.02/call
- Free threshold: 1,000

# Pro Tier
Name: "Pro"
Base Price: $79/month
Usage Pricing:
- Meter: api.call
- Price: $0.01/call
- Free threshold: 25,000

# ... and so on for Business and Enterprise
```

### Upgrade Path

When customers upgrade tiers, they get:

* Higher included allowance
* Lower overage rates
* More value per dollar

```typescript theme={null}
// Customer upgrades from Starter to Pro
await client.subscriptions.changePlan('sub_123', {
  product_id: 'prod_pro',
  quantity: 1,
  proration_billing_mode: 'prorated_immediately'
});
```

***

## Hybrid Model 7: Subscription + On-Demand Charges

Recurring subscription plus variable manual charges for services or overages.

### How It Works

**Retainer Plan: \$199/month**

**Includes:**

* Platform access
* 5 hours consulting/month
* Email support

**On-Demand Charges (as needed):**

* Extra consulting: \$150/hour
* Custom development: \$200/hour
* Emergency support: \$100/incident

**Example calculation** (this month):

* Retainer: \$199.00
* 3 extra consulting hours: \$450.00
* 1 emergency support: \$100.00
* **Total: \$749.00**

### Use Cases

* **Consulting services**: Retainer + hourly billing
* **Managed services**: Base fee + incident charges
* **Agency services**: Monthly fee + project charges
* **Support plans**: SLA fee + per-ticket or per-hour

### Implementation

<Steps>
  <Step title="Create On-Demand Subscription">
    Set up subscription with on-demand charging enabled.

    ```typescript theme={null}
    const subscription = await client.subscriptions.create({
      billing: {
        city: 'San Francisco',
        country: 'US',
        state: 'CA',
        street: '123 Main St',
        zipcode: '94105'
      },
      customer: { customer_id: 'cus_123' },
      product_id: 'prod_retainer',
      quantity: 1,
      payment_link: true,
      return_url: 'https://yourapp.com/success',
      on_demand: {
        mandate_only: false,
        product_price: 19900  // $199 initial charge
      }
    });
    ```
  </Step>

  <Step title="Charge for Services">
    Create charges when services are delivered.

    ```typescript theme={null}
    // Charge for 3 hours of consulting
    await client.subscriptions.charge('sub_123', {
      product_price: 45000,  // $450.00 (3 × $150)
      product_description: 'Consulting - 3 hours (March 15)'
    });

    // Charge for emergency support incident
    await client.subscriptions.charge('sub_123', {
      product_price: 10000,  // $100.00
      product_description: 'Emergency support - Server outage (March 18)'
    });
    ```
  </Step>

  <Step title="Track and Invoice">
    All charges appear on the customer's invoice.

    ```typescript theme={null}
    // Retrieve subscription charges
    const payments = await client.payments.list({
      subscription_id: 'sub_123'
    });

    // Show itemized breakdown to customer
    payments.items.forEach(payment => {
      console.log(`${payment.description}: $${payment.amount / 100}`);
    });
    ```
  </Step>
</Steps>

***

## Real-World Examples

<Info>
  These examples show ideal pricing structures. Due to the constraint that usage meters and add-ons cannot be attached to the same product, some combinations require workarounds (using on-demand charges for usage or app-managed seats).
</Info>

### Example 1: AI SaaS Platform

**Pricing Structure:**

* **Base Subscription**: \$99/month (platform access, 5 seats included)
* **Seat Add-on**: \$20/seat/month
* **Feature Add-ons**: Custom Models (\$49/mo), API Access (\$29/mo), Priority Queue (\$19/mo)
* **Usage Overage**: \$0.02 per 1,000 tokens after 100K (charged via on-demand)

**Implementation**: Use subscription with seat and feature add-ons. Track token usage in your application and charge overages via on-demand charges at end of billing cycle.

**Example Customer** (12 users, 500K tokens, Custom Models + API Access):

| Component     | Calculation                  | Amount          |
| ------------- | ---------------------------- | --------------- |
| Base          | Platform fee                 | \$99            |
| Extra seats   | 7 × \$20                     | \$140           |
| Custom Models | Add-on                       | \$49            |
| API Access    | Add-on                       | \$29            |
| Token overage | 400K × \$0.02/1K (on-demand) | \$8             |
| **Total**     |                              | **\$325/month** |

### Example 2: Developer Tools Platform

**Tier Options:**

|             | Free      | Pro        | Enterprise  |
| ----------- | --------- | ---------- | ----------- |
| **Price**   | \$0/month | \$29/month | \$199/month |
| **Users**   | 1         | 5 included | Unlimited   |
| **Builds**  | 100       | 1,000      | 10,000      |
| **Storage** | 1 GB      | 10 GB      | 100 GB      |

**Implementation Options**:

**Option A** (Usage-focused): Create products with usage meters for builds/storage. Manage users in your application.

**Option B** (Seat-focused): Create products with seat add-ons. Track builds/storage usage and charge overages via on-demand.

**Add-ons (if using Option B):**

* Extra users: \$10/user/month
* Priority builds: \$19/month
* Custom domains: \$9/domain/month

### Example 3: Marketing Automation

**Pricing Structure:**

* **Base**: \$79/month (core automation features, 3 seats included)
* **Contact Tiers** (add-ons): 1K included, 5K (+\$30), 25K (+\$80), 100K (+\$200)
* **Feature Add-ons**: SMS Marketing (\$29/mo), Landing Pages (\$19/mo), A/B Testing (\$29/mo)
* **Team Seats**: \$15/user/month add-on
* **Email Volume**: Track in application, charge overage via on-demand (\$1/1,000 emails over limit)

**Implementation**: Use subscription with contact tier add-ons, feature add-ons, and seat add-ons. Track email sends in your application and charge overages via on-demand charges.

***

## Implementation Best Practices

### Pricing Page Clarity

<Tip>
  Make hybrid pricing easy to understand. Show base costs, what's included, and how overages work prominently on your pricing page.
</Tip>

**Good**: "\$49/month includes 10,000 API calls. Additional calls: \$0.005 each"

**Bad**: "\$49/month + usage fees"

### Cost Predictability

Help customers estimate their costs:

```typescript theme={null}
// Provide a cost calculator
function estimateMonthlyCost({
  plan,
  seats,
  expectedUsage,
  addons
}: EstimateParams): number {
  let total = plan.basePrice;

  // Add seat costs
  const extraSeats = Math.max(0, seats - plan.includedSeats);
  total += extraSeats * plan.seatPrice;

  // Add usage overage
  const overage = Math.max(0, expectedUsage - plan.includedUsage);
  total += overage * plan.overageRate;

  // Add feature add-ons
  total += addons.reduce((sum, addon) => sum + addon.price, 0);

  return total;
}
```

### Usage Visibility

Show customers their usage in real-time:

```typescript theme={null}
// Display usage dashboard
async function getUsageSummary(subscriptionId: string) {
  const usage = await client.subscriptions.getUsageHistory(subscriptionId);

  return {
    current: usage.current_period_usage,
    included: usage.free_threshold,
    remaining: Math.max(0, usage.free_threshold - usage.current_period_usage),
    overage: Math.max(0, usage.current_period_usage - usage.free_threshold),
    projectedCost: calculateProjectedOverage(usage)
  };
}
```

### Billing Transparency

Provide detailed invoices showing all components:

| Line Item                                    | Amount       |
| -------------------------------------------- | ------------ |
| Pro Plan (Monthly)                           | \$49.00      |
| Additional Seats (7 × \$15.00)               | \$105.00     |
| API Usage - Included (10,000 calls)          | \$0.00       |
| API Usage - Overage (15,420 calls × \$0.005) | \$77.10      |
| Advanced Analytics Add-on                    | \$19.00      |
| **Subtotal**                                 | **\$250.10** |
| Tax (8.5%)                                   | \$21.26      |
| **Total Due**                                | **\$271.36** |

***

## Troubleshooting Hybrid Billing

<AccordionGroup>
  <Accordion title="Usage not being tracked correctly">
    **Symptoms**: Usage shows 0 or incorrect values.

    **Solutions**:

    1. Verify event ingestion is working (check API responses)
    2. Confirm `customer_id` matches the subscription customer
    3. Check `event_name` matches the meter configuration
    4. Verify events have correct timestamps (not future-dated)
  </Accordion>

  <Accordion title="Proration confusion with multiple components">
    **Symptoms**: Customer charged unexpected amounts when changing plans.

    **Solutions**:

    1. Use `previewChangePlan` API to show exact charges before confirming
    2. Communicate that proration applies to subscription AND add-ons
    3. Consider using `difference_immediately` for simpler upgrade billing
  </Accordion>

  <Accordion title="Free threshold not applying correctly">
    **Symptoms**: Customer charged for usage that should be free.

    **Solutions**:

    1. Verify free threshold is configured on the usage-based product
    2. Check threshold unit matches event aggregation (calls vs. requests)
    3. Confirm usage meter is correctly attached to the subscription product
  </Accordion>

  <Accordion title="Add-ons not appearing in checkout">
    **Symptoms**: Can't add seats or features during checkout.

    **Solutions**:

    1. Verify add-ons are attached to the subscription product in dashboard
    2. Check add-on IDs are correct in API calls
    3. Ensure add-on currency matches subscription product currency
  </Accordion>
</AccordionGroup>

***

## Related Documentation

<CardGroup>
  <Card title="Products" icon="box" href="/features/products">
    Overview of all product types and guides.
  </Card>

  <Card title="Usage-Based Billing Guide" icon="chart-line" href="/developer-resources/usage-based-billing-guide">
    Complete usage billing implementation.
  </Card>

  <Card title="Subscription Management" icon="repeat" href="/features/subscription">
    Managing recurring subscriptions.
  </Card>

  <Card title="Add-ons" icon="puzzle" href="/features/addons">
    Extending subscriptions with add-ons.
  </Card>
</CardGroup>


# Invoice Management
Source: https://docs.dodopayments.com/features/invoice-generation

Automatically generate and deliver professional invoices for every successful payment, with customizable branding and seamless email delivery.

<Frame>
  <img alt="Invoice Generation Cover Image" />
</Frame>

## Overview

Dodo Payments automatically generates professional invoices for every successful transaction, eliminating manual invoice creation and ensuring consistent documentation for your business. Invoices are instantly delivered to both you and your customers via email after each payment.

<Info>
  Invoices are generated automatically for both one-time purchases and recurring subscription payments.
</Info>

## Key Features

<CardGroup>
  <Card title="Automatic Generation" icon="wand-magic-sparkles">
    Invoices are created instantly after successful payment processing without manual intervention.
  </Card>

  <Card title="Custom Branding" icon="palette">
    Add your business logo and name to maintain brand consistency across all customer touchpoints.
  </Card>

  <Card title="Email Delivery" icon="envelope">
    Invoices are automatically sent to customers and merchants immediately after generation.
  </Card>

  <Card title="Dashboard Management" icon="table-columns">
    Access and download invoices from a centralized dashboard view.
  </Card>
</CardGroup>

## Setting Up Invoice Branding

<Steps>
  <Step title="Navigate to Business Profile">
    Open the Dodo Payments dashboard and go to **Settings** → **Business Profile**.
  </Step>

  <Step title="Configure Branding">
    Upload your business logo and enter your business name. These details will appear on all generated invoices.

    <Tip>
      Use a high-resolution logo (minimum 300x300px) in PNG format for the best print quality.
    </Tip>
  </Step>

  <Step title="Save Configuration">
    Click **Save** to apply your branding settings. All future invoices will automatically use these details.

    <Check>
      Your invoice branding is now configured and will be applied to all new invoices.
    </Check>
  </Step>
</Steps>

## What's Included in Invoices

Every generated invoice contains comprehensive transaction details:

* **Business Information**: Your business name, logo, and contact details
* **Customer Details**: Customer name and email address
* **Invoice Number**: Unique identifier for tracking and reference
* **Transaction Date**: When the payment was processed
* **Payment Details**: Amount paid, currency, and payment method
* **Product/Service Description**: Itemized list of purchased products or subscriptions
* **Tax Information**: Applicable taxes and tax identification numbers
* **Payment Status**: Confirmation of successful payment

<Note>
  Invoice numbers are automatically generated and follow a sequential format for easy tracking.
</Note>

## How Invoice Generation Works

<Tabs>
  <Tab title="One-Time Purchases">
    When a customer completes a one-time purchase:

    1. Payment is processed successfully
    2. Invoice is automatically generated with transaction details
    3. Invoice is emailed to both customer and merchant
    4. Invoice appears in your dashboard **Invoices** section

    All one-time purchase invoices include product details, pricing, and payment confirmation.
  </Tab>

  <Tab title="Subscription Renewals">
    For recurring subscription payments:

    1. Subscription renewal payment is processed automatically
    2. Invoice is generated for the billing period
    3. Invoice is emailed to customer with subscription details
    4. Invoice is stored in your dashboard for records

    Subscription invoices include the billing period, subscription plan details, and next renewal date.
  </Tab>
</Tabs>

## Managing Invoices

### Accessing Your Invoices

Navigate to the **Invoices** section in your Dodo Payments dashboard to view all generated invoices. You can:

* **View Invoice Details**: Click any invoice to see complete transaction information
* **Download PDF**: Export invoices in PDF format for your records
* **Resend to Customer**: Email the invoice again if needed
* **Filter and Search**: Find specific invoices by date, customer, or invoice number

<Tip>
  Use the search and filter options to quickly locate invoices for accounting or customer support purposes.
</Tip>

## Invoice Template Preview

Here's what your branded invoices will look like:

<Frame>
  <img alt="Invoice template showing business branding, transaction details, and professional layout" />
</Frame>

## Related Features

<CardGroup>
  <Card title="Subscription Management" icon="calendar-days" href="/features/subscription">
    Learn how subscriptions work with automatic recurring invoices.
  </Card>

  <Card title="Multi-Brand Support" icon="layer-group" href="/features/multi-brands">
    Manage multiple brands with separate invoice branding for each.
  </Card>

  <Card title="Customer Portal" icon="user" href="/features/customer-portal">
    Allow customers to access their invoice history through the customer portal.
  </Card>

  <Card title="Tax Configuration" icon="percent" href="/features/tax-inclusive-pricing">
    Configure tax settings to ensure invoices display correct tax information.
  </Card>
</CardGroup>


# License Keys
Source: https://docs.dodopayments.com/features/license-keys

Securely generate, manage, and track license keys for your digital products with advanced access control and revocation.

<Frame>
  <iframe title="License Keys | Dodo Payments" />
</Frame>

<Info>
  Issue unique keys for your software or digital goods, control activations, and revoke access when needed. License keys pair well with subscriptions and one-time purchases.
</Info>

## What Are License Keys?

License keys are unique tokens that authorize access to your product. They're ideal for:

* **Software licensing**: Desktop apps, plugins, and CLIs
* **Per-seat controls**: Limit activations per user or device
* **Digital goods**: Gate downloads, updates, or premium features

## Key Benefits

* **Access control**: Define expiry and activation limits
* **Operational visibility**: Track usage, devices, and history
* **Security and support**: Disable, re-enable, and audit quickly

## Creating License Keys

<Steps>
  <Step title="Create a License Key">
    Go to your Dodo Payments dashboard and open the License Keys section. Select the option to create a new license key.
  </Step>

  <Step title="Configure License Key Settings">
    Set how your license keys will be issued and used by specifying these fields:

    * **License Key Expiry Date**: Define how long the key stays valid. Choose a specific duration (for example, 30 days or 1 year), or select "no expiry" for a perpetual key.
    * **Activation Limit**: Set the maximum number of concurrent activations per key. Use a specific number for scenarios like single-user (1) or team licenses (5), or select "unlimited" for no activation cap.
    * **Activation Instructions**: Provide clear activation steps for your customers, which will also be emailed with the license key. Examples: "Paste the key in Settings → License" or "Run: `mycli activate <key>`".
  </Step>

  <Step title="Review and Save">
    Check all entered details. When ready, save the license key configuration to finish key creation.

    <Tip>
      Use realistic instructions and include support links to reduce activation tickets.
    </Tip>
  </Step>
</Steps>

<Frame>
  <img alt="Creating a license key in Dodo Payments dashboard" />
</Frame>

## Manage & Monitor

The **License Keys Section** provides a comprehensive view of all license key activity and enables you to manage and monitor licenses effectively.

### Key Information

View detailed information for each license key:

* **Key Details**: License key value, associated product name, customer details (customer\_id), and purchase date
* **Usage Activity**: Number of activations, activation dates and times, and status (active, expired, disabled)
* **Expiry and Limits**: Key expiry date, remaining activation count, and current activation instances

<Frame>
  <img alt="License key details" />
</Frame>

### Available Actions

You can perform the following actions on license keys:

* **Disable License Key**: Immediately disable a key to prevent further usage
* **Enable Key**: Re-enable a previously disabled license key
* **View Activation Instances**: See all associated activation instances for a particular license key

<Frame>
  <img alt="License key actions" />
</Frame>

### Benefits

* Track license key activity in real-time
* Identify potential misuse or unauthorized activations
* Simplify customer support by providing detailed usage records in case of discrepancy

## API Management

Use these APIs to activate, validate, list, and update license keys and their activation instances.

<Info>
  **Public Endpoints**: The activate, deactivate, and validate license endpoints are **public** and do **not require an API key**. This allows you to call them directly from your client applications, desktop software, or CLIs without exposing your API credentials.
</Info>

<AccordionGroup>
  <Accordion title="Lifecycle Operations">
    Trigger activation, deactivation, and validation actions on license keys.

    <CardGroup>
      <Card title="Activate License" icon="code" href="/api-reference/licenses/activate-license">
        Create or record an activation instance for a license key.
      </Card>

      <Card title="Deactivate License" icon="code" href="/api-reference/licenses/deactivate-license">
        Revoke a prior activation to free up capacity.
      </Card>

      <Card title="Validate License" icon="code" href="/api-reference/licenses/validate-license">
        Check authenticity, status, and constraints before granting access.
      </Card>
    </CardGroup>
  </Accordion>

  <Accordion title="License Key Management">
    List, retrieve, and update license keys with their settings and status.

    <CardGroup>
      <Card title="List License Keys" icon="code" href="/api-reference/licenses/list-license-keys">
        Browse all keys with status and usage details.
      </Card>

      <Card title="Get License Key" icon="code" href="/api-reference/licenses/get-license-key">
        Retrieve a specific key and its metadata.
      </Card>

      <Card title="Update License Key" icon="code" href="/api-reference/licenses/update-license-key">
        Modify expiry, activation limits, or enable/disable a key.
      </Card>
    </CardGroup>
  </Accordion>

  <Accordion title="Activation Instances">
    Work with individual device activations for each key.

    <CardGroup>
      <Card title="List Instances" icon="code" href="/api-reference/licenses/get-license-key-instances">
        Return all activation instances for a specific key.
      </Card>

      <Card title="Get Instance" icon="code" href="/api-reference/licenses/get-license-key-instance">
        Fetch details for a single activation instance.
      </Card>

      <Card title="Update Instance" icon="code" href="/api-reference/licenses/update-license-key-instance">
        Revoke or update device information for an instance.
      </Card>
    </CardGroup>
  </Accordion>
</AccordionGroup>

## Integration Examples

### Activate a license

<Note>
  These endpoints do not require an API key and can be called directly from your client applications.
</Note>

<CodeGroup>
  ```typescript TypeScript/Node.js theme={null}
  import DodoPayments from 'dodopayments';

  // No API key needed for public license endpoints
  const client = new DodoPayments();

  const response = await client.licenses.activate({ 
    license_key: 'license_key', 
    name: 'Device Name' 
  });

  console.log(response.id);
  ```

  ```bash cURL theme={null}
  curl -X POST https://api.dodopayments.com/licenses/activate \
    -H "Content-Type: application/json" \
    -d '{
      "license_key": "your_license_key",
      "name": "Device Name"
    }'
  ```
</CodeGroup>

### Validate a license

<CodeGroup>
  ```typescript TypeScript/Node.js theme={null}
  import DodoPayments from 'dodopayments';

  // No API key needed for public license endpoints
  const client = new DodoPayments();

  const response = await client.licenses.validate({ 
    license_key: '2b1f8e2d-c41e-4e8f-b2d3-d9fd61c38f43' 
  });

  console.log(response.valid);
  ```

  ```bash cURL theme={null}
  curl -X POST https://api.dodopayments.com/licenses/validate \
    -H "Content-Type: application/json" \
    -d '{
      "license_key": "2b1f8e2d-c41e-4e8f-b2d3-d9fd61c38f43"
    }'
  ```
</CodeGroup>

## Best Practices

* **Keep limits clear**: Choose sensible defaults for expiry and activations
* **Guide users**: Provide precise activation instructions and self-serve documentation
* **Automate checks**: Validate keys server-side before granting access
* **Monitor events**: Use webhooks to detect abuse and automate revocations


# Multi-Brand Setup
Source: https://docs.dodopayments.com/features/multi-brands

Learn how to set up multi-brand in Dodo Payments.

## Introduction

Multi-Brand lets you attach several brands—each with its own logo, descriptor, and website URL—to **one verified business**. Your payout account, fees, and KYC stay exactly the same, while every Product, Payment Link, Subscription, Invoice, and Transaction can now be filed under a specific brand. Use it to test new niches, localise a site, or separate B2B and B2C lines without opening extra business accounts.

## Merchant Dashboard Flow

<Steps>
  <Step title="Open Business Settings → Brands">
    The Brands page lists your Primary brand and any Secondary brands.
  </Step>

  <Step title="Click 'Add Brand'">
    A Brand Verification form opens up.
  </Step>

  <Step title="Fill the form">
    Enter Brand Name, Website URL (or social profile), Description and Submit the form.
  </Step>

  <Step title="Upload Logo and Set Details">
    Upload Logo, set Statement Descriptor, and Support Email for each brand.
  </Step>

  <Step title="Approval">
    Once our compliance team marks the website "Verified", live mode will be enabled for this brand. Products can now be tagged to this brand and live payment links will display its branding.
  </Step>

  <Step title="Brand Selector">
    A Brand filter is now visible on Product creation.
  </Step>

  <Step title="Brand ID in Transactions">
    Transactions and Subscriptions have a Brand ID to help you identify which brand the transaction belongs to.
  </Step>
</Steps>

## Additional Points

* **No payout changes:** All funds, payout cycles and fees still flow to the business-level wallet and merchant bank account.
* **Suspensions:** If a brand is suspended, only its payment links stop—other brands under the same business keep transacting.
* No changes to Storefront, Invoices, License Keys, Discount Codes, Payout Settings and any other business level features.


# One‑Time Payments
Source: https://docs.dodopayments.com/features/one-time-payment-products

Sell fixed‑price digital goods or services with a single upfront charge, no renewals.

<Info>
  One‑time payments let you sell lifetime access, downloads, or single‑use services with a single charge. There are no renewals, proration rules, or billing cycles. Just a clean, instant purchase experience.
</Info>

<CardGroup>
  <Card title="License Keys" icon="code" href="/features/license-keys">
    Issue unique license keys after purchase.
  </Card>

  <Card title="Digital Delivery" icon="code" href="/features/digital-product-delivery">
    Automatically deliver files and content after payment.
  </Card>

  <Card title="Payment Webhooks" icon="code" href="/developer-resources/webhooks/intents/payment">
    React to payment succeeded/failed and receipt events.
  </Card>

  <Card title="Refunds API" icon="code" href="/api-reference/refunds/post-refunds">
    Create full or partial refunds programmatically.
  </Card>
</CardGroup>

## What Are One‑Time Payments?

One‑time payments are fixed, up‑front purchases - ideal for:

* **Software licenses**: Lifetime or major‑version unlocks
* **Digital downloads**: E‑books, templates, graphics, or plugins
* **Services**: Audits, onboarding packages, or one‑off consulting
* **Courses and tickets**: Courses, workshops, or live sessions

## Key Benefits

* **Simple checkout**: No renewals or proration logic
* **Instant fulfillment**: Deliver licenses or files right away
* **Flexible pricing**: Discounts and taxes supported
* **Developer‑first**: Clear APIs for creation, refunds, and webhooks

## Creating One‑Time Products

Create products in your Dodo Payments dashboard, then sell them via hosted checkout, payment links, or your API.

<Frame>
  <img alt="One-Time Payment Products" />
</Frame>

### Product configuration

Configure the fields in the dashboard to define how your product appears and sells.

#### Product details

* **Product Name** (required): Display name shown in checkout and invoices
* **Product Description** (required): Clear value statement customers see before paying
* **Product Image** (required): PNG/JPG/WebP up to 3 MB
* **Brand**: Associate the product with a specific brand for theming and emails
* **Tax Category** (required): Choose the correct category to determine tax rules

<Tip>
  Pick the most accurate tax category to ensure correct tax collection per region.
</Tip>

#### Pricing

* **Pricing Type**: Choose <b>Single Payment</b>
* **Price** (required): Fixed charge with currency
* **Discount Applicable (%)**: Optional percentage discount displayed in checkout and invoices

<Warning>
  Changing product pricing affects only new purchases. Existing customers aren’t impacted.
</Warning>

#### Advanced settings

* **Tax Inclusive Pricing**: Display prices inclusive of applicable taxes
* **Generate license keys**: Issue a unique key after purchase. See <a href="/features/license-keys">License Keys</a>
* **Digital Product Delivery**: Deliver files or content automatically. See <a href="/features/digital-product-delivery">Digital Product Delivery</a>
* **Metadata**: Attach custom key–value pairs for internal tagging or integrations. See <a href="/api-reference/metadata">Metadata</a>

<Tip>
  Use metadata to store identifiers from your system (e.g., orderId) to reconcile events and receipts later.
</Tip>

## API Management

<AccordionGroup>
  <Accordion title="Create payments">
    Use `POST /checkout-sessions/create` to create one‑time charges from products.

    <Card title="API Reference" icon="code" href="/api-reference/checkout-sessions/create">
      View the create payment API.
    </Card>
  </Accordion>

  <Accordion title="Refund payments">
    Use `POST /refunds` to create full or partial refunds.

    <Card title="API Reference" icon="code" href="/api-reference/refunds/post-refunds">
      Learn how to refund a payment.
    </Card>
  </Accordion>

  <Accordion title="List and retrieve payments">
    Use `GET /payments` to list payments and `GET /payments/{payment_id}` to retrieve one. Retrieve line items with `GET /payments/{payment_id}/line-items`.

    <Card title="List Payments" icon="code" href="/api-reference/payments/get-payments">
      Browse the listing API.
    </Card>

    <Card title="Get Payment Detail" icon="code" href="/api-reference/payments/get-payments-1">
      See the retrieval API.
    </Card>

    <Card title="Retrieve Line Items" icon="code" href="/api-reference/payments/retrieve-line-items">
      Inspect purchased items for a payment.
    </Card>
  </Accordion>

  <Accordion title="Payment webhooks">
    React to events like payment.succeeded or payment.failed in your backend.

    <Card title="Webhook Guide" icon="code" href="/developer-resources/webhooks/intents/payment">
      Handle payment lifecycle events.
    </Card>
  </Accordion>
</AccordionGroup>

## Common Use Cases

* **License‑based tools**: Unlock features with a one‑time key
* **Digital assets**: Themes, templates, icon sets, or media
* **Professional services**: Fixed‑fee implementation or setup
* **Education**: Course tickets and one‑off workshops

## Integration Examples

### Checkout Sessions (single payment)

Create a checkout session with a one‑time product in the cart:

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    { product_id: 'prod_one_time', quantity: 1 }
  ]
});
```

## Best Practices

* **Clarify deliverables**: Tell buyers exactly what they get and how it’s delivered
* **Deliver instantly**: Use license keys or digital delivery for immediate access
* **Track with metadata**: Store your IDs for easy reconciliation

<Info>
  One‑time payments are the fastest path to selling fixed‑price products. Start simple, verify delivery, and iterate your offer based on conversion and feedback.
</Info>


# Pay What You Want Pricing
Source: https://docs.dodopayments.com/features/pay-what-you-want

Let customers choose their price above a minimum. Optionally show a suggested price. Optimized for one‑time purchases.

**Pay What You Want (PWYW)** lets customers decide how much they pay—at or above a merchant‑defined minimum. It increases engagement, encourages community support, and provides flexible pricing for digital products.

<Frame>
  <iframe title="Pay What You Want Pricing | Dodo Payments" />
</Frame>

## What Is Pay What You Want?

PWYW is a pricing model where customers set their own price within guardrails you define. It’s ideal for:

* **Digital products and media**: Templates, e‑books, courses, plugins
* **Experimental launches**: Early access, beta releases, time‑boxed promos
* **Bundles and extras**: Add a PWYW tier to boost participation

## Key Benefits

* **Customer‑driven pricing**: Buyers choose what they pay
* **Revenue floor**: Enforce a minimum to protect margins
* **Anchored expectations**: Optional suggested price to guide choices
* **Seamless checkout**: Hosted checkout and receipts handled for you
* **Developer‑first**: Clear APIs for creation, refunds, and webhooks

<Warning>
  PWYW is available only for **Single Payment** (one‑time) products.
</Warning>

## Creating Pay What You Want

Create a one‑time product and enable PWYW in your Dodo Payments dashboard. The sections below map directly to the creation form.

### Product creation

#### Product details

* **Product Name** (required): Display name shown in checkout and invoices
* **Product Description** (required): Clear value statement customers see before paying
* **Product Image** (required): PNG/JPG/WebP up to 3 MB
* **Brand**: Associate the product with a specific brand for theming and emails
* **Tax Category** (required): Choose the correct category to determine tax rules

<Tip>
  Pick the most accurate tax category to ensure correct tax collection per region.
</Tip>

#### Pricing

* **Pricing Type**: Choose <b>Single Payment</b>
* **Pay What You Want** (toggle): Enable to let buyers choose the amount
* **Minimum Price** (required): Lowest allowed amount a customer can pay
* **Suggested Price** (optional): Recommended amount shown on the product page

<Tip>
  Use metadata to store identifiers from your system (e.g., orderId) so you can reconcile events and receipts later.
</Tip>

## API Management

<AccordionGroup>
  <Accordion title="Create checkout sessions (PWYW)">
    Use `POST /checkout-sessions/create` to create one‑time checkout sessions from products. Checkout will prompt buyers to enter an amount that meets your PWYW minimum.

    <Card title="API Reference" icon="code" href="/api-reference/checkout-sessions/create">
      View the create checkout session API.
    </Card>
  </Accordion>

  <Accordion title="Refund payments">
    Use `POST /refunds` to create full or partial refunds. Customers are refunded the exact amount they paid.

    <Card title="API Reference" icon="code" href="/api-reference/refunds/post-refunds">
      Learn how to refund a payment.
    </Card>
  </Accordion>

  <Accordion title="List and retrieve">
    Use `GET /payments` to list payments and `GET /payments/{payment_id}` to retrieve one. Retrieve line items with `GET /payments/{payment_id}/line-items`.

    <Card title="List Payments" icon="code" href="/api-reference/payments/get-payments">
      Browse the listing API.
    </Card>

    <Card title="Get Payment Detail" icon="code" href="/api-reference/payments/get-payments-1">
      See the retrieval API.
    </Card>

    <Card title="Retrieve Line Items" icon="code" href="/api-reference/payments/retrieve-line-items">
      Inspect purchased items for a payment.
    </Card>
  </Accordion>

  <Accordion title="Payment webhooks">
    React to events like payment.succeeded or payment.failed in your backend.

    <Card title="Webhook Guide" icon="code" href="/developer-resources/webhooks/intents/payment">
      Handle payment lifecycle events.
    </Card>
  </Accordion>
</AccordionGroup>

## Common Use Cases

* **Digital assets**: Themes, templates, icon sets, media, or plugins
* **Content and education**: E‑books, courses, workshops with supporter pricing
* **Community & donations**: Fundraisers, open‑source sponsorships, creator support
* **Launch experiments**: Beta access and time‑boxed campaigns to gauge demand

## Integration Examples

### Checkout Sessions (single payment, PWYW)

Add a PWYW product to the cart. Checkout collects the buyer’s amount (respecting your minimum) — no extra fields are required.

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    { product_id: 'prod_pwyw_demo', quantity: 1 }
  ],
  return_url: 'https://yoursite.com/checkout/success'
});
```

## Best Practices

* **Choose a sensible minimum**: Cover costs while keeping participation easy
* **Use a suggested price**: Anchor expectations to improve average order value
* **Explain value clearly**: Tell buyers what their contribution unlocks
* **A/B test campaigns**: Time‑box offers and experiment with messaging
* **Monitor distribution**: Track paid amounts to refine minimum and suggested price

<Info>
  PWYW is a flexible way to invite more customers in while preserving a revenue floor. Start simple, test thoroughly, and iterate based on conversion, contribution distribution, and refund rates.
</Info>


# Payment Methods
Source: https://docs.dodopayments.com/features/payment-methods

Complete guide to payment methods supported by Dodo Payments, including credit/debit cards, digital wallets, BNPL, UPI/Rupay, European options, and how to configure them for your checkout.

Dodo Payments supports a wide range of payment methods to help you serve customers globally. Turn on new payment methods instantly — no additional contracts, integrations, or merchant accounts needed.

## Why Offer Multiple Payment Methods?

<CardGroup>
  <Card title="Boost Conversion" icon="chart-line">
    Local methods increase sales 20-30% in target markets.
  </Card>

  <Card title="One Platform" icon="layer-group">
    All methods managed through a single API.
  </Card>

  <Card title="Smart Routing" icon="route">
    Right options shown based on location and device.
  </Card>
</CardGroup>

## How It Works

Payment methods are automatically presented to customers based on:

* **Customer Location** — Regional methods like iDEAL (Netherlands) or UPI (India) only appear for customers in those regions
* **Transaction Currency** — Payment methods are filtered by supported currencies
* **Device Type** — Apple Pay only appears on compatible Apple devices and browsers
* **Transaction Type** — Some methods don't support subscriptions or have minimum amounts

<Info>
  **Automatic Activation:** All payment methods are pre-configured and managed by Dodo Payments. No additional setup needed — they become available once your account is verified and live mode is enabled.
</Info>

## Supported Payment Methods

| Payment Method   | Supported Countries | Supported Currencies   | Subscriptions | Min Amount |
| :--------------- | :------------------ | :--------------------- | :-----------: | :--------- |
| **Credit Cards** | Global              | All currencies         |      Yes      | \$0.50     |
| **Debit Cards**  | Global              | All currencies         |      Yes      | \$0.50     |
| **Apple Pay**    | Global (Excl. IN)   | All currencies         |      Yes      | \$0.50     |
| **Google Pay**   | Global (Excl. IN)   | All currencies         |      Yes      | \$0.50     |
| **Amazon Pay**   | Global (Excl. IN)   | USD                    |       No      | \$0.50     |
| **Cash App Pay** | US                  | USD                    |       No      | \$0.50     |
| **Klarna**       | US, Europe          | USD, EUR, GBP + 7 more |       No      | \$50.01    |
| **Afterpay**     | US, UK              | USD, GBP               |       No      | \$50.01    |
| **UPI**          | India               | INR                    |     Yes\*     | ₹1         |
| **Rupay**        | India               | INR                    |     Yes\*     | ₹1         |
| **iDEAL**        | Netherlands         | EUR                    |       No      | €0.50      |
| **Bancontact**   | Belgium             | EUR                    |       No      | €0.50      |
| **EPS**          | Austria             | EUR                    |       No      | €0.50      |
| **Multibanco**   | Portugal            | EUR                    |       No      | €0.50      |
| **RevolutPay**   | Global              | GBP                    |       No      | £0.50      |
| **Billie**       | Global              | GBP                    |       No      | £0.50      |

<Note>
  \*Indian payment methods (UPI, Rupay) support subscriptions with RBI-compliant mandates. See the <a href="/features/payment-methods/india">India Payment Methods</a> page for details on the 48-hour processing delay and mandate requirements.
</Note>

<Warning>
  **PayPal Support Paused:** PayPal is temporarily unavailable for new transactions. We'll update this page when restored.
</Warning>

## Payment Method Categories

<CardGroup>
  <Card title="Credit & Debit Cards" icon="credit-card" href="/features/payment-methods/cards">
    Accept Visa, Mastercard, Amex, Discover, JCB, UnionPay, and regional networks like Cartes Bancaires and Interac.
  </Card>

  <Card title="Digital Wallets" icon="wallet" href="/features/payment-methods/digital-wallets">
    Apple Pay, Google Pay, Amazon Pay, Cash App Pay, and RevolutPay for fast, secure one-tap checkout.
  </Card>

  <Card title="Buy Now Pay Later" icon="calendar-days" href="/features/payment-methods/bnpl">
    Klarna, Afterpay, and Billie installment options to increase average order value and conversion.
  </Card>

  <Card title="India" icon="indian-rupee-sign" href="/features/payment-methods/india">
    UPI and Rupay cards with RBI-compliant subscription mandates for the Indian market.
  </Card>

  <Card title="Europe" icon="euro-sign" href="/features/payment-methods/europe">
    iDEAL (Netherlands), Bancontact (Belgium), EPS (Austria), and Multibanco (Portugal).
  </Card>
</CardGroup>

## Configuring Payment Methods

By default, all eligible payment methods appear automatically. Use `allowed_payment_method_types` to restrict which methods are shown:

<Tabs>
  <Tab title="JavaScript">
    ```javascript theme={null}
    const session = await client.checkoutSessions.create({
      product_cart: [{ product_id: 'prod_123', quantity: 1 }],
      allowed_payment_method_types: [
        'credit',
        'debit', 
        'apple_pay',
        'google_pay'
      ],
      return_url: 'https://example.com/success'
    });
    ```
  </Tab>

  <Tab title="Python">
    ```python theme={null}
    session = client.checkout_sessions.create(
        product_cart=[{"product_id": "prod_123", "quantity": 1}],
        allowed_payment_method_types=[
            "credit",
            "debit",
            "apple_pay", 
            "google_pay"
        ],
        return_url="https://example.com/success"
    )
    ```
  </Tab>

  <Tab title="cURL">
    ```bash theme={null}
    curl -X POST https://api.dodopayments.com/checkout-sessions \
      -H "Authorization: Bearer YOUR_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "product_cart": [{"product_id": "prod_123", "quantity": 1}],
        "allowed_payment_method_types": ["credit", "debit", "apple_pay", "google_pay"],
        "return_url": "https://example.com/success"
      }'
    ```
  </Tab>
</Tabs>

### Available Method Types

| Type                | Description                                 |
| :------------------ | :------------------------------------------ |
| `credit`            | Credit cards (Visa, Mastercard, Amex, etc.) |
| `debit`             | Debit cards                                 |
| `apple_pay`         | Apple Pay                                   |
| `google_pay`        | Google Pay                                  |
| `amazon_pay`        | Amazon Pay                                  |
| `cashapp`           | Cash App Pay                                |
| `klarna`            | Klarna BNPL                                 |
| `afterpay_clearpay` | Afterpay / Clearpay                         |
| `upi_collect`       | UPI Collect (QR code)                       |
| `ideal`             | iDEAL (Netherlands)                         |
| `bancontact_card`   | Bancontact (Belgium)                        |
| `eps`               | EPS (Austria)                               |
| `multibanco`        | Multibanco (Portugal)                       |
| `revolut_pay`       | RevolutPay                                  |
| `billie`            | Billie B2B BNPL                             |

<Warning>
  Always include `credit` and `debit` as fallbacks. If all specified payment methods are unavailable for a customer, the checkout will fail.
</Warning>

### API Endpoints

<CardGroup>
  <Card title="Checkout Sessions" icon="cart-shopping" href="/api-reference/checkout-sessions/create">
    Create checkout with allowed methods.
  </Card>

  <Card title="Payments" icon="credit-card" href="/api-reference/payments/post-payments">
    One-time payments with method filtering.
  </Card>

  <Card title="Subscriptions" icon="repeat" href="/api-reference/subscriptions/post-subscriptions">
    Recurring payments with method restrictions.
  </Card>
</CardGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="Match methods to your market">
    Include regional payment methods for your target markets. iDEAL captures \~60% of online payments in the Netherlands; UPI dominates in India. Omitting these methods significantly hurts conversion.
  </Accordion>

  <Accordion title="Always provide card fallbacks">
    Even when targeting specific methods, include `credit` and `debit` as fallbacks. Not all customers have access to every payment method.
  </Accordion>

  <Accordion title="Consider transaction minimums">
    BNPL methods (Klarna, Afterpay) require \$50.01 minimum. Don't include them for low-value products — they simply won't appear, which is fine.
  </Accordion>

  <Accordion title="Test across regions and devices">
    Use test mode to verify payment method availability for different customer locations, currencies, and device types before going live.
  </Accordion>
</AccordionGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Payment method not appearing">
    **Check these factors:**

    1. Method included in `allowed_payment_method_types`?
    2. Customer location matches method's supported region?
    3. Transaction currency supported by method?
    4. Transaction amount meets minimum (e.g., \$50.01 for BNPL)?
    5. For subscriptions: method supports recurring payments?

    **Solution:** Remove `allowed_payment_method_types` temporarily to see all eligible methods, then narrow down the issue.
  </Accordion>

  <Accordion title="Unexpected methods appearing">
    **Possible causes:**

    * `allowed_payment_method_types` not being passed correctly
    * Parameter formatted incorrectly (must be array of strings)

    **Solution:** Log your API request payload and verify the parameter structure.
  </Accordion>

  <Accordion title="Regional method not available">
    **Check:**

    * Customer billing address matches method's region
    * Currency is set correctly (e.g., EUR for iDEAL)
    * Adaptive Currency is enabled if customer is international

    **Solution:** Verify billing address country code and currency in your API request.
  </Accordion>

  <Accordion title="Indian payment method issues">
    UPI and Rupay subscriptions have unique requirements including 48-hour processing delays and RBI mandate limits.

    **See:** <a href="/features/payment-methods/india">India Payment Methods</a> for complete guidance.
  </Accordion>
</AccordionGroup>

## Related Pages

<CardGroup>
  <Card title="Adaptive Currency" icon="globe" href="/features/adaptive-currency">
    Supported currencies and automatic conversion.
  </Card>

  <Card title="Checkout Guide" icon="book" href="/developer-resources/checkout-session">
    Complete checkout implementation guide.
  </Card>

  <Card title="Testing Process" icon="flask" href="/miscellaneous/testing-process">
    Test cards, UPI IDs, and wallet testing.
  </Card>

  <Card title="Subscriptions" icon="repeat" href="/features/subscription">
    Recurring billing and payment method updates.
  </Card>
</CardGroup>

## Expanding Payment Options

We continuously add new payment methods. If you need a specific method not listed here, contact us at [support@dodopayments.com](mailto:support@dodopayments.com).


# Buy Now Pay Later (BNPL)
Source: https://docs.dodopayments.com/features/payment-methods/bnpl

Offer Klarna, Afterpay, and Billie installment payments to increase average order value and conversion. Learn about eligibility, minimum amounts, and testing.

Buy Now Pay Later (BNPL) lets customers split purchases into interest-free installments, increasing average order value by 20-50% and conversion rates by 10-30% for eligible transactions.

## Why Offer BNPL?

<CardGroup>
  <Card title="Higher AOV" icon="chart-line">
    Customers spend more when they can spread payments over time. Average order value increases 20-50%.
  </Card>

  <Card title="Better Conversion" icon="percent">
    Removing payment friction at checkout. Conversion rates improve 10-30% for high-ticket items.
  </Card>

  <Card title="Zero Risk" icon="shield-check">
    BNPL providers handle credit risk and collections. You receive full payment upfront.
  </Card>
</CardGroup>

## Supported Providers

### Klarna

| Feature           | Details                                          |
| :---------------- | :----------------------------------------------- |
| **Availability**  | US + 19 European countries                       |
| **Currencies**    | USD, EUR, GBP, DKK, NOK, SEK, CZK, RON, PLN, CHF |
| **Minimum**       | \$50.01 (or equivalent)                          |
| **Subscriptions** | No                                               |

**Supported Countries:** Austria, Belgium, Czech Republic, Denmark, Finland, France, Germany, Greece, Ireland, Italy, Netherlands, Norway, Poland, Portugal, Romania, Spain, Sweden, Switzerland, United Kingdom, United States

**Payment Options:**

* **Pay in 4** — Split into 4 interest-free payments
* **Pay in 30 days** — Full payment due in 30 days
* **Financing** — Longer-term installment plans

### Afterpay (Clearpay)

| Feature           | Details                 |
| :---------------- | :---------------------- |
| **Availability**  | US, UK                  |
| **Currencies**    | USD, GBP                |
| **Minimum**       | \$50.01 (or equivalent) |
| **Subscriptions** | No                      |

**Payment Options:**

* **Pay in 4** — 4 interest-free payments every 2 weeks

<Note>
  In the UK, Afterpay operates as "Clearpay" but uses the same API type (`afterpay_clearpay`).
</Note>

### Billie

| Feature           | Details |
| :---------------- | :------ |
| **Availability**  | Global  |
| **Currencies**    | GBP     |
| **Minimum**       | None    |
| **Subscriptions** | No      |

**About Billie:**
Billie is a B2B Buy Now Pay Later solution that enables businesses to offer flexible payment terms to their customers. It's designed for business-to-business transactions where buyers need invoice-based payment options.

**Payment Options:**

* **Invoice Payment** — Pay within agreed payment terms
* **Flexible Terms** — Business-friendly payment schedules

## Configuration

### API Method Types

| Type                | Provider            |
| :------------------ | :------------------ |
| `klarna`            | Klarna              |
| `afterpay_clearpay` | Afterpay / Clearpay |
| `billie`            | Billie (B2B)        |

### Example

```javascript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  allowed_payment_method_types: [
    'klarna',
    'afterpay_clearpay',
    'credit',
    'debit'
  ],
  customer: {
    email: 'customer@example.com',
    name: 'Jane Smith'
  },
  billing_address: {
    country: 'US',
    zipcode: '10001'
  },
  return_url: 'https://example.com/success'
});
```

<Warning>
  Always include `credit` and `debit` as fallbacks. Not all customers are eligible for BNPL, and transactions below \$50.01 won't qualify.
</Warning>

## Minimum Transaction Amount

**Both Klarna and Afterpay require a minimum of \$50.01 USD** (or equivalent in supported currencies).

Transactions below this threshold:

* BNPL options won't appear at checkout
* No error is thrown — options simply don't show
* Card payments remain available

This is expected behavior. Don't include BNPL in `allowed_payment_method_types` for products under \$50.

## How Installments Work

```mermaid theme={null}
sequenceDiagram
    participant Customer
    participant Checkout
    participant Dodo
    participant BNPL Provider
    
    Customer->>Checkout: Select Klarna/Afterpay
    Checkout->>Dodo: Process payment
    Dodo->>BNPL Provider: Create installment plan
    BNPL Provider->>Customer: Approve/Deny based on credit
    BNPL Provider->>Dodo: Full payment (if approved)
    Dodo->>You: Payout (full amount)
    BNPL Provider->>Customer: Collect installments over time
```

**Key points:**

* You receive the **full payment upfront** from the BNPL provider
* The BNPL provider handles **credit risk and collections**
* Customer pays the provider directly over **4 installments** (typically)
* **No chargebacks** from installment failures — that's the provider's risk

## Testing

### Klarna Test Data

Use these details in test mode:

| Field             | Approved                                      | Denied                                                      |
| :---------------- | :-------------------------------------------- | :---------------------------------------------------------- |
| **Date of Birth** | 07-10-1970                                    | 07-10-1970                                                  |
| **First Name**    | Test                                          | Test                                                        |
| **Last Name**     | Person-us                                     | Person-us                                                   |
| **Email**         | [customer@email.us](mailto:customer@email.us) | [customer+denied@email.us](mailto:customer+denied@email.us) |
| **Street**        | Amsterdam Ave                                 | Amsterdam Ave                                               |
| **House Number**  | 509                                           | 509                                                         |
| **City**          | New York                                      | New York                                                    |
| **State**         | New York                                      | New York                                                    |
| **Postal Code**   | 10024-3941                                    | 10024-3941                                                  |
| **Phone**         | +13106683312                                  | +13106354386                                                |

<Note>
  Transaction must be at least \$50 for Klarna to appear as an option.
</Note>

### Afterpay Testing

<Steps>
  <Step title="Select Afterpay">
    Choose Afterpay in checkout and click Pay.
  </Step>

  <Step title="Successful payment">
    Use any valid email and shipping address.
  </Step>

  <Step title="Failed authentication">
    To test failure: close the Afterpay modal on the redirect page. Payment status transitions to `requires_payment_method`.
  </Step>
</Steps>

## Best Practices

<AccordionGroup>
  <Accordion title="Target high-ticket items">
    BNPL works best for products $100-$1000. The value proposition of "pay over time" is most compelling in this range.
  </Accordion>

  <Accordion title="Show installment amounts">
    "4 payments of $25" is more compelling than "$100 with Klarna". Display the per-payment amount when possible.
  </Accordion>

  <Accordion title="Don't force BNPL for low-value products">
    Under $50, BNPL won't appear anyway. Under $100, most customers prefer cards. Focus BNPL promotion on higher-ticket items.
  </Accordion>

  <Accordion title="Collect billing address">
    BNPL providers require billing information for credit checks. Ensure your checkout collects full address details.
  </Accordion>

  <Accordion title="Set clear expectations">
    Customers should understand they're entering a credit agreement with Klarna/Afterpay, not with you.
  </Accordion>
</AccordionGroup>

## Limitations

### No Subscriptions

BNPL payment methods **do not support recurring payments**. For subscription products, use cards or other recurring-compatible methods.

### Credit-Based Approval

BNPL providers perform instant credit checks. Not all customers will be approved. Approval rates vary by:

* Customer credit history with the provider
* Transaction amount
* Customer location

### Currency Restrictions

| Provider | Currencies                                       |
| :------- | :----------------------------------------------- |
| Klarna   | USD, EUR, GBP, DKK, NOK, SEK, CZK, RON, PLN, CHF |
| Afterpay | USD, GBP                                         |

## Troubleshooting

<AccordionGroup>
  <Accordion title="BNPL not appearing at checkout">
    **Check:**

    1. Transaction amount at least \$50.01?
    2. Customer location in supported country?
    3. Currency supported by BNPL provider?
    4. BNPL method included in `allowed_payment_method_types`?

    **Solution:** Most commonly, the transaction is below minimum. Verify amount meets \$50.01 threshold.
  </Accordion>

  <Accordion title="Customer denied by BNPL provider">
    **Causes:**

    * Insufficient credit history with provider
    * Too many active installment plans
    * Failed identity verification

    **Solution:** This is expected for some customers. Ensure card fallbacks are available. Don't expose specific denial reasons.
  </Accordion>

  <Accordion title="Payment stuck in pending">
    **Cause:** Customer didn't complete authentication flow with BNPL provider.

    **Solution:** Payment will timeout and fail. Customer can retry or use a different method.
  </Accordion>
</AccordionGroup>

## Related Pages

<CardGroup>
  <Card title="Payment Methods Overview" icon="credit-card" href="/features/payment-methods">
    See all supported payment methods.
  </Card>

  <Card title="Checkout Guide" icon="book" href="/developer-resources/checkout-session">
    Complete checkout implementation guide.
  </Card>

  <Card title="Testing Process" icon="flask" href="/miscellaneous/testing-process">
    All test data for payment methods.
  </Card>

  <Card title="Adaptive Currency" icon="globe" href="/features/adaptive-currency">
    Currency support and conversion.
  </Card>
</CardGroup>


# Credit & Debit Cards
Source: https://docs.dodopayments.com/features/payment-methods/cards

Accept all major credit and debit card networks globally with Dodo Payments. Learn about 3D Secure, saved cards, tokenization, and regional card support.

Card payments are the foundation of online payments, accepted globally and trusted by customers worldwide. Dodo Payments supports all major card networks with built-in fraud protection and PCI compliance.

## Supported Card Networks

### Global Networks

| Network              | Coverage                                |
| :------------------- | :-------------------------------------- |
| **Visa**             | Global leader, 4B+ cards worldwide      |
| **Mastercard**       | Global reach, strong security features  |
| **American Express** | Premium cardholders, higher spending    |
| **Discover**         | US-focused, growing globally            |
| **JCB**              | Leading in Japan, expanding across Asia |
| **UnionPay**         | Dominant in China, 8B+ cards            |
| **Diners Club**      | Premium international travelers         |

### Regional Networks

| Network                | Region                    |
| :--------------------- | :------------------------ |
| **Interac**            | Canada's debit network    |
| **Cartes Bancaires**   | France's national network |
| **Korean Local Cards** | Korean domestic networks  |
| **Rupay**              | India's national network  |

## Configuration

Use these values in `allowed_payment_method_types`:

| Type     | Description      |
| :------- | :--------------- |
| `credit` | All credit cards |
| `debit`  | All debit cards  |

```javascript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  allowed_payment_method_types: ['credit', 'debit'],
  return_url: 'https://example.com/success'
});
```

<Tip>
  Include both `credit` and `debit` unless you have a specific reason to exclude one. Debit cards are preferred by many customers and often have lower fees.
</Tip>

## 3D Secure Authentication

3D Secure (3DS) adds an authentication layer that reduces fraud and chargebacks by verifying the cardholder's identity.

### When 3DS is Triggered

3DS is automatically triggered when:

* Required by the card network
* Required by regional regulations (e.g., PSD2 in Europe)
* The transaction is flagged as high-risk

### Force 3DS

You can require 3DS on all transactions:

```javascript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  force_3ds: true,
  return_url: 'https://example.com/success'
});
```

<Note>
  Enabling 3DS for all transactions reduces fraud but may slightly decrease conversion as some customers abandon during authentication.
</Note>

## Saved Payment Methods

Customers can save their cards for faster future checkouts.

<CardGroup>
  <Card title="Tokenized" icon="lock">
    Original card numbers never stored.
  </Card>

  <Card title="PCI Compliant" icon="shield-check">
    Dodo handles all compliance.
  </Card>

  <Card title="Customer-Scoped" icon="user">
    Cards tied to specific customers.
  </Card>
</CardGroup>

### Enable Saved Cards

```javascript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  show_saved_payment_methods: true,
  customer: { customer_id: 'cus_existing_123' },
  return_url: 'https://example.com/success'
});
```

### One-Click Purchases

```javascript theme={null}
// Get customer's saved payment methods
const methods = await client.customers.getPaymentMethods('cus_123');

// Use saved card for instant checkout
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  customer: { customer_id: 'cus_123' },
  payment_method_id: methods[0].payment_method_id,
  confirm: true,
  return_url: 'https://example.com/success'
});
```

## Testing

<Tabs>
  <Tab title="Successful Payments">
    | Region | Brand      | Card Number        | Expiry | CVV |
    | :----- | :--------- | :----------------- | :----- | :-- |
    | US     | Visa       | `4242424242424242` | 06/32  | 123 |
    | US     | Mastercard | `5555555555554444` | 06/32  | 123 |
    | India  | Visa       | `4576238912771450` | 06/32  | 123 |
    | India  | Mastercard | `5409162669381034` | 06/32  | 123 |
  </Tab>

  <Tab title="Declined Payments">
    | Region | Brand      | Card Number        | Scenario           |
    | :----- | :--------- | :----------------- | :----------------- |
    | US     | Visa       | `4000000000000002` | Generic decline    |
    | US     | Mastercard | `4000000000009995` | Insufficient funds |
    | India  | Visa       | `4706131211212123` | Generic decline    |
    | India  | Mastercard | `5105105105105100` | Generic decline    |
  </Tab>
</Tabs>

<Warning>
  Test cards only work in test mode. Never use them for production transactions.
</Warning>

## Security & Compliance

| Feature             | Description                        |
| :------------------ | :--------------------------------- |
| **PCI DSS Level 1** | Highest level of certification     |
| **Tokenization**    | Card numbers immediately tokenized |
| **Fraud Scoring**   | Real-time risk assessment          |
| **AVS**             | Address Verification Service       |
| **CVV Validation**  | Security code verification         |
| **3D Secure**       | Cardholder authentication          |

## Best Practices

<AccordionGroup>
  <Accordion title="Accept all major networks">
    Don't restrict card types unless necessary. Customers expect their preferred card to work.
  </Accordion>

  <Accordion title="Display card logos">
    Show Visa, Mastercard, Amex logos on your checkout to build trust.
  </Accordion>

  <Accordion title="Handle declines gracefully">
    Show clear error messages. Don't expose raw error codes to customers.
  </Accordion>

  <Accordion title="Enable saved cards for returning customers">
    Saved payment methods significantly boost conversion for repeat purchases.
  </Accordion>
</AccordionGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Card declined">
    **Causes:** Insufficient funds, card expired, incorrect CVV, bank fraud protection.

    **Solution:** Ask customer to verify details or try a different card.
  </Accordion>

  <Accordion title="3DS authentication failed">
    **Causes:** Customer abandoned, bank system unavailable, timeout.

    **Solution:** Retry or ask customer to contact their bank.
  </Accordion>

  <Accordion title="Card not supported">
    **Causes:** Regional card not supported, prepaid restrictions.

    **Solution:** Customer should try a different card from a major network.
  </Accordion>
</AccordionGroup>

## Related Pages

<CardGroup>
  <Card title="Payment Methods Overview" icon="layer-group" href="/features/payment-methods">
    All supported payment methods.
  </Card>

  <Card title="Upsells & Downsells" icon="arrow-up-right-dots" href="/features/upsells-and-downsells">
    One-click purchases with saved cards.
  </Card>

  <Card title="Testing Process" icon="flask" href="/miscellaneous/testing-process">
    Complete testing guide.
  </Card>

  <Card title="Subscriptions" icon="repeat" href="/features/subscription">
    Recurring billing with cards.
  </Card>
</CardGroup>


# Digital Wallets
Source: https://docs.dodopayments.com/features/payment-methods/digital-wallets

Accept Apple Pay, Google Pay, Amazon Pay, Cash App Pay, and RevolutPay for fast, secure one-tap checkout. Learn about setup, domain verification, and testing.

Digital wallets let customers pay with a single tap using payment methods saved on their devices. They offer higher conversion rates, stronger security through tokenization, and a streamlined checkout experience.

## Supported Wallets

| Wallet           | Availability         | Currencies | Subscriptions | Setup Required      |
| :--------------- | :------------------- | :--------- | :-----------: | :------------------ |
| **Apple Pay**    | Global (excl. India) | All        |      Yes      | Domain verification |
| **Google Pay**   | Global (excl. India) | All        |      Yes      | None                |
| **Amazon Pay**   | Global (excl. India) | USD        |       No      | None                |
| **Cash App Pay** | US only              | USD        |       No      | None                |
| **RevolutPay**   | Global               | GBP        |       No      | None                |

<Warning>
  **PayPal Support Paused:** PayPal is temporarily unavailable for new transactions.
</Warning>

## Apple Pay

Apple Pay allows customers to pay using cards saved in their Apple Wallet, with Face ID or Touch ID authentication.

### Requirements

* **Devices:** iOS 17+, iPadOS 17+, Safari 17+ on macOS
* **Protocol:** HTTPS required
* **Domain:** Must be verified with Apple

### Domain Verification

<Steps>
  <Step title="Download the domain association file">
    Download the [Apple Pay domain association file](http://checkout.dodopayments.com/.well-known/apple-developer-merchantid-domain-association).
  </Step>

  <Step title="Host the file on your domain">
    Upload to your server at:

    ```
    https://yourdomain.com/.well-known/apple-developer-merchantid-domain-association
    ```

    The file must be accessible without redirects and served with `Content-Type: application/octet-stream` or `text/plain`.
  </Step>

  <Step title="Request activation">
    Email **[support@dodopayments.com](mailto:support@dodopayments.com)** with:

    * Your production domain (e.g., `https://yourdomain.com`)
    * Confirmation that the file is hosted

    We'll verify and enable Apple Pay within 1-2 business days.
  </Step>

  <Step title="Test the integration">
    After confirmation:

    1. Open checkout on an Apple device
    2. Verify Apple Pay button appears
    3. Complete a test transaction
  </Step>
</Steps>

<Warning>
  Apple Pay won't appear in checkout until domain verification is complete. Plan for this when launching.
</Warning>

### Configuration

```javascript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  allowed_payment_method_types: ['apple_pay', 'credit', 'debit'],
  return_url: 'https://example.com/success'
});
```

## Google Pay

Google Pay allows customers to pay using cards saved in their Google account, with built-in fraud protection.

### Requirements

* **Browsers:** Chrome (desktop/mobile), Safari, Firefox
* **Devices:** Android devices with Google Pay app
* **Settings:** "Allow sites to check if you have payment methods" enabled in Chrome

### Configuration

```javascript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  allowed_payment_method_types: ['google_pay', 'credit', 'debit'],
  return_url: 'https://example.com/success'
});
```

<Info>
  No domain verification needed for Google Pay — it works automatically once your account is live.
</Info>

## Amazon Pay

Amazon Pay lets customers use their Amazon account credentials and saved payment methods for a familiar checkout experience.

### Limitations

* **Currency:** USD only
* **Subscriptions:** Not supported
* **Region:** Not available in India

### Configuration

```javascript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  allowed_payment_method_types: ['amazon_pay', 'credit', 'debit'],
  return_url: 'https://example.com/success'
});
```

## Cash App Pay

Cash App Pay enables payments from Cash App, popular among US consumers for peer-to-peer payments.

### Limitations

* **Region:** US only
* **Currency:** USD only
* **Subscriptions:** Not supported

### Configuration

```javascript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  allowed_payment_method_types: ['cashapp', 'credit', 'debit'],
  return_url: 'https://example.com/success'
});
```

## RevolutPay

RevolutPay enables fast, seamless payments for Revolut users globally, leveraging their existing Revolut account balance or linked cards.

### Limitations

* **Currency:** GBP only
* **Subscriptions:** Not supported

### Configuration

```javascript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  allowed_payment_method_types: ['revolut_pay', 'credit', 'debit'],
  return_url: 'https://example.com/success'
});
```

## Testing

### Apple Pay Testing

<Steps>
  <Step title="Use test mode">
    Enable test mode in your Dodo Payments dashboard.
  </Step>

  <Step title="Add a card to Apple Wallet">
    Add a real card to your Apple Wallet. In test mode, the card won't be charged.
  </Step>

  <Step title="Complete test purchase">
    Open checkout on an Apple device and complete the Apple Pay flow.
  </Step>
</Steps>

<Warning>
  Apple Pay requires HTTPS. It won't appear on `localhost` without proper SSL setup.
</Warning>

### Google Pay Testing

<Steps>
  <Step title="Join the test card group">
    [Join the Google Pay test card group](https://groups.google.com/g/googlepay-test-mode-stub-data) to get test cards automatically added to your wallet.
  </Step>

  <Step title="Enable test mode">
    Use your Dodo Payments test API keys.
  </Step>

  <Step title="Complete test purchase">
    Select one of the test cards in Google Pay to complete the transaction.
  </Step>
</Steps>

### Amazon Pay & Cash App Pay

Use your test API keys and follow the standard checkout flow. Test transactions will be simulated without actual charges.

## SDK Support

### Web SDKs

All digital wallets are fully supported in:

* Overlay Checkout
* Inline Checkout
* Direct API integration

### Mobile SDKs

<Warning>
  **React Native Limitation:** Apple Pay, Google Pay, Cash App Pay, and UPI are **not currently supported** in the React Native SDK. Use the web-based checkout overlay for mobile apps that need these methods.
</Warning>

For native mobile support, consider:

* Opening checkout in a WebView
* Using the [Overlay Checkout](/developer-resources/overlay-checkout) in a web context
* Implementing platform-native Apple Pay / Google Pay SDKs separately

## Best Practices

<AccordionGroup>
  <Accordion title="Prioritize wallets on mobile">
    Mobile users expect Apple Pay and Google Pay. Show these options prominently on mobile checkouts.
  </Accordion>

  <Accordion title="Complete domain verification early">
    Apple Pay requires domain verification. Don't wait until launch day — start the process during development.
  </Accordion>

  <Accordion title="Always include card fallbacks">
    Not all customers have digital wallets. Always include `credit` and `debit` in your allowed methods.
  </Accordion>

  <Accordion title="Test on real devices">
    Simulators don't fully replicate wallet behavior. Test on actual iOS and Android devices before launch.
  </Accordion>

  <Accordion title="Handle wallet unavailability gracefully">
    If a wallet isn't available (wrong device, no cards saved), ensure other payment options are visible.
  </Accordion>
</AccordionGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Apple Pay button not appearing">
    **Check:**

    1. Domain verified with Dodo Payments?
    2. Using HTTPS?
    3. Device is iOS 17+ / Safari 17+ / iPadOS 17+?
    4. Customer has cards in Apple Wallet?
    5. `apple_pay` included in `allowed_payment_method_types`?

    **Solution:** Complete domain verification and ensure HTTPS. Test on a real Apple device.
  </Accordion>

  <Accordion title="Google Pay button not appearing">
    **Check:**

    1. Using Chrome or compatible browser?
    2. Customer has cards in Google Pay?
    3. Chrome setting "Allow sites to check payment methods" enabled?
    4. `google_pay` included in `allowed_payment_method_types`?

    **Solution:** Verify browser compatibility and customer's Google Pay setup.
  </Accordion>

  <Accordion title="Wallet payment failed">
    **Common causes:**

    * Card in wallet expired or invalid
    * Bank declined the transaction
    * Network connectivity issue

    **Solution:** Customer should verify card in their wallet or try a different payment method.
  </Accordion>

  <Accordion title="Wrong device type">
    Digital wallets only appear on compatible devices:

    * Apple Pay: Apple devices only
    * Google Pay: Chrome browser or Android devices

    **Solution:** This is expected behavior. Ensure card fallbacks are available.
  </Accordion>
</AccordionGroup>

## Related Pages

<CardGroup>
  <Card title="Payment Methods Overview" icon="credit-card" href="/features/payment-methods">
    See all supported payment methods.
  </Card>

  <Card title="Overlay Checkout" icon="window-restore" href="/developer-resources/overlay-checkout">
    Implement checkout with digital wallet support.
  </Card>

  <Card title="Testing Process" icon="flask" href="/miscellaneous/testing-process">
    Complete testing guide for all payment methods.
  </Card>

  <Card title="React Native Integration" icon="mobile" href="/developer-resources/react-native-integration">
    Mobile SDK documentation and limitations.
  </Card>
</CardGroup>


# European Payment Methods
Source: https://docs.dodopayments.com/features/payment-methods/europe

Accept iDEAL, Bancontact, EPS, and Multibanco to increase conversion rates across European markets. Learn about regional availability, bank coverage, and configuration.

European customers strongly prefer local payment methods that integrate with their banking systems. Offering these methods can increase conversion rates by 20-40% in target markets.

## Why Local European Payment Methods?

<CardGroup>
  <Card title="Higher Conversion" icon="chart-line">
    iDEAL captures \~60% of Dutch online payments. Not offering it means losing customers.
  </Card>

  <Card title="Lower Fraud" icon="shield-check">
    Bank-authenticated payments have near-zero fraud rates and no chargebacks.
  </Card>

  <Card title="Real-Time Settlement" icon="bolt">
    Most European methods provide instant payment confirmation.
  </Card>
</CardGroup>

## Supported Methods

| Method         | Country     | Market Share | Currency | Subscriptions |
| :------------- | :---------- | :----------- | :------- | :-----------: |
| **iDEAL**      | Netherlands | \~60%        | EUR      |       No      |
| **Bancontact** | Belgium     | \~50%        | EUR      |       No      |
| **EPS**        | Austria     | \~30%        | EUR      |       No      |
| **Multibanco** | Portugal    | \~40%        | EUR      |       No      |

## iDEAL (Netherlands)

iDEAL is the dominant online payment method in the Netherlands, connecting directly to all major Dutch banks.

### How It Works

```mermaid theme={null}
sequenceDiagram
    participant Customer
    participant Checkout
    participant Dodo
    participant iDEAL
    participant Bank
    
    Customer->>Checkout: Select iDEAL
    Checkout->>Dodo: Create payment
    Dodo->>iDEAL: Initiate payment
    iDEAL->>Customer: Redirect to bank selection
    Customer->>Bank: Select bank & authenticate
    Bank->>iDEAL: Payment confirmed
    iDEAL->>Dodo: Success callback
    Dodo->>Checkout: Payment complete
```

### Supported Banks

All major Dutch banks are supported:

* ABN AMRO
* ASN Bank
* Bunq
* ING
* Knab
* Rabobank
* RegioBank
* Revolut
* SNS
* Triodos Bank
* Van Lanschot

### Configuration

```javascript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  allowed_payment_method_types: ['ideal', 'credit', 'debit'],
  billing_currency: 'EUR',
  billing_address: {
    country: 'NL',
    zipcode: '1012JS'
  },
  return_url: 'https://example.com/success'
});
```

## Bancontact (Belgium)

Bancontact is Belgium's national payment scheme, used by virtually all Belgian banks for online payments.

### Features

* Works with existing Belgian debit cards
* Mobile app support (Payconiq by Bancontact)
* Instant payment confirmation
* No additional registration needed for customers

### Configuration

```javascript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  allowed_payment_method_types: ['bancontact_card', 'credit', 'debit'],
  billing_currency: 'EUR',
  billing_address: {
    country: 'BE',
    zipcode: '1000'
  },
  return_url: 'https://example.com/success'
});
```

## EPS (Austria)

EPS (Electronic Payment Standard) enables direct online bank transfers for Austrian customers.

### Features

* Direct integration with Austrian banks
* Real-time payment confirmation
* High trust among Austrian consumers
* No chargebacks

### Supported Banks

Major Austrian banks including:

* Erste Bank
* Bank Austria
* Raiffeisen
* BAWAG
* Volksbank

### Configuration

```javascript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  allowed_payment_method_types: ['eps', 'credit', 'debit'],
  billing_currency: 'EUR',
  billing_address: {
    country: 'AT',
    zipcode: '1010'
  },
  return_url: 'https://example.com/success'
});
```

## Multibanco (Portugal)

Multibanco is Portugal's interbank network, offering both online payments and ATM-based payments.

### Payment Options

1. **Online Banking** — Direct bank transfer via internet banking
2. **ATM Payment** — Customer receives a reference to pay at any Multibanco ATM
3. **Mobile Banking** — Payment via bank mobile apps

### How ATM Payment Works

For ATM payments, customers receive a payment reference:

```
Entity: 12345
Reference: 123 456 789
Amount: €50.00
Expiry: 24 hours
```

Customer can pay at any Portuguese ATM or via online banking using this reference.

### Configuration

```javascript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  allowed_payment_method_types: ['multibanco', 'credit', 'debit'],
  billing_currency: 'EUR',
  billing_address: {
    country: 'PT',
    zipcode: '1000-001'
  },
  return_url: 'https://example.com/success'
});
```

<Note>
  Multibanco ATM payments may have a delay between checkout and actual payment. Monitor webhooks for payment confirmation.
</Note>

## API Method Types

| Type              | Method     | Country     |
| :---------------- | :--------- | :---------- |
| `ideal`           | iDEAL      | Netherlands |
| `bancontact_card` | Bancontact | Belgium     |
| `eps`             | EPS        | Austria     |
| `multibanco`      | Multibanco | Portugal    |

## Multi-Country European Checkout

For businesses serving multiple European countries, include all regional methods:

```javascript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  allowed_payment_method_types: [
    'ideal',           // Netherlands
    'bancontact_card', // Belgium
    'eps',             // Austria
    'multibanco',      // Portugal
    'credit',          // Fallback
    'debit'            // Fallback
  ],
  billing_currency: 'EUR',
  return_url: 'https://example.com/success'
});
```

Dodo automatically shows only the relevant methods based on customer location. A Dutch customer will see iDEAL; a Belgian customer will see Bancontact.

## Testing

European payment methods can be tested in sandbox mode. The test flow simulates the bank authentication process.

<Steps>
  <Step title="Enable test mode">
    Use your Dodo Payments test API keys.
  </Step>

  <Step title="Set appropriate billing address">
    Set the billing address country to match the payment method:

    * `NL` for iDEAL
    * `BE` for Bancontact
    * `AT` for EPS
    * `PT` for Multibanco
  </Step>

  <Step title="Complete the test flow">
    Follow the simulated bank authentication flow in the test environment.
  </Step>
</Steps>

## Best Practices

<AccordionGroup>
  <Accordion title="Always include regional methods for target markets">
    If you sell to Dutch customers, include iDEAL. Not doing so is like not accepting Visa in the US — you'll lose significant sales.
  </Accordion>

  <Accordion title="Match currency to region">
    European payment methods require EUR. Ensure your pricing supports Euro transactions.
  </Accordion>

  <Accordion title="Handle redirects gracefully">
    All European methods involve redirects to bank sites. Ensure your return URL handling is robust and accounts for users who abandon mid-flow.
  </Accordion>

  <Accordion title="Provide card fallbacks">
    Not all European customers have access to these regional methods (tourists, expats, etc.). Always include `credit` and `debit` as fallbacks.
  </Accordion>

  <Accordion title="Consider Multibanco timing">
    Multibanco ATM payments may take hours to complete. Don't block fulfillment on immediate payment — use webhooks for async confirmation.
  </Accordion>
</AccordionGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="European method not appearing">
    **Check:**

    1. Customer billing country matches method's country?
    2. Currency set to EUR?
    3. Method included in `allowed_payment_method_types`?

    **Solution:** European methods are strictly regional. A customer with billing country `DE` (Germany) won't see iDEAL, which is Netherlands-only.
  </Accordion>

  <Accordion title="Bank authentication failed">
    **Causes:**

    * Customer cancelled during bank authentication
    * Bank's authentication system temporarily unavailable
    * Customer entered incorrect credentials

    **Solution:** Customer should retry. If persistent, suggest trying a different payment method.
  </Accordion>

  <Accordion title="Redirect not completing">
    **Causes:**

    * Customer closed browser during bank redirect
    * Network issues during authentication
    * Return URL misconfigured

    **Solution:** Verify return URL is correct and accessible. Ensure it handles both success and failure states.
  </Accordion>

  <Accordion title="Multibanco payment pending">
    **Cause:** Customer received payment reference but hasn't paid yet.

    **Solution:** This is expected for ATM-based payments. Wait for webhook confirmation. Reference typically expires in 24-72 hours.
  </Accordion>
</AccordionGroup>

## PSD2 Compliance

All European payment methods comply with PSD2 (Payment Services Directive 2) regulations:

* **Strong Customer Authentication (SCA)** — Built into the bank authentication flow
* **Secure Communication** — All data transmitted via secure channels
* **Consumer Protection** — Full compliance with EU consumer rights

## Related Pages

<CardGroup>
  <Card title="Payment Methods Overview" icon="credit-card" href="/features/payment-methods">
    See all supported payment methods.
  </Card>

  <Card title="Adaptive Currency" icon="globe" href="/features/adaptive-currency">
    Currency support and automatic conversion.
  </Card>

  <Card title="Checkout Guide" icon="book" href="/developer-resources/checkout-session">
    Complete checkout implementation guide.
  </Card>

  <Card title="Webhooks" icon="webhook" href="/developer-resources/webhooks">
    Handle payment confirmations asynchronously.
  </Card>
</CardGroup>


# India Payment Methods
Source: https://docs.dodopayments.com/features/payment-methods/india

Accept UPI and Rupay cards in India with RBI-compliant subscription mandates. Understand the 48-hour processing delay, mandate limits, and webhook handling.

India has unique payment infrastructure dominated by UPI (60%+ of digital transactions) and Rupay cards. Dodo Payments supports both with full RBI compliance for subscription mandates.

## Why India Payment Methods Matter

<CardGroup>
  <Card title="UPI Dominance" icon="mobile">
    UPI processes 10B+ transactions/month. Many Indian customers don't have international cards.
  </Card>

  <Card title="Low Transaction Costs" icon="indian-rupee-sign">
    UPI has near-zero transaction fees. Excellent for high-volume, lower-value transactions.
  </Card>

  <Card title="Subscription Support" icon="repeat">
    Unlike most alternative payment methods, UPI and Rupay support recurring payments via RBI mandates.
  </Card>
</CardGroup>

## Supported Methods

| Method           | Type          | Subscriptions | Min Amount |
| :--------------- | :------------ | :-----------: | :--------- |
| **UPI Collect**  | QR code / VPA |     Yes\*     | ₹1         |
| **Rupay Credit** | Card          |     Yes\*     | ₹1         |
| **Rupay Debit**  | Card          |     Yes\*     | ₹1         |

\*Subscriptions require RBI-compliant mandates with special processing rules.

## Configuration

### API Method Types

| Type          | Description                  |
| :------------ | :--------------------------- |
| `upi_collect` | UPI via QR code or VPA entry |
| `credit`      | Credit cards including Rupay |
| `debit`       | Debit cards including Rupay  |

### Example: India-Focused Checkout

```javascript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  allowed_payment_method_types: [
    'upi_collect',
    'credit',
    'debit'
  ],
  billing_currency: 'INR',
  customer: {
    email: 'customer@example.in',
    name: 'Priya Sharma',
    phone_number: '+919876543210'
  },
  billing_address: {
    country: 'IN',
    zipcode: '560001'
  },
  return_url: 'https://example.com/success'
});
```

### Requirements for UPI

For UPI to appear at checkout:

1. **Billing country** must be India (`IN`)
2. **Currency** must be INR
3. For non-Indian merchants: **Adaptive Currency** must be enabled

<Warning>
  If you're a non-Indian merchant and Adaptive Currency is not enabled, UPI will not be available to your customers.
</Warning>

## Subscriptions with RBI Mandates

Indian payment method subscriptions operate under RBI (Reserve Bank of India) regulations with unique requirements.

### How RBI Mandates Work

```mermaid theme={null}
sequenceDiagram
    participant Customer
    participant Your App
    participant Dodo
    participant Bank
    
    Customer->>Your App: Subscribe
    Your App->>Dodo: Create subscription
    Dodo->>Bank: Create mandate
    Bank->>Customer: Authorize mandate
    Customer->>Bank: Approve (face value or Rs 15K limit)
    Bank->>Dodo: Mandate active
    
    Note over Dodo,Bank: On renewal date...
    
    Dodo->>Bank: Initiate charge
    Note over Bank: 48-hour window starts
    Bank->>Customer: Pre-debit notification
    Note over Bank: After 48 hours...
    Bank->>Dodo: Debit completed
    Dodo->>Your App: payment.succeeded webhook
```

### Mandate Types

| Subscription Amount    | Mandate Type         | Limit                     |
| :--------------------- | :------------------- | :------------------------ |
| **Below Rs 15,000**    | On-demand mandate    | Rs 15,000                 |
| **Rs 15,000 or above** | Fixed-amount mandate | Exact subscription amount |

**Important for plan changes:** If an upgrade results in a charge exceeding the existing mandate limit, the charge will fail and the customer must re-authorize.

### The 48-Hour Processing Delay

This is the most important difference from international card payments:

<Steps>
  <Step title="Charge Initiated (Day 0)">
    On the scheduled renewal date, Dodo initiates the charge with the bank.
  </Step>

  <Step title="Pre-Debit Notification">
    Customer receives notification from their bank about the upcoming debit.
  </Step>

  <Step title="48-Hour Window">
    Customer can cancel the mandate during this period via their banking app.
  </Step>

  <Step title="Debit Completed (~48-51 hours)">
    After 48 hours (plus up to 3 additional hours for bank processing), funds are debited.
  </Step>

  <Step title="Webhook Sent">
    `payment.succeeded` webhook is sent after actual debit, not at initiation.
  </Step>
</Steps>

<Warning>
  **Do not grant benefits at charge initiation.** Wait for the `payment.succeeded` webhook, which arrives \~48-51 hours after the scheduled charge date.
</Warning>

### Handling the 48-Hour Window

```javascript theme={null}
// DON'T do this:
async function handleSubscriptionRenewal(subscription) {
  // ❌ Bad: Granting access immediately when charge is initiated
  grantPremiumAccess(subscription.customer_id);
}

// DO this:
async function handlePaymentWebhook(event) {
  if (event.type === 'payment.succeeded') {
    // ✅ Good: Only grant access after payment is confirmed
    grantPremiumAccess(event.data.customer_id);
  }
  
  if (event.type === 'payment.failed') {
    // Handle failed payment (mandate cancelled, insufficient funds)
    revokePremiumAccess(event.data.customer_id);
  }
}
```

### Webhook Events for Indian Subscriptions

| Event                  | When                      | Action                           |
| :--------------------- | :------------------------ | :------------------------------- |
| `subscription.created` | Mandate authorized        | Record subscription start        |
| `payment.succeeded`    | \~48h after charge date   | Grant/continue access            |
| `payment.failed`       | Debit failed              | Notify customer, pause access    |
| `subscription.on_hold` | Payment failed            | Prompt for payment method update |
| `subscription.active`  | Reactivated after payment | Restore access                   |

## Testing

### UPI Test IDs

| Status  | UPI ID        |
| :------ | :------------ |
| Success | `success@upi` |
| Failure | `failure@upi` |

### Indian Card Test Numbers

| Brand      | Scenario | Card Number        | Expiry | CVV |
| :--------- | :------- | :----------------- | :----- | :-- |
| Visa       | Success  | `4576238912771450` | 06/32  | 123 |
| Visa       | Declined | `4706131211212123` | 06/32  | 123 |
| Mastercard | Success  | `5409162669381034` | 06/32  | 123 |
| Mastercard | Declined | `5105105105105100` | 06/32  | 123 |

## Best Practices

<AccordionGroup>
  <Accordion title="Plan for the 48-hour delay">
    Build your application to handle the gap between charge initiation and actual payment. Consider:

    * Grace periods for subscription access
    * Clear communication to customers about processing time
    * Webhook-driven fulfillment, not date-driven
  </Accordion>

  <Accordion title="Handle mandate cancellations">
    Customers can cancel mandates via their bank apps at any time. Monitor `subscription.on_hold` webhooks and prompt customers to re-subscribe or update payment methods.
  </Accordion>

  <Accordion title="Set appropriate mandate amounts">
    For variable pricing (e.g., usage-based), consider whether a Rs 15,000 on-demand mandate is sufficient. If charges might exceed this, customers will need to re-authorize.
  </Accordion>

  <Accordion title="Offer UPI prominently">
    For Indian customers, UPI should be the primary payment option. Many users prefer it over cards due to familiarity and lower friction.
  </Accordion>
</AccordionGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="UPI not appearing at checkout">
    **Check:**

    1. Billing country set to `IN`?
    2. Currency set to `INR`?
    3. If non-Indian merchant: Adaptive Currency enabled?
    4. `upi_collect` included in `allowed_payment_method_types`?

    **Solution:** Verify billing address has `country: "IN"` and `billing_currency: "INR"`.
  </Accordion>

  <Accordion title="Subscription charge failed after upgrade">
    **Cause:** New charge amount exceeds existing mandate limit (Rs 15,000 threshold).

    **Solution:** Customer must update payment method to establish a new mandate with the correct limit.
  </Accordion>

  <Accordion title="Subscription on hold but customer claims they didn't cancel">
    **Cause:** Customer may have cancelled the mandate during the 48-hour window, or their bank declined the debit.

    **Solution:** Customer needs to re-authorize the mandate or update their payment method.
  </Accordion>

  <Accordion title="Payment deduction delayed beyond 48 hours">
    **Cause:** Bank API delays can extend processing by 2-3 additional hours.

    **Solution:** This is expected. Build your system to handle variable delays up to \~51 hours total.
  </Accordion>

  <Accordion title="Mandate cancelled but subscription still active">
    **Cause:** Edge case in RBI regulations — mandate cancellation during processing window doesn't immediately cancel subscription.

    **Solution:** The next charge will fail and subscription will move to `on_hold`. Monitor webhooks for `payment.failed`.
  </Accordion>
</AccordionGroup>

## Related Pages

<CardGroup>
  <Card title="Payment Methods Overview" icon="credit-card" href="/features/payment-methods">
    See all supported payment methods.
  </Card>

  <Card title="Subscriptions" icon="repeat" href="/features/subscription">
    Complete subscription documentation including RBI mandates.
  </Card>

  <Card title="Webhooks" icon="webhook" href="/developer-resources/webhooks">
    Webhook handling for payment events.
  </Card>

  <Card title="Testing Process" icon="flask" href="/miscellaneous/testing-process">
    All test data including UPI IDs and Indian cards.
  </Card>
</CardGroup>


# Payouts Process
Source: https://docs.dodopayments.com/features/payouts/payout-structure

Consolidate your eligible earnings and manage your payout threshold directly from the dashboard.

## Introduction

The **Payouts Section** consolidates all eligible earnings that can be disbursed in the next payout cycle. It provides transparency on the net available balance after accounting for all fees, refunds, and taxes.

<Frame>
  <img alt="Payouts section showing balance eligible for payout" />
</Frame>

## Key Features

* Displays the total balance eligible for payout in the upcoming cycle in USD
* Automatically applies FX conversion for non-USD currencies
* Lets businesses **set or modify their payout threshold** directly from the wallet settings

<Info>
  The displayed amount is **for reference only**. Final payout amounts may vary based on the actual exchange rate at the time of transfer.
</Info>

## Payout Cycles

We support the following payout cycles:

<Steps>
  <Step title="Bi-Monthly (Default)">
    **Billing Period 1:** 1st to 15th of the month\
    **Payout Date 1:** 18th of the same month

    **Billing Period 2:** 16th to the end of the month\
    **Payout Date 2:** 4th of the following month
  </Step>

  <Step title="Weekly">
    **Billing Period 1:** 1st to 7th\
    **Payout Date 1:** 11th of the same month

    **Billing Period 2:** 8th to 14th\
    **Payout Date 2:** 18th of the same month

    **Billing Period 3:** 15th to 21st\
    **Payout Date 3:** 25th of the same month

    **Billing Period 4:** 22nd to the end of the month\
    **Payout Date 4:** 4th of the following month
  </Step>

  <Step title="Monthly">
    **Billing Period:** 1st to the end of the month\
    **Payout Date:** 11th of the following month
  </Step>
</Steps>

**Note:**

* Payouts will only be initiated if all verifications are successful and Payout Threshold is crossed in the billing period.
* The default payout cycle for all businesses is **bi-monthly**.
* Businesses with higher transaction volumes may request **weekly** payouts by contacting [support@dodopayments.com](mailto:support@dodopayments.com).
* Certain high-risk businesses may be placed on a **monthly** payout cycle at our discretion.

## Payout Processing and Bank Timelines

1. The dates provided above are the **initiation dates** for payouts.
2. It typically takes **1-2 business days** for the amount to appear in your bank account.
3. Delays may occur if payout processing dates fall on weekends or bank holidays.

## Minimum Payout Threshold

| Currency | Minimum Threshold |
| -------- | ----------------- |
| USD      | \$50              |
| INR      | Rs 1,000          |

<Info>
  If your balance does not meet the threshold, it will carry forward to the next payout cycle.
</Info>

## Flexible Minimum Payout Threshold

You can customize the balance that must build up in your USD wallet before Dodo Payments triggers a payout.

**Configuration:**

* **Allowed values:** \$50 or any higher amount
* **Effective from:** Your current payout cycle
* **Note:** Payouts already scheduled (if entry is created in the payout table) remain unchanged

### How to Edit Your Threshold

<Frame>
  <img alt="Edit payout threshold in dashboard" />
</Frame>

<Steps>
  <Step title="Navigate to Payout Settings">
    Go to **Payouts → Payouts Page → Minimum Threshold**
  </Step>

  <Step title="Enter New Threshold">
    Choose edit threshold and enter a number **≥ 50** (e.g., "250")
  </Step>

  <Step title="Confirm Changes">
    Click **Confirm** to save your new threshold
  </Step>

  <Step title="Verify Update">
    You will see the updated amount in the Minimum Payout Threshold field
  </Step>
</Steps>

<Note>
  This feature is only applicable to the USD/EUR/GBP Wallet as of now. The INR wallet will have no changes.
</Note>

## Payout Deductions

The following amounts are deducted from your sales before payout:

**Taxes:**
All applicable taxes as per the Tax Calculator will be deducted from the sales amount before payout.

**Fees:**
Dodo Payment Fees and Payout Fees will be deducted before sending the payout.

<Tip>
  For detailed fee information, check out our [Pricing Page](https://dodopayments.com/pricing).
</Tip>

## Payout Status

Track the progress of your payouts through the following status indicators:

| Status        | Description                                                                              |
| ------------- | ---------------------------------------------------------------------------------------- |
| Not Initiated | Payout due date has not yet arrived hence it has not been initiated                      |
| In Progress   | Payout due date has arrived and payout is in progress                                    |
| On Hold       | Payout is put on hold by the Payout Team (by backend until admin dashboard is available) |
| Successful    | Payout to the business account is processed successfully                                 |
| Failed        | Payout to the business account has failed                                                |

## Payout Invoice

A reverse invoice is generated to indicate the amount paid by Dodo Payments to the business.

### Invoice Structure

<Frame>
  <img alt="Payout invoice structure example" />
</Frame>

## Important Disclaimer for Indian Businesses

* **INR Payouts to businesses in India are handled independently** and are **not part of the consolidated USD/GBP/EUR payout cycle**.
* Businesses with Indian bank accounts will receive **two separate payouts** per cycle:
  * One for INR Wallet (domestic payout)
  * One for global currencies (USD/GBP/EUR consolidated payout)
* Each payout will generate a separate invoice and entry in the balance ledger.

<Card title="Balances & Wallets" icon="file-invoice-dollar" href="/features/account-summary-payout-wallet">
  Get a comprehensive overview of all your USD, GBP, EUR, and INR wallet balances, transaction ledgers, and payout-related financial activity.
</Card>


# Product Collections
Source: https://docs.dodopayments.com/features/product-collections

Group related products together for unified checkout experiences, plan selection, and seamless upgrade/downgrade paths within the Customer Portal.

<Info>
  Product Collections let you group related products (e.g., Starter, Pro, Enterprise plans) under one umbrella. Display all options in a single checkout, define upgrade/downgrade paths, and give customers the flexibility to switch plans directly from the Customer Portal.
</Info>

<Frame>
  <img alt="Screenshot of the Product Collection checkout page showing multiple products displayed" />
</Frame>

## Key Highlights

* **Collection-based structure**: Group related products (plans, tiers, pricing options) under a single collection for organized management.
* **One collection, many products**: Include multiple products like Starter, Pro, Lifetime, etc., each with its own pricing model.
* **Dynamic checkout experience**: Display all products from a collection in one checkout view, letting customers choose their preferred plan.
* **Merchant-level control**: Enable, disable, and reorder products within each collection. The first product is automatically pre-selected at checkout.
* **Lifecycle awareness**: Enable customers to upgrade or downgrade between products in the same collection via the Customer Portal.

## Creating a Product Collection

Product Collections are created and managed from the dashboard or via API. Each collection acts as a container for related products.

<Steps>
  <Step title="Create the collection">
    Define the collection with a name and optional description. Upload an image to visually represent the collection in checkout.

    <Frame>
      <img alt="Screenshot of the Product Collection creation form in the dashboard showing fields for name, description, and image upload" />
    </Frame>

    **Collection fields:**

    * **Name** (required): Display name for the collection (e.g., "SaaS Plans", "License Tiers")
    * **Description** (optional): Brief explanation shown in checkout
    * **Image** (optional): Visual branding for the collection
  </Step>

  <Step title="Add products to the collection">
    Add existing products to your collection. Products can be organized into groups for better structure.

    <Frame>
      <img alt="Screenshot of the Product Collection products page showing a list of products and the ability to add them to the collection" />
    </Frame>

    **Product organization:**

    * **Groups**: Optionally organize products into named groups (e.g., "Monthly Plans", "Annual Plans")
    * **Ungrouped products**: Products without a group appear at the collection level
    * **Ordering**: Drag and drop to set the display order

    <Warning>
      Each product can only belong to one collection. If a product is already in another collection, you'll need to remove it first.
    </Warning>
  </Step>

  <Step title="Configure ordering and visibility">
    Control the display order and visibility of products within the collection.

    **Configuration options:**

    * **Product status**: Enable or disable individual products within the collection
    * **Display order**: Drag and drop to set the sequence products appear in checkout

    <Info>
      The first product in the collection is automatically pre-selected as the default at checkout. Reorder products to change which one is selected by default.
    </Info>
  </Step>
</Steps>

## Collection Checkout

Collections enable a unified checkout experience where customers can view and select from all available products in one place.

### Checkout Types

| Type                        | Description                                      | Use Case                                    |
| --------------------------- | ------------------------------------------------ | ------------------------------------------- |
| **Collection Checkout**     | Displays all active products within a collection | Subscription plan selection, tiered pricing |
| **Single Product Checkout** | Displays only one specific product               | Direct purchase, promotional links          |

### Collection Checkout Experience

When using a collection checkout:

1. **All active products displayed**: Customers see every enabled product in the collection
2. **First product pre-selected**: The first product in the collection order is automatically selected
3. **Product details shown**: Each product displays its name, description, and pricing
4. **Single selection**: Customer selects one product to purchase
5. **Standard flow continues**: After selection, the checkout proceeds with the chosen product's pricing and billing settings

<Frame>
  <img alt="Screenshot of the Product Collection checkout page showing multiple products displayed" />
</Frame>

<Tip>
  Collection checkout is ideal for subscription businesses where you want customers to compare plans side-by-side before purchasing.
</Tip>

### API Integration

Create a checkout session for a collection:

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_collection_id: 'pdc_abc123',
  product_cart: [], // Required: pass an empty array for collection checkout
  return_url: 'https://yoursite.com/return'
});

// Redirect customer to the checkout
window.location.href = session.url;
```

<Warning>
  When using `product_collection_id`, discount codes cannot be applied at session creation. Customers can still enter discount codes during checkout if enabled.
</Warning>

## Customer Portal Integration

Customers can upgrade or downgrade between products within the same collection directly from the Customer Portal.

<Tip>
  **Already have subscription products?** Simply add them to a Product Collection to enable upgrade/downgrade flows in the Customer Portal. No need to recreate your products.
</Tip>

### Plan Management Actions

| Action                | Description                                           | Merchant Control                |
| --------------------- | ----------------------------------------------------- | ------------------------------- |
| **View Current Plan** | Display current product name, price, and renewal date | Always available                |
| **Upgrade Plan**      | Move to a higher-tier product in the same collection  | Configurable (default: allowed) |
| **Downgrade Plan**    | Move to a lower-tier product in the same collection   | Configurable (default: allowed) |
| **Cancel**            | Cancel the subscription entirely                      | Always available                |

<Frame>
  <img alt="Screenshot of the Product Collection customer portal plan change interface showing the plan management actions" />
</Frame>

### Upgrade/Downgrade Rules

* Upgrades and downgrades are only available between products **within the same collection**
* Proration is applied based on your subscription settings
* Email notifications are sent to the business on every upgrade, downgrade, or cancellation

<Frame>
  <img alt="Screenshot of the Product Collection customer portal plan change interface showing the plan management actions" />
</Frame>

<Info>
  Customers cannot change to products outside their current collection. Create separate collections for distinct product lines.
</Info>

## Subscription Settings

Configure how subscriptions and plan changes work across your business from the Subscription Settings section in your dashboard.

<Frame>
  <img alt="Screenshot of the subscription settings page showing Allow Multiple Subscriptions and Allow Subscription Updates toggles" />
</Frame>

### Available Settings

| Setting                          | Description                                                                                 | Default  |
| -------------------------------- | ------------------------------------------------------------------------------------------- | -------- |
| **Allow Multiple Subscriptions** | Customers can hold more than one active subscription at the same time                       | Enabled  |
| **Allow Subscription Updates**   | Customers can upgrade or downgrade their existing subscriptions anytime via Customer Portal | Disabled |

<Info>
  Plan changes via Customer Portal are disabled by default. Enable "Allow Subscription Updates" in your Subscription Settings to let customers upgrade or downgrade between products in the same collection.
</Info>

<Card title="Subscription Plan Changes" icon="repeat" href="/features/subscription#subscription-plan-changes">
  Learn more about proration modes and plan change behavior.
</Card>

## Managing Collections

Product Collections are created and managed exclusively through the Dodo Payments dashboard.

<Info>
  Creating, updating, and deleting collections is only available via the dashboard. The API provides read-only access to retrieve collection data for integration purposes.
</Info>

### Dashboard Operations

* **Create**: Set up new collections with products and groups
* **Update**: Modify name, description, image, and product organization
* **Reorder**: Drag and drop to change product display order
* **Enable/Disable products**: Control which products appear in checkout
* **Delete**: Remove a collection (products remain but are unlinked)

<Frame>
  <img alt="Screenshot of the Product Collection dashboard showing the collection management operations" />
</Frame>

## Best Practices

* **Group logically**: Organize products by billing interval (monthly/annual) or feature tier (starter/pro/enterprise)
* **Order strategically**: Place your most popular or recommended plan first, as it will be pre-selected at checkout
* **Use clear naming**: Product names should clearly communicate value differences
* **Enable both directions**: Allow both upgrades and downgrades to give customers flexibility
* **Consider proration**: Choose a proration mode that aligns with your business model
* **Test thoroughly**: Verify checkout and plan change flows in test mode before going live

<Check>
  You're ready to create product collections and offer customers a unified plan selection experience.
</Check>

<CardGroup>
  <Card title="Products" icon="box" href="/features/products">
    Create one-time, subscription, or usage-based products to add to collections.
  </Card>

  <Card title="Checkout" icon="cart-shopping" href="/features/checkout">
    Display collection products in a unified checkout experience.
  </Card>

  <Card title="Customer Portal" icon="id-card" href="/features/customer-portal">
    Let customers upgrade or downgrade within the same collection.
  </Card>

  <Card title="Subscriptions" icon="repeat" href="/features/subscription">
    Manage recurring plans with proration and plan changes.
  </Card>
</CardGroup>


# Products
Source: https://docs.dodopayments.com/features/products

Create one-time, subscription, or usage-based products in minutes. Manage pricing, media, fields, and automated entitlements - all in one place.

<Info>
  Products are the foundation of Dodo Payments. Whether you sell a one‑time download, a recurring subscription, or usage‑based access, you start by creating a product. Each product defines how it’s priced, presented at checkout, and fulfilled after purchase.
</Info>

<CardGroup>
  <Card title="One‑Time" icon="credit-card" href="/features/one-time-payment-products">
    Charge once for lifetime access or a single deliverable.
  </Card>

  <Card title="Subscriptions" icon="repeat" href="/features/subscription">
    Bill on a schedule with trials, proration, and add‑ons.
  </Card>

  <Card title="Usage‑Based" icon="arrow-trend-up" href="/features/usage-based-billing">
    Meter consumption and bill by actual usage.
  </Card>
</CardGroup>

## Create a product

You can create products from the dashboard or via API. Choose the pricing model up‑front, One‑Time, Subscription, or Usage‑Based and then configure details. The pricing model can’t be changed later; create a new product if you need a different model.

<Steps>
  <Step title="Name & description">
    Provide a clear title and a concise value‑oriented description. Markdown is supported in descriptions.

    <Tip>
      Keep the first sentence customer‑facing and outcome‑oriented; it appears prominently in checkout.
    </Tip>

    <Frame>
      <img alt="Products" />
    </Frame>
  </Step>

  <Step title="Pricing model & price">
    Select the pricing model:

    * **One‑Time**: Fixed price paid once.
    * **Subscription**: Recurring price with interval and optional trial.
    * **Usage‑Based**: Price derived from metered events.

    Then set pricing:

    * **Price**: Base amount and currency.
    * **Discount (%)**: Optional inline discount shown in checkout and invoices.
    * For subscriptions, set **Repeat every** (e.g., 1 month or 1 year) and **Trial days** if needed.

    <Warning>
      Changing price affects only new purchases. Existing subscriptions follow plan‑change rules.
    </Warning>
  </Step>

  <Step title="Product media">
    Upload images to showcase the product on checkout and invoices. Supported PNG/JPG/WebP up to 3 MB. Reorder or replace any time.
  </Step>

  <Step title="Automated entitlements (Under Advanced Settings)">
    Attach fulfillment that activates automatically after payment:

    * **License Keys**: Issue and validate unique keys
    * **File Downloads**: Grant secure file access
    * **Custom**: Trigger your own entitlement logic via webhooks

    Add or remove benefits as your offer evolves. Existing subscribers gain or lose access accordingly.
  </Step>
</Steps>

## Variants and pricing options

Instead of variants under one product, create separate products for each pricing option (for example, Monthly and Yearly). Then group them into a **Product Collection** to present all options in a single checkout and enable plan switching in the Customer Portal.

<Frame>
  <img alt="Product Collections" />
</Frame>

### Why this approach?

* **Clear pricing models**: Each product has a single, well-defined pricing model (one-time, subscription, or usage-based)
* **Predictable APIs**: Simpler integrations without nested variant logic
* **Easier reporting**: Track revenue and metrics per product without variant aggregation
* **Flexible checkout**: Display multiple products side-by-side, letting customers compare and choose

### How Product Collections work

1. **Create products**: Set up individual products for each plan (e.g., Starter Monthly, Starter Annual, Pro Monthly, Pro Annual)
2. **Group into a collection**: Add related products to a Product Collection
3. **Unified checkout**: Customers see all options in one checkout and select their preferred plan
4. **Plan switching**: Customers can upgrade or downgrade between products in the same collection via the Customer Portal

<Card title="Product Collections" icon="layer-group" href="/features/product-collections">
  Group related products together for unified checkout experiences and seamless upgrade/downgrade paths.
</Card>

## Managing products

You can manage products through the dashboard or programmatically via API. The API provides full control over product creation, updates, retrieval, image uploads, and archiving.

### Dashboard Management

* **Update**: Edit name, description, images, price, fields, and benefits at any time (pricing model is immutable).
* **Archive**: Hide a product from new purchases without disrupting existing customers. You can unarchive later.

### API Management

The following instructions allow you to create, update, manage, and retrieve products, including uploading images.

<AccordionGroup>
  <Accordion title="Creating a Product">
    A product can be a one-time item or a subscription-based service. To create a new product, send a `POST` request to the `/products` endpoint with details such as name, description, price, currency, and whether it is a recurring product.

    For recurring products, set `recurring: true` and specify a `billing_cycle` (`daily`, `weekly`, `monthly`, `yearly`).

    <Card title="Create Product API" icon="code" href="/api-reference/products/post-products">
      View detailed request and response structure in the Create Product API documentation.
    </Card>
  </Accordion>

  <Accordion title="Updating a Product">
    To modify an existing product, send a `PATCH` request to the `/products/{product_id}` endpoint. You can update properties such as name, price, and description while keeping other details unchanged.

    Ensure that the `product_id` in the endpoint matches an existing product.

    <Card title="Update Product API" icon="code" href="/api-reference/products/patch-products">
      View detailed request and response structure in the Update Product API documentation.
    </Card>
  </Accordion>

  <Accordion title="Retrieving Products">
    You can fetch a list of products stored in your account using a `GET` request to the `/products` endpoint. This allows you to retrieve product details, including active and archived products.

    <Card title="Retrieve Products API" icon="code" href="/api-reference/products/get-products">
      View detailed request and response structure in the Retrieve Products API documentation.
    </Card>
  </Accordion>

  <Accordion title="Uploading Product Images">
    You can associate an image with a product by uploading it to AWS S3 using a pre-signed URL provided by the API. First, request an image upload URL from the `/products/{product_id}/images` endpoint, then use the provided URL to upload the image within 60 seconds.

    <Warning>
      The pre-signed URL expires in 60 seconds, so the image must be uploaded within that timeframe.
    </Warning>

    Once the pre-signed URL is received from the API, upload the image using the `PUT` method. This ensures secure and temporary access to AWS S3 for uploading the image.

    **Supported libraries for uploading to S3:**

    * **Node.js**: `axios`, `node-fetch`
    * **Python**: `requests`, `boto3`
    * **Go**: `net/http`
    * **PHP**: `GuzzleHttp`
    * **Ruby**: `rest-client`

    If the upload is successful, AWS S3 will return a `200 OK` status, indicating that the image has been stored successfully.

    <Card title="Upload Product Image API" icon="code" href="/api-reference/products/put-products-images">
      View detailed request and response structure in the Upload Product Image API documentation.
    </Card>
  </Accordion>

  <Accordion title="Archiving a Product">
    If you no longer wish to display or use a product, you can archive it using a `POST` request to the `/products/{product_id}/archive` endpoint. This action hides the product but does not delete it permanently.

    <Card title="Archive Product API" icon="code" href="/api-reference/products/archive-product">
      View detailed request and response structure in the Archive Product API documentation.
    </Card>
  </Accordion>

  <Accordion title="Unarchiving a Product">
    If you need to restore an archived product, send a `POST` request to the `/products/{product_id}/unarchive` endpoint. This will reactivate the product and make it available for use again.

    <Card title="Unarchive Product API" icon="code" href="/api-reference/products/unarchive-product">
      View detailed request and response structure in the Unarchive Product API documentation.
    </Card>
  </Accordion>

  <Accordion title="Checkout & fulfillment">
    Create payment or subscription flows from products, and fulfill automatically via benefits and webhooks.

    <CardGroup>
      <Card title="Checkout Sessions" icon="code" href="/developer-resources/checkout-session">
        Create checkout sessions for one‑time or subscription purchases.
      </Card>

      <Card title="Payment Webhooks" icon="code" href="/developer-resources/webhooks/intents/payment">
        React to payment lifecycle events.
      </Card>

      <Card title="Subscription Webhooks" icon="code" href="/developer-resources/webhooks/intents/subscription">
        Handle subscription created, renewed, and canceled events.
      </Card>
    </CardGroup>
  </Accordion>
</AccordionGroup>

## Best practices

* **Start with clarity**: Separate products for each pricing option (Monthly vs Yearly)
* **Use trials thoughtfully**: Pair trials with onboarding to drive activation
* **Automate fulfillment**: Use benefits and webhooks to deliver instantly
* **Tag with metadata**: Store your system IDs for reconciliation

<Check>
  You’re ready to create products and start selling - one‑time, recurring, or by usage.
</Check>


# Purchasing Power Parity
Source: https://docs.dodopayments.com/features/purchasing-power-parity

Learn how to implement Purchasing Power Parity pricing with ParityDeals integration to offer location-based discounts for your customers on Dodo Payments

## Introduction

[ParityDeals](https://www.paritydeals.com/) is a platform that enables automatic pricing optimization based on a customer's geographical location, commonly known as "purchasing power parity" pricing.

With ParityDeals, you can also offer [automatic time-based discounts](https://www.paritydeals.com/features/time-based-discounts/) and [holiday-based promotions](https://www.paritydeals.com/features/holiday-based-discounts/) throughout the year.

<Info>
  While you can't directly embed the ParityDeals banner on a Dodo Payments storefront (as custom scripts aren't supported), you can still implement ParityDeals effectively on your own website or application.
</Info>

## How It Works

When ParityDeals is integrated into your website, eligible visitors will see a banner that includes a location-based discount code they can use at checkout.

<Frame>
  <img alt="ParityDeals discount banner example" />
</Frame>

These discount codes are automatically created and managed by ParityDeals and will appear in your **Dodo Payments Dashboard** under **Sales → Discounts**.

## Step-by-Step Setup Guide

### 1. Sign up on ParityDeals

Visit [app.paritydeals.com](https://app.paritydeals.com/) and create an account.

### 2. Create Deals

After signing in, locate the option to create deals. From the dropdown menu, select:

**→ "Create Deals via Dodo Payments"**

<Frame>
  <img alt="Creating deals via Dodo Payments" />
</Frame>

### 3. Generate a Dodo Payments API Key

Log in to your **Dodo Payments dashboard** and navigate to:

**Developers → API Keys**

Click **"Create New API"** and name it something descriptive like "ParityDeals".

<Frame>
  <img alt="Creating a new API key in Dodo Payments" />
</Frame>

### 4. Connect Your API Key to ParityDeals

Copy the API key you created and paste it into the ParityDeals interface to establish the connection with your Dodo Payments account.

<Frame>
  <img alt="Connecting API key to ParityDeals" />
</Frame>

### 5. Select Products

Once connected, ParityDeals will fetch your Dodo Payments product catalog. Select the products you want to associate with your deals.

<Frame>
  <img alt="Selecting products for ParityDeals" />
</Frame>

### 6. Configure Deal Settings

Enter your website URL and optionally select specific target pages where the discount banner should appear.

Then choose your preferred deal type:

* Location-based deals
* Holiday deals
* Time-based flash deals

<Frame>
  <img alt="Configuring deal settings" />
</Frame>

### 7. Set Country-Based Rules

Select the countries you want to offer localized discounts to and define the discount percentage for each. ParityDeals provides recommended defaults that you can adjust as needed.

<Frame>
  <img alt="Setting country-based discount rules" />
</Frame>

### 8. Customize the Banner

Design your discount banner by:

* Customizing the text
* Selecting colors and layout
* Choosing the banner position (top or bottom of page)

This banner will be displayed to eligible visitors based on your configured rules.

<Frame>
  <img alt="Customizing the discount banner" />
</Frame>

### 9. Add the ParityDeals Script to Your Website

After saving your deal, ParityDeals will generate a script. Add this script to your website code (typically in the `<head>` section).

This script automatically detects visitor locations and displays the appropriate discount banner.

<Frame>
  <img alt="ParityDeals integration script" />
</Frame>

## All Set!

You're now ready to offer:

* **Location-based deals** - Adjust pricing based on purchasing power
* **Countdown/time-sensitive discounts** - Create urgency with limited-time offers
* **Holiday promotions** - Capitalize on seasonal shopping trends

All of these are automated through ParityDeals and work seamlessly with Dodo Payments.

For more detailed information, refer to the [ParityDeals Documentation](https://www.paritydeals.com/docs/) or contact their support team.


# Seat-Based Billing
Source: https://docs.dodopayments.com/features/seat-based-billing

Implement per-user pricing for team software, SaaS products, and enterprise licenses with flexible seat management and proration.

<Info>
  Seat-based billing lets you charge customers based on the number of users, team members, or licenses they need. It's the standard pricing model for team collaboration tools, enterprise software, and B2B SaaS products.
</Info>

<CardGroup>
  <Card title="Implementation Tutorial" icon="code" href="/developer-resources/seat-based-pricing">
    Step-by-step guide with code examples.
  </Card>

  <Card title="Add-ons Documentation" icon="puzzle" href="/features/addons">
    Learn about the add-on system that powers seat-based billing.
  </Card>

  <Card title="Subscription Management" icon="repeat" href="/features/subscription">
    Manage seat-based subscriptions and plan changes.
  </Card>

  <Card title="Webhooks" icon="bell" href="/developer-resources/webhooks/intents/subscription">
    Track seat changes with subscription webhooks.
  </Card>
</CardGroup>

***

## What is Seat-Based Billing?

Seat-based billing (also called per-user or per-seat pricing) charges customers based on the number of users who access your product. Instead of a flat fee, the price scales with team size.

### Common Use Cases

| Industry           | Example              | Pricing Model         |
| ------------------ | -------------------- | --------------------- |
| Team Collaboration | Slack, Notion, Asana | Per active user/month |
| Developer Tools    | GitHub, GitLab, Jira | Per seat/month        |
| CRM Software       | Salesforce, HubSpot  | Per user license      |
| Design Tools       | Figma, Canva         | Per editor seat       |
| Security Software  | 1Password, Okta      | Per user/month        |
| Video Conferencing | Zoom, Teams          | Per host license      |

### Benefits of Seat-Based Pricing

**For Your Business:**

* Revenue scales naturally as customers grow
* Predictable pricing customers can budget for
* Clear upgrade path from individual to team to enterprise
* Higher lifetime value as teams expand

**For Your Customers:**

* Pay only for what they use
* Easy to understand and forecast costs
* Flexibility to add/remove users as needed
* Fair pricing that matches team size

***

## How Seat-Based Billing Works in Dodo Payments

Dodo Payments implements seat-based billing using the **Add-ons** system. Here's how it works:

### Architecture Overview

A Team Pro subscription costs \$99/month and includes 5 seats. If you have more than 5 users, you pay an additional \$15/month for each extra seat.

For example, if your team needs 15 seats:

* Base Plan: \$99/month (includes 5 seats)
* Add-ons: 10 extra seats × \$15/month = \$150/month
* Total monthly cost: \$99 + \$150 = \$249 for 15 seats

### Key Components

| Component    | Purpose                               | Example                                     |
| ------------ | ------------------------------------- | ------------------------------------------- |
| Base Product | Core subscription with included seats | "Team Plan - \$99/month (5 seats included)" |
| Seat Add-on  | Per-seat charge for additional users  | "Extra Seat - \$15/month each"              |
| Quantity     | Number of additional seats purchased  | 10 extra seats                              |

***

## Pricing Strategies

Choose the seat-based pricing strategy that fits your business:

### Strategy 1: Base + Per-Seat Add-on

Include a set number of seats in the base plan, charge for additional seats.

**Example:**

```
Starter Plan: $49/month
├── Includes: 3 seats
├── Extra seats: $10/month each
└── 8 total seats = $49 + (5 × $10) = $99/month
```

**Best for:** Products where small teams can function with the base offering.

### Strategy 2: Pure Per-Seat Pricing

Charge a flat rate per seat with no base fee.

**Example:**

```
Per User: $12/month
├── 5 users = $60/month
├── 20 users = $240/month
└── 100 users = $1,200/month
```

**Implementation:** Set base plan price to \$0, use only the seat add-on.

**Best for:** Simple, transparent pricing; usage-based models.

### Strategy 3: Tiered Seat Pricing

Different base plans with different per-seat rates.

**Example:**

```
Starter: $0/month base + $15/seat
├── Lower features, higher per-seat cost

Professional: $99/month base + $10/seat
├── More features, lower per-seat cost

Enterprise: $499/month base + $7/seat
└── All features, volume discount on seats
```

**Implementation:** Create separate products for each tier with different add-on prices.

**Best for:** Encouraging upgrades to higher tiers; enterprise sales.

### Strategy 4: Seat Bundles

Sell seats in packs rather than individually.

**Example:**

```
5-Seat Pack: $50/month ($10/seat)
10-Seat Pack: $80/month ($8/seat)
25-Seat Pack: $175/month ($7/seat)
```

**Implementation:** Create multiple add-ons for different pack sizes.

**Best for:** Simplifying purchasing decisions; encouraging larger commitments.

***

## Setting Up Seat-Based Billing

### Step 1: Plan Your Pricing

Before implementation, define your pricing structure:

<Steps>
  <Step title="Define Base Plan">
    Decide what's included in the base subscription:

    * Base price (can be \$0 for pure per-seat)
    * Number of included seats
    * Features available at this tier
  </Step>

  <Step title="Set Seat Pricing">
    Determine the per-seat add-on cost:

    * Price per additional seat
    * Any volume discounts (via multiple add-ons)
    * Maximum seats allowed (if applicable)
  </Step>

  <Step title="Consider Billing Frequency">
    Align seat pricing with your billing cycle:

    * Monthly subscriptions → monthly seat charges
    * Annual subscriptions → annual seat charges (often discounted)
  </Step>
</Steps>

### Step 2: Create the Seat Add-on

In your Dodo Payments dashboard:

1. Navigate to **Products** → **Add-Ons**
2. Click **Create Add-On**
3. Configure the add-on:

| Field        | Value                                       | Notes                           |
| ------------ | ------------------------------------------- | ------------------------------- |
| Name         | "Additional Seat" or "Team Member"          | Clear, user-friendly name       |
| Description  | "Add another team member to your workspace" | Explain what customers get      |
| Price        | Your per-seat price                         | e.g., \$10.00                   |
| Currency     | Match your base product                     | Must be the same currency       |
| Tax Category | Same as base product                        | Ensures consistent tax handling |

<Tip>
  Create descriptive add-on names that make sense on invoices. "Additional Team Seat" is clearer than "Seat Add-on" for customers reviewing their bills.
</Tip>

### Step 3: Create the Base Subscription

Create your subscription product:

1. Navigate to **Products** → **Create Product**
2. Select **Subscription**
3. Configure pricing and details
4. In the **Add-Ons** section, attach your seat add-on

### Step 4: Attach Add-on to Product

Link the seat add-on to your subscription:

1. Edit your subscription product
2. Scroll to **Add-Ons** section
3. Click **Add Add-Ons**
4. Select your seat add-on
5. Save changes

<Check>
  Your subscription product now supports seat-based pricing. Customers can purchase any quantity of additional seats during checkout.
</Check>

***

## Managing Seats

### Adding Seats to New Subscriptions

When creating a checkout session, specify the seat quantity:

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{
    product_id: 'prod_team_plan',
    quantity: 1,
    addons: [{
      addon_id: 'addon_seat',
      quantity: 10  // 10 additional seats
    }]
  }],
  customer: { email: 'admin@company.com' },
  return_url: 'https://yourapp.com/success'
});
```

### Changing Seat Count on Existing Subscriptions

Use the Change Plan API to adjust seats:

```typescript theme={null}
// Add 5 more seats to existing subscription
await client.subscriptions.changePlan('sub_123', {
  product_id: 'prod_team_plan',
  quantity: 1,
  proration_billing_mode: 'prorated_immediately',
  addons: [{
    addon_id: 'addon_seat',
    quantity: 15  // New total: 15 additional seats
  }]
});
```

### Removing Seats

To reduce seat count, specify the lower quantity:

```typescript theme={null}
// Reduce from 15 to 8 additional seats
await client.subscriptions.changePlan('sub_123', {
  product_id: 'prod_team_plan',
  quantity: 1,
  proration_billing_mode: 'difference_immediately',
  addons: [{
    addon_id: 'addon_seat',
    quantity: 8  // Reduced to 8 additional seats
  }]
});
```

### Removing All Additional Seats

Pass an empty addons array to remove all add-ons:

```typescript theme={null}
// Remove all additional seats, keep only base plan seats
await client.subscriptions.changePlan('sub_123', {
  product_id: 'prod_team_plan',
  quantity: 1,
  proration_billing_mode: 'difference_immediately',
  addons: []  // Removes all add-ons
});
```

***

## Proration for Seat Changes

When customers add or remove seats mid-cycle, proration determines how they're billed.

### Proration Modes

| Mode                     | Adding Seats                                | Removing Seats                    |
| ------------------------ | ------------------------------------------- | --------------------------------- |
| `prorated_immediately`   | Charge for remaining days in cycle          | Credit for unused days            |
| `difference_immediately` | Charge full seat price                      | Credit applied to future renewals |
| `full_immediately`       | Charge full seat price, reset billing cycle | No credit                         |

### Proration Examples

**Scenario: 15-day billing cycle remaining, adding 5 seats at \$10/seat**

<Tabs>
  <Tab title="prorated_immediately">
    ```
    Prorated charge = ($10 × 5 seats) × (15 days / 30 days)
                    = $50 × 0.5
                    = $25 immediate charge
    ```

    Customer pays \$25 now, then \$50/month on renewal.
  </Tab>

  <Tab title="difference_immediately">
    ```
    Immediate charge = $10 × 5 seats = $50
    ```

    Customer pays full \$50 now, regardless of cycle position.
  </Tab>

  <Tab title="full_immediately">
    ```
    Immediate charge = Full subscription + add-ons
    Billing cycle resets to today
    ```

    Customer pays full amount, new billing cycle starts.
  </Tab>
</Tabs>

### Preview Before Changing

Always preview proration before making changes:

```typescript theme={null}
const preview = await client.subscriptions.previewChangePlan('sub_123', {
  product_id: 'prod_team_plan',
  quantity: 1,
  proration_billing_mode: 'prorated_immediately',
  addons: [{ addon_id: 'addon_seat', quantity: 20 }]
});

console.log('Immediate charge:', preview.immediate_charge.summary);
// Show customer: "Adding 5 seats will cost $25 today"
```

***

## Tracking Seats with Webhooks

Monitor seat changes by listening to subscription webhooks:

### Relevant Events

| Event                       | When Triggered             | Use Case                      |
| --------------------------- | -------------------------- | ----------------------------- |
| `subscription.active`       | New subscription activated | Provision initial seats       |
| `subscription.plan_changed` | Seats added/removed        | Update seat count in your app |
| `subscription.renewed`      | Subscription renewed       | Confirm seat count unchanged  |
| `subscription.cancelled`    | Subscription cancelled     | Deprovision all seats         |

### Webhook Handler Example

```typescript theme={null}
app.post('/webhooks/dodo', async (req, res) => {
  const event = req.body;

  switch (event.type) {
    case 'subscription.active':
      // New subscription - provision seats
      const seats = calculateTotalSeats(event.data);
      await provisionSeats(event.data.customer_id, seats);
      break;

    case 'subscription.plan_changed':
      // Seats changed - update access
      const newSeats = calculateTotalSeats(event.data);
      await updateSeatCount(event.data.subscription_id, newSeats);
      break;

    case 'subscription.cancelled':
      // Subscription cancelled - deprovision
      await deprovisionAllSeats(event.data.subscription_id);
      break;
  }

  res.json({ received: true });
});

function calculateTotalSeats(subscriptionData) {
  const baseSeats = 5;  // Included in plan
  const addonSeats = subscriptionData.addons?.reduce(
    (total, addon) => total + addon.quantity, 0
  ) || 0;
  return baseSeats + addonSeats;
}
```

***

## Enforcing Seat Limits

Your application must enforce seat limits. Dodo Payments tracks billing, but you control access.

### Enforcement Strategies

<Tabs>
  <Tab title="Hard Limit">
    Strictly prevent adding users beyond the seat count.

    ```typescript theme={null}
    async function inviteUser(teamId: string, email: string) {
      const team = await getTeam(teamId);
      const subscription = await getSubscription(team.subscriptionId);
      const totalSeats = calculateTotalSeats(subscription);
      const usedSeats = await countTeamMembers(teamId);

      if (usedSeats >= totalSeats) {
        throw new Error('No seats available. Please upgrade your plan.');
      }

      await sendInvitation(teamId, email);
    }
    ```
  </Tab>

  <Tab title="Soft Limit with Warning">
    Allow exceeding with a warning and grace period.

    ```typescript theme={null}
    async function inviteUser(teamId: string, email: string) {
      const team = await getTeam(teamId);
      const { totalSeats, usedSeats } = await getSeatInfo(team);

      if (usedSeats >= totalSeats) {
        // Allow but flag for billing
        await flagOverage(teamId, usedSeats - totalSeats + 1);
        await notifyAdmin(team.adminEmail, 'You have exceeded your seat limit');
      }

      await sendInvitation(teamId, email);
    }
    ```
  </Tab>

  <Tab title="Auto-Upgrade">
    Automatically add seats when limit is reached.

    ```typescript theme={null}
    async function inviteUser(teamId: string, email: string) {
      const team = await getTeam(teamId);
      const { totalSeats, usedSeats, subscriptionId } = await getSeatInfo(team);

      if (usedSeats >= totalSeats) {
        // Automatically add a seat
        await client.subscriptions.changePlan(subscriptionId, {
          product_id: team.productId,
          quantity: 1,
          proration_billing_mode: 'prorated_immediately',
          addons: [{ addon_id: 'addon_seat', quantity: totalSeats - baseSeats + 1 }]
        });

        await notifyAdmin(team.adminEmail, 'A new seat was added to your plan');
      }

      await sendInvitation(teamId, email);
    }
    ```
  </Tab>
</Tabs>

***

## Advanced Patterns

### Different Seat Types

Offer different seat types with different pricing:

```
Full Seats: $20/month - Full access to all features
View-Only Seats: $5/month - Read-only access
Guest Seats: $0/month - Limited external collaborator access
```

**Implementation:** Create separate add-ons for each seat type.

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{
    product_id: 'prod_team_plan',
    quantity: 1,
    addons: [
      { addon_id: 'addon_full_seat', quantity: 10 },
      { addon_id: 'addon_viewer_seat', quantity: 25 },
      { addon_id: 'addon_guest_seat', quantity: 50 }
    ]
  }]
});
```

### Annual Seat Discounts

Offer discounted annual seat pricing:

```
Monthly: $15/seat/month
Annual: $12/seat/month (20% savings)
```

**Implementation:** Create separate products for monthly and annual plans with different add-on prices.

### Minimum Seat Requirements

Require a minimum number of seats for certain plans:

```typescript theme={null}
async function validateSeatCount(planId: string, seatCount: number) {
  const minimums = {
    'prod_starter': 1,
    'prod_team': 5,
    'prod_enterprise': 25
  };

  if (seatCount < minimums[planId]) {
    throw new Error(`${planId} requires at least ${minimums[planId]} seats`);
  }
}
```

***

## Best Practices

### Pricing Best Practices

* **Clear Communication**: Show per-seat pricing prominently on your pricing page
* **Included Seats**: Consider including a few seats in the base price to reduce friction
* **Volume Discounts**: Offer lower per-seat rates for larger teams to win enterprise deals
* **Annual Incentives**: Discount annual plans to improve cash flow and retention

### Technical Best Practices

* **Cache Seat Counts**: Cache subscription seat counts locally to avoid API calls on every request
* **Sync Regularly**: Periodically sync your local seat count with Dodo Payments via API
* **Handle Failures**: If a seat change fails, show clear error messages and retry options
* **Audit Trail**: Log all seat changes for billing disputes and compliance

### User Experience Best Practices

* **Real-Time Feedback**: Show immediate cost impact when adjusting seats
* **Confirmation Steps**: Require confirmation before billing changes
* **Proration Transparency**: Clearly explain prorated charges before applying
* **Easy Downgrades**: Don't make it difficult to reduce seats (it builds trust)

***

## Troubleshooting

<AccordionGroup>
  <Accordion title="Seat count mismatch between app and billing">
    **Symptom**: Your app shows a different seat count than the subscription.

    **Causes**:

    * Webhook not received or processed
    * Race condition during seat change
    * Cached data not updated

    **Solutions**:

    1. Implement webhook handlers for `subscription.plan_changed`
    2. Add a "Sync with billing" button that fetches current subscription
    3. Set cache TTL to ensure regular refresh
  </Accordion>

  <Accordion title="Proration charges unexpected">
    **Symptom**: Customer confused by mid-cycle charge amount.

    **Causes**:

    * Proration mode not communicated clearly
    * Customer didn't see preview before confirming

    **Solutions**:

    1. Always use `previewChangePlan` before making changes
    2. Show clear breakdown: "Adding X seats = \$Y today (prorated for Z days)"
    3. Document your proration policy in help center
  </Accordion>

  <Accordion title="Add-on not appearing in checkout">
    **Symptom**: Seat add-on not available during checkout.

    **Causes**:

    * Add-on not attached to product
    * Add-on archived or deleted
    * Currency mismatch between product and add-on

    **Solutions**:

    1. Verify add-on is attached in product settings
    2. Check add-on status in Add-Ons dashboard
    3. Ensure currencies match exactly
  </Accordion>

  <Accordion title="Cannot reduce seats below current usage">
    **Symptom**: Customer wants to reduce seats but has users assigned.

    **Solutions**:

    1. Show which users must be removed before reducing seats
    2. Implement a workflow: Remove users → Reduce seats
    3. Consider a grace period before enforcing seat reduction
  </Accordion>
</AccordionGroup>

***

## Related Documentation

<CardGroup>
  <Card title="Seat-Based Pricing Tutorial" icon="code" href="/developer-resources/seat-based-pricing">
    Complete implementation guide with code.
  </Card>

  <Card title="Add-ons" icon="puzzle" href="/features/addons">
    Understand the add-on system in depth.
  </Card>

  <Card title="Plan Changes & Proration" icon="arrows-rotate" href="/developer-resources/subscription-upgrade-downgrade">
    Handle subscription modifications.
  </Card>

  <Card title="Subscription Webhooks" icon="bell" href="/developer-resources/webhooks/intents/subscription">
    Track subscription events.
  </Card>
</CardGroup>


# Storefront
Source: https://docs.dodopayments.com/features/storefront

The Storefront Feature allows you to create a simple, branded, and mobile-friendly online store where you can showcase both One-Time Payment products and Subscription products. This feature eliminates the complexity of building an entire website, enabling you to quickly offer your products or services online without additional web development efforts.

<Frame>
  <img alt="Storefront Cover Image" />
</Frame>

## Key Highlights of the Feature

1. **Branded Storefront**
   * Customize your store with a Store Name, Logo, and Cover Image.
   * Easily share your store URL (e.g., `store.dodopayments.com/your-store`).
2. **Product Segregation**
   * Automatically organizes your products into One-Time Payment and Subscription sections.
3. **Simple Checkout Flow**
   * Customers can select a product & quantity and click **“Buy Now”** to be redirected to Dodopayments checkout.
4. **Publish/Unpublish**
   * Control which products appear on your store: quickly publish or unpublish within the Merchant Dashboard.
5. **No Extra Setup**
   * You don’t need a separate CMS; all product management happens in your Merchant Dashboard, where you already manage pricing, descriptions, and subscription details.
6. **Mobile-Friendly**
   * The storefront layout is responsive, ensuring a seamless shopping experience on phones, tablets, and desktops.

## Store Front Setup

Below is the step-by-step process for merchants to set up and manage their storefront:

<img />

### Accessing Your Storefront Settings

1. Open Business Section → Select Store Front

### Store Branding

1. **Store Name**: Enter the public-facing name of your store. This appears prominently at the top of your storefront.
2. **Logo**: Upload an image (e.g., PNG or JPG) for your brand logo.
3. **Cover Image**: Select or upload a banner/cover image that appear on the storefront homepage.
4. **Store URL**:
   * Typically auto-generated based on your business name (e.g., `business.dodopayments.com/my-store`).
   * You can edit this URL if the system supports custom slugs.
5. **Products:** You can select the Products you want to display on your storefront

### Saving & Viewing Your Store

<img />

1. **Click Publish**: Click Publish to confirm your storefront setup and product publishing decisions.
2. **Preview Store**: You can preview your storefront at the generated URL.
3. **Share URL**: Once satisfied, share the link with your customers via email, social media, or your website.

### Test Mode

<img />

Test Mode and Live Mode have separate storefronts. You can see the test mode indicator on the top of your website and store front generated through test mode as well.

Test Mode is for you try out the user flow and purchase experience on the store. Please share the live mode Store link with your users to facilitate real purchases

## Customer Experience

<img />

### Landing on the Storefront

* **Visual Branding**: Customers see your store name, logo, and cover image immediately.
* **Organized Products**: Two categories are displayed: One-Time Payment and Subscription.

### Browsing Products

* **Product Cards**: Each product shows a name, description, and price. Description can be viewed by clicking the i icon on the bottom right of the card.
* **Quantity Selection**: Customers can pick how many items they want to buy.
* **Subscription Frequency & Trial**: Subscription products explicitly state billing frequency (e.g., monthly) and if a trial is available (e.g., 7-day free trial).

<img />

### Buying Process

1. **Select “Buy Now”**: Once ready, the customer clicks “Purchase” for the desired product, selects quantity and clicks “Buy Now”
2. **Redirect to Dodopayments checkout**:
   * The customer will be taken to the dodo payments checkout
   * The customer completes the secure checkout flow on Dodopayments.
3. **Confirmation**:
   * After successful payment, Dodopayments shows a confirmation.
   * Optionally, the customer may be redirected back to a “Thank You” page on your storefront based on the redirect URL entered.


# Subscriptions
Source: https://docs.dodopayments.com/features/subscription

Offer recurring billing for memberships, SaaS, or services with flexible cycles, trials, proration, add-ons, and on‑demand charges.

<Info>
  Subscriptions let you sell ongoing access with automated renewals. Use flexible billing cycles, free trials, plan changes, and add‑ons to tailor pricing for each customer.
</Info>

<CardGroup>
  <Card title="Upgrade & Downgrade" icon="repeat" href="/developer-resources/subscription-upgrade-downgrade">
    Control plan changes with proration and quantity updates.
  </Card>

  <Card title="On‑Demand Subscriptions" icon="bolt" href="/developer-resources/ondemand-subscriptions">
    Authorize a mandate now and charge later with custom amounts.
  </Card>

  <Card title="Customer Portal" icon="id-card" href="/features/customer-portal">
    Let customers manage plans, billing, and cancellations.
  </Card>

  <Card title="Subscription Webhooks" icon="code" href="/developer-resources/webhooks/intents/subscription">
    React to lifecycle events like created, renewed, and canceled.
  </Card>
</CardGroup>

## What Are Subscriptions?

Subscriptions are recurring products customers purchase on a schedule. They’re ideal for:

* **SaaS licenses**: Apps, APIs, or platform access
* **Memberships**: Communities, programs, or clubs
* **Digital content**: Courses, media, or premium content
* **Support plans**: SLAs, success packages, or maintenance

## Key Benefits

* **Predictable revenue**: Recurring billing with automated renewals
* **Flexible cycles**: Monthly, annual, custom intervals, and trials
* **Plan agility**: Proration for upgrades and downgrades
* **Add‑ons and seats**: Attach optional, quantifiable upgrades
* **Seamless checkout**: Hosted checkout and customer portal
* **Developer-first**: Clear APIs for creation, changes, and usage tracking

## Creating Subscriptions

Create subscription products in your Dodo Payments dashboard, then sell them through checkout or your API. Separating products from active subscriptions lets you version pricing, attach add‑ons, and track performance independently.

### Subscription product creation

Configure the fields in the dashboard to define how your subscription sells, renews, and bills. The sections below map directly to what you see in the creation form.

#### Product details

* **Product Name** (required): The display name shown in checkout, customer portal, and invoices.
* **Product Description** (required): A clear value statement that appears in checkout and invoices.
* **Product Image** (required): PNG/JPG/WebP up to 3 MB. Used on checkout and invoices.
* **Brand**: Associate the product with a specific brand for theming and emails.
* **Tax Category** (required): Choose the category (for example, SaaS) to determine tax rules.

<Tip>
  Pick the most accurate tax category to ensure correct tax collection per region.
</Tip>

#### Pricing

* **Pricing Type**: Choose <b>Subscription</b> (this guide). Alternatives are Single Payment and Usage Based Billing.
* **Price** (required): Base recurring price with currency.
* **Discount Applicable (%)**: Optional percentage discount applied to the base price; reflected in checkout and invoices.
* **Repeat payment every** (required): Interval for renewals, e.g., every 1 Month. Select the cadence (months or years) and quantity.
* **Subscription Period** (required): Total term for which the subscription remains active (e.g., 10 Years). After this period ends, renewals stop unless extended.
* **Trial Period Days** (required): Set trial length in days. Use 0 to disable trials. The first charge occurs automatically when the trial ends.
* **Select add‑on**: Attach up to 10 add‑ons that customers can purchase alongside the base plan.

<Warning>
  Changing pricing on an active product affects new purchases. Existing subscriptions follow your plan‑change and proration settings.
</Warning>

<Info>
  Add‑ons are ideal for quantifiable extras such as seats or storage. You can control allowed quantities and proration behavior when customers change them.
</Info>

#### Advanced settings

* **Tax Inclusive Pricing**: Display prices inclusive of applicable taxes. Final tax calculation still varies by customer location.
* **Generate license keys**: Issue a unique key to each customer after purchase. See the <a href="/features/license-keys">License Keys</a> guide.
* **Digital Product Delivery**: Deliver files or content automatically after purchase. Learn more in <a href="/features/digital-product-delivery">Digital Product Delivery</a>.
* **Metadata**: Attach custom key–value pairs for internal tagging or client integrations. See <a href="/api-reference/metadata">Metadata</a>.

<Tip>
  Use metadata to store identifiers from your system (e.g., accountId) so you can reconcile events and invoices later.
</Tip>

## Subscription Trials

Trials let customers access subscriptions without immediate payment. The first charge occurs automatically when the trial ends.

### Configuring Trials

Set **Trial Period Days** in the product pricing section (use `0` to disable). You can override this when creating subscriptions:

```typescript theme={null}
// Via subscription creation
const subscription = await client.subscriptions.create({
  customer_id: 'cus_123',
  product_id: 'prod_monthly',
  trial_period_days: 14  // Overrides product's trial period
});

// Via checkout session
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_monthly', quantity: 1 }],
  subscription_data: { trial_period_days: 14 }
});
```

<Warning>
  The `trial_period_days` value must be between 0 and 10,000 days.
</Warning>

### Detecting Trial Status

<Warning>
  Currently, there is no direct field to detect trial status. The following is a workaround that requires querying payments, which is inefficient. We are working on a more efficient solution.
</Warning>

To determine if a subscription is in trial, retrieve the list of payments for the subscription. If there is exactly one payment with amount 0, the subscription is in trial period:

```typescript theme={null}
const subscription = await client.subscriptions.retrieve('sub_123');
const payments = await client.payments.list({
  subscription_id: subscription.subscription_id
});

// Check if subscription is in trial
const isInTrial = payments.items.length === 1 && 
                  payments.items[0].total_amount === 0;
```

### Updating Trial Period

Extend the trial by updating `next_billing_date`:

```typescript theme={null}
await client.subscriptions.update('sub_123', {
  next_billing_date: '2025-02-15T00:00:00Z'  // New trial end date
});
```

<Warning>
  You cannot set `next_billing_date` to a past time. The date must be in the future.
</Warning>

## Subscription Plan Changes

Plan changes let you upgrade or downgrade subscriptions, adjust quantities, or migrate to different products. Each change triggers an immediate charge based on the proration mode you select.

<Tip>
  You can change subscription plans and update the next billing date directly from the Dodo Payments dashboard. This provides a quick way to adjust subscriptions for customer support requests, promotional upgrades, or plan migrations without making API calls.
</Tip>

<Tip>
  **Enable self-service plan changes:** Want customers to upgrade or downgrade their own subscriptions via the Customer Portal? Add your subscription products to a Product Collection and enable "Allow Subscription Updates" in your Subscription Settings.
</Tip>

<Card title="Product Collections" icon="layer-group" href="/features/product-collections">
  Group related products into collections to enable seamless upgrade/downgrade paths in the Customer Portal.
</Card>

### Proration Modes

Choose how customers are billed when changing plans:

#### `prorated_immediately`

Charges prorated amount based on remaining time in the current billing cycle. Best for fair billing that accounts for unused time.

```typescript theme={null}
await client.subscriptions.changePlan('sub_123', {
  product_id: 'prod_pro',
  quantity: 1,
  proration_billing_mode: 'prorated_immediately'
});
```

#### `difference_immediately`

Charges the price difference immediately (upgrade) or adds credit for future renewals (downgrade). Best for simple upgrade/downgrade scenarios.

```typescript theme={null}
// Upgrade: charges $50 (difference between $30 and $80)
// Downgrade: credits remaining value, auto-applied to renewals
await client.subscriptions.changePlan('sub_123', {
  product_id: 'prod_pro',
  quantity: 1,
  proration_billing_mode: 'difference_immediately'
});
```

<Info>
  Credits from downgrades using `difference_immediately` are subscription-scoped and auto-applied to future renewals. They're distinct from <a href="/features/customer-credit">Customer Credits</a>.
</Info>

#### `full_immediately`

Charges full new plan amount immediately, ignoring remaining time. Best for resetting billing cycles.

```typescript theme={null}
await client.subscriptions.changePlan('sub_123', {
  product_id: 'prod_monthly',
  quantity: 1,
  proration_billing_mode: 'full_immediately'
});
```

### Changing Plans with Add-ons

Modify add-ons when changing plans. Add-ons are included in proration calculations:

```typescript theme={null}
await client.subscriptions.changePlan('sub_123', {
  product_id: 'prod_pro',
  quantity: 1,
  proration_billing_mode: 'difference_immediately',
  addons: [{ addon_id: 'addon_extra_seats', quantity: 2 }]  // Add add-ons
  // addons: []  // Empty array removes all existing add-ons
});
```

<Info>
  Plan changes trigger immediate charges. Failed charges may move the subscription to `on_hold` status. Track changes via `subscription.plan_changed` webhook events.
</Info>

### Previewing Plan Changes

Before committing to a plan change, preview the exact charge and resulting subscription:

```typescript theme={null}
const preview = await client.subscriptions.previewChangePlan('sub_123', {
  product_id: 'prod_pro',
  quantity: 1,
  proration_billing_mode: 'prorated_immediately'
});

// Show customer the charge before confirming
console.log('You will be charged:', preview.immediate_charge.summary);
```

<Card title="Preview Change Plan API" icon="eye" href="/api-reference/subscriptions/preview-change-plan">
  Preview plan changes before committing to them.
</Card>

## Subscription States

Subscriptions can be in different states throughout their lifecycle:

* **`active`**: Subscription is active and will renew automatically
* **`on_hold`**: Subscription is paused due to failed payment. Payment method update required to reactivate
* **`cancelled`**: Subscription is cancelled and will not renew
* **`expired`**: Subscription has reached its end date
* **`pending`**: Subscription is being created or processed

### On Hold State

A subscription enters `on_hold` state when:

* A renewal payment fails (insufficient funds, expired card, etc.)
* A plan change charge fails
* Payment method authorization fails

<Warning>
  When a subscription is in `on_hold` state, it will not renew automatically. You must update the payment method to reactivate the subscription.
</Warning>

### Reactivating from On Hold

To reactivate a subscription from `on_hold` state, update the payment method. This automatically:

1. Creates a charge for remaining dues
2. Generates an invoice
3. Processes the payment using the new payment method
4. Reactivates the subscription to `active` state upon successful payment

```typescript theme={null}
// Reactivate subscription from on_hold
const response = await client.subscriptions.updatePaymentMethod('sub_123', {
  type: 'new',
  return_url: 'https://example.com/return'
});

// For on_hold subscriptions, a charge is automatically created
if (response.payment_id) {
  console.log('Charge created:', response.payment_id);
  // Redirect customer to response.payment_link to complete payment
  // Monitor webhooks for payment.succeeded and subscription.active
}
```

<Info>
  After successfully updating the payment method for an `on_hold` subscription, you'll receive `payment.succeeded` followed by `subscription.active` webhook events.
</Info>

## API Management

<AccordionGroup>
  <Accordion title="Create subscriptions">
    Use `POST /subscriptions` to create subscriptions programmatically from products, with optional trials and add‑ons.

    <Card title="API Reference" icon="code" href="/api-reference/subscriptions/post-subscriptions">
      View the create subscription API.
    </Card>
  </Accordion>

  <Accordion title="Update subscriptions">
    Use `PATCH /subscriptions/{id}` to update quantities, cancel at period end, or modify metadata.

    <Card title="API Reference" icon="code" href="/api-reference/subscriptions/patch-subscriptions">
      Learn how to update subscription details.
    </Card>
  </Accordion>

  <Accordion title="Change plans (proration)">
    Change the active product and quantities with proration controls.

    <Card title="API Reference" icon="code" href="/api-reference/subscriptions/change-plan">
      Review plan change options.
    </Card>
  </Accordion>

  <Accordion title="On‑demand charges">
    For on‑demand subscriptions, charge specific amounts on demand.

    <Card title="API Reference" icon="code" href="/api-reference/subscriptions/create-charge">
      Charge an on‑demand subscription.
    </Card>
  </Accordion>

  <Accordion title="List and retrieve">
    Use `GET /subscriptions` to list all subscriptions and `GET /subscriptions/{id}` to retrieve one.

    <Card title="API Reference" icon="code" href="/api-reference/subscriptions/get-subscriptions">
      Browse listing and retrieval APIs.
    </Card>
  </Accordion>

  <Accordion title="Usage history">
    Fetch recorded usage for metered or hybrid pricing models.

    <Card title="API Reference" icon="code" href="/api-reference/subscriptions/get-usage-history">
      See usage history API.
    </Card>
  </Accordion>

  <Accordion title="Update payment method">
    Update the payment method for a subscription. For active subscriptions, this updates the payment method for future renewals. For subscriptions in `on_hold` state, this reactivates the subscription by creating a charge for remaining dues.

    <Card title="API Reference" icon="code" href="/api-reference/subscriptions/update-payment-method">
      Learn how to update payment methods and reactivate subscriptions.
    </Card>
  </Accordion>
</AccordionGroup>

## Common Use Cases

* **SaaS and APIs**: Tiered access with add‑ons for seats or usage
* **Content and media**: Monthly access with introductory trials
* **B2B support plans**: Annual contracts with premium support add‑ons
* **Tools and plugins**: License keys and versioned releases

## Integration Examples

### Checkout Sessions (subscriptions)

When creating checkout sessions, include your subscription product and optional add‑ons:

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_subscription',
      quantity: 1
    }
  ]
});
```

### Plan changes with proration

Upgrade or downgrade a subscription and control proration behavior:

```typescript theme={null}
await client.subscriptions.changePlan('sub_123', {
  product_id: 'prod_new',
  quantity: 1,
  proration_billing_mode: 'difference_immediately'
});
```

### Cancel at period end

Schedule a cancellation without immediate termination of access:

```typescript theme={null}
await client.subscriptions.update('sub_123', {
  cancel_at_period_end: true
});
```

### On‑demand subscriptions

Create an on‑demand subscription and charge later as needed:

```typescript theme={null}
const onDemand = await client.subscriptions.create({
  customer_id: 'cus_123',
  product_id: 'prod_on_demand',
  on_demand: true
});

await client.subscriptions.createCharge(onDemand.id, {
  amount: 4900,
  currency: 'USD',
  description: 'Extra usage for September'
});
```

### Update payment method for active subscription

Update the payment method for an active subscription:

```typescript theme={null}
// Update with new payment method
const response = await client.subscriptions.updatePaymentMethod('sub_123', {
  type: 'new',
  return_url: 'https://example.com/return'
});

// Or use existing payment method
await client.subscriptions.updatePaymentMethod('sub_123', {
  type: 'existing',
  payment_method_id: 'pm_abc123'
});
```

### Reactivate subscription from on\_hold

Reactivate a subscription that went on hold due to failed payment:

```typescript theme={null}
// Update payment method - automatically creates charge for remaining dues
const response = await client.subscriptions.updatePaymentMethod('sub_123', {
  type: 'new',
  return_url: 'https://example.com/return'
});

if (response.payment_id) {
  // Charge created for remaining dues
  // Redirect customer to response.payment_link
  // Monitor webhooks: payment.succeeded → subscription.active
}
```

## Subscriptions with RBI-Compliant Mandates

UPI and Indian card subscriptions operate under RBI (Reserve Bank of India) regulations with specific mandate requirements:

### Mandate Limits

The mandate type and amount depend on your subscription's recurring charge:

* **Charges below Rs 15,000:** We create an on-demand mandate for Rs 15,000 INR. The subscription amount is charged periodically according to your subscription frequency, up to the mandate limit.
* **Charges Rs 15,000 or above:** We create a subscription mandate (or on-demand mandate) for the exact subscription amount.

For detailed information about RBI-compliant mandates for Indian payment methods, see the <a href="/features/payment-methods/india">India Payment Methods</a> page.

### Upgrade and Downgrade Considerations

**Important:** When upgrading or downgrading subscriptions, carefully consider the mandate limits:

* If an upgrade/downgrade results in a charge amount that exceeds Rs 15,000 and goes beyond the existing on-demand payment limit, the transaction charge may fail.
* In such cases, the customer may need to update their payment method or change the subscription again to establish a new mandate with the correct limit.

### Authorization for High-Value Charges

For subscription charges of Rs 15,000 or more:

* The customer will be prompted by their bank to authorize the transaction.
* If the customer fails to authorize the transaction, the transaction will fail and the subscription will be put on hold.

### 48-Hour Processing Delay

**Processing Timeline:** Recurring charges on Indian cards and UPI subscriptions follow a unique processing pattern:

* Charges are **initiated** on the scheduled date according to your subscription frequency.
* The actual **deduction** from the customer's account occurs only after **48 hours** from payment initiation.
* This 48-hour window may extend up to **2-3 additional hours** depending on bank API responses.

### Mandate Cancellation Window

During the 48-hour processing window:

* Customers can cancel the mandate via their banking apps.
* If a customer cancels the mandate during this period, the subscription will remain **active** (this is an edge case specific to Indian card and UPI AutoPay subscriptions).
* However, the actual deduction may fail, and in that case, we will put the subscription **on hold**.

**Edge Case Handling:** If you provide benefits, credits, or subscription usage to customers immediately upon charge initiation, you need to handle this 48-hour window appropriately in your application. Consider:

* Delaying benefit activation until payment confirmation
* Implementing grace periods or temporary access
* Monitoring subscription status for mandate cancellations
* Handling subscription hold states in your application logic

<Tip>
  Monitor subscription webhooks to track payment status changes and handle edge cases where mandates are cancelled during the 48-hour window.
</Tip>

## Best Practices

* **Start with clear tiers**: 2–3 plans with obvious differences
* **Communicate pricing**: Show totals, proration, and next renewal
* **Use trials thoughtfully**: Convert with onboarding, not just time
* **Leverage add‑ons**: Keep base plans simple and upsell extras
* **Test changes**: Validate plan changes and proration in test mode

<Info>
  Subscriptions are a flexible foundation for recurring revenue. Start simple, test thoroughly, and iterate based on adoption, churn, and expansion metrics.
</Info>


# Tax Inclusive Pricing
Source: https://docs.dodopayments.com/features/tax-inclusive-pricing

Show final, tax‑inclusive prices upfront. Dodo calculates tax by location and clearly breaks it out at checkout and on invoices.

## What Is Tax Inclusive Pricing?

Tax Inclusive Pricing lets you embed applicable taxes directly in your displayed product price. Customers see one final amount upfront for a more transparent, conversion‑friendly experience. At checkout, Dodo calculates the tax‑exclusive portion and tax amount from the displayed price based on customer location, and clearly breaks them out on the invoice.

<Info>
  Final tax still varies by customer location and tax category. Checkout and invoices show the calculated tax portion derived from the displayed price.
</Info>

## Key Benefits

* **Clarity for customers**: One final price displayed upfront
* **Compliance by region**: Tax is calculated per location and broken out
* **Accurate invoicing**: Invoices show net amount and tax derived from price
* **Conversion friendly**: Reduced surprises at checkout

## Product Setup

Create or edit a product in your dashboard, then enable tax‑inclusive pricing under pricing settings.

#### Pricing

* **Price** (required): Base price that is displayed to the customer.
* **Tax Inclusive Pricing**: Toggle on to treat the displayed price as tax inclusive. Dodo will compute the net (pre‑tax) amount and tax portion at checkout based on customer location and tax category.

<Warning>
  Only future purchases reflect updated tax‑inclusive settings. Existing purchases and active subscriptions are not retroactively changed.
</Warning>

<Tip>
  Use consistent product copy such as “Tax inclusive” so customers understand totals at a glance.
</Tip>

## API Management

<AccordionGroup>
  <Accordion title="Create products (tax inclusive)">
    Use `POST /products` to create products with `tax_inclusive` set to `true`.

    <Card title="API Reference" icon="code" href="/api-reference/products/post-products">
      Create product via API
    </Card>
  </Accordion>

  <Accordion title="Update products">
    Use `PATCH /products/{id}` to toggle `tax_inclusive` on existing products.

    <Card title="API Reference" icon="code" href="/api-reference/products/patch-products">
      Update product via API
    </Card>
  </Accordion>

  <Accordion title="Checkout Sessions">
    Use `POST /checkout-sessions/create` to sell products marked as tax inclusive. The displayed price remains the same; checkout derives net amount and tax.

    <Card title="API Reference" icon="code" href="/api-reference/checkout-sessions/create">
      Create checkout session
    </Card>
  </Accordion>

  <Accordion title="Refunds (tax handling)">
    Use `POST /refunds` to issue refunds. You can specify whether the refund is tax inclusive using the `tax_inclusive` flag when applicable.

    <Card title="API Reference" icon="code" href="/api-reference/refunds/post-refunds">
      Create a refund
    </Card>
  </Accordion>
</AccordionGroup>

## Integration Examples

### Create a product with tax‑inclusive pricing

```typescript theme={null}
const product = await client.products.create({
  name: 'Pro Plan',
  description: 'All features included',
  price: {
    currency: 'USD',
    price: 10000
    tax_inclusive: true
  }
});
```

### Update an existing product to toggle tax inclusive

```typescript theme={null}
await client.products.update(product.id, {
  price: {
    tax_inclusive: true
  }
});
```

## Best Practices

* **Choose the right tax category** to ensure correct calculation per region.
* **Communicate totals** clearly with “Tax Inclusive” labels in product copy.
* **Test in sandbox** to validate.

## Related

<CardGroup>
  <Card title="Product Pricing" icon="dollar-sign" href="/features/pricing">
    Manage pricing options across products.
  </Card>

  <Card title="Subscriptions" icon="repeat" href="/features/subscription">
    Configure recurring products with advanced settings.
  </Card>

  <Card title="Discount Codes" icon="percent" href="/features/discount-codes">
    Offer promotions while keeping invoice clarity.
  </Card>
</CardGroup>


# Team Members
Source: https://docs.dodopayments.com/features/team

The Team feature enables you to add teammates to your Dodo Payments dashboard, granting them access based on customizable permissions. You can allow full modification rights or restrict access to view-only mode, ensuring secure and flexible collaboration.

<Frame>
  <img alt="Team Cover Image" />
</Frame>

## How to add a teammate?

<img />

1. Go to Business → Team.
2. Click on +**invite** button on the top right corner.

<img />

3. Provide the teammates email and assign a role to them.
4. Click on **Send Invite**.

## How can a teammate access the dashboard?

<img />

1. The teammate receives an invitation link via email and clicks on it.
2. If they do not have a Dodo Payments account, they are directed to the signup page where they need to provide the required details. If they already have a Dodo Payments account they can access the business through the business toggle on the bottom left.
3. After completing the signup process, they gain access to the dashboard.

## Roles and Permissions

<img />

The Dodo Dashboard has three types of user roles, each with different levels of access. The role icon of the user can be seen in the bottom left of the dashboard.

### 1. Owner

The **Owner** has the highest level of access and full control over the account. Only the account owner holds this role and has the exclusive ability to invite new users. The ownership of the account cannot be transferred.

### 2. Editor

Editors have almost the same permissions as the Owner, except they cannot invite new Editors. However, they can invite and remove users with the Viewer role. Additionally, they can create, edit, and delete products and make other modifications within the dashboard.

### 3. Viewer

Viewers have read-only access to the dashboard. They can view all information, including products, transactions, and reports, but cannot add, edit, or delete products or make any modifications.


# Disputes
Source: https://docs.dodopayments.com/features/transactions/disputes

The Disputes section is dedicated to managing customer disputes related to payments. Merchants can view and manage disputes from the Transactions page, including tracking the status of chargebacks and responding to disputes.

## Introduction

The disputes section provides a detailed view of all the disputes raised along with the current status of these disputes. You will have to manage the dispute resolution at your end but the dashboard will provide a visibility into the status, reason for dispute, dispute ID for convenience of access to information.

## Viewing and Understanding Disputes

<Steps>
  <Step title="Open the Transactions Page">
    Go to the <strong>Transactions</strong> page in your dashboard and select the <strong>Disputes</strong> tab. This displays a list of all disputes associated with your account.
  </Step>

  <Step title="View Dispute Details">
    Click the <strong>eye icon</strong> next to any dispute entry to open a detailed view. Here, you can review the dispute reason, status, dispute ID, and other relevant information.
  </Step>

  <Step title="Access Associated Payment Information">
    In the dispute details, locate the <strong>Associated Payment</strong> field. Click the <strong>eye icon</strong> here to view the full payment details related to the dispute.
  </Step>
</Steps>

## Responding to a Dispute

When a dispute is raised against your transaction, follow these steps to respond effectively:

1. **Check Your Dashboard**
   * Navigate to the transactions → disputes section
   * Look for the new dispute entry

2. **Review Email Notification**
   * Check your registered email for dispute creation notification

3. **Choose Your Response**
   * You can either accept or counter the dispute
   <Frame>
     <img alt="Dispute Creation" />
   </Frame>

4. **If Accepting**
   * No further action required
   * You will lose the dispute

5. **If Countering**

   * Prepare to submit evidence
   * Follow the best practices below

   <Frame>
     <img alt="Dispute Creation" />
   </Frame>

   <Frame>
     <img alt="Dispute Creation" />
   </Frame>

<Info>
  You have 4 days to respond to a dispute after creation
</Info>

## Dispute Response Best Practices

<Steps>
  <Step title="Understand the Dispute Reason">
    Review the dispute reason carefully. Common reasons include:

    <CardGroup>
      <Card title="Fraudulent Transaction">
        The customer claims they did not authorize the transaction
      </Card>

      <Card title="Product/Service Not Received">
        The customer claims they did not receive the product/service after payment
      </Card>

      <Card title="Not as Described">
        The customer claims the product/service differs from what was advertised
      </Card>
    </CardGroup>

    <Info>
      Your response must directly address the specific reason. Avoid submitting generic or unrelated evidence.
    </Info>
  </Step>

  <Step title="Gather the Right Evidence">
    Focus on customer identity, access, and usage evidence.

    <Tabs>
      <Tab title="Fraudulent Transaction">
        <Card title="Required Evidence">
          * **Invoice** of the purchase
          * **IP address, device, and location** details at time of purchase
          * **Login timestamps** showing access to your platform or service
          * **Browser/device fingerprint** or account activity logs
          * Previous successful transactions from the same customer or account
          * Terms of Service and Refund Policy accepted at time of purchase
        </Card>
      </Tab>

      <Tab title="Product/Service Not Received">
        <Card title="Required Evidence">
          * **Invoice** of the purchase
          * Screenshot or logs showing **successful login**
          * Timestamped activity (downloads, content viewed, sessions started)
          * Emails or support messages confirming access was granted
          * Welcome emails or onboarding steps completed by the customer
          * Internal logs showing product/service was delivered as promised
        </Card>
      </Tab>

      <Tab title="Not as Described">
        <Card title="Required Evidence">
          * **Invoice** of the purchase
          * Product/service description from your website at time of purchase
          * Comparison of what was promised vs. what was delivered
          * Documentation or screenshots of what was accessed
          * Any customer communication acknowledging receipt or usage
          * Refund policy and support options made available to the customer
        </Card>
      </Tab>
    </Tabs>
  </Step>

  <Step title="Craft a Clear Description">
    <Card title="Focus Points">
      * What the customer purchased
      * When and how they accessed it
      * Why the dispute claim is inaccurate
    </Card>

    <Info>
      Keep your language factual and professional. Avoid emotional or accusatory statements.
    </Info>

    <Card title="Example Response">
      "We offer a digital image generation from text service using AI. The customer purchased a monthly subscription on March 5 and accessed the product multiple times from March 5–10 and generated 4 images in the duration. Please see attached access logs and the accepted terms showing our no-refund policy."
    </Card>
  </Step>

  <Step title="Format & Submit Evidence">
    <Card title="Submission Guidelines">
      * Use **PDF, JPG, or PNG** formats only
      * Clearly **label each file** (e.g., `Login_Log_March_5.pdf`)
      * Submit only **relevant** and **organized** files
      * Keep files under 5 MB each
      * Do **not include links or URLs**
    </Card>
  </Step>
</Steps>

<AccordionGroup>
  <Accordion title="Common Mistakes to Avoid">
    <Card title="Avoid These Errors">
      * Ignoring the actual dispute reason
      * Using vague or emotional statements
      * Uploading unrelated or unstructured files
      * Providing links instead of files
    </Card>
  </Accordion>

  <Accordion title="Bonus Tips">
    <Card title="Strengthen Your Case">
      * Include **timestamps with timezone** to prove access timelines
      * Highlight any **two-factor authentication** or verification steps
      * Share **refund refusal communication** if it aligns with your policy
      * Keep your policies clearly visible and easy to prove were accepted
    </Card>
  </Accordion>
</AccordionGroup>


# Payments
Source: https://docs.dodopayments.com/features/transactions/payments

The Payments section provides merchants with a detailed overview of all payment transactions. Merchants can track payment statuses, initiate refunds, and access payment details for each transaction.

<Frame>
  <iframe title="Checkout Experience | Dodo Payments" />
</Frame>

## **Payments Listing Page**

The Payments listing page provides a record of all the payments that have taken place and includes important information about the payment like the transaction amount, payment status and payment method along with the invoice for reference to the purchase associated with the payment.&#x20;

* The following Payment statuses are shown:

  * **In Progress**: The payment is currently being processed.

  * **Failed**: The payment attempt was unsuccessful.

  * **Successful**: The payment was completed successfully.

<Info>The payment method and timestamp are updated once the payment is completed.</Info>

***

## **Payment Details Page**

Upon clicking a payment in the listing, merchants are directed to the **Payment Details Page**, which provides a comprehensive breakdown of the transaction

### Successful payment

<Frame>
  <img alt="Payment details page showing a successful payment with green status and transaction breakdown" />
</Frame>

* **Status**: Shows as **Successful** at the top with the final captured amount.
* **Transaction details**: Displays `Payment ID`, `Payment date`, `Payment method`, and `Settlement amount`.
* **Card information**: Card network, last four, issuing country, and type.
* **Customer details**: Name, email, and billing info.
* **Product cart**: Product IDs and quantities purchased.
* **Actions**: You can generate the invoice or initiate a refund from the top-right.

### Failed payment

<Frame>
  <img alt="Payment details page showing a failed payment with red error banner, decline error code and message" />
</Frame>

* **Status**: Shows as **Failed** with a red banner.
* **Error context**: Includes the gateway `Error Code` and human-readable `Error Message` (for example, `INSUFFICIENT_FUNDS` – “Your card was declined”).
* **Other information**: The error fields are repeated in the details section for quick reference.
* **Next steps**:
  * Retry the payment with a different card or funding source.
  * Verify card details and available funds.
  * If the decline persists, contact the issuer and try again.

## **Important Information**

* **Automatic Activation**: All the payment methods listed above will become available to customers automatically once the merchant's account is verified and live mode is enabled.

* **No Additional Configuration Required**: Merchants do not need to configure these payment options, as they are pre-defined and managed by Dodo Payments.

* **Additional Payment Methods**: We are constantly adding more payment methods to our roster. We will keep updating this page as and when we add more methods. If you have a requirement for any particular payment method, please write to us at [support@dodopayments.com](mailto:support@dodopayments.com) and we will add this to our roadmap if not present.

## How to Navigate and Use the Payments Page

<Steps>
  <Step title="Navigate to the Payments section">
    Open the **Transactions** page and click on the **Payments** tab to view all payment transactions.
  </Step>

  <Step title="Filter and search payments">
    Use the available filters to narrow down your payment list:

    * **Status filter**: View payments by status.
    * **Date range**: Select custom date ranges to view payments from specific periods
  </Step>

  <Step title="View payment details">
    Click on the **Array icon** next to any payment to access the detailed payment information.
  </Step>

  <Step title="Review payment information">
    On the payment details page, you can view:

    * **Transaction details**: Amount, currency, payment method, and timestamp
    * **Customer information**: Name, email, and billing details
    * **Payment status**: Current status with timestamp of status changes
  </Step>

  <Step title="Download invoice">
    To download the associated invoice, click the **download Invoice** (📥) on the invoice preview section.
  </Step>
</Steps>


# Refunds
Source: https://docs.dodopayments.com/features/transactions/refunds

The Refunds section allows merchants to manage and initiate refunds for transactions. Merchants can initiate full or partial refunds directly from the transaction details view, with built-in rules ensuring compliance and protecting against errors.

## Initiate Refund

You can initiate two types of refunds from the Payment Details Page:

* **Full refund**: Refunds the entire payment amount to the customer.
* **Partial refund**: Refunds only a portion of the payment amount, as specified by you.

To begin, click the **Initiate Refund** button. The refund will only proceed if all refund rules are met.

<Frame>
  <img alt="Initiate refund button on the payment details page" />
</Frame>

<Tip>
  Partial refunds are useful when only a portion of the order needs to be refunded.
</Tip>

### Details Required for Refund

* **Refund Amount**: The amount to be refunded. For partial refunds, enter the specific amount you wish to return to the customer. The system will prevent you from refunding more than the original payment.

* **Refund Reason**: The reason for the refund, to be recorded in the system.

### Refund Rules

1. The payment must have been successful.

2. Refunds (full or partial) must be initiated within 30 days of the transaction date. Initiating refunds will not be allowed post that.

3. Refunds are issued to the original payment method used by the customer.

If any rule is violated, the refund request will be denied. Please reach out to support for assistance if needed.

## Refund Status

Track the progress of your refund through the following status indicators:

| Status    | Description                                               | Possible Reason                                                                                  |
| --------- | --------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
| succeeded | The refund has been successfully processed.               | —                                                                                                |
| pending   | The refund is being processed and is awaiting completion. | —                                                                                                |
| failed    | The refund could not be processed due to an error.        | <ul><li>Payment was disputed</li><li>Insufficient balance in wallet</li><li>Bank issue</li></ul> |

## Refunds Page

The **Refunds Page** provides a detailed view of all refund transactions:&#x20;

* Clicking the **Associated Payment ID** will take the merchant to the **Payment Details Page** for that transaction.

* Merchants can export the refund report in CSV format for a specified date range.

Here’s how the **Refunds Page** looks:

<Frame>
  <img alt="Refunds page showing a list of refund transactions" />
</Frame>

## Refund Receipt

Once a refund is successfully processed, a **Refund Receipt** is automatically sent to the customer.

**Refund Receipt Template:**

<Frame>
  <img alt="Refund receipt template showing the refund details" />
</Frame>

The refund receipt includes:

* **Refund ID**: The unique identifier for the refund.
* **Refund amount**: The amount refunded to the customer.
* **Refund date**: The date the refund was processed.
* **Refund method**: The method used to refund the customer.
* **Refund status**: The status of the refund.
* **Refund reason**: The reason for the refund.


# Upsells & Downsells
Source: https://docs.dodopayments.com/features/upsells-and-downsells

Increase revenue with one-click purchases using saved payment methods for post-purchase offers, subscription upgrades, and cross-sells.

<Info>
  Upsells and downsells let you offer additional products or plan changes to customers using their saved payment methods. This enables one-click purchases that skip payment collection, dramatically improving conversion rates.
</Info>

<CardGroup>
  <Card title="Post-Purchase Upsells" icon="cart-plus">
    Offer complementary products immediately after checkout with one-click purchasing.
  </Card>

  <Card title="Subscription Upgrades" icon="arrow-up">
    Move customers to higher tiers with automatic proration and instant billing.
  </Card>

  <Card title="Cross-Sells" icon="grid-2-plus">
    Add related products to existing customers without re-entering payment details.
  </Card>
</CardGroup>

## Overview

Upsells and downsells are powerful revenue optimization strategies:

* **Upsells**: Offer a higher-value product or upgrade (e.g., Pro plan instead of Basic)
* **Downsells**: Offer a lower-priced alternative when a customer declines or downgrades
* **Cross-sells**: Suggest complementary products (e.g., add-ons, related items)

Dodo Payments enables these flows through the `payment_method_id` parameter, which lets you charge a customer's saved payment method without requiring them to re-enter card details.

### Key Benefits

| Benefit                 | Impact                                             |
| ----------------------- | -------------------------------------------------- |
| **One-click purchases** | Skip payment form entirely for returning customers |
| **Higher conversion**   | Reduce friction at the moment of decision          |
| **Instant processing**  | Charges process immediately with `confirm: true`   |
| **Seamless UX**         | Customers stay in your app throughout the flow     |

## How It Works

```mermaid theme={null}
sequenceDiagram
    participant C as Customer
    participant A as Your App
    participant D as Dodo API
    
    C->>A: Completes purchase
    A->>D: Get payment methods
    D-->>A: payment_method_id
    A->>C: Show upsell offer
    C->>A: Accept (one click)
    A->>D: Charge with payment_method_id
    D-->>A: Payment success
    D->>A: Webhook: payment.succeeded
```

## Prerequisites

Before implementing upsells and downsells, ensure you have:

<Steps>
  <Step title="Customer with Saved Payment Method">
    Customers must have completed at least one purchase. Payment methods are automatically saved when customers complete checkout.
  </Step>

  <Step title="Products Configured">
    Create your upsell products in the Dodo Payments dashboard. These can be one-time payments, subscriptions, or add-ons.
  </Step>

  <Step title="Webhook Endpoint">
    Set up webhooks to handle `payment.succeeded`, `payment.failed`, and `subscription.plan_changed` events.
  </Step>
</Steps>

## Getting Customer Payment Methods

Before offering an upsell, retrieve the customer's saved payment methods:

<Tabs>
  <Tab title="TypeScript">
    ```typescript theme={null}
    import DodoPayments from 'dodopayments';

    const client = new DodoPayments({
      bearerToken: process.env.DODO_PAYMENTS_API_KEY,
      environment: 'live_mode',
    });

    async function getPaymentMethods(customerId: string) {
      const paymentMethods = await client.customers.listPaymentMethods(customerId);
      
      // Returns array of saved payment methods
      // Each has: payment_method_id, type, card (last4, brand, exp_month, exp_year)
      return paymentMethods;
    }

    // Example usage
    const methods = await getPaymentMethods('cus_123');
    console.log('Available payment methods:', methods);

    // Use the first available method for upsell
    const primaryMethod = methods[0]?.payment_method_id;
    ```
  </Tab>

  <Tab title="Python">
    ```python theme={null}
    import os
    from dodopayments import DodoPayments

    client = DodoPayments(
        bearer_token=os.environ.get("DODO_PAYMENTS_API_KEY"),
        environment="live_mode",
    )

    def get_payment_methods(customer_id: str):
        payment_methods = client.customers.list_payment_methods(customer_id)
        
        # Returns list of saved payment methods
        # Each has: payment_method_id, type, card (last4, brand, exp_month, exp_year)
        return payment_methods

    # Example usage
    methods = get_payment_methods("cus_123")
    print("Available payment methods:", methods)

    # Use the first available method for upsell
    primary_method = methods[0].payment_method_id if methods else None
    ```
  </Tab>

  <Tab title="Go">
    ```go theme={null}
    package main

    import (
        "context"
        "fmt"
        "github.com/dodopayments/dodopayments-go"
        "github.com/dodopayments/dodopayments-go/option"
    )

    func getPaymentMethods(customerID string) ([]dodopayments.PaymentMethod, error) {
        client := dodopayments.NewClient(
            option.WithBearerToken(os.Getenv("DODO_PAYMENTS_API_KEY")),
        )
        
        methods, err := client.Customers.ListPaymentMethods(
            context.TODO(),
            customerID,
        )
        if err != nil {
            return nil, err
        }
        
        return methods, nil
    }

    func main() {
        methods, err := getPaymentMethods("cus_123")
        if err != nil {
            panic(err)
        }
        
        fmt.Println("Available payment methods:", methods)
        
        // Use the first available method for upsell
        if len(methods) > 0 {
            primaryMethod := methods[0].PaymentMethodID
            fmt.Println("Primary method:", primaryMethod)
        }
    }
    ```
  </Tab>
</Tabs>

<Info>
  Payment methods are automatically saved when customers complete checkout. You don't need to explicitly save them.
</Info>

## Post-Purchase One-Click Upsells

Offer additional products immediately after a successful purchase. The customer can accept with a single click since their payment method is already saved.

```mermaid theme={null}
flowchart LR
    A[Purchase] --> B{Upsell?}
    B -->|Yes| C[Show Offer]
    B -->|No| F[Done]
    C --> D{Accept?}
    D -->|Yes| E[One-Click Charge] --> F
    D -->|No| F
```

### Implementation

<Tabs>
  <Tab title="TypeScript">
    ```typescript theme={null}
    import DodoPayments from 'dodopayments';

    const client = new DodoPayments({
      bearerToken: process.env.DODO_PAYMENTS_API_KEY,
      environment: 'live_mode',
    });

    async function createOneClickUpsell(
      customerId: string,
      paymentMethodId: string,
      upsellProductId: string
    ) {
      // Create checkout session with saved payment method
      // confirm: true processes the payment immediately
      const session = await client.checkoutSessions.create({
        product_cart: [
          {
            product_id: upsellProductId,
            quantity: 1
          }
        ],
        customer: {
          customer_id: customerId
        },
        payment_method_id: paymentMethodId,
        confirm: true,  // Required when using payment_method_id
        return_url: 'https://yourapp.com/upsell-success',
        feature_flags: {
          redirect_immediately: true  // Skip success page
        },
        metadata: {
          upsell_source: 'post_purchase',
          original_order_id: 'order_123'
        }
      });

      return session;
    }

    // Example: Offer premium add-on after initial purchase
    async function handlePostPurchaseUpsell(customerId: string) {
      // Get customer's payment methods
      const methods = await client.customers.listPaymentMethods(customerId);
      
      if (methods.length === 0) {
        console.log('No saved payment methods available');
        return null;
      }

      // Create the upsell with one-click checkout
      const upsell = await createOneClickUpsell(
        customerId,
        methods[0].payment_method_id,
        'prod_premium_addon'
      );

      console.log('Upsell processed:', upsell.session_id);
      return upsell;
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python theme={null}
    import os
    from dodopayments import DodoPayments

    client = DodoPayments(
        bearer_token=os.environ.get("DODO_PAYMENTS_API_KEY"),
        environment="live_mode",
    )

    def create_one_click_upsell(
        customer_id: str,
        payment_method_id: str,
        upsell_product_id: str
    ):
        """Create a one-click upsell using saved payment method."""
        
        # Create checkout session with saved payment method
        # confirm=True processes the payment immediately
        session = client.checkout_sessions.create(
            product_cart=[
                {
                    "product_id": upsell_product_id,
                    "quantity": 1
                }
            ],
            customer={
                "customer_id": customer_id
            },
            payment_method_id=payment_method_id,
            confirm=True,  # Required when using payment_method_id
            return_url="https://yourapp.com/upsell-success",
            feature_flags={
                "redirect_immediately": True  # Skip success page
            },
            metadata={
                "upsell_source": "post_purchase",
                "original_order_id": "order_123"
            }
        )
        
        return session


    def handle_post_purchase_upsell(customer_id: str):
        """Offer premium add-on after initial purchase."""
        
        # Get customer's payment methods
        methods = client.customers.list_payment_methods(customer_id)
        
        if not methods:
            print("No saved payment methods available")
            return None
        
        # Create the upsell with one-click checkout
        upsell = create_one_click_upsell(
            customer_id=customer_id,
            payment_method_id=methods[0].payment_method_id,
            upsell_product_id="prod_premium_addon"
        )
        
        print(f"Upsell processed: {upsell.session_id}")
        return upsell
    ```
  </Tab>

  <Tab title="Go">
    ```go theme={null}
    package main

    import (
        "context"
        "fmt"
        "os"
        
        "github.com/dodopayments/dodopayments-go"
        "github.com/dodopayments/dodopayments-go/option"
    )

    func createOneClickUpsell(
        customerID string,
        paymentMethodID string,
        upsellProductID string,
    ) (*dodopayments.CheckoutSession, error) {
        client := dodopayments.NewClient(
            option.WithBearerToken(os.Getenv("DODO_PAYMENTS_API_KEY")),
        )
        
        // Create checkout session with saved payment method
        // Confirm: true processes the payment immediately
        session, err := client.CheckoutSessions.Create(context.TODO(), dodopayments.CheckoutSessionCreateParams{
            ProductCart: dodopayments.F([]dodopayments.CheckoutSessionCreateParamsProductCart{
                {
                    ProductID: dodopayments.F(upsellProductID),
                    Quantity:  dodopayments.F(int64(1)),
                },
            }),
            Customer: dodopayments.F(dodopayments.CheckoutSessionCreateParamsCustomer{
                CustomerID: dodopayments.F(customerID),
            }),
            PaymentMethodID: dodopayments.F(paymentMethodID),
            Confirm:         dodopayments.F(true), // Required when using payment_method_id
            ReturnURL:       dodopayments.F("https://yourapp.com/upsell-success"),
            FeatureFlags: dodopayments.F(dodopayments.CheckoutSessionCreateParamsFeatureFlags{
                RedirectImmediately: dodopayments.F(true), // Skip success page
            }),
            Metadata: dodopayments.F(map[string]string{
                "upsell_source":     "post_purchase",
                "original_order_id": "order_123",
            }),
        })
        
        return session, err
    }

    func handlePostPurchaseUpsell(customerID string) (*dodopayments.CheckoutSession, error) {
        client := dodopayments.NewClient(
            option.WithBearerToken(os.Getenv("DODO_PAYMENTS_API_KEY")),
        )
        
        // Get customer's payment methods
        methods, err := client.Customers.ListPaymentMethods(context.TODO(), customerID)
        if err != nil {
            return nil, err
        }
        
        if len(methods) == 0 {
            fmt.Println("No saved payment methods available")
            return nil, nil
        }
        
        // Create the upsell with one-click checkout
        upsell, err := createOneClickUpsell(
            customerID,
            methods[0].PaymentMethodID,
            "prod_premium_addon",
        )
        if err != nil {
            return nil, err
        }
        
        fmt.Printf("Upsell processed: %s\n", upsell.SessionID)
        return upsell, nil
    }
    ```
  </Tab>
</Tabs>

<Warning>
  When using `payment_method_id`, you must set `confirm: true` and provide an existing `customer_id`. The payment method must belong to that customer.
</Warning>

## Subscription Upgrades

Move customers to higher-tier subscription plans with automatic proration handling.

```mermaid theme={null}
sequenceDiagram
    participant C as Customer
    participant A as Your App
    participant D as Dodo API
    
    C->>A: Request upgrade
    A->>D: Preview change plan
    D-->>A: Charge amount
    A->>C: Confirm $50 charge?
    C->>A: Confirm
    A->>D: Change plan
    D->>A: Webhook: plan_changed
```

### Preview Before Committing

Always preview plan changes to show customers exactly what they'll be charged:

<Tabs>
  <Tab title="TypeScript">
    ```typescript theme={null}
    async function previewUpgrade(
      subscriptionId: string,
      newProductId: string
    ) {
      const preview = await client.subscriptions.previewChangePlan(subscriptionId, {
        product_id: newProductId,
        quantity: 1,
        proration_billing_mode: 'difference_immediately'
      });

      return {
        immediateCharge: preview.immediate_charge?.summary,
        newPlan: preview.new_plan,
        effectiveDate: preview.effective_date
      };
    }

    // Show customer the charge before confirming
    const preview = await previewUpgrade('sub_123', 'prod_pro_plan');
    console.log(`Upgrade will charge: ${preview.immediateCharge}`);
    ```
  </Tab>

  <Tab title="Python">
    ```python theme={null}
    def preview_upgrade(subscription_id: str, new_product_id: str):
        preview = client.subscriptions.preview_change_plan(
            subscription_id=subscription_id,
            product_id=new_product_id,
            quantity=1,
            proration_billing_mode="difference_immediately"
        )
        
        return {
            "immediate_charge": preview.immediate_charge.summary if preview.immediate_charge else None,
            "new_plan": preview.new_plan,
            "effective_date": preview.effective_date
        }

    # Show customer the charge before confirming
    preview = preview_upgrade("sub_123", "prod_pro_plan")
    print(f"Upgrade will charge: {preview['immediate_charge']}")
    ```
  </Tab>

  <Tab title="Go">
    ```go theme={null}
    func previewUpgrade(subscriptionID string, newProductID string) (map[string]interface{}, error) {
        client := dodopayments.NewClient(
            option.WithBearerToken(os.Getenv("DODO_PAYMENTS_API_KEY")),
        )
        
        preview, err := client.Subscriptions.PreviewChangePlan(
            context.TODO(),
            subscriptionID,
            dodopayments.SubscriptionPreviewChangePlanParams{
                ProductID:             dodopayments.F(newProductID),
                Quantity:              dodopayments.F(int64(1)),
                ProrationBillingMode:  dodopayments.F(dodopayments.ProrationBillingModeDifferenceImmediately),
            },
        )
        if err != nil {
            return nil, err
        }
        
        return map[string]interface{}{
            "immediate_charge": preview.ImmediateCharge.Summary,
            "new_plan":         preview.NewPlan,
            "effective_date":   preview.EffectiveDate,
        }, nil
    }
    ```
  </Tab>
</Tabs>

### Execute the Upgrade

<Tabs>
  <Tab title="TypeScript">
    ```typescript theme={null}
    async function upgradeSubscription(
      subscriptionId: string,
      newProductId: string,
      prorationMode: 'prorated_immediately' | 'difference_immediately' | 'full_immediately' = 'difference_immediately'
    ) {
      const result = await client.subscriptions.changePlan(subscriptionId, {
        product_id: newProductId,
        quantity: 1,
        proration_billing_mode: prorationMode
      });

      return {
        status: result.status,
        subscriptionId: result.subscription_id,
        paymentId: result.payment_id,
        invoiceId: result.invoice_id
      };
    }

    // Upgrade from Basic ($30) to Pro ($80)
    // With difference_immediately: charges $50 instantly
    const upgrade = await upgradeSubscription('sub_123', 'prod_pro_plan');
    console.log('Upgrade status:', upgrade.status);
    ```
  </Tab>

  <Tab title="Python">
    ```python theme={null}
    def upgrade_subscription(
        subscription_id: str,
        new_product_id: str,
        proration_mode: str = "difference_immediately"
    ):
        result = client.subscriptions.change_plan(
            subscription_id=subscription_id,
            product_id=new_product_id,
            quantity=1,
            proration_billing_mode=proration_mode
        )
        
        return {
            "status": result.status,
            "subscription_id": result.subscription_id,
            "payment_id": result.payment_id,
            "invoice_id": result.invoice_id
        }

    # Upgrade from Basic ($30) to Pro ($80)
    # With difference_immediately: charges $50 instantly
    upgrade = upgrade_subscription("sub_123", "prod_pro_plan")
    print(f"Upgrade status: {upgrade['status']}")
    ```
  </Tab>

  <Tab title="Go">
    ```go theme={null}
    func upgradeSubscription(
        subscriptionID string,
        newProductID string,
        prorationMode dodopayments.ProrationBillingMode,
    ) (*dodopayments.SubscriptionChangePlanResponse, error) {
        client := dodopayments.NewClient(
            option.WithBearerToken(os.Getenv("DODO_PAYMENTS_API_KEY")),
        )
        
        result, err := client.Subscriptions.ChangePlan(
            context.TODO(),
            subscriptionID,
            dodopayments.SubscriptionChangePlanParams{
                ProductID:            dodopayments.F(newProductID),
                Quantity:             dodopayments.F(int64(1)),
                ProrationBillingMode: dodopayments.F(prorationMode),
            },
        )
        
        return result, err
    }

    // Upgrade from Basic ($30) to Pro ($80)
    // With DifferenceImmediately: charges $50 instantly
    upgrade, err := upgradeSubscription(
        "sub_123",
        "prod_pro_plan",
        dodopayments.ProrationBillingModeDifferenceImmediately,
    )
    if err != nil {
        panic(err)
    }
    fmt.Printf("Upgrade status: %s\n", upgrade.Status)
    ```
  </Tab>
</Tabs>

### Proration Modes

Choose how customers are billed when upgrading:

| Mode                     | Behavior                                            | Best For                |
| ------------------------ | --------------------------------------------------- | ----------------------- |
| `difference_immediately` | Charges price difference instantly ($30→$80 = \$50) | Simple upgrades         |
| `prorated_immediately`   | Charges based on remaining time in billing cycle    | Fair time-based billing |
| `full_immediately`       | Charges full new plan price, ignores remaining time | Billing cycle resets    |

<Tip>
  Use `difference_immediately` for straightforward upgrade flows. Use `prorated_immediately` when you want to account for unused time on the current plan.
</Tip>

## Cross-Sells

Add complementary products for existing customers without requiring them to re-enter payment details.

```mermaid theme={null}
flowchart LR
    A[View Product] --> B{Existing Customer?}
    B -->|Yes| C[One-Click Buy] --> E[Deliver]
    B -->|No| D[Standard Checkout] --> E
```

### Implementation

<Tabs>
  <Tab title="TypeScript">
    ```typescript theme={null}
    async function createCrossSell(
      customerId: string,
      paymentMethodId: string,
      productId: string,
      quantity: number = 1
    ) {
      // Create a one-time payment using saved payment method
      const payment = await client.payments.create({
        product_cart: [
          {
            product_id: productId,
            quantity: quantity
          }
        ],
        customer_id: customerId,
        payment_method_id: paymentMethodId,
        return_url: 'https://yourapp.com/purchase-complete',
        metadata: {
          purchase_type: 'cross_sell',
          source: 'product_recommendation'
        }
      });

      return payment;
    }

    // Example: Customer bought a course, offer related ebook
    async function offerRelatedProduct(customerId: string, relatedProductId: string) {
      const methods = await client.customers.listPaymentMethods(customerId);
      
      if (methods.length === 0) {
        // Fall back to standard checkout
        return client.checkoutSessions.create({
          product_cart: [{ product_id: relatedProductId, quantity: 1 }],
          customer: { customer_id: customerId },
          return_url: 'https://yourapp.com/purchase-complete'
        });
      }

      // One-click purchase
      return createCrossSell(customerId, methods[0].payment_method_id, relatedProductId);
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python theme={null}
    def create_cross_sell(
        customer_id: str,
        payment_method_id: str,
        product_id: str,
        quantity: int = 1
    ):
        """Create a one-time payment using saved payment method."""
        
        payment = client.payments.create(
            product_cart=[
                {
                    "product_id": product_id,
                    "quantity": quantity
                }
            ],
            customer_id=customer_id,
            payment_method_id=payment_method_id,
            return_url="https://yourapp.com/purchase-complete",
            metadata={
                "purchase_type": "cross_sell",
                "source": "product_recommendation"
            }
        )
        
        return payment


    def offer_related_product(customer_id: str, related_product_id: str):
        """Offer related product with one-click purchase if possible."""
        
        methods = client.customers.list_payment_methods(customer_id)
        
        if not methods:
            # Fall back to standard checkout
            return client.checkout_sessions.create(
                product_cart=[{"product_id": related_product_id, "quantity": 1}],
                customer={"customer_id": customer_id},
                return_url="https://yourapp.com/purchase-complete"
            )
        
        # One-click purchase
        return create_cross_sell(customer_id, methods[0].payment_method_id, related_product_id)
    ```
  </Tab>

  <Tab title="Go">
    ```go theme={null}
    func createCrossSell(
        customerID string,
        paymentMethodID string,
        productID string,
        quantity int64,
    ) (*dodopayments.Payment, error) {
        client := dodopayments.NewClient(
            option.WithBearerToken(os.Getenv("DODO_PAYMENTS_API_KEY")),
        )
        
        payment, err := client.Payments.Create(context.TODO(), dodopayments.PaymentCreateParams{
            ProductCart: dodopayments.F([]dodopayments.PaymentCreateParamsProductCart{
                {
                    ProductID: dodopayments.F(productID),
                    Quantity:  dodopayments.F(quantity),
                },
            }),
            CustomerID:      dodopayments.F(customerID),
            PaymentMethodID: dodopayments.F(paymentMethodID),
            ReturnURL:       dodopayments.F("https://yourapp.com/purchase-complete"),
            Metadata: dodopayments.F(map[string]string{
                "purchase_type": "cross_sell",
                "source":        "product_recommendation",
            }),
        })
        
        return payment, err
    }

    func offerRelatedProduct(customerID string, relatedProductID string) (interface{}, error) {
        client := dodopayments.NewClient(
            option.WithBearerToken(os.Getenv("DODO_PAYMENTS_API_KEY")),
        )
        
        methods, err := client.Customers.ListPaymentMethods(context.TODO(), customerID)
        if err != nil {
            return nil, err
        }
        
        if len(methods) == 0 {
            // Fall back to standard checkout
            return client.CheckoutSessions.Create(context.TODO(), dodopayments.CheckoutSessionCreateParams{
                ProductCart: dodopayments.F([]dodopayments.CheckoutSessionCreateParamsProductCart{
                    {ProductID: dodopayments.F(relatedProductID), Quantity: dodopayments.F(int64(1))},
                }),
                Customer:  dodopayments.F(dodopayments.CheckoutSessionCreateParamsCustomer{CustomerID: dodopayments.F(customerID)}),
                ReturnURL: dodopayments.F("https://yourapp.com/purchase-complete"),
            })
        }
        
        // One-click purchase
        return createCrossSell(customerID, methods[0].PaymentMethodID, relatedProductID, 1)
    }
    ```
  </Tab>
</Tabs>

## Subscription Downgrades

When customers want to move to a lower-tier plan, handle the transition gracefully with automatic credits.

### How Downgrades Work

1. Customer requests downgrade (Pro → Basic)
2. System calculates remaining value on current plan
3. Credit is added to subscription for future renewals
4. Customer moves to new plan immediately

<Tabs>
  <Tab title="TypeScript">
    ```typescript theme={null}
    async function downgradeSubscription(
      subscriptionId: string,
      newProductId: string
    ) {
      // Preview the downgrade first
      const preview = await client.subscriptions.previewChangePlan(subscriptionId, {
        product_id: newProductId,
        quantity: 1,
        proration_billing_mode: 'difference_immediately'
      });

      console.log('Credit to be applied:', preview.credit_amount);

      // Execute the downgrade
      const result = await client.subscriptions.changePlan(subscriptionId, {
        product_id: newProductId,
        quantity: 1,
        proration_billing_mode: 'difference_immediately'
      });

      // Credits are automatically applied to future renewals
      return result;
    }

    // Downgrade from Pro ($80) to Basic ($30)
    // $50 credit added to subscription, auto-applied on next renewal
    const downgrade = await downgradeSubscription('sub_123', 'prod_basic_plan');
    ```
  </Tab>

  <Tab title="Python">
    ```python theme={null}
    def downgrade_subscription(subscription_id: str, new_product_id: str):
        # Preview the downgrade first
        preview = client.subscriptions.preview_change_plan(
            subscription_id=subscription_id,
            product_id=new_product_id,
            quantity=1,
            proration_billing_mode="difference_immediately"
        )
        
        print(f"Credit to be applied: {preview.credit_amount}")
        
        # Execute the downgrade
        result = client.subscriptions.change_plan(
            subscription_id=subscription_id,
            product_id=new_product_id,
            quantity=1,
            proration_billing_mode="difference_immediately"
        )
        
        # Credits are automatically applied to future renewals
        return result

    # Downgrade from Pro ($80) to Basic ($30)
    # $50 credit added to subscription, auto-applied on next renewal
    downgrade = downgrade_subscription("sub_123", "prod_basic_plan")
    ```
  </Tab>

  <Tab title="Go">
    ```go theme={null}
    func downgradeSubscription(subscriptionID string, newProductID string) (*dodopayments.SubscriptionChangePlanResponse, error) {
        client := dodopayments.NewClient(
            option.WithBearerToken(os.Getenv("DODO_PAYMENTS_API_KEY")),
        )
        
        // Preview the downgrade first
        preview, err := client.Subscriptions.PreviewChangePlan(
            context.TODO(),
            subscriptionID,
            dodopayments.SubscriptionPreviewChangePlanParams{
                ProductID:            dodopayments.F(newProductID),
                Quantity:             dodopayments.F(int64(1)),
                ProrationBillingMode: dodopayments.F(dodopayments.ProrationBillingModeDifferenceImmediately),
            },
        )
        if err != nil {
            return nil, err
        }
        
        fmt.Printf("Credit to be applied: %v\n", preview.CreditAmount)
        
        // Execute the downgrade
        result, err := client.Subscriptions.ChangePlan(
            context.TODO(),
            subscriptionID,
            dodopayments.SubscriptionChangePlanParams{
                ProductID:            dodopayments.F(newProductID),
                Quantity:             dodopayments.F(int64(1)),
                ProrationBillingMode: dodopayments.F(dodopayments.ProrationBillingModeDifferenceImmediately),
            },
        )
        
        return result, err
    }
    ```
  </Tab>
</Tabs>

<Info>
  Credits from downgrades using `difference_immediately` are subscription-scoped and automatically applied to future renewals. They're distinct from [Customer Credits](/features/customer-credit).
</Info>

## Complete Example: Post-Purchase Upsell Flow

Here's a complete implementation showing how to offer an upsell after a successful purchase:

<Tabs>
  <Tab title="TypeScript">
    ```typescript theme={null}
    import DodoPayments from 'dodopayments';
    import express from 'express';

    const client = new DodoPayments({
      bearerToken: process.env.DODO_PAYMENTS_API_KEY,
      environment: 'live_mode',
    });

    const app = express();

    // Store for tracking upsell eligibility (use your database in production)
    const eligibleUpsells = new Map<string, { customerId: string; productId: string }>();

    // Webhook handler for initial purchase success
    app.post('/webhooks/dodo', express.raw({ type: 'application/json' }), async (req, res) => {
      const event = JSON.parse(req.body.toString());
      
      switch (event.type) {
        case 'payment.succeeded':
          // Check if customer is eligible for upsell
          const customerId = event.data.customer_id;
          const productId = event.data.product_id;
          
          // Define upsell rules (e.g., bought Basic, offer Pro)
          const upsellProduct = getUpsellProduct(productId);
          
          if (upsellProduct) {
            eligibleUpsells.set(customerId, {
              customerId,
              productId: upsellProduct
            });
          }
          break;
          
        case 'payment.failed':
          console.log('Payment failed:', event.data.payment_id);
          // Handle failed upsell payment
          break;
      }
      
      res.json({ received: true });
    });

    // API endpoint to check upsell eligibility
    app.get('/api/upsell/:customerId', async (req, res) => {
      const { customerId } = req.params;
      const upsell = eligibleUpsells.get(customerId);
      
      if (!upsell) {
        return res.json({ eligible: false });
      }
      
      // Get payment methods
      const methods = await client.customers.listPaymentMethods(customerId);
      
      if (methods.length === 0) {
        return res.json({ eligible: false, reason: 'no_payment_method' });
      }
      
      // Get product details for display
      const product = await client.products.retrieve(upsell.productId);
      
      res.json({
        eligible: true,
        product: {
          id: product.product_id,
          name: product.name,
          price: product.price,
          currency: product.currency
        },
        paymentMethodId: methods[0].payment_method_id
      });
    });

    // API endpoint to accept upsell
    app.post('/api/upsell/:customerId/accept', async (req, res) => {
      const { customerId } = req.params;
      const upsell = eligibleUpsells.get(customerId);
      
      if (!upsell) {
        return res.status(400).json({ error: 'No upsell available' });
      }
      
      try {
        const methods = await client.customers.listPaymentMethods(customerId);
        
        // Create one-click purchase
        const session = await client.checkoutSessions.create({
          product_cart: [{ product_id: upsell.productId, quantity: 1 }],
          customer: { customer_id: customerId },
          payment_method_id: methods[0].payment_method_id,
          confirm: true,
          return_url: `${process.env.APP_URL}/upsell-success`,
          feature_flags: { redirect_immediately: true },
          metadata: { upsell: 'true', source: 'post_purchase' }
        });
        
        // Clear the upsell offer
        eligibleUpsells.delete(customerId);
        
        res.json({ success: true, sessionId: session.session_id });
      } catch (error) {
        console.error('Upsell failed:', error);
        res.status(500).json({ error: 'Upsell processing failed' });
      }
    });

    // Helper function to determine upsell product
    function getUpsellProduct(purchasedProductId: string): string | null {
      const upsellMap: Record<string, string> = {
        'prod_basic_plan': 'prod_pro_plan',
        'prod_starter_course': 'prod_complete_bundle',
        'prod_single_license': 'prod_team_license'
      };
      
      return upsellMap[purchasedProductId] || null;
    }

    app.listen(3000);
    ```
  </Tab>

  <Tab title="Python">
    ```python theme={null}
    import os
    from flask import Flask, request, jsonify
    from dodopayments import DodoPayments

    client = DodoPayments(
        bearer_token=os.environ.get("DODO_PAYMENTS_API_KEY"),
        environment="live_mode",
    )

    app = Flask(__name__)

    # Store for tracking upsell eligibility (use your database in production)
    eligible_upsells = {}


    @app.route('/webhooks/dodo', methods=['POST'])
    def webhook_handler():
        event = request.json
        
        if event['type'] == 'payment.succeeded':
            # Check if customer is eligible for upsell
            customer_id = event['data']['customer_id']
            product_id = event['data']['product_id']
            
            # Define upsell rules
            upsell_product = get_upsell_product(product_id)
            
            if upsell_product:
                eligible_upsells[customer_id] = {
                    'customer_id': customer_id,
                    'product_id': upsell_product
                }
        
        elif event['type'] == 'payment.failed':
            print(f"Payment failed: {event['data']['payment_id']}")
        
        return jsonify({'received': True})


    @app.route('/api/upsell/<customer_id>', methods=['GET'])
    def check_upsell(customer_id):
        upsell = eligible_upsells.get(customer_id)
        
        if not upsell:
            return jsonify({'eligible': False})
        
        # Get payment methods
        methods = client.customers.list_payment_methods(customer_id)
        
        if not methods:
            return jsonify({'eligible': False, 'reason': 'no_payment_method'})
        
        # Get product details for display
        product = client.products.retrieve(upsell['product_id'])
        
        return jsonify({
            'eligible': True,
            'product': {
                'id': product.product_id,
                'name': product.name,
                'price': product.price,
                'currency': product.currency
            },
            'payment_method_id': methods[0].payment_method_id
        })


    @app.route('/api/upsell/<customer_id>/accept', methods=['POST'])
    def accept_upsell(customer_id):
        upsell = eligible_upsells.get(customer_id)
        
        if not upsell:
            return jsonify({'error': 'No upsell available'}), 400
        
        try:
            methods = client.customers.list_payment_methods(customer_id)
            
            # Create one-click purchase
            session = client.checkout_sessions.create(
                product_cart=[{'product_id': upsell['product_id'], 'quantity': 1}],
                customer={'customer_id': customer_id},
                payment_method_id=methods[0].payment_method_id,
                confirm=True,
                return_url=f"{os.environ['APP_URL']}/upsell-success",
                feature_flags={'redirect_immediately': True},
                metadata={'upsell': 'true', 'source': 'post_purchase'}
            )
            
            # Clear the upsell offer
            del eligible_upsells[customer_id]
            
            return jsonify({'success': True, 'session_id': session.session_id})
        
        except Exception as error:
            print(f"Upsell failed: {error}")
            return jsonify({'error': 'Upsell processing failed'}), 500


    def get_upsell_product(purchased_product_id: str) -> str:
        """Determine upsell product based on purchased product."""
        upsell_map = {
            'prod_basic_plan': 'prod_pro_plan',
            'prod_starter_course': 'prod_complete_bundle',
            'prod_single_license': 'prod_team_license'
        }
        return upsell_map.get(purchased_product_id)


    if __name__ == '__main__':
        app.run(port=3000)
    ```
  </Tab>
</Tabs>

## Best Practices

<AccordionGroup>
  <Accordion title="Time Your Upsells Strategically">
    The best time to offer an upsell is immediately after a successful purchase when customers are in a buying mindset. Other effective moments:

    * After feature usage milestones
    * When approaching plan limits
    * During onboarding completion
  </Accordion>

  <Accordion title="Validate Payment Method Eligibility">
    Before attempting a one-click charge, verify the payment method:

    * Is compatible with the product's currency
    * Hasn't expired
    * Belongs to the customer

    The API will validate these, but checking proactively improves UX.
  </Accordion>

  <Accordion title="Handle Failures Gracefully">
    When one-click charges fail:

    1. Fall back to standard checkout flow
    2. Notify the customer with clear messaging
    3. Offer to update payment method
    4. Don't repeatedly attempt failed charges
  </Accordion>

  <Accordion title="Provide Clear Value Proposition">
    Upsells convert better when customers understand the value:

    * Show what they're getting vs. current plan
    * Highlight the price difference, not total price
    * Use social proof (e.g., "Most popular upgrade")
  </Accordion>

  <Accordion title="Respect Customer Choice">
    * Always provide an easy way to decline
    * Don't show the same upsell repeatedly after decline
    * Track and analyze which upsells convert to optimize offers
  </Accordion>
</AccordionGroup>

## Webhooks to Monitor

Track these webhook events for upsell and downgrade flows:

| Event                       | Trigger                                    | Action                              |
| --------------------------- | ------------------------------------------ | ----------------------------------- |
| `payment.succeeded`         | Upsell/cross-sell payment completed        | Deliver product, update access      |
| `payment.failed`            | One-click charge failed                    | Show error, offer retry or fallback |
| `subscription.plan_changed` | Upgrade/downgrade completed                | Update features, send confirmation  |
| `subscription.active`       | Subscription reactivated after plan change | Grant access to new tier            |

<Card title="Webhook Integration Guide" icon="webhook" href="/developer-resources/webhooks">
  Learn how to set up and verify webhook endpoints.
</Card>

## Related Resources

<CardGroup>
  <Card title="Subscription Upgrade Guide" icon="arrows-rotate" href="/developer-resources/subscription-upgrade-downgrade">
    Detailed guide on plan changes, proration modes, and handling failures.
  </Card>

  <Card title="Checkout Sessions" icon="cart-shopping" href="/developer-resources/checkout-session">
    Complete reference for creating checkout sessions with all options.
  </Card>

  <Card title="Customer Payment Methods API" icon="credit-card" href="/api-reference/customers/get-customer-payment-methods">
    API reference for listing customer payment methods.
  </Card>

  <Card title="Add-ons" icon="puzzle-piece" href="/features/addons">
    Enhance subscriptions with flexible add-ons for additional revenue.
  </Card>
</CardGroup>


# Event Ingestion
Source: https://docs.dodopayments.com/features/usage-based-billing/event-ingestion

Send usage events from your application to track customer consumption and power billing.

Events are the foundation of usage-based billing. Send events when billable actions occur, and meters aggregate them into charges.

<Card title="API Reference - Events Ingestion" icon="code" href="/api-reference/usage-events/ingest-events">
  Complete API documentation with examples and response codes.
</Card>

## Event Structure

<Accordion title="Required Fields">
  <ParamField type="string">
    Unique identifier. Use UUIDs or combine customer ID + timestamp + action.
  </ParamField>

  <ParamField type="string">
    Dodo Payments customer ID. Must be a valid existing customer.
  </ParamField>

  <ParamField type="string">
    Event type that matches your meter's event name (case-sensitive). Examples: `api.call`, `image.generated`
  </ParamField>
</Accordion>

<Accordion title="Optional Fields">
  <ParamField type="string">
    ISO 8601 timestamp. Defaults to server time if omitted. Include for accurate billing with delayed/batch events.
  </ParamField>

  <ParamField type="object">
    Additional properties for aggregation and filtering:

    * Numeric values: `bytes`, `tokens`, `duration_ms`
    * Filters: `endpoint`, `method`, `quality`

    ```javascript theme={null}
    metadata: {
      endpoint: "/v1/orders",
      method: "POST",
      tokens: 1024
    }
    ```
  </ParamField>
</Accordion>

## Sending Events

<CodeGroup>
  ```javascript Single Event theme={null}
  await fetch('https://test.dodopayments.com/events/ingest', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.DODO_API_KEY}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      events: [{
        event_id: "api_call_1234",
        customer_id: "cus_abc123",
        event_name: "api.call",
        metadata: { endpoint: "/v1/orders" }
      }]
    })
  });
  ```

  ```javascript Batch Events theme={null}
  await fetch('https://test.dodopayments.com/events/ingest', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.DODO_API_KEY}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      events: [
        { event_id: "call_1", customer_id: "cus_abc", event_name: "api.call" },
        { event_id: "call_2", customer_id: "cus_abc", event_name: "api.call" },
        { event_id: "call_3", customer_id: "cus_abc", event_name: "api.call" }
      ]
    })
  });
  ```

  ```python Python theme={null}
  import requests

  requests.post(
      'https://test.dodopayments.com/events/ingest',
      headers={'Authorization': f'Bearer {api_key}', 'Content-Type': 'application/json'},
      json={'events': [{'event_id': 'call_1', 'customer_id': 'cus_abc', 'event_name': 'api.call'}]}
  )
  ```

  ```curl cURL theme={null}
  curl -X POST 'https://test.dodopayments.com/events/ingest' \
    -H 'Authorization: Bearer YOUR_API_KEY' \
    -H 'Content-Type: application/json' \
    -d '{"events": [{"event_id": "call_1", "customer_id": "cus_abc", "event_name": "api.call"}]}'
  ```
</CodeGroup>

<Tip>
  Batch up to 100 events per request for better performance.
</Tip>

## Ingestion Blueprints

Ready-made event patterns for common use cases. Start with a proven blueprint instead of building from scratch.

<CardGroup>
  <Card title="LLM Blueprint" icon="brain-circuit" href="/developer-resources/ingestion-blueprints/llm">
    Track AI token usage across OpenAI, Anthropic, Groq, Gemini, and more.
  </Card>

  <Card title="API Gateway Blueprint" icon="cloud" href="/developer-resources/ingestion-blueprints/api-gateway">
    Meter API requests with endpoint filtering and rate limiting support.
  </Card>

  <Card title="Object Storage Blueprint" icon="box-archive" href="/developer-resources/ingestion-blueprints/object-storage">
    Track file uploads and storage consumption for cloud storage services.
  </Card>

  <Card title="Stream Blueprint" icon="tower-broadcast" href="/developer-resources/ingestion-blueprints/stream">
    Measure streaming bandwidth for video, audio, and real-time data.
  </Card>

  <Card title="Time Range Blueprint" icon="clock" href="/developer-resources/ingestion-blueprints/time-range">
    Bill by elapsed time for serverless functions and compute instances.
  </Card>

  <Card title="View All Blueprints" icon="copy" href="/features/usage-based-billing/ingestion-blueprints">
    See all available blueprints with detailed implementation guides.
  </Card>
</CardGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="Use Unique Event IDs">
    Use deterministic IDs to prevent duplicates: `${customerId}_${action}_${timestamp}`
  </Accordion>

  <Accordion title="Implement Retries">
    Retry on 5xx errors with exponential backoff. Don't retry 4xx errors.
  </Accordion>

  <Accordion title="Include Timestamps">
    Omit for real-time events. Include for delayed/batch events for accuracy.
  </Accordion>

  <Accordion title="Monitor Delivery">
    Track success rates and queue failed events for retry.
  </Accordion>
</AccordionGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Events not appearing">
    * Event name must exactly match meter (case-sensitive)
    * Customer ID must exist
    * Check meter filters aren't excluding events
    * Verify timestamps are recent
  </Accordion>

  <Accordion title="Authentication errors (401)">
    Verify API key is correct and use format: `Bearer YOUR_API_KEY`
  </Accordion>

  <Accordion title="Validation errors (400)">
    Ensure all required fields are present: `event_id`, `customer_id`, `event_name`
  </Accordion>

  <Accordion title="Metadata not aggregating">
    * Metadata keys must match meter's "Over Property" exactly
    * Use numbers, not strings: `tokens: 150` not `tokens: "150"`
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup>
  <Card title="Create Meters" icon="sliders" href="/features/usage-based-billing/meters">
    Define how your events are aggregated into billable quantities with filters and aggregation functions.
  </Card>

  <Card title="Ingestion Blueprints" icon="copy" href="/features/usage-based-billing/ingestion-blueprints">
    Use ready-made blueprints for common use cases like LLM tracking, API gateways, and storage.
  </Card>

  <Card title="Complete Tutorial" icon="code" href="/developer-resources/usage-based-billing-build-ai-image-generator">
    Build a full AI image generator with usage-based billing from scratch.
  </Card>

  <Card title="API Reference" icon="terminal" href="/api-reference/usage-events/ingest-events">
    Complete API documentation with all parameters, response codes, and interactive testing.
  </Card>
</CardGroup>


# Ingestion Blueprints
Source: https://docs.dodopayments.com/features/usage-based-billing/ingestion-blueprints

Ready-made event ingestion patterns for common use cases with sample code.

Ingestion blueprints are pre-built patterns for tracking usage in common scenarios. Instead of figuring out event structures and meter configurations from scratch, start with a proven blueprint and customize it for your needs.

## What Are Blueprints?

Each blueprint includes:

* **Event structure recommendations**: Optimal event naming and metadata design
* **Meter configuration**: Suggested aggregation types and filters
* **Sample code**: Working implementation examples in multiple languages
* **Best practices**: Tips for accuracy, performance, and cost optimization

<Tip>
  Blueprints save hours of setup time and help you avoid common pitfalls. Start with a blueprint, then adapt it to your specific requirements.
</Tip>

## Why Use Blueprints?

<CardGroup>
  <Card title="Faster Setup" icon="rocket">
    Get usage tracking working in minutes instead of hours. Copy proven patterns instead of designing from scratch.
  </Card>

  <Card title="Best Practices Built In" icon="shield-check">
    Avoid common mistakes with tested event structures, proper metadata, and optimal aggregation choices.
  </Card>

  <Card title="Production Ready" icon="code">
    Sample code is based on real-world implementations. Just add your API keys and go.
  </Card>
</CardGroup>

## Available Blueprints

Choose the blueprint that matches your use case:

<CardGroup>
  <Card title="LLM Blueprint" icon="brain-circuit" href="/developer-resources/ingestion-blueprints/llm">
    Track AI token usage across OpenAI, Anthropic, Groq, Gemini, Vercel AI SDK, and more.

    **Perfect for**: AI chatbots, code generators, content creation tools, AI-powered apps.

    **What you'll track**: Input tokens, output tokens, model usage, request counts.
  </Card>

  <Card title="API Gateway Blueprint" icon="cloud" href="/developer-resources/ingestion-blueprints/api-gateway">
    Meter API requests at the gateway level with endpoint filtering and rate limiting support.

    **Perfect for**: REST APIs, GraphQL services, webhook providers, API-first platforms.

    **What you'll track**: Request counts, endpoint usage, HTTP methods, response times.
  </Card>

  <Card title="Object Storage Blueprint" icon="box-archive" href="/developer-resources/ingestion-blueprints/object-storage">
    Track file uploads, storage consumption, and bandwidth for cloud storage services.

    **Perfect for**: File hosting, media platforms, backup services, document management.

    **What you'll track**: Bytes stored, file uploads, downloads, storage snapshots.
  </Card>

  <Card title="Stream Blueprint" icon="tower-broadcast" href="/developer-resources/ingestion-blueprints/stream">
    Measure streaming bandwidth for video, audio, and real-time data delivery.

    **Perfect for**: Video streaming, audio platforms, live broadcasts, real-time data feeds.

    **What you'll track**: Bandwidth consumed, stream duration, quality levels, concurrent streams.
  </Card>

  <Card title="Time Range Blueprint" icon="clock" href="/developer-resources/ingestion-blueprints/time-range">
    Bill by elapsed time for compute resources, serverless functions, and long-running jobs.

    **Perfect for**: Serverless platforms, container hosting, compute instances, batch processing.

    **What you'll track**: Execution time, compute hours, function invocations, job duration.
  </Card>
</CardGroup>

## How to Use a Blueprint

<Steps>
  <Step title="Choose your blueprint">
    Select the blueprint that best matches your billing scenario. Each blueprint page includes detailed implementation guides.
  </Step>

  <Step title="Review the event structure">
    Understand the recommended event naming and metadata design. Copy the event structure for your use case.
  </Step>

  <Step title="Create the meter">
    Follow the blueprint's meter configuration instructions. Use the suggested aggregation type and filters.
  </Step>

  <Step title="Implement event sending">
    Copy the sample code for your language/framework. Replace placeholder values with your actual API keys and customer IDs.
  </Step>

  <Step title="Test and verify">
    Send test events and verify they appear in your meter dashboard with correct aggregation.
  </Step>

  <Step title="Customize as needed">
    Adapt the blueprint to your specific requirements—add custom metadata, adjust filters, or modify pricing.
  </Step>
</Steps>

## Blueprint Comparison

Not sure which blueprint fits your needs? Here's a quick comparison:

| Use Case       | Blueprint      | Aggregation     | Common Metadata                      |
| -------------- | -------------- | --------------- | ------------------------------------ |
| AI chat app    | LLM            | Sum (tokens)    | model, input\_tokens, output\_tokens |
| REST API       | API Gateway    | Count           | endpoint, method, status\_code       |
| File storage   | Object Storage | Sum (bytes)     | file\_size, file\_type, operation    |
| Video platform | Stream         | Sum (bandwidth) | duration, quality, bitrate           |
| Serverless     | Time Range     | Sum (duration)  | function\_name, execution\_time\_ms  |

## Custom Implementations

Don't see a blueprint for your exact use case? No problem:

1. **Start with the closest blueprint**: Pick the one most similar to your needs
2. **Adapt the event structure**: Modify metadata fields to match your requirements
3. **Adjust meter configuration**: Change aggregation type or filters as needed
4. **Test thoroughly**: Verify billing calculations with sample usage

<Info>
  All blueprints are starting points. Feel free to mix concepts from different blueprints or create entirely custom implementations.
</Info>

## Need Help?

If you're unsure which blueprint to use or need help customizing:

<CardGroup>
  <Card title="Complete Tutorial" icon="code" href="/developer-resources/usage-based-billing-build-ai-image-generator">
    Follow our end-to-end tutorial building an AI image generator with usage billing.
  </Card>

  <Card title="Integration Guide" icon="book" href="/developer-resources/usage-based-billing-guide">
    Comprehensive guide covering all aspects of usage-based billing implementation.
  </Card>
</CardGroup>


# Usage Based Billing
Source: https://docs.dodopayments.com/features/usage-based-billing/introduction

Charge customers based on what they actually use with flexible metering and automated billing.

Usage-based billing lets you charge customers for what they actually use—API calls, storage, AI tokens, or any metric you define. Customers pay for consumption, not fixed fees.

<Info>
  **Perfect for**: APIs, AI services, infrastructure platforms, and any product where value scales with usage.
</Info>

## How It Works

<Steps>
  <Step title="Send Usage Events">
    Your application sends events when billable actions occur.

    ```javascript theme={null}
    {
      "event_id": "evt_123",
      "customer_id": "cus_abc",
      "event_name": "api.call",
      "metadata": { "endpoint": "/v1/users" }
    }
    ```
  </Step>

  <Step title="Meters Aggregate Usage">
    Meters aggregate events into billable quantities using Count, Sum, Max, or Last aggregation.
  </Step>

  <Step title="Automatic Billing">
    Set pricing per unit and free thresholds. Customers are billed automatically each cycle.
  </Step>
</Steps>

## Core Concepts

### Events

Events represent usage actions in your application. Each event includes:

* **Event Name**: Type of usage (e.g., `api.call`)
* **Customer ID**: Who used it
* **Metadata**: Additional properties for aggregation

### Meters

Meters aggregate events into billable quantities:

* **Count**: Total events (API calls)
* **Sum**: Add values (total bytes)
* **Max**: Highest value (peak users)
* **Last**: Most recent value

<Frame>
  <img alt="Create meter interface" />
</Frame>

### Products with Usage Pricing

Set pricing per unit and optional free thresholds:

<Frame>
  <img alt="Pricing configuration" />
</Frame>

**Example**: 2,500 calls - 1,000 free = 1,500 × $0.02 = $30.00

### Customer Credits

Give customers included usage credits that refresh each billing cycle. Credits apply before paid usage.

## Quick Start

<Steps>
  <Step title="Create a Meter">
    In your dashboard: **Meters** → **Create Meter**

    1. Set event name (e.g., `api.call`)
    2. Choose aggregation (Count, Sum, Max, Last)
    3. Add optional filters
  </Step>

  <Step title="Add to Product">
    Link meter to a product with pricing:

    <Frame>
      <img alt="Adding meter to product" />
    </Frame>

    1. Select **Usage-Based Billing**
    2. Choose your meter
    3. Set price per unit and free threshold
  </Step>

  <Step title="Send Events">
    ```javascript theme={null}
    await fetch('https://test.dodopayments.com/events/ingest', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.DODO_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        events: [{
          event_id: "unique_event_id",
          customer_id: "cus_abc123",
          event_name: "api.call",
          metadata: { endpoint: "/v1/users" }
        }]
      })
    });
    ```
  </Step>

  <Step title="Monitor Usage">
    <Frame>
      <img alt="Meter dashboard" />
    </Frame>

    Check your meter's dashboard to see events and usage aggregation. Customers are billed automatically each cycle.
  </Step>
</Steps>

## Use Cases

<CardGroup>
  <Card title="APIs & Infrastructure" icon="cloud">
    Track API calls, compute hours, bandwidth, storage. Example: \$0.001 per call after 10,000 free.
  </Card>

  <Card title="AI Usage Tracking" icon="brain">
    Track tokens, generations, processing time. Example: \$0.04 per standard image, \$0.08 per HD.
  </Card>

  <Card title="Data & Analytics" icon="chart-line">
    Bill by data processed, queries run, records analyzed. Example: \$5 per GB after 10 GB free.
  </Card>

  <Card title="Communication" icon="message">
    Count messages, minutes, data transferred. Example: \$0.01 per SMS sent.
  </Card>
</CardGroup>

## Next Steps

<CardGroup>
  <Card title="Event Ingestion" icon="bolt" href="/features/usage-based-billing/event-ingestion">
    Learn how to structure and send usage events from your application.
  </Card>

  <Card title="Meters Guide" icon="sliders" href="/features/usage-based-billing/meters">
    Master meter configuration, aggregation types, and event filtering.
  </Card>

  <Card title="Complete Tutorial" icon="code" href="/developer-resources/usage-based-billing-build-ai-image-generator">
    Build a complete AI image generator with usage-based billing from scratch.
  </Card>

  <Card title="Integration Guide" icon="book" href="/developer-resources/usage-based-billing-guide">
    Comprehensive guide to implementing usage-based billing in your application.
  </Card>
</CardGroup>


# Meters
Source: https://docs.dodopayments.com/features/usage-based-billing/meters

Transform raw usage events into billable quantities with aggregation and filtering.

<Info>
  Meters convert raw events into billable quantities. They filter events and apply aggregation functions (Count, Sum, Max, Last) to calculate usage per customer.
</Info>

<Frame>
  <img alt="Meter creation interface showing event name, aggregation type, and filtering options" />
</Frame>

## API Resources

<AccordionGroup>
  <Accordion title="View Meter API References">
    <CardGroup>
      <Card title="Create Meter" icon="plus" href="/api-reference/meters/create-meter">
        Create meters programmatically via API.
      </Card>

      <Card title="List Meters" icon="list" href="/api-reference/meters/get-meters">
        Retrieve all meters in your account.
      </Card>

      <Card title="Get Meter" icon="eye" href="/api-reference/meters/retrieve-meter">
        Fetch details for a specific meter by ID.
      </Card>

      <Card title="Archive Meter" icon="arrow-rotate-right" href="/api-reference/meters/archive-meter">
        Archive a meter to stop tracking usage.
      </Card>

      <Card title="Unarchive Meter" icon="arrow-rotate-left" href="/api-reference/meters/unarchive-meter">
        Restore an archived meter to resume tracking.
      </Card>
    </CardGroup>
  </Accordion>
</AccordionGroup>

## Creating a Meter

<Steps>
  <Step title="Basic Information">
    <ParamField type="string">
      Descriptive name (e.g., "API Requests", "Token Usage")
    </ParamField>

    <ParamField type="string">
      Exact event name to match (case-sensitive). Examples: `api.call`, `image.generated`
    </ParamField>
  </Step>

  <Step title="Aggregation">
    <ParamField type="string">
      Choose how events are aggregated:

      * **Count**: Total number of events (API calls, uploads)
      * **Sum**: Add numeric values (tokens, bytes)
      * **Max**: Highest value in period (peak users)
      * **Last**: Most recent value
    </ParamField>

    <ParamField type="string">
      Metadata key to aggregate (required for all types except Count). Examples: `tokens`, `bytes`, `duration_ms`
    </ParamField>

    <ParamField type="string">
      Unit label for invoices. Examples: `calls`, `tokens`, `GB`, `hours`
    </ParamField>
  </Step>

  <Step title="Filtering (Optional)">
    <Frame>
      <img alt="Event filtering" />
    </Frame>

    Add conditions to filter which events are counted:

    * **AND logic**: All conditions must match
    * **OR logic**: Any condition can match

    **Comparators**: equals, not equals, greater than, less than, contains

    Enable filtering, choose logic, add conditions with property key, comparator, and value.
  </Step>

  <Step title="Create">
    Review configuration and click **Create Meter**.
  </Step>
</Steps>

## Viewing Analytics

<Frame>
  <img alt="Meter analytics" />
</Frame>

Your meter dashboard shows:

* **Overview**: Total usage and usage chart
* **Events**: Individual events received
* **Customers**: Per-customer usage and charges

## Troubleshooting

<AccordionGroup>
  <Accordion title="Events not appearing">
    * Event name must match exactly (case-sensitive)
    * Check meter filters aren't excluding events
    * Verify customer IDs exist
    * Temporarily disable filters to test
  </Accordion>

  <Accordion title="Aggregation not working">
    * Verify Over Property matches metadata key exactly
    * Use numbers, not strings: `tokens: 150` not `"150"`
    * Include required properties in all events
  </Accordion>

  <Accordion title="Filters not working">
    * Match case exactly
    * Use correct operators for data type
    * Ensure events include filtered properties
  </Accordion>

  <Accordion title="Wrong usage totals">
    * Check Events tab to count actual events received
    * Verify aggregation type (Count vs Sum)
    * Ensure values are numeric for Sum/Max
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup>
  <Card title="Send Events" icon="bolt" href="/features/usage-based-billing/event-ingestion">
    Start sending usage events from your application to your meters.
  </Card>

  <Card title="View Blueprints" icon="copy" href="/features/usage-based-billing/ingestion-blueprints">
    Use ready-made meter configurations for common use cases.
  </Card>
</CardGroup>


# Figma Plugin Boilerplate
Source: https://docs.dodopayments.com/integrations/figma-plugin

Build Figma plugins with Dodo Payments license key validation and activation

This is an example implementation and boilerplate designed as a starting point for Figma plugin developers who want to integrate Dodo Payments license key API to grant access to their plugins. The template demonstrates complete license key validation and activation functionality, providing everything you need to create premium Figma plugins with built-in licensing.

## Features

* **License Key Validation**: Validates license keys against the Dodo Payments API
* **License Key Activation**: Activates license keys with user identification
* **Environment Support**: Configurable for both test and live environments
* **CORS Proxy**: Uses a Cloudflare Worker proxy to handle CORS restrictions
* **TypeScript Support**: Fully typed implementation with proper error handling

## Getting Started

<Steps>
  <Step title="Create Base Plugin">
    Create your own Figma plugin project using [Figma's plugin quickstart guide](https://www.figma.com/plugin-docs/plugin-quickstart-guide/). This will generate a scaffold with a `manifest.json` file.

    <Tip>
      This step is just to get a unique name and ID for your plugin. You can discard the generated files after committing the ID and name to your git repository in the next step.
    </Tip>
  </Step>

  <Step title="Clone the Example Implementation">
    Clone the [dodopayments-figma repository](https://github.com/dodopayments/dodopayments-figma) and update its `manifest.json` with the name and ID from your generated plugin folder.

    ```bash theme={null}
    git clone https://github.com/dodopayments/dodopayments-figma.git
    cd dodopayments-figma
    ```

    This example serves as your starting point for integration.

    <Tip>
      You need to change the remote origin URL to your own repository for version control.
    </Tip>
  </Step>

  <Step title="Install Dependencies">
    Run the following command in your project root:

    ```bash theme={null}
    npm install
    ```
  </Step>

  <Step title="Configure Environment">
    Set the `API_MODE` in `src/ui/api.ts`:

    ```typescript theme={null}
    const API_MODE = "test_mode"; // for development
    // const API_MODE = "live_mode"; // for production
    ```

    <Warning>
      Always use `test_mode` during development to avoid processing real payments.
    </Warning>
  </Step>

  <Step title="Customize Components">
    Customize the plugin components to match your needs:

    * Update `Authenticated.tsx` to expose functionality for users with valid license keys
    * Customize `LicenseKeyInput.tsx` to match your design preferences

    <Note>
      The `Authenticated.tsx` component is where you'll add your plugin's premium features that require a valid license.
    </Note>
  </Step>
</Steps>

## Configuration

<Steps>
  <Step title="Configure Network Access">
    The plugin needs network access to communicate with the CORS proxy. Add the following to your `manifest.json`:

    ```json theme={null}
    {
      "networkAccess": {
        "allowedDomains": ["https://dodo-payments-proxy.aagarwal9782.workers.dev"]
      }
    }
    ```

    This allows the plugin to validate and activate license keys using the Dodo Payments API.

    <Info>
      The CORS proxy is necessary because Dodo Payments API doesn't allow API calls from browser-based applications as of now.
    </Info>
  </Step>

  <Step title="Configure API Mode">
    In `src/ui/api.ts`, configure the API mode:

    ```typescript theme={null}
    const API_MODE = "test_mode"; // or "live_mode"
    ```

    <Tip>
      Switch to `live_mode` only when you're ready for production and have tested thoroughly in test mode.
    </Tip>
  </Step>
</Steps>

## Development

<Steps>
  <Step title="Import Plugin">
    Import the plugin into Figma using "Import Manifest" from the Figma desktop app.

    <Note>
      You'll need to have the Figma desktop app installed to develop and test plugins locally.
    </Note>
  </Step>

  <Step title="Start Development Server">
    ```bash theme={null}
    npm run dev
    ```

    This starts the development server with file watching for automatic rebuilds.

    <Check>
      Your plugin will automatically rebuild when you make changes to the source code.
    </Check>
  </Step>
</Steps>

## Build Commands

| Command          | Description                                 |
| ---------------- | ------------------------------------------- |
| `npm run build`  | Build the plugin for production             |
| `npm run dev`    | Start development server with file watching |
| `npm run lint`   | Check code style and errors                 |
| `npm run format` | Format code with Prettier                   |

## License Key Integration

The example implementation includes complete license key validation and activation that you can customize for your plugin:

1. **User Input**: Users enter their license key in the plugin UI
2. **Validation**: The plugin validates the key against Dodo Payments API
3. **Activation**: Valid keys are activated with user identification
4. **Access Control**: Plugin functionality is unlocked for valid license holders

## Publishing

Once your plugin is ready:

1. Build for production: `npm run build`
2. Test thoroughly in both test and live modes
3. Follow [Figma's plugin publishing guidelines](https://www.figma.com/plugin-docs/publishing-plugins/)
4. Submit for review through the Figma Community

## Repository

The complete example implementation is available at: [github.com/dodopayments/dodopayments-figma](https://github.com/dodopayments/dodopayments-figma)

Use this as your starting point to build your own premium Figma plugin with Dodo Payments license key integration.


# Welcome to Dodo Payments
Source: https://docs.dodopayments.com/introduction

The complete payments & billing platform for SaaS, AI, and digital products. Accept payments globally, set up flexible billing models, and monetize your product in minutes - all without building your own infrastructure.

<Frame>
  <img alt="Dodo Payments - Complete payments and billing platform for modern digital products" />
</Frame>

## What is Dodo Payments?

Dodo Payments is the **all-in-one engine** to launch, scale, and monetize worldwide. Designed for the new generation of digital SaaS and AI products, we handle everything from **payments to billing to distribution** - all without extra engineering.

<Info>
  **Built for SaaS and AI Products**: Handle one-time payments, subscriptions, credits, seats, tokens, or any usage metric with our optimized billing infrastructure.
</Info>

<Tip>
  <strong>Meet Sentra: Your AI-powered billing assistant</strong><br />
  Sentra is an AI agent that integrates, analyzes, and acts on billing and payments directly in your IDE. Ask questions, build integrations, or plan billing architectures - all by describing what you want.

  <a href="/developer-resources/sentra">
    Get started with Sentra →
  </a>
</Tip>

### Why Choose Dodo Payments?

<CardGroup>
  <Card title="All-in-One Platform" icon="box">
    One solution for payments, billing, and distribution—no more piecing tools together
  </Card>

  <Card title="Global Merchant of Record" icon="globe">
    Go global without complexity: built-in coverage in 150+ countries, 80+ currencies, and 30+ payment methods
  </Card>

  <Card title="Developer-First & No-Code" icon="code">
    Seamless APIs and SDKs for fast integration, plus <a href="/developer-resources/sentra">Sentra AI agent</a> to build integrations by just describing what you need
  </Card>

  <Card title="Faster Monetization" icon="bolt">
    Start collecting revenue in minutes, not weeks
  </Card>

  <Card title="Flexible Billing Models" icon="repeat">
    Usage-based, subscriptions with addons, or one-time payments are built in
  </Card>

  <Card title="Optimized for AI Products" icon="brain">
    Handle credits, seats, tokens, or any usage metric
  </Card>
</CardGroup>

## Quick Start Guide

Get up and running with Dodo Payments in just a few steps:

<Steps>
  <Step title="Create Your Account">
    Sign up at [app.dodopayments.com](https://app.dodopayments.com/signup) using your email.

    <Check>
      You'll receive a confirmation email to verify your account.
    </Check>
  </Step>

  <Step title="Add Your First Product">
    Choose your billing model and add your product to start accepting payments.

    <CardGroup>
      <Card title="One-Time Payment" icon="box" href="/features/one-time-payment-products">
        Perfect for digital downloads, courses, or single purchases
      </Card>

      <Card title="Subscription Product" icon="repeat" href="/features/subscription">
        Ideal for SaaS, memberships, or recurring services
      </Card>

      <Card title="Usage-Based Billing" icon="chart-bar" href="/features/usage-based-billing">
        Bill customers for API calls, credits, tokens, or any usage metric - ideal for AI and SaaS
      </Card>
    </CardGroup>
  </Step>

  <Step title="Choose Your Integration Method">
    Select the integration approach that best fits your needs and technical requirements.

    <Tabs>
      <Tab title="No-Code (Fastest)">
        **Perfect for getting started quickly:**

        * Create **Payment Links** from your dashboard
        * Share via email, social media, or embed in websites
        * Start accepting payments immediately
      </Tab>

      <Tab title="Overlay Checkout">
        **Best for seamless, on-brand payments:**

        * Launch checkout as an overlay on your site or app
        * Keep users on your page for a frictionless experience
        * Customize appearance to match your brand

        <Card title="Overlay Integration" icon="layer-group" href="/developer-resources/overlay-checkout">
          Add our overlay checkout with a single line of code
        </Card>
      </Tab>

      <Tab title="Inline Checkout">
        **Best for fully integrated, embedded checkout experiences:**

        * Embed checkout directly into your page layout
        * Build custom order summaries that sync with checkout
        * Maximum control over checkout design and flow

        <Card title="Inline Integration" icon="credit-card" href="/developer-resources/inline-checkout">
          Embed checkout directly into your website
        </Card>
      </Tab>

      <Tab title="Full SDK Integration">
        **Best for advanced, fully customized solutions:**

        * Use our TypeScript/Python/Go/Java/Kotlin/C#/Ruby SDK for seamless integration
        * Programmatic access to all payment, subscription, and customer portal APIs
        * Deep integration with your backend, workflows, and data models
        * Full support for webhooks, advanced features, and automation

        <Tip>
          <strong>Skip the manual work with Sentra</strong><br />
          Install our AI agent in VS Code, Cursor, or Windsurf. Describe what you want - SDK integration, webhook handlers, subscription flows - and Sentra generates the code for you.

          <a href="/developer-resources/sentra">
            Install Sentra →
          </a>
        </Tip>

        <Card title="SDK Quickstart" icon="code" href="/developer-resources/integration-guide">
          Learn how to install and use our official SDK
        </Card>

        <Card title="API Reference" icon="server" href="/api-reference/introduction">
          Explore the full API and SDK documentation
        </Card>
      </Tab>
    </Tabs>
  </Step>
</Steps>

## Developer Integration

<Card title="Sentra: AI-Powered Integration Assistant" icon="wand-magic-sparkles" href="/developer-resources/sentra">
  **Build billing integrations by describing what you need.** Sentra is an AI agent for VS Code, Cursor, and Windsurf that generates SDK code, webhook handlers, subscription flows, and more. Use **Ask** mode to learn, **Build** mode to implement, or **Plan** mode to architect your billing system.
</Card>

### MCP Servers for AI Assistants

Connect your AI coding assistant (Cursor, Claude Desktop, Windsurf, VS Code) directly to Dodo Payments with our MCP servers.

<CardGroup>
  <Card title="Dodo Knowledge MCP" icon="book-open" href="/developer-resources/mcp-server#dodo-knowledge-mcp">
    Semantic search across Dodo Payments documentation - get instant answers about features, APIs, and best practices
  </Card>

  <Card title="Dodo Payments MCP" icon="credit-card" href="/developer-resources/mcp-server">
    Execute API operations directly - create payments, manage subscriptions, and handle refunds through your AI assistant
  </Card>
</CardGroup>

<Accordion title="Quick MCP Setup for Cursor/Claude Desktop">
  Add both servers to your MCP configuration (`~/.cursor/mcp.json` or Claude Desktop config):

  ```json theme={null}
  {
    "mcpServers": {
      "dodo-knowledge": {
        "command": "npx",
        "args": ["-y", "mcp-remote@latest", "https://knowledge.dodopayments.com/mcp"]
      },
      "dodopayments": {
        "command": "npx",
        "args": ["-y", "mcp-remote@latest", "https://mcp.dodopayments.com/sse"]
      }
    }
  }
  ```

  <Info>
    Requires Node.js 18+. See the [MCP Server documentation](/developer-resources/mcp-server) for detailed setup instructions for all supported clients.
  </Info>
</Accordion>

### Agent Skills

Enhance your AI coding assistant with official Dodo Payments skills - reusable capabilities that teach agents how to implement payment integrations, webhook handlers, and billing flows correctly.

<Card title="Dodo Payments Skills" icon="wand-magic-sparkles" href="/developer-resources/agent-skills">
  Install skills for checkout integration, subscriptions, usage-based billing, webhooks, and more. Works with Claude Code, OpenCode, Cursor, and any MCP-compatible agent.
</Card>

<Accordion title="Quick Skills Installation">
  ```bash theme={null}
  # Install all Dodo Payments skills
  npx skills add dodopayments/skills

  # Or install individual skills
  npx skills add dodopayments/skills/dodo-best-practices
  npx skills add dodopayments/skills/webhook-integration
  npx skills add dodopayments/skills/subscription-integration
  ```

  <Info>
    See the [Agent Skills documentation](/developer-resources/agent-skills) for Claude Code, OpenCode, and other client setup instructions.
  </Info>
</Accordion>

### Framework Adapters

Integrate in under 10 lines of code with our framework adapters. Choose from our recommended frameworks or explore all supported options.

#### Recommended Frameworks

<CardGroup>
  <Card title="Next.js" icon="atom" href="/developer-resources/nextjs-adaptor">
    React-based full-stack framework with App Router support
  </Card>

  <Card title="Better Auth" icon="shield" href="/developer-resources/better-auth-adaptor">
    Authentication framework with built-in integrations
  </Card>

  <Card title="Supabase" icon="database" href="developer-resources/supabase-boilerplate">
    Open source Firebase alternative with Postgres and Auth
  </Card>

  <Card title="Convex" icon="database" href="/developer-resources/convex-component">
    Backend-as-a-Service with real-time capabilities
  </Card>
</CardGroup>

<AccordionGroup>
  <Accordion title="Show other 8+ supported frameworks">
    <CardGroup>
      <Card title="SvelteKit" icon="js" href="/developer-resources/sveltekit-adaptor" />

      <Card title="Nuxt" icon="vuejs" href="/developer-resources/nuxt-adaptor" />

      <Card title="Remix" icon="react" href="/developer-resources/remix-adaptor" />

      <Card title="Express" icon="js" href="/developer-resources/express-adaptor" />

      <Card title="Fastify" icon="bolt" href="/developer-resources/fastify-adaptor" />

      <Card title="Hono" icon="cloud" href="/developer-resources/hono-adaptor" />

      <Card title="Astro" icon="star" href="/developer-resources/astro-adaptor" />

      <Card title="TanStack" icon="chart-line" href="/developer-resources/tanstack-adaptor" />
    </CardGroup>
  </Accordion>
</AccordionGroup>

### Powerful SDKs

Speed up development with our official SDKs. Choose from our recommended languages or explore all supported options.

<CardGroup>
  <Card title="TypeScript" icon="code-simple" href="/developer-resources/dodo-payments-sdks#typescript" />

  <Card title="Python" icon="python" href="/developer-resources/dodo-payments-sdks#python" />

  <Card title="Go" icon="golang" href="/developer-resources/dodo-payments-sdks#go" />

  <Card title="PHP" icon="php" href="/developer-resources/dodo-payments-sdks#php" />

  <Card title="Java" icon="java" href="/developer-resources/dodo-payments-sdks#java" />

  <Card title="Kotlin" icon="android" href="/developer-resources/dodo-payments-sdks#kotlin" />

  <Card title="C#" icon="hashtag" href="/developer-resources/dodo-payments-sdks#c%23" />

  <Card title="Ruby" icon="gem" href="/developer-resources/dodo-payments-sdks#ruby" />
</CardGroup>

### Billing SDK

Stop reinventing the wheel. Use production-ready, accessible billing components, from pricing cards to subscription dashboards, built for React and ShadCN.

<Card title="Billing Components" icon="credit-card" href="https://billingsdk.com">
  Beautiful, customizable billing components, pricing tables, subscription management, and usage meters - save development time with production-ready UI for billing and payments.
</Card>

<Info>
  **Open Source & Free**: BillingSDK is completely free to use and modify for personal and commercial projects. Built by the Dodo Payments team for developers.
</Info>

### In-App Purchases for Android and iOS

Build rich in-app payment experiences with our lightweight payment links and secure React Native SDKs optimized for iOS and Android.

<CardGroup>
  <Card title="Mobile Integration Guide" icon="book" href="/developer-resources/mobile-integration">
    Complete guide for integrating payments in mobile applications
  </Card>

  <Card title="React Native SDK" icon="mobile" href="/developer-resources/react-native-integration">
    Native mobile SDK for iOS and Android with seamless payment flows
  </Card>

  <Card title="Expo Boilerplate" icon="box-open" href="/developer-resources/expo-boilerplate">
    Jumpstart your React Native in-app payments with our open source Expo template
  </Card>
</CardGroup>

## External Integrations

Connect Dodo Payments with your favorite tools and platforms to automate workflows, send notifications, and enhance your payment operations.

<Info>
  **Automate Everything**: Set up real-time notifications, trigger workflows, sync customer data, and more with our growing library of integrations.
</Info>

### Popular Integrations

Quickly connect Dodo Payments to the most used design and productivity tools to streamline your workflow and automate payment operations.

<CardGroup>
  <Card title="Framer Plugin" icon="frame" href="/integrations/framer-plugin">
    Add payments to Framer websites
  </Card>

  <Card title="WooCommerce" icon="wordpress" href="/integrations/woocommerce-plugin">
    Accept payments on WooCommerce stores
  </Card>

  <Card title="Raycast Extension" icon="rocket" href="/integrations/raycast-extension">
    Manage payments from Raycast
  </Card>

  <Card title="Figma Plugin" icon="figma" href="/integrations/figma-plugin">
    Access Dodo Payments in Figma
  </Card>
</CardGroup>

<AccordionGroup>
  <Accordion title="Communication & Notifications">
    Stay informed about payment events with real-time notifications in your team communication tools.

    <CardGroup>
      <Card title="Slack" icon="slack" href="/integrations/slack">
        Send payment notifications and alerts to Slack channels
      </Card>

      <Card title="Discord" icon="discord" href="/integrations/discord">
        Get instant payment updates in your Discord server
      </Card>

      <Card title="Microsoft Teams" icon="microsoft" href="/integrations/microsoft-teams">
        Receive payment notifications directly in Teams channels
      </Card>
    </CardGroup>
  </Accordion>

  <Accordion title="Email Marketing & Customer Communication">
    Sync customer data and trigger email campaigns based on payment events.

    <CardGroup>
      <Card title="Resend" icon="envelope" href="/integrations/resend">
        Send transactional emails with Resend
      </Card>

      <Card title="SendGrid" icon="paper-plane" href="/integrations/sendgrid">
        Automate email campaigns with SendGrid
      </Card>

      <Card title="Loops" icon="repeat" href="/integrations/loops">
        Trigger email sequences with Loops
      </Card>

      <Card title="Customer.io" icon="users" href="/integrations/customer-io">
        Sync customer data to Customer.io
      </Card>

      <Card title="AutoSend" icon="paper-plane" href="/integrations/autosend">
        Send automated transactional emails with AutoSend
      </Card>
    </CardGroup>
  </Accordion>

  <Accordion title="CRM & Sales">
    Connect your payment data with CRM platforms to streamline sales and customer management.

    <CardGroup>
      <Card title="HubSpot" icon="hubspot" href="/integrations/hubspot">
        Sync customers and deals with HubSpot CRM
      </Card>

      <Card title="Close CRM" icon="briefcase" href="/integrations/close-crm">
        Automate sales workflows with Close CRM
      </Card>
    </CardGroup>
  </Accordion>

  <Accordion title="Automation & Workflows">
    Build powerful automations and data pipelines with workflow automation platforms.

    <CardGroup>
      <Card title="Zapier" icon="bolt" href="/integrations/zapier">
        Connect to 5,000+ apps with Zapier
      </Card>

      <Card title="N8N" icon="diagram-project" href="/integrations/n8n">
        Automate workflows with self-hosted or cloud N8N
      </Card>

      <Card title="Windmill" icon="wind" href="/integrations/windmill">
        Build custom workflows with Windmill
      </Card>

      <Card title="Inngest" icon="code" href="/integrations/inngest">
        Create event-driven workflows with Inngest
      </Card>

      <Card title="Segment" icon="chart-network" href="/integrations/segment">
        Stream payment data to Segment CDP
      </Card>

      <Card title="DataFast" icon="chart-bar" href="/integrations/datafast">
        Attribute revenue to marketing channels with DataFast analytics
      </Card>
    </CardGroup>
  </Accordion>
</AccordionGroup>

<Card title="View All Integrations" icon="puzzle-piece" href="/integrations/introduction">
  Explore our complete library of integrations with detailed setup guides
</Card>

## Need Help?

<CardGroup>
  <Card title="Developer Documentation" icon="book" href="/developer-resources/integration-guide">
    Explore comprehensive guides and API references
  </Card>

  <Card title="API Reference" icon="terminal" href="/api-reference/introduction">
    Full OpenAPI reference, endpoints, parameters, and example requests for all Dodo Payments APIs
  </Card>

  <Card title="Community Support" icon="users" href="https://discord.gg/bYqAp4ayYh">
    Join our Discord community for help and discussions
  </Card>

  <Card title="Contact Support" icon="headphones" href="mailto:support@dodopayments.com">
    Get direct help from our support team
  </Card>
</CardGroup>


# Migrate to Dodo Payments
Source: https://docs.dodopayments.com/migrate-to-dodo

Easily migrate your data from other payment providers to Dodo Payments using our CLI tool

**Switching from another payment provider to Dodo Payments?** Our migration tool makes it easy to move your **products, customers, and discount codes without losing any data.** The process is safe, guided, and can be done in just a few minutes.

We currently support migrations from **Lemon Squeezy, Stripe, Polar.sh, and Paddle**.

### Supported Migrations

<CardGroup>
  <Card title="Products & Pricing" icon="box">
    Migrate all your products and pricing details.
  </Card>

  <Card title="Customer Data" icon="users">
    Transfer your complete customer database, including contact details.
  </Card>

  <Card title="Discount Codes & Promotions" icon="tag">
    Move all discount codes and promotional offers seamlessly.
  </Card>
</CardGroup>

## Get Started

First, install the migration tool:

```bash theme={null}
npm install -g dodo-migrate
```

<Note>
  You'll need Node.js ≥ 18 installed on your computer.
</Note>

## Migrate Your Data

### If you're coming from Lemon Squeezy:

```bash theme={null}
dodo-migrate lemonsqueezy
```

### If you're coming from Stripe:

```bash theme={null}
dodo-migrate stripe
```

### If you're coming from Polar.sh:

```bash theme={null}
dodo-migrate polar
```

### If you're coming from Paddle:

```bash theme={null}
dodo-migrate paddle
```

The tool will walk you through everything step by step. You'll need:

* Your provider's API key (Lemon Squeezy, Stripe, Polar.sh, Paddle, etc.)
* Your Dodo Payments API key
* Whether you want to test first (recommended) or go live
* Which Dodo Payments brand to migrate to

## Why Use Our Migration Tool?

* **No data loss** - Everything transfers safely
* **Test first** - Try it in test mode before going live
* **Guided process** - We walk you through each step
* **Resume if needed** - If something goes wrong, you can pick up where you left off

## Advanced Usage

If you prefer to run the migration without prompts, you can provide all the details upfront:

### Lemon Squeezy migration:

```bash theme={null}
dodo-migrate lemonsqueezy \
  --provider-api-key=lsq_XXXXXXXXXXXXXXXX \
  --dodo-api-key=dp_XXXXXXXXXXXXXXXX \
  --mode=test_mode \
  --dodo-brand-id=brand_XXXXXX
```

### Stripe migration:

```bash theme={null}
dodo-migrate stripe \
  --provider-api-key=sk_test_XXXXXXXXXXXXXXXX \
  --dodo-api-key=dp_XXXXXXXXXXXXXXXX \
  --mode=test_mode \
  --dodo-brand-id=brand_XXXXXX \
  --migrate-types=products,coupons
```

### Polar.sh migration:

```bash theme={null}
dodo-migrate polar \
  --provider-api-key=polar_org_XXXXXXXXXXXXXXXX \
  --dodo-api-key=dp_XXXXXXXXXXXXXXXX \
  --mode=test_mode \
  --dodo-brand-id=brand_XXXXXX \
  --migrate-types=products,discounts,customers
```

### Paddle migration:

```bash theme={null}
dodo-migrate paddle \
  --provider-api-key=paddle_XXXXXXXXXXXXXXXX \
  --dodo-api-key=dp_XXXXXXXXXXXXXXXX \
  --mode=test_mode \
  --dodo-brand-id=brand_XXXXXX
```

## Need Help?

* **Tool help**: `dodo-migrate --help`
* **Lemon Squeezy help**: `dodo-migrate lemonsqueezy --help`
* **Stripe help**: `dodo-migrate stripe --help`
* **Polar.sh help**: `dodo-migrate polar --help`
* **Paddle help**: `dodo-migrate paddle --help`
* **Community support**: [Discord](https://discord.gg/bYqAp4ayYh)
* **Report issues**: [GitHub](https://github.com/dodopayments/dodo-migrate)

## Update the Tool

```bash theme={null}
# Update to latest version
npm update -g dodo-migrate

# Remove the tool
npm uninstall -g dodo-migrate
```


# My Accounts
Source: https://docs.dodopayments.com/miscellaneous/accounts

Merchant can access and manage their personal account information such as Contact Name, Profile Image and phone number for a more personalised experience through the my account section.

## **Business Profile**

<Steps>
  <Step title="Access your Business Profile">
    Go to <strong>Business → Business Profile</strong>.
  </Step>

  <Step title="Edit and save business details">
    Update the business details, such as the business logo and Brand display name (used on invoices), then click <strong>Save Changes</strong>.
  </Step>
</Steps>

## **User Account**

<Steps>
  <Step title="Access your User Profile">
    Click the icon in the top right, then select <strong>Profile</strong>.
  </Step>

  <Step title="Edit and save personal details">
    Update your personal information (Contact Name, Profile Image, phone number) for a personalized experience, then click <strong>Save Changes</strong>.
  </Step>
</Steps>

## Managing Multiple Businesses

Merchants with more than one business can easily add and verify additional businesses through their Dodo Payments account.

* **How to Add Multiple Businesses**:

  1. Navigate to the **Business Settings** section of the dashboard.

  2. Click **Add Another Business** and provide the required details.

  3. Submit the business registration documents for manual review.

  4. After approval, merchants can switch between verified businesses to manage their products, payments, and reports.


# Test Mode vs Live Mode
Source: https://docs.dodopayments.com/miscellaneous/test-mode-vs-live-mode

Learn the difference between Test Mode and Live Mode and how to switch between them.

Find the detailed breakdown of the features which will be available in test mode vs live mode

## Feature Comparison

| **Feature**                                 | **Test Mode** | **Live Mode** | **Is Environment Dependent?** |
| ------------------------------------------- | ------------- | ------------- | ----------------------------- |
| **Create Products (One-Time/Subscription)** | ✓             | ✓             | YES                           |
| **Generate Payment Links**                  | ✓             | ✓             | YES                           |
| **Simulate Payments (Card, Wallet, etc.)**  | ✓             | x             | YES                           |
| **Process Real Payments**                   | x             | ✓             | YES                           |
| **Issue Refunds**                           | ✓ (Simulated) | ✓ (Real)      | YES                           |
| **Access Transaction History**              | ✓ (Simulated) | ✓ (Real)      | YES                           |
| **Download Invoices**                       | ✓ (Simulated) | ✓ (Real)      | YES                           |
| **Link Bank Account**                       | ✓             | ✓             | Environment Independent       |
| **Payouts to Bank Account**                 | x             | ✓             | YES                           |
| **Simulate Failed Transactions**            | ✓             | x             | YES                           |
| **Analytics Section**                       | ✓ (Simulated) | ✓ (Real)      | YES                           |
| **View Detailed Reports**                   | ✓ (Simulated) | ✓ (Real)      | YES                           |
| **Customize Invoice Templates**             | ✓             | ✓             | Environment Independent       |
| **API Keys generation**                     | ✓             | ✓             | YES                           |
| **Real-time Fraud Detection**               | x             | ✓             | YES                           |
| **Access Live Customer Support**            | ✓             | ✓             | Environment Independent       |
| **Webhook Creation**                        | ✓             | ✓             | YES                           |
| **Business Profile section**                | ✓             | ✓             | Environment Independent       |
| **My Account section**                      | ✓             | ✓             | Environment Independent       |
| **Create multiple businesses**              | ✓             | ✓             | Environment Independent       |
| **Payout Compliance**                       | ✓             | ✓             | Environment Independent       |
| **Transaction Emails**                      | x             | ✓             | YES                           |

### Environment Dependency

**Environment Dependent:** All Environment Dependent features will have independent data in Test Mode and Live Mode. Any changes made in one environment will not affect the other. Eg. API Keys generated in Test Mode will be independent of API keys generated in Live Mode and vice versa

**Environment Independent:** All Environment Independent features will have the same data in both live mode and test mode. Eg. My Account section will have the same data in test mode and live mode. Changes made in one environment will affect the other environment

Live Mode will be available only post successful completion of Identity verification and Business Verification. You can accept real payments only in \`live mode\`.

API Hostnames for Test Mode and Live Mode are below:

* Test Mode: [`https://test.dodopayments.com`](https://test.dodopayments.com/)
* Live Mode: [`https://live.dodopayments.com`](https://live.dodopayments.com/)

## Key Highlights

1. All products created in test mode or live mode will only be available in the respective environment. There is an option of copy to live mode in the test mode environment. This will copy the product with all relevant details and create the same in live mode

2. API keys and Webhooks created in test mode will only be limited to test mode environment and will not affect live mode deployment and vice versa

3. All documents submitted for verification and Bank account details submitted will be the same in test mode and live mode. A change in this information in any environment will also change it in the other environment

## Test Cards and UPI IDs

For detailed information about test cards, UPI IDs, and other testing methods, please refer to our comprehensive [Testing Process](/miscellaneous/testing-process) guide.

This guide includes:

* Test card numbers for different scenarios
* Test UPI IDs for simulating payments
* Instructions for testing various payment outcomes
* Best practices for testing your integration

<Note>
  Test payment methods are only valid in test mode. Never use them for real payments.
</Note>

## Transaction in Test Mode - Tutorial

Please watch this video on how you can perform a transation in Test Mode.

<Frame>
  <iframe title="Test Transaction | Dodo Payments" />
</Frame>


# Testing Process
Source: https://docs.dodopayments.com/miscellaneous/testing-process

Complete guide to testing your Dodo Payments integration with test cards, UPI IDs, BNPL data, and digital wallets.

<Frame>
  <iframe title="Test Transaction | Dodo Payments" />
</Frame>

## Overview

Test mode lets you simulate payments without processing real transactions. All test credentials only work in test mode — never use them in production.

<CardGroup>
  <Card title="No Real Charges" icon="shield-check">
    Test transactions don't process actual payments or affect real accounts.
  </Card>

  <Card title="Full API Access" icon="code">
    All API endpoints work identically in test and live modes.
  </Card>

  <Card title="Webhook Testing" icon="webhook">
    Webhooks fire for test transactions just like production.
  </Card>
</CardGroup>

<Warning>
  Test credentials only work in test mode. Attempting to use them in live mode will result in payment failures.
</Warning>

## Test Cards

Use these card numbers to simulate successful and declined payments across different regions.

<Tabs>
  <Tab title="Successful Payments">
    | Region | Brand      | Card Number        | Expiry | CVV |
    | :----- | :--------- | :----------------- | :----- | :-- |
    | US     | Visa       | `4242424242424242` | 06/32  | 123 |
    | US     | Mastercard | `5555555555554444` | 06/32  | 123 |
    | India  | Visa       | `4576238912771450` | 06/32  | 123 |
    | India  | Mastercard | `5409162669381034` | 06/32  | 123 |
  </Tab>

  <Tab title="Declined Payments">
    | Region | Brand      | Card Number        | Scenario           |
    | :----- | :--------- | :----------------- | :----------------- |
    | US     | Visa       | `4000000000000002` | Generic decline    |
    | US     | Mastercard | `4000000000009995` | Insufficient funds |
    | India  | Visa       | `4706131211212123` | Generic decline    |
    | India  | Mastercard | `5105105105105100` | Generic decline    |
  </Tab>
</Tabs>

<Info>
  For all test cards, use expiry date **06/32** and CVV **123**.
</Info>

For more details on card testing, including 3D Secure and saved payment methods, see the [Cards](/features/payment-methods/cards) page.

## Test UPI

UPI testing uses special VPA (Virtual Payment Address) identifiers that simulate different payment outcomes.

| Status  | UPI ID        |
| :------ | :------------ |
| Success | `success@upi` |
| Failure | `failure@upi` |

### Requirements for UPI Testing

* Billing country must be set to `IN`
* Currency must be `INR`
* For non-Indian merchants: Adaptive Currency must be enabled

For complete UPI documentation including RBI mandate testing for subscriptions, see the [India Payment Methods](/features/payment-methods/india) page.

## Test BNPL

Buy Now Pay Later providers have specific test data requirements.

### Klarna Test Data

Use these details to simulate Klarna payments in test mode:

| Field             | Approved                                      | Denied                                                      |
| :---------------- | :-------------------------------------------- | :---------------------------------------------------------- |
| **Date of Birth** | 07-10-1970                                    | 07-10-1970                                                  |
| **First Name**    | Test                                          | Test                                                        |
| **Last Name**     | Person-us                                     | Person-us                                                   |
| **Email**         | [customer@email.us](mailto:customer@email.us) | [customer+denied@email.us](mailto:customer+denied@email.us) |
| **Street**        | Amsterdam Ave                                 | Amsterdam Ave                                               |
| **House Number**  | 509                                           | 509                                                         |
| **City**          | New York                                      | New York                                                    |
| **State**         | New York                                      | New York                                                    |
| **Postal Code**   | 10024-3941                                    | 10024-3941                                                  |
| **Phone**         | +13106683312                                  | +13106354386                                                |

<Note>
  Klarna requires a minimum transaction amount of **\$50.01** to appear as a payment option.
</Note>

### Afterpay Testing

<Steps>
  <Step title="Select Afterpay">
    Choose Afterpay as the payment method in checkout and click Pay.
  </Step>

  <Step title="Test successful payment">
    Use any valid email address and shipping address for successful payments.
  </Step>

  <Step title="Test failed authentication">
    To simulate failure, close the Afterpay modal window on the redirect page. The payment transitions from `requires_action` to `requires_payment_method`.
  </Step>
</Steps>

<Note>
  Afterpay requires a minimum transaction amount of **\$50.01** to appear as a payment option.
</Note>

For complete BNPL documentation including Billie B2B testing, see the [Buy Now Pay Later](/features/payment-methods/bnpl) page.

## Test Digital Wallets

### Apple Pay

<Steps>
  <Step title="Enable test mode">
    Use your Dodo Payments test API keys.
  </Step>

  <Step title="Add a card to Apple Wallet">
    Add a real card to your Apple Wallet. In test mode, the card won't be charged.
  </Step>

  <Step title="Complete test purchase">
    Open checkout on an Apple device and complete the Apple Pay flow.
  </Step>
</Steps>

<Warning>
  Apple Pay requires HTTPS. It won't appear on `localhost` without proper SSL setup. Domain verification must also be complete.
</Warning>

### Google Pay

<Steps>
  <Step title="Join the test card group">
    [Join the Google Pay test card group](https://groups.google.com/g/googlepay-test-mode-stub-data) to get test cards automatically added to your wallet.
  </Step>

  <Step title="Enable test mode">
    Use your Dodo Payments test API keys.
  </Step>

  <Step title="Complete test purchase">
    Select one of the test cards in Google Pay to complete the transaction.
  </Step>
</Steps>

### Amazon Pay, Cash App Pay & RevolutPay

Use your test API keys and follow the standard checkout flow. Test transactions are simulated without actual charges.

For complete digital wallet documentation including domain verification for Apple Pay, see the [Digital Wallets](/features/payment-methods/digital-wallets) page.

## Test European Methods

European payment methods (iDEAL, Bancontact, EPS, Multibanco) can be tested in sandbox mode.

<Steps>
  <Step title="Enable test mode">
    Use your Dodo Payments test API keys.
  </Step>

  <Step title="Set billing address">
    Set the billing address country to match the payment method:

    * `NL` for iDEAL
    * `BE` for Bancontact
    * `AT` for EPS
    * `PT` for Multibanco
  </Step>

  <Step title="Set currency">
    European methods require EUR currency.
  </Step>

  <Step title="Complete test flow">
    Follow the simulated bank authentication flow in the test environment.
  </Step>
</Steps>

For complete European payment methods documentation, see the [Europe](/features/payment-methods/europe) page.

## Testing Best Practices

<AccordionGroup>
  <Accordion title="Test all payment scenarios">
    Don't just test successful payments. Test declines, cancellations, and edge cases like insufficient funds.
  </Accordion>

  <Accordion title="Verify webhook handling">
    Ensure your webhook endpoints correctly process all event types, especially `payment.succeeded`, `payment.failed`, and subscription events.
  </Accordion>

  <Accordion title="Test on real devices">
    For Apple Pay and Google Pay, test on actual iOS and Android devices. Simulators don't fully replicate wallet behavior.
  </Accordion>

  <Accordion title="Test regional methods with correct addresses">
    Regional payment methods (UPI, iDEAL, etc.) require matching billing addresses. A US billing address won't show iDEAL.
  </Accordion>

  <Accordion title="Verify minimum amounts">
    BNPL methods require \$50.01 minimum. Test that they correctly appear/hide based on cart total.
  </Accordion>
</AccordionGroup>

## Related Pages

<CardGroup>
  <Card title="Cards" icon="credit-card" href="/features/payment-methods/cards">
    Card testing, 3D Secure, and saved payment methods.
  </Card>

  <Card title="Digital Wallets" icon="wallet" href="/features/payment-methods/digital-wallets">
    Apple Pay, Google Pay, Amazon Pay testing.
  </Card>

  <Card title="BNPL" icon="calendar-days" href="/features/payment-methods/bnpl">
    Klarna, Afterpay, and Billie testing.
  </Card>

  <Card title="India" icon="indian-rupee-sign" href="/features/payment-methods/india">
    UPI and RBI mandate testing.
  </Card>

  <Card title="Europe" icon="euro-sign" href="/features/payment-methods/europe">
    iDEAL, Bancontact, EPS, Multibanco testing.
  </Card>

  <Card title="Webhooks" icon="webhook" href="/developer-resources/webhooks">
    Set up webhooks for test events.
  </Card>
</CardGroup>


# Account Verification
Source: https://docs.dodopayments.com/miscellaneous/verification-process

Complete account verification to activate payments and payouts. Learn about required forms, identity verification, business verification, compliance requirements, and ongoing monitoring.

At Dodo Payments, businesses can start using live mode immediately after sign-up. **Live mode is available from day 1.**

To receive live payments and activate payouts, you must complete **Account Verification**. This process includes:

1. Submitting a **Product Information Form**
2. Completing **Payout Details**
3. Compliance team review of your submitted information

Once approved, your account will be enabled for live payments and payouts. This ensures compliance with regulatory guidelines, card-network rules, tax requirements, and our Merchant Acceptance Policy.

<Info>
  For the most up-to-date and comprehensive details on supported and prohibited product categories, as well as restricted and accepted business locations, please refer to our [Merchant Acceptance Policy](/miscellaneous/merchant-acceptance).
</Info>

## Account Verification

The Verification section is available in your dashboard.

### When Do You Need to Complete Verification?

Complete the verification process after sign-up to receive access to live payments and enable payouts as soon as possible.

<Frame>
  <img alt="Verification Process" />
</Frame>

### Steps to Activate Payouts

<Steps>
  <Step title="Access the Verification section">
    Visit the **Verification** section in your dashboard (see screenshot above).
  </Step>

  <Step title="Submit Product Information Form">
    Complete and submit the **Product Information Form**. This short form helps us understand your business.
  </Step>

  <Step title="Complete Payout Details">
    Submit all required payout details to complete the verification process.
  </Step>
</Steps>

<Warning>
  Until verification is complete:

  * Live payments will not be available for your account
  * Payouts will not be available for your account
</Warning>

### Required Forms by Account Type

The forms you need to complete depend on your account type:

| Account Type            | Required Forms                                   |
| ----------------------- | ------------------------------------------------ |
| **Individual**          | Product Information Form + KYC + Bank Form       |
| **Registered Business** | Product Information Form + KYC + KYB + Bank Form |

<Info>
  If you are a **UK registered business**, you must also submit a [Tax Form W-8BEN-E](#4-additional-compliance) as part of the verification process.
</Info>

### 1. Product Information Form

Before collecting payout details, all merchants must complete a **Product Information Form**. This form helps us understand your business and ensure compliance with our [Merchant Acceptance Policy](/miscellaneous/merchant-acceptance).

<Info>
  This form is **required for both individuals and registered businesses**.
</Info>

### Information Required

The Product Information Form collects the following details:

* **Product website or landing page**

  The URL where customers learn about or purchase your product

* **Product description**

  A brief, one-sentence explanation of what your product does

* **Product category**

  Select from options such as SaaS, digital content, services, marketplace, or physical goods

* **Delivery method**

  How customers receive the product after payment (e.g., instant access, email delivery, subscriptions, manual fulfillment)

* **Level of automation**

  Whether product delivery is fully automated, partially automated, or human-driven

* **Compliance-sensitive areas**

  Disclosure of any regulated, restricted, or higher-risk product types (if applicable)

* **Dodo Payments integration method**

  How you plan to collect payments (e.g., payment links, checkout sessions, APIs, SDKs)

* **Product stage and customer acquisition**

  Information about your product's maturity and go-to-market approach

* **Social media presence**

  Links to your product or founder social media profiles

* **Confirmation and declaration**

  Acknowledgement that the information provided is accurate and policy-compliant

<Note>
  This information is used **only for compliance review** and does not impact your ability to integrate, test, or accept live payments.
</Note>

### 2. Identity Verification

We use **Persona**, a leading global verification provider following industry standard security measure and following global data privacy guidelines.

KYC ensures the authenticity of individual businesses through:

* **Government-issued ID verification** (passport, national ID, driver's license etc)
* **Selfie check** to confirm liveness and match with ID

Persona's AI-driven process completes verification within minutes while maintaining bank-grade security standards.

<Tip>
  For more information about Persona's security measures, visit [withpersona.com/security](https://withpersona.com/security).
</Tip>

<Note>
  **Camera Access Issues:** If you encounter a "Can't access your camera" error during identity verification, you'll need to enable camera permissions for your device and browser. The steps vary by browser and device:

  * **Chrome:** Enable camera permissions through your browser settings (Desktop, iPhone & iPad, or Android)
  * **Safari:** For desktop, enable through Safari preferences. For mobile devices, go to Settings → Safari → Camera and set permission to "Ask" or "Allow"
  * **iOS Apps:** Go to Settings → Apps → \[Your App] → Allow Camera permissions. Also ensure Lockdown Mode is not blocking the app
  * **Android Apps:** Go to Settings → Apps → \[Your App] → Allow Camera permissions

  For detailed, step-by-step troubleshooting instructions for your specific browser and device, refer to [Persona's camera access guide](https://help.withpersona.com/articles/3V9VoOoGLp6zRCwthpzpx4/).
</Note>

### 3. Bank Form

The Bank Form collects your **bank account details** and **contact information**.

**⚠️ Important:**

* Bank account details **must match** the verified identity or registered business name.
* For individuals, the account holder’s name should match the Identity Verification document.
* For registered businesses, it should match the company’s legal name as per Business Verification.
* Dodo Payments cannot process payouts to mismatched or third-party accounts.

### 4. Business Verification

<Info>
  Business Verification is <strong>required only for registered businesses</strong>. If you have an individual account, you can skip this section.
</Info>

For registered businesses, verification ensures the legitimacy of the company and its authorised representatives.

#### Required Details

<AccordionGroup>
  <Accordion title="Company Registration Number">
    Provide your **Company Registration Number** and supporting document (Certificate of Incorporation or similar as per your jurisdiction).
  </Accordion>

  <Accordion title="Tax ID (Optional)">
    If you want your tax number reflected on payout invoices for claiming tax benefits, please provide a valid Tax ID and documents.

    Examples of tax identifiers across regions: EIN, CRN, VAT ID, GSTIN
  </Accordion>

  <Accordion title="Director / UBO Information">
    Provide details about all Director's or UBO's of the company in the verification form.

    **Beneficial Owner(s)**

    The beneficial owner is any natural person who, whether acting alone or together, or through other companies, LLPs, or legal persons, owns or is entitled to 10% or more of the shares or capital or profits of the connected user, or who exercises control over the connected user through other means, including enjoying the right to appoint the majority of its directors or to control its management or policy decisions through shareholding or management rights or through shareholders agreements or voting agreements. If the connected user has more than 1 beneficial owner, please provide us with the requisite documents for all.

    **Business Director(s)**

    Individuals appointed and currently serving as directors on the board of directors for the connected user in accordance with your local laws. Please provide us with the government issued ID's of all Directors.
  </Accordion>
</AccordionGroup>

### 5. Additional Compliance

<Info>
  <strong>W-8BEN-E:</strong> Only required for <strong>UK registered businesses</strong>. Ensure you fill out this form if your company is based in the United Kingdom.
</Info>

Registered businesses from the United Kingdom need to fill a **W-8BEN-E** form to comply with international tax reporting regulations. This ensures smooth payout processing and tax documentation accuracy.

<CardGroup>
  <Card title="Download W-8BEN-E Form" icon="download" href="https://www.irs.gov/pub/irs-pdf/fw8bene.pdf">
    Download the official IRS W-8BEN-E form (PDF) required for UK registered businesses.<br />

    <small>
      <strong>Tip:</strong> Complete the form digitally before printing and signing for best results.
    </small>
  </Card>
</CardGroup>

#### What is Form W-8 BEN-E?

W-8 BEN-E forms are Internal Revenue Service (IRS) forms that foreign businesses must file to verify their country of residence for tax purposes, certifying that they qualify for a lower rate of tax withholding.

#### How to Fill Out Form W-8 BEN-E

<AccordionGroup>
  <Accordion title="Part I – Identification of Beneficial Owner">
    **1. Name of Organization That is the Beneficial Owner**

    This is your entity name.

    **2. Country of Incorporation or Organization**

    This is the country of residence (where the business is registered). For a corporation, it is the country of incorporation. If you are another type of entity, enter the country under whose laws you are created, organized, or governed.

    **3. Chapter 3 Status**

    In this section, the most commonly checked box is "Corporation". The majority of foreign entities that are doing business fall under "Corporation" or "Partnership" status. Other options include:

    * Foreign government – Controlled Entity
    * Foreign government – Integral Part
    * Estate
    * Simple trust (grantor and complex, too)
    * Central Bank of Issue
    * Tax-exempt organization
    * Private foundation
    * International organization
    * Disregarded entity

    For Private Limited company - check the Corporation box
    For Limited Liability Partnership - check the Partnership box

    **4. Chapter 4 Status (FATCA Status)**

    For SaaS/Digital Products, the most common choice here is Active NFFE. This means the business is an Active Non-Financial Foreign Entity. If none of the other categories fit, Active NFFE is the best option.

    **5. Permanent Residence Address**

    This is your business's permanent resident address. Your permanent residence address is the address in the country where you claim to be a resident for purposes of that country's income tax.

    **8-10. Tax Identification Information**

    You may provide the FTIN issued to you by your jurisdiction of tax residence on line 9b for purposes of claiming treaty benefits.
  </Accordion>

  <Accordion title="Part XXV – Active NFFE">
    In this part of the form, you simply need to check box 39 to certify that:

    * The entity in Part I is a foreign entity that is not a bank or financial institution.
    * Less than 50% of the gross income for the preceding calendar year is passive income.
    * Less than 50% of assets held are assets that produce or are held for the production of passive income (calculated as a weighted average of the % of quarterly passive assets).
  </Accordion>

  <Accordion title="Part XXX – Certification">
    The most important part of the document is the certification and signature. Here, in writing, there needs to be a first name, last name, and date (on which the form was signed). The person signing the W-8BEN-E form must be authorized to sign for the beneficial owner.
  </Accordion>
</AccordionGroup>

#### View Sample W-8 BEN-E Forms

<AccordionGroup>
  <Accordion title="Private Limited Company">
    <Note>
      **Sample Profile:**

      * Company: ABC Technologies PVT LTD
      * Type: SaaS / Digital Products
      * Country: India (example)
      * TIN: PAN or equivalent tax ID in your country
    </Note>

    **Page 1**

    <Frame>
      <img alt="W-8 BEN-E Private Limited Sample Page 1" />
    </Frame>

    **Page 2**

    <Frame>
      <img alt="W-8 BEN-E Private Limited Sample Page 2" />
    </Frame>

    **Page 8**

    <Frame>
      <img alt="W-8 BEN-E Private Limited Sample Page 8" />
    </Frame>
  </Accordion>

  <Accordion title="Limited Liability Partnership (LLP)">
    <Note>
      **Sample Profile:**

      * Company: ABC Technologies LLP
      * Type: SaaS / Digital Products
      * Country: India (example)
      * TIN: PAN or equivalent tax ID in your country
    </Note>

    **Page 1**

    <Frame>
      <img alt="W-8 BEN-E LLP Sample Page 1" />
    </Frame>

    **Page 2**

    <Frame>
      <img alt="W-8 BEN-E LLP Sample Page 2" />
    </Frame>

    **Page 8**

    <Frame>
      <img alt="W-8 BEN-E LLP Sample Page 8" />
    </Frame>
  </Accordion>
</AccordionGroup>

## Account Monitoring and Compliance Review

Once your Payout Details are reviewed and approved, our compliance team performs a manual **Monitoring Review** in accordance with our **[Review & Monitoring Policy](https://docs.dodopayments.com/miscellaneous/review-monitoring-policy)**. This is a standard compliance check for all merchants on Dodo Payments

### Why do we do this?

As a MoR platform, we handle payment processing, invoicing, taxes, and refunds on your behalf. To keep your business - and our entire merchant community protected, we follow  monitoring practices that check for:

* The type of products/services you’re selling and compliance with our [**Merchant Acceptance Policy**](https://docs.dodopayments.com/miscellaneous/merchant-acceptance).
* Card-network rules and AML regulations
* Potential fraud indicators or unusual activity patterns

### What does this mean for you?

💡 **If your business operates in line with our Merchant Acceptance Policy and general platform rules, you have nothing to worry about.**

This review is designed to ensure everything looks good before we enable payouts. Most merchants pass this step smoothly with no action required.

The process is quick, lightweight, and intended to safeguard *your* payouts and long-term account stability.

Once the review is complete and everything looks good, payouts will be enabled for your account

* You will be able to view your payout schedule, next payout date, payout threshold and eligible balance directly in the dashboard

<Frame>
  <img alt="Account Activated" />
</Frame>

### Ongoing Monitoring

Dodo Payments also performs **ongoing monitoring periodically** so we can keep accounts compliant over time.

This is routine monitoring and if **your business remains compliant, you can continue operating without concern.** If we have any concern about your account during this check then necessary action will be taken in accordance with our [**Review & Monitoring Policy**](https://docs.dodopayments.com/miscellaneous/review-monitoring-policy)

## Additional Information Requests

As part of our **ongoing monitoring**, our compliance team may request additional information from time to time.

These requests can be completed directly from the dashboard and **do not block payments or payouts**, but failure to submit them may trigger pauses in payouts/payments processing, further compliance reviews or account restrictions.

<Tip>
  For more details, refer to our [Review Monitoring Policy](/miscellaneous/review-monitoring-policy).
</Tip>

## Timeline & Support

* Typical verification time: **1–3 business days (excludes weekends and public holidays)**
* If additional review is needed, you will be notified via email and dashboard.
* For help, reach out to [support@dodopayments.com](mailto:support@dodopayments.com)

## Resubmission of Documents

If there are issues with the documents submitted during the onboarding process, the Dodo Payments Verification Team may request that you resubmit specific documents.

You can resubmit documents using the **resubmit** option in your dashboard.

### When Can You Resubmit Documents?

* **Missing or Incomplete Information**: If essential details such as identification numbers, business name, or other key data are missing.
* **Document Mismatch**: When the documents submitted do not match the business or personal information provided.
* **Unreadable or Expired Documents**: If the uploaded documents are unclear, illegible, or have expired.
* **Additional Clarification Needed**: If the verification team requires further documentation to clarify your identity or business information.

### How to Resubmit Documents

<Steps>
  <Step title="Check your dashboard">
    Check your Dodo Payments Dashboard for a resubmission request (you will also receive an email notification if resubmission is required).
  </Step>

  <Step title="Access the resubmit option">
    The verification team will enable the **Resubmit** option, allowing you to upload new documents.
  </Step>

  <Step title="Upload correct documents">
    Navigate to the **Verification Section** in the dashboard and upload the correct documents.
  </Step>

  <Step title="Submit for review">
    Submit the documents for review by clicking **Submit for Review**.
  </Step>
</Steps>

<CardGroup>
  <Card title="Merchant Acceptance Policy" icon="shield-check" href="/miscellaneous/merchant-acceptance">
    Review our comprehensive acceptance standards, including supported and prohibited products, and ensure your business is eligible for onboarding.
  </Card>

  <Card title="Review Monitoring Policy" icon="magnifying-glass" href="/miscellaneous/review-monitoring-policy">
    Understand how ongoing compliance is monitored, learn about triggers for document review, and stay proactive with your account status.
  </Card>
</CardGroup>


# Create Addon
Source: https://docs.dodopayments.com/api-reference/addons/create-addon

post /addons
Create a new addon product that can be attached to your main subscription products



# Get Addon
Source: https://docs.dodopayments.com/api-reference/addons/get-addon

get /addons/{id}
Retrieve detailed information about a specific addon using its unique identifier



# List Addons
Source: https://docs.dodopayments.com/api-reference/addons/list-addons

get /addons
Retrieve a comprehensive list of all available addons



# Update Addon
Source: https://docs.dodopayments.com/api-reference/addons/update-addon

patch /addons/{id}
Modify the details of an existing addon using its unique identifier



# Update Addon Images
Source: https://docs.dodopayments.com/api-reference/addons/update-addon-images

put /addons/{id}/images
Update images for an existing addon



# Create Checkout Session
Source: https://docs.dodopayments.com/api-reference/checkout-sessions/create

post /checkouts
Unified endpoint for creating checkout sessions for all types of billing requirements.



# Get Checkout Session
Source: https://docs.dodopayments.com/api-reference/checkout-sessions/get-checkouts

get /checkouts/{id}
Retrieve details of a specific checkout session by its ID.



# Preview Checkout Session
Source: https://docs.dodopayments.com/api-reference/checkout-sessions/preview

post /checkouts/preview
Preview a checkout session to calculate pricing, taxes, and totals without creating an actual session.



# Create Customer
Source: https://docs.dodopayments.com/api-reference/customers/create-customer

post /customers
Create a new customer in your Dodo Payments account.



# Create Customer Portal Session
Source: https://docs.dodopayments.com/api-reference/customers/create-customer-portal-session

post /customers/{customer_id}/customer-portal/session
Create a session of the Customer Portal for a specific customer.



# List Payment Methods
Source: https://docs.dodopayments.com/api-reference/customers/get-customer-payment-methods

get /customers/{customer_id}/payment-methods
List all payment methods associated with a specific customer.



# Get Customer Wallets
Source: https://docs.dodopayments.com/api-reference/customers/get-customer-wallets

get /customers/{customer_id}/wallets
Retrieve wallets associated with a specific customer.



# List Customer Wallet Ledger Entries
Source: https://docs.dodopayments.com/api-reference/customers/get-customer-wallets-ledger-entries

get /customers/{customer_id}/wallets/ledger-entries
List wallet ledger entries for a specific customer. Supports pagination and currency filter.



# List Customers
Source: https://docs.dodopayments.com/api-reference/customers/get-customers

get /customers
Get a list of all customers associated with your account.



# Get Customer Detail
Source: https://docs.dodopayments.com/api-reference/customers/get-customers-1

get /customers/{customer_id}
Get detailed information about a specific customer.



# Patch Customer
Source: https://docs.dodopayments.com/api-reference/customers/patch-customer

patch /customers/{customer_id}
Update a customer's information.



# Create Customer Wallet Ledger Entry
Source: https://docs.dodopayments.com/api-reference/customers/post-customer-wallets-ledger-entries

post /customers/{customer_id}/wallets/ledger-entries
Create a credit or debit ledger entry in a customer's wallet.



# Create Discount
Source: https://docs.dodopayments.com/api-reference/discounts/create-discount

post /discounts
Create a discount for your account.



# Delete Discount
Source: https://docs.dodopayments.com/api-reference/discounts/delete-discount

delete /discounts/{discount_id}
Delete a discount from your account.



# Get Discount by Code
Source: https://docs.dodopayments.com/api-reference/discounts/get-discount-by-code

get /discounts/code/{code}
Validate and retrieve a discount by its code name (e.g., 'SAVE20') instead of using the internal discount ID.



# List Discounts
Source: https://docs.dodopayments.com/api-reference/discounts/list-discounts

get /discounts
Retrieve a list of all discounts associated with your account.



# Update Discount
Source: https://docs.dodopayments.com/api-reference/discounts/update-discount

patch /discounts/{discount_id}
Update a discount in your account.



# Validate Discount
Source: https://docs.dodopayments.com/api-reference/discounts/validate-discount

get /discounts/{discount_id}
Validate a discount code to check if it is valid and can be applied to the current cart.



# Error Codes
Source: https://docs.dodopayments.com/api-reference/error-codes

Learn more about error codes and how to resolve them in Dodo Payments API.

## Overview

Dodo Payments API uses standard HTTP status codes and custom error codes to indicate the success or failure of API requests. When an error occurs, the API returns an appropriate HTTP status code and a JSON response containing detailed information about the error.

Each error response includes:

* An HTTP status code indicating the general category of the error
* A specific error code that identifies the exact nature of the error
* A human-readable error message explaining what went wrong
* Additional details about the error when applicable

Understanding these error codes and their meanings is crucial for:

* Debugging integration issues
* Implementing proper error handling in your application
* Providing meaningful feedback to end users
* Maintaining a robust payment processing system

The following sections provide detailed information about standard HTTP status codes and specific error codes you may encounter when using the Dodo Payments API.

## Standard API Error Codes

| Error code | HTTP Status           | Description                                                          |
| ---------- | --------------------- | -------------------------------------------------------------------- |
| **400**    | Bad Request           | The request was malformed or contained invalid parameters            |
| **401**    | Unauthorized          | Authentication failed or API key is invalid                          |
| **403**    | Forbidden             | The API key doesn't have permission to access the requested resource |
| **404**    | Not Found             | The requested resource doesn't exist                                 |
| **405**    | Method Not Allowed    | The HTTP method is not supported for this endpoint                   |
| **409**    | Conflict              | The request conflicts with the current state of the resource         |
| **422**    | Unprocessable Entity  | The request was well-formed but contained semantic errors            |
| **429**    | Too Many Requests     | Rate limit exceeded                                                  |
| **500**    | Internal Server Error | An unexpected error occurred on our servers                          |
| **502**    | Bad Gateway           | The server received an invalid response from an upstream server      |
| **503**    | Service Unavailable   | The service is temporarily unavailable                               |
| **504**    | Gateway Timeout       | The server timed out while waiting for an upstream response          |

## Error Response Format

When an error occurs, the API returns a JSON response with the following structure:

```json theme={null}
{
  "code": "UNSUPPORTED_COUNTRY",
  "message": "Country AI currently not supported"
}
```

## Error Codes Reference

* `ACTIVATION_LIMIT_LESS_THAN_CURRENT_AMOUNT`
  * **Trigger:** License-key activations: new limit \< existing instance count
  * **Message:** New activation limit cannot be less than current instances count

* `ADDONS_IN_USAGE_BASED_BILLING_NOT_SUPPORTED`
  * **Trigger:** Attempt to add addons to usage-based billing subscriptions
  * **Message:** Addons in Subscriptions are not supported for Usage Based Billing

* `ADDONS_NOT_ALLOWED_FOR_ON_DEMAND`
  * **Trigger:** Attempt to add addons to on-demand subscriptions
  * **Message:** Addons are not allowed for on demand subscriptions

* `BRAND_MISMATCH`
  * **Trigger:** Cart items belong to different brands
  * **Message:** All items in the product cart should belong to the same brand

* `BRAND_NOT_ENABLED`
  * **Trigger:** Brand is disabled or not active
  * **Message:** Brand provided is not enabled

* `BRAND_SUBMISSION_NOT_ENABLED`
  * **Trigger:** Brand verification resubmission feature not enabled
  * **Message:** Brand verificatin resubmission is not enabled

* `CHARGE_NOT_ALLOWED_FOR_SCHEDULED_CANCELLATION`
  * **Trigger:** Attempt to charge subscription scheduled for cancellation
  * **Message:** Subscription scheduled for cancellation

* `CHECKOUT_SESSION_CONSUMED`
  * **Trigger:** Checkout session has already generated a payment
  * **Message:** Checkout session has already been consumed

* `DISCOUNT_CODE_ALREADY_EXISTS`
  * **Trigger:** Duplicate discount code creation
  * **Message:** Discount Code already exists

* `DISCOUNT_CODE_EXPIRED`
  * **Trigger:** Discount code past its `expires_at` date
  * **Message:** Discount code expired

* `DISCOUNT_CODE_USAGE_LIMIT_EXCEEDED`
  * **Trigger:** Discount reused after `usage_limit` reached
  * **Message:** Usage limit cannot be less than times\_used / Discount code hit usage limit

* `DISCOUNT_NOT_AVAILABLE_FOR_ON_DEMAND`
  * **Trigger:** Code applied to on-demand subscription
  * **Message:** Discount coupon not available for on demand subscriptions

* `DISCOUNT_NOT_AVAILABLE_FOR_PRODUCT`
  * **Trigger:** Code applied to unrelated product(s)
  * **Message:** Discount coupon not available for this product

* `DUPLICATE_LINE_ITEMS_IN_REQUEST`
  * **Trigger:** Same `item_id` appears twice in `items[]`
  * **Message:** Duplicate item\_ids specified in items array

* `DUPLICATE_METER_IDS_IN_REQUEST`
  * **Trigger:** Same meter ID appears multiple times in request
  * **Message:** Duplicate Meter Ids are not allowed

* `EXCHANGE_RATE_NOT_FOUND`
  * **Trigger:** No FX rate for `from → to` currency pair
  * **Message:** Exchange rate not found to convert from Currency to Currency

* `EXISTING_REFUND_REQUEST_PROCESSING`
  * **Trigger:** Previous refund request still being processed
  * **Message:** A refund request with status "Pending" is still being processed

* `INACTIVE_LICENSE_KEY`
  * **Trigger:** Key status ≠ `ACTIVE`
  * **Message:** License key is not active

* `INACTIVE_SUBSCRIPTION_PLAN_CHANGE_NOT_SUPPORTED`
  * **Trigger:** Plan change on inactive subscription
  * **Message:** Changing plans is not supported for inactive subscriptions

* `INSUFFICIENT_WALLET_FUNDS`
  * **Trigger:** Wallet balance \< debit amount
  * **Message:** Insufficient funds in wallet

* `INTEGER_CONVERSION_FAILURE`
  * **Trigger:** Any integer ↔ string/decimal conversion that fails server-side
  * **Message:** Integer Conversion Failure

* `INTERNAL_SERVER_ERROR`
  * **Trigger:** Uncaught exceptions; you should log details server-side
  * **Message:** *No public message (generic 500)*

* `INVALID_DISCOUNT_CODE`
  * **Trigger:** Code does not exist / not applicable
  * **Message:** Invalid Discount Code / Discount Code cannot be applied to any product in the cart

* `INVALID_PERCENTAGE`
  * **Trigger:** Percent amount > 100% (or 10,000 basis points)
  * **Message:** Percentage amount cannot be more than 10000 / Discount code amount cannot be more than 100%

* `INVALID_QUANTITY`
  * **Trigger:** Invalid quantity specified for usage-based pricing
  * **Message:** Only 1 quantity allowed in usage based price products

* `INVALID_QUERY_PARAMS`
  * **Trigger:** Mutually exclusive / malformed query parameters
  * **Message:** Query params should only contain either time\_frame or (start, end)

* `INVALID_REQUEST_BODY`
  * **Trigger:** Malformed JSON or schema violation
  * **Message:** Your request body is invalid. Please check your request headers and object.

* `INVALID_REQUEST_PARAMETERS`
  * **Trigger:** Semantics wrong (e.g. date in past)
  * **Message:** Cannot change next\_billing\_date to past time

* `INVALID_SUGGESTED_PRICE`
  * **Trigger:** PWYW price \< minimum allowed price
  * **Message:** Suggested Price cannot be lower than minimum price. In case of pay what you want, price is considered as minimum accepted amount

* `INVALID_TAX_ID`
  * **Trigger:** VAT/GST/TIN failed validation
  * **Message:** Tax Id is invalid

* `LICENSE_KEY_LIMIT_REACHED`
  * **Trigger:** Activations = limit
  * **Message:** License key activation limit reached

* `LICENSE_KEY_NOT_FOUND`
  * **Trigger:** Instance ID or key ID invalid
  * **Message:** License key instance not found or does not belong to this license key

* `LINE_ITEM_FULLY_REFUNDED`
  * **Trigger:** Attempt to refund already fully refunded line item
  * **Message:** Line item  has been fully refunded cannot be refunded further.

* `LINE_ITEM_NOT_FOUND`
  * **Trigger:** Item ID not part of the referenced payment
  * **Message:** Line item  not found in payment

* `LINE_ITEM_PRORATED`
  * **Trigger:** Refund or update attempted on a prorated line
  * **Message:** Line item  cannot be refunded because its prorated

* `LINE_ITEM_REFUND_AMOUNT_TOO_HIGH`
  * **Trigger:** Refund amount > paid amount (tax incl.)
  * **Message:** Line item  requested refund amount including tax is  which is above the paid amount&#x20;

* `LINE_ITEM_REFUND_AMOUNT_TOO_LOW`
  * **Trigger:** Refund amount below minimum threshold
  * **Message:** Line item  requested refund amount is  which is too low

* `MAXIMUM_KEYS_REACHED`
  * **Trigger:** Metadata / custom-fields exceeded 50 pairs
  * **Message:** Exceeds 50 key-value pairs

* `MERCHANT_NOT_LIVE`
  * **Trigger:** Business still in test/sandbox mode
  * **Message:** Merchant is not live

* `METER_IS_DELETED`
  * **Trigger:** Attempt to use deleted meter
  * **Message:** The Meter is already been deleted

* `MISSING_ADDON_IDS`
  * **Trigger:** `addon_id` list empty or unknown IDs
  * **Message:** One or more product IDs do not exist:&#x20;

* `MISSING_METER_IDS`
  * **Trigger:** Meter ID list empty or contains invalid IDs
  * **Message:** One or more meter IDs do not exist:&#x20;

* `MISSING_PRODUCT_INFORMATION`
  * **Trigger:** Product exists but mandatory info missing
  * **Message:** Product  exists but other mandatory information is missing or invalid

* `NEGATIVE_BALANCE_ADJUSTMENT`
  * **Trigger:** Attempt to make wallet balance negative
  * **Message:** Wallet balance is not allowed to be made negative

* `NO_ELIGIBLE_PAYMENT_METHODS`
  * **Trigger:** After filtering, nothing left
  * **Message:** No eligible payment methods found

* `NO_EXPIRY_ON_SUBSCRIPTION_LICENSE_KEYS`
  * **Trigger:** Attempt to set expiry on sub-based key
  * **Message:** Cannot set expiry date for subscription-based license key

* `NOT_FOUND`
  * **Trigger:** Generic 404 for any missing resource
  * **Message:** Item not found *(or more specific)*

* `ON_DEMAND_PLAN_CHANGE_NOT_SUPPORTED`
  * **Trigger:** Plan swap not allowed for on-demand
  * **Message:** Changing plans is not supported for on demand subscriptions

* `ON_DEMAND_SUBSCRIPTIONS_NOT_ENABLED`
  * **Trigger:** Business has feature flag off
  * **Message:** On demand subscriptions not enabled for this business

* `ON_DEMAND_USAGE_BASED_BILLING_NOT_SUPPORTED`
  * **Trigger:** Attempt to use on-demand with usage-based billing
  * **Message:** On Demand Subscriptions are not supported for Usage Based Billing

* `PAY_AS_YOU_WANT_AMOUNT_REQUIRED`
  * **Trigger:** Price missing for PWYW product
  * **Message:** Amount is mandatory for pay as you want product

* `PAYMENT_ALREADY_REFUNDED`
  * **Trigger:** Duplicate refund
  * **Message:** This payment has already been refunded

* `PAYMENT_HAS_BEEN_REFUNDED`
  * **Trigger:** Payment has been fully refunded
  * **Message:** The Payment ID has been fully refunded.

* `PAYMENT_NOT_SUCCEEDED`
  * **Trigger:** Attempt to refund/process unsuccessful payment
  * **Message:** The provided payment has not succeeded

* `PLAN_CHANGE_NOT_ALLOWED_FOR_SCHEDULED_CANCELLATION`
  * **Trigger:** Plan change attempted on subscription scheduled for cancellation
  * **Message:** Subscription scheduled for cancellation

* `PREVIOUS_PAYMENT_PENDING`
  * **Trigger:** Attempt to create charge while previous is in non-terminal state
  * **Message:** Cannot create new charge as previous payment is not successful yet

* `PRODUCT_CART_EMPTY`
  * **Trigger:** Empty product cart submitted
  * **Message:** product\_cart is empty

* `PRODUCT_IS_DELETED`
  * **Trigger:** Product soft-deleted
  * **Message:** *No messages*

* `REFUND_AMOUNT_EXCEEDS_PAID_AMOUNT`
  * **Trigger:** Aggregate refund amount > paid amount
  * **Message:** The calculated refund amount is larger than the paid amount

* `REFUND_WINDOW_EXPIRED`
  * **Trigger:** Outside allowable refund window
  * **Message:** Refunds cannot be initiated  days after payment creation. Contact [support@dodopayments.com](mailto:support@dodopayments.com).

* `REQUEST_AMOUNT_BELOW_MINIMUM`
  * **Trigger:** Amount \< product minimum
  * **Message:** Amount cannot be less than minimum amount specified for the product

* `SUBSCRIPTION_EXPIRED`
  * **Trigger:** Billing past `ends_at`
  * **Message:** Subscription expired cannot create new charges

* `SUBSCRIPTION_INACTIVE`
  * **Trigger:** Status ≠ `ACTIVE`
  * **Message:** Subscription is not active

* `SUBSCRIPTION_NOT_ON_DEMAND`
  * **Trigger:** Expected on-demand but got fixed interval
  * **Message:** Subscription is already not on demand

* `SUBSCRIPTION_PAYMENT_RETRY_LIMIT_EXCEEDED`
  * **Trigger:** Subscription payment retries exceeded maximum attempts
  * **Message:** Maximum retry limit of 10 attempts exceeded for this subscription

* `TOO_MANY_REQUESTS`
  * **Trigger:** 429 rate-limit
  * **Message:** *No messages*

* `TOTAL_PAYMENT_AMOUNT_BELOW_MINIMUM_AMOUNT`
  * **Trigger:** Combined cart total \< gateway minimum
  * **Message:** Minimum amount of  is required to process payment

* `UNABLE_TO_EDIT_PRIMARY_BRAND`
  * **Trigger:** Attempt to update primary brand via regular API
  * **Message:** Primary brand cannot be updated via this API endpoint.

* `UNAUTHORIZED`
  * **Trigger:** No API key or invalid token / scope
  * **Message:** You are not authorised to perform this action

* `UNSUPPORTED_ACTION`
  * **Trigger:** Unsupported action for resource type
  * **Message:** Changing plans for usage based subscriptions is not supported

* `UNSUPPORTED_BILLING_CURRENCY`
  * **Trigger:** Subscriptions restricted to USD
  * **Message:** Non USD billing currency is not supported for subscriptions

* `UNSUPPORTED_COUNTRY`
  * **Trigger:** Geo not yet supported
  * **Message:** Country  currently not supported

* `UNSUPPORTED_CURRENCY`
  * **Trigger:** Product or addon currency invalid
  * **Message:** Currency is not currently supported / Only USD and INR products supported currently / Only USD and INR supported for addon price / Can only request USD or INR for billing\_currency / Currency Not Supported / Unexpected currency for Indian card subscripitons

* `UNSUPPORTED_DISCOUNT_TYPE`
  * **Trigger:** Flat-amount discounts, etc., not yet live
  * **Message:** Only percentage discount codes are supported for now

* `UNSUPPORTED_PAYMENT_CURRENCY`
  * **Trigger:** Payment currency blocked for connector
  * **Message:** INR transaction is not supported for this transaction

* `UNSUPPORTED_TAX_CATEGORY`
  * **Trigger:** Tax category string not in enum
  * **Message:** Category  currently not supported

* `UNSUCCESSFUL_PAYMENT_ID`
  * **Trigger:** Payment ID references unsuccessful payment
  * **Message:** The Payment ID has an unsuccessful status.

* `ZERO_AMOUNT_PAYMENT_REFUND_NOT_ALLOWED`
  * **Trigger:** Attempt to refund zero-amount payment
  * **Message:** Cannot refund a payment with zero currency amount

## Best Practices

1. Always handle errors gracefully in your application
2. Implement proper error logging
3. Use appropriate error messages for end users
4. Implement retry logic for transient errors
5. Contact support for unresolved issues

## Support

For additional help with error codes or integration issues, please contact our support team at [support@dodopayments.com](mailto:support@dodopayments.com).


# Introduction
Source: https://docs.dodopayments.com/api-reference/introduction

The Dodo Payments API provides comprehensive endpoints for payment processing, subscription management, and digital product delivery. Our RESTful API follows industry standards with detailed responses for all operations.

<Card title="SDKs & Libraries" icon="code" href="/developer-resources/dodo-payments-sdks">
  Accelerate your integration by using official SDKs for <strong>TypeScript</strong>, <strong>Python</strong>, <strong>Go</strong>, <strong>PHP</strong>, <strong>Java</strong>, <strong>Kotlin</strong>, <strong>C#</strong>, <strong>Ruby</strong>, and <strong>React Native</strong>. These libraries simplify API requests, authentication, and error handling, letting you focus on building great payment experiences.
</Card>

## Environment URLs

* **Test Mode**: [`https://test.dodopayments.com`](https://test.dodopayments.com)
* **Live Mode**: [`https://live.dodopayments.com`](https://live.dodopayments.com)

<Note>
  Learn more about [Test Mode vs Live Mode](/miscellaneous/test-mode-vs-live-mode).
</Note>

## API Key Management and Authentication

<Steps>
  <Step title="Access API Keys">
    Navigate to **Developer → API Keys** in your dashboard to manage your keys.
  </Step>

  <Step title="Generate a New Key">
    Select **Add API Key**, provide a descriptive name, and configure write access:

    * **Enable write access** (checked): Full read and write permissions for all API operations
    * **Enable write access** (unchecked): Read-only access - can only fetch data (payments, subscriptions, customers, products). Cannot create or modify resources.

    <Tip>
      Uncheck "Enable write access" for dashboard integrations, analytics tools, and any system that only needs to view data without making changes.
    </Tip>
  </Step>

  <Step title="Store Your Key Securely">
    Copy the generated key immediately and ensure it is stored securely.
  </Step>

  <Step title="Authenticate Your API Requests">
    Use your API keys to authenticate all requests. Apply the following authorization format:

    ```bash theme={null}
    Authorization: Bearer YOUR_API_KEY
    ```

    <Warning>
      Never expose your secret API keys in client-side code or public repositories.
    </Warning>
  </Step>
</Steps>

## Response Format

<CodeGroup>
  ```json Success Response theme={null}
  {
    "id": "pay_1234567890",
    "status": "completed",
    "amount": 2999,
    "currency": "USD",
    "created_at": "2024-01-15T10:30:00Z"
  }
  ```

  ```json Error Response theme={null}
  {
    "code": "INVALID_REQUEST",
    "message": "The request contains invalid parameters"
  }
  ```
</CodeGroup>

## Rate Limits

Our API uses a dual-window rate limiting system with burst protection. Limits are applied based on your authentication method and business tier.

### Default Limits (Tier 0)

| Window                 | Limit        |
| ---------------------- | ------------ |
| Per Second (Burst)     | 40 requests  |
| Per Minute (Sustained) | 240 requests |

### Business Tiers

Higher rate limits are available for businesses with increased API needs:

| Tier             | Burst (per second) | Sustained (per minute) |
| ---------------- | ------------------ | ---------------------- |
| Tier 0 (Default) | 40                 | 240                    |
| Tier 1           | 100                | 1,000                  |
| Tier 2           | 500                | 5,000                  |

<Tip>
  Contact support to upgrade your business to a higher rate limit tier.
</Tip>

### Unauthenticated Requests

Requests without valid authentication headers are rate limited by IP address:

| Window                 | Limit        |
| ---------------------- | ------------ |
| Per Second (Burst)     | 20 requests  |
| Per Minute (Sustained) | 100 requests |

### Rate Limit Headers

Monitor your usage with these response headers:

* `X-RateLimit-Limit` - Maximum requests allowed
* `X-RateLimit-Remaining` - Requests remaining in current window
* `X-RateLimit-Reset` - Time when the rate limit resets

<Note>
  When you exceed rate limits, the API returns a `429 Too Many Requests` response. Implement exponential backoff in your retry logic.
</Note>

## Error Handling

To effectively manage errors, consult the *Error Codes* and *Transaction Failures* sections for detailed guidance.

<CardGroup>
  <Card title="Error Codes" icon="triangle-exclamation" href="/api-reference/error-codes">
    Delve into comprehensive error details and their resolutions.
  </Card>

  <Card title="Transaction Failures" icon="circle-exclamation" href="/api-reference/transaction-failures">
    Gain insights into common transaction issues and their solutions.
  </Card>
</CardGroup>

## Webhooks

Receive real-time notifications about payment events. See our [Webhook Guide](/developer-resources/webhooks) for setup instructions.

<Card title="Webhook Guide" icon="webhook" href="/developer-resources/webhooks">
  Set up webhooks for real-time notifications and event handling.
</Card>


# Activate License
Source: https://docs.dodopayments.com/api-reference/licenses/activate-license

post /licenses/activate
This endpoint allows you to activate a license for the user.

<Info>
  **No API Key Required**: This is a public endpoint that does not require authentication. You can call it directly from client applications, desktop software, or CLIs to activate license keys without exposing your API credentials.
</Info>


# Deactivate License
Source: https://docs.dodopayments.com/api-reference/licenses/deactivate-license

post /licenses/deactivate
This endpoint allows you to deactivate a license for the user.

<Info>
  **No API Key Required**: This is a public endpoint that does not require authentication. You can call it directly from client applications, desktop software, or CLIs to deactivate license keys without exposing your API credentials.
</Info>


# Get License Key
Source: https://docs.dodopayments.com/api-reference/licenses/get-license-key

get /license_keys/{id}
Retrieve the details of a specific license key by its ID.



# Get License Key Instance
Source: https://docs.dodopayments.com/api-reference/licenses/get-license-key-instance

get /license_key_instances/{id}
Retrieve details of a specific license key instance by its ID.



# Get License Key Instances
Source: https://docs.dodopayments.com/api-reference/licenses/get-license-key-instances

get /license_key_instances
Retrieve a list of instances for a specific license key.



# List Licenses
Source: https://docs.dodopayments.com/api-reference/licenses/list-license-keys

get /license_keys
Retrieve a list of license keys associated with your account.



# Update License Key
Source: https://docs.dodopayments.com/api-reference/licenses/update-license-key

patch /license_keys/{id}
This endpoint allows you to update a license key by its ID.



# Update License Key Instance
Source: https://docs.dodopayments.com/api-reference/licenses/update-license-key-instance

patch /license_key_instances/{id}
This endpoint allows you to update a specific license key instance by its ID.



# Validate License
Source: https://docs.dodopayments.com/api-reference/licenses/validate-license

post /licenses/validate
This endpoint allows you to validate a license for the user.

<Info>
  **No API Key Required**: This is a public endpoint that does not require authentication. You can call it directly from client applications, desktop software, or CLIs to validate license keys without exposing your API credentials.
</Info>


# Metadata Guide
Source: https://docs.dodopayments.com/api-reference/metadata

Learn how to use metadata to store additional information about your Dodo Payments objects

## Introduction

Metadata allows you to store additional, structured information about your objects in Dodo Payments. You can attach metadata to most Dodo Payments objects, including payments, subscriptions, and more.

## Overview

* Metadata keys can be up to 40 characters long
* Metadata values can be up to 500 characters long
* You can have up to 50 metadata key-value pairs per object
* Keys should only contain alphanumeric characters, dashes, and underscores
* Metadata is not searchable using our API but is returned in API responses and webhooks

## Use Cases

Metadata is useful for:

* Storing external IDs or references
* Adding internal annotations
* Linking Dodo Payments objects to your system
* Categorizing transactions
* Adding custom attributes for reporting

## Adding Metadata

You can add metadata when creating or updating objects through the API. For products, you also have the option to add metadata directly from the dashboard UI.

### Via API

```javascript theme={null}
// Adding metadata when creating a checkout session
const checkoutSession = await client.checkoutSessions.create({
    product_cart: [{ product_id: 'product_id', quantity: 1 }],
    return_url: 'https://example.com/return',
    metadata: {
        order_id: 'ORD-123',
        campaign_source: 'email',
        customer_segment: 'premium'
    }
});

// Adding metadata when creating a payment
const payment = await client.payments.create({
    billing: { city: 'city', country: 'AF', state: 'state', street: 'street', zipcode: 0 },
    customer: { customer_id: 'customer_id' },
    product_cart: [{ product_id: 'product_id', quantity: 0 }],
    metadata:{order_id: 'ORD-123', customer_notes: 'Customer notes'}
  });

// Adding metadata when creating a product
const product = await client.products.create({
    name: 'Premium Software License',
    price: 9900,
    currency: 'USD',
    metadata: {
        category: 'software',
        license_type: 'premium',
        support_tier: 'priority'
    }
});

// Adding metadata when creating a customer
const customer = await client.customers.create({
    email: 'customer@example.com',
    name: 'John Doe',
    metadata: {
        crm_id: 'CRM-12345',
        customer_segment: 'enterprise',
        referral_source: 'website'
    }
});

// Adding metadata when changing a subscription plan
await client.subscriptions.changePlan('sub_123', {
    product_id: 'prod_premium',
    proration_billing_mode: 'prorated_immediately',
    quantity: 1,
    metadata: {
        upgrade_reason: 'feature_request',
        previous_plan: 'basic',
        sales_rep: 'john@company.com'
    }
});
```

### Via Dashboard UI (Products Only)

For products, you can also add metadata directly from the Dodo Payments dashboard when creating or editing a product. The metadata section allows you to easily add custom key-value pairs without writing code.

<Frame>
  <img alt="Product metadata interface in Dodo Payments dashboard" />
</Frame>

<Tip>
  Using the dashboard UI for product metadata is particularly useful for non-technical team members who need to manage product information and categories.
</Tip>

## Retrieving Metadata

Metadata is included in API responses when retrieving objects:

```javascript theme={null}
// Retrieving checkout session metadata
const checkoutSession = await client.checkoutSessions.retrieve('cs_123');
console.log(checkoutSession.metadata.order_id); // 'ORD-123'

// Retrieving payment metadata
const payment = await client.payments.retrieve('pay_123');
console.log(payment.metadata.order_id); // '6735'

// Retrieving customer metadata
const customer = await client.customers.retrieve('customer_123');
console.log(customer.metadata.crm_id); // 'CRM-12345'

// Retrieving refund metadata
const refund = await client.refunds.retrieve('refund_123');
console.log(refund.metadata.refund_reason); // 'customer_request'
```

## Searching and Filtering

While metadata is not directly searchable via our API, you can:

1. Store important identifiers in metadata
2. Retrieve objects using their primary IDs
3. Filter the results in your application code

```javascript theme={null}
// Example: Find a checkout session using metadata
const checkoutSessions = await client.checkoutSessions.list({
  limit: 100
});

const matchingSession = checkoutSessions.data.find(
  session => session.metadata?.order_id === 'ORD-123'
);

// Example: Find a payment using your order ID
const payments = await client.payments.list({
  limit: 100
});

const matchingPayment = payments.data.find(
  payment => payment.metadata.order_id === '6735'
);
```

## Best Practices

### Do:

* Use consistent naming conventions for metadata keys
* Document your metadata schema internally
* Keep values short and meaningful
* Use metadata for static data only
* Consider using prefixes for different systems (e.g., `crm_id`, `inventory_sku`)

### Don't:

* Store sensitive data in metadata
* Use metadata for frequently changing values
* Rely on metadata for critical business logic
* Store duplicate information that's available elsewhere in the object
* Use special characters in metadata keys

## Supported Objects

Metadata is supported on the following objects:

| Object Type              | Support |
| ------------------------ | ------- |
| Payments                 | ✓       |
| Subscriptions            | ✓       |
| Subscription Change Plan | ✓       |
| Products                 | ✓       |
| Refunds                  | ✓       |
| Checkout Sessions        | ✓       |
| Customers                | ✓       |

## Webhooks and Metadata

Metadata is included in webhook events, making it easy to handle notifications with your custom data:

```javascript theme={null}
// Example webhook handler
app.post('/webhook', (req, res) => {
  const event = req.body;

  if (event.type === 'payment.succeeded') {
    const orderId = event.data.object.metadata.order_id;
    // Process order using your internal order ID
  }
  
  if (event.type === 'checkout.session.completed') {
    const orderId = event.data.object.metadata.order_id;
    const campaignSource = event.data.object.metadata.campaign_source;
    // Handle checkout session completion with custom metadata
  }
});
```


# Archive Meter
Source: https://docs.dodopayments.com/api-reference/meters/archive-meter

delete /meters/{id}
Archive a meter by its ID.



# Create Meter
Source: https://docs.dodopayments.com/api-reference/meters/create-meter

post /meters
Create a new meter.



# List Meters
Source: https://docs.dodopayments.com/api-reference/meters/get-meters

get /meters
Get a list of all meters.



# Get Meter
Source: https://docs.dodopayments.com/api-reference/meters/retrieve-meter

get /meters/{id}
Retrieve a meter by its ID.



# Unarchive Meter
Source: https://docs.dodopayments.com/api-reference/meters/unarchive-meter

post /meters/{id}/unarchive
Unarchive a meter by its ID.



# Get Invoice
Source: https://docs.dodopayments.com/api-reference/payments/get-invoice

get /invoices/payments/{payment_id}
Get an invoice by Payment ID.



# List Payments
Source: https://docs.dodopayments.com/api-reference/payments/get-payments

get /payments
Get a list of all payments associated with your account.



# Get Payment Detail
Source: https://docs.dodopayments.com/api-reference/payments/get-payments-1

get /payments/{payment_id}
Get detailed information about a specific payment.



# Create One Time Payment
Source: https://docs.dodopayments.com/api-reference/payments/post-payments

post /payments
Create a one-time payment for a customer.

<Warning>
  **Deprecated API**: This API will be deprecated soon. We recommend using [Checkout Sessions](/api-reference/checkout-sessions/create) instead, which provides a more powerful and customizable API to create payment links for one-time payments and subscriptions.
</Warning>


# Retrieve Line Items
Source: https://docs.dodopayments.com/api-reference/payments/retrieve-line-items

get /payments/{payment_id}/line-items
Retrieve line items for a specific payment.



# Archive Products
Source: https://docs.dodopayments.com/api-reference/products/archive-product

delete /products/{id}
Archive a product associated with your account.



# List Products
Source: https://docs.dodopayments.com/api-reference/products/get-products

get /products
Get a list of all products associated with your account.



# Get Product Detail
Source: https://docs.dodopayments.com/api-reference/products/get-products-1

get /products/{id}
Get detailed information about a specific product.



# List Short Links
Source: https://docs.dodopayments.com/api-reference/products/get-products-short-links

get /products/short_links
Lists all short links created by the business. Short links provide shortened checkout URLs with custom slugs for your products.



# Update Product
Source: https://docs.dodopayments.com/api-reference/products/patch-products

patch /products/{id}
Update a product's details.



# Create Product
Source: https://docs.dodopayments.com/api-reference/products/post-products

post /products
Create a new product.



# Create Short Link
Source: https://docs.dodopayments.com/api-reference/products/post-products-id-short-links

post /products/{id}/short_links
Creates a short checkout URL with a custom slug for a product. Uses a Static Checkout URL under the hood.



# Update Product Images
Source: https://docs.dodopayments.com/api-reference/products/put-products-images

put /products/{id}/images
Update a product's images.



# Unarchive Products
Source: https://docs.dodopayments.com/api-reference/products/unarchive-product

post /products/{id}/unarchive
Unarchive a product associated with your account.



# Update Files
Source: https://docs.dodopayments.com/api-reference/products/update-files

put /products/{id}/files
Update the files associated with a product.



# Change Plan
Source: https://docs.dodopayments.com/api-reference/subscriptions/change-plan

post /subscriptions/{subscription_id}/change-plan
Modify an existing subscription's plan, enabling both upgrades and downgrades to different pricing tiers.<br/><br/>Note&colon; This will use the existing payment information of the customer to upgrade/downgrade the plan.



# Create Charge (On-Demand)
Source: https://docs.dodopayments.com/api-reference/subscriptions/create-charge

post /subscriptions/{subscription_id}/charge
Create a charge for a subscription. This is useful for on-demand billing.



# Get Subscription Detail
Source: https://docs.dodopayments.com/api-reference/subscriptions/get-subscriptions

get /subscriptions/{subscription_id}
Get detailed information about a specific subscription.



# List subscriptions
Source: https://docs.dodopayments.com/api-reference/subscriptions/get-subscriptions-1

get /subscriptions
Get a list of all subscriptions associated with your account.



# Get Subscription Usage History
Source: https://docs.dodopayments.com/api-reference/subscriptions/get-usage-history

get /subscriptions/{subscription_id}/usage-history
Retrieve the complete usage history for a subscription with usage-based billing.



# Update Subscription
Source: https://docs.dodopayments.com/api-reference/subscriptions/patch-subscriptions

patch /subscriptions/{subscription_id}
Update a subscription's details.



# Create Subscription
Source: https://docs.dodopayments.com/api-reference/subscriptions/post-subscriptions

post /subscriptions
Create a subscription for a customer.

<Warning>
  **Deprecated API**: This API will be deprecated soon. We recommend using [Checkout Sessions](/api-reference/checkout-sessions/create) instead, which provides a more powerful and customizable API to create payment links for one-time payments and subscriptions.
</Warning>


# Preview Plan Change
Source: https://docs.dodopayments.com/api-reference/subscriptions/preview-change-plan

post /subscriptions/{subscription_id}/change-plan/preview
Preview the effects of a subscription plan change before committing to it. Returns the immediate charge amount and the new subscription details without making any actual changes.

<Info>
  Use this endpoint to show customers exactly what they'll be charged when upgrading or downgrading their subscription, improving transparency and reducing support requests.
</Info>

## Use Cases

* **Checkout confirmation**: Display the prorated charge before customers confirm a plan change
* **Pricing calculators**: Build upgrade/downgrade calculators in your application
* **Customer self-service**: Let customers explore plan options with accurate pricing

## Response Fields

The preview response includes:

| Field              | Description                                                                    |
| ------------------ | ------------------------------------------------------------------------------ |
| `immediate_charge` | The charge that would be created immediately, including line items and summary |
| `new_plan`         | The full subscription object showing how it would look after the plan change   |

<Tip>
  The `immediate_charge.summary` contains the total amount that would be charged. Use this to display pricing to your customers before they confirm the plan change.
</Tip>


# Update Payment Method
Source: https://docs.dodopayments.com/api-reference/subscriptions/update-payment-method

post /subscriptions/{subscription_id}/update-payment-method
Update the payment method for an existing subscription. You can either add a new payment method or use an existing one from the customer's saved payment methods.

Update the payment method for a subscription. This endpoint supports both active subscriptions and subscriptions in `on_hold` state.

<Info>
  For subscriptions in `on_hold` state, updating the payment method automatically creates a charge for remaining dues, generates an invoice, and reactivates the subscription to `active` state upon successful payment.
</Info>

### Use Cases

* **Active subscriptions**: Update payment method when a card expires or customer wants to use a different payment method
* **On hold subscriptions**: Reactivate subscriptions that went on hold due to failed payments by updating the payment method
* **Payment method management**: Switch between saved payment methods or add new ones

<Info>
  To list existing payment methods for a customer, use the [List Payment Methods API](/api-reference/customers/get-customer-payment-methods). This helps you retrieve available payment method IDs when using `type: "existing"` to update a subscription's payment method.
</Info>

### Behavior for Active Subscriptions

When updating the payment method for an active subscription:

* The payment method is updated immediately
* No charge is created
* The subscription remains active
* Future renewals will use the new payment method

### Behavior for On Hold Subscriptions

When updating the payment method for a subscription in `on_hold` state:

1. A charge is automatically created for remaining dues
2. An invoice is generated for the charge
3. The payment is processed using the new payment method
4. Upon successful payment, the subscription is reactivated to `active` state
5. You'll receive webhook events: `payment.succeeded` followed by `subscription.active`

<Warning>
  If the payment fails after updating the payment method for an `on_hold` subscription, the subscription will remain in `on_hold` state. Monitor webhook events to track payment status.
</Warning>

### Webhook Events

When updating a payment method for an `on_hold` subscription, you'll receive the following webhook events:

1. **`payment.succeeded`** - The charge for remaining dues was successful
2. **`subscription.active`** - The subscription has been reactivated


# Transaction Failures
Source: https://docs.dodopayments.com/api-reference/transaction-failures

Learn about different transaction failure reasons and how to handle them in Dodo Payments API.

## Overview

Dodo Payments API provides detailed transaction failure reasons to help you understand why a payment attempt was unsuccessful. These failure reasons are standardized across different payment methods and providers, making it easier to implement consistent error handling in your application.

Each transaction failure response includes:

* A specific failure reason code
* A human-readable error message
* Additional context about the failure when available
* Whether the error is user-correctable or requires system intervention

Understanding these failure reasons is crucial for:

* Providing clear feedback to your customers
* Implementing appropriate retry logic
* Handling different failure scenarios gracefully
* Maintaining a reliable payment processing system

## Transaction Failure Reasons

The following table lists all possible transaction failure reasons, their meanings, and whether they are user-correctable errors.

| Failure Code                       | User Error | Description                                                     |
| ---------------------------------- | ---------- | --------------------------------------------------------------- |
| `AUTHENTICATION_FAILURE`           | Yes        | The authentication process failed during the transaction        |
| `AUTHENTICATION_REQUIRED`          | Yes        | Additional authentication is needed to complete the transaction |
| `AUTHENTICATION_TIMEOUT`           | Yes        | The authentication process timed out                            |
| `CARD_DECLINED`                    | No         | The card was declined by the issuing bank                       |
| `CARD_NOT_ACTIVATED`               | Yes        | The card has not been activated by the cardholder               |
| `CARD_VELOCITY_EXCEEDED`           | Yes        | Too many transactions attempted in a short period               |
| `CUSTOMER_CANCELLED`               | Yes        | The customer cancelled the transaction                          |
| `DO_NOT_HONOR`                     | No         | The issuing bank declined the transaction                       |
| `EXPIRED_CARD`                     | Yes        | The card has expired                                            |
| `FRAUDULENT`                       | Yes        | The transaction was flagged as potentially fraudulent           |
| `GENERIC_DECLINE`                  | No         | The transaction was declined for an unspecified reason          |
| `INCORRECT_CVC`                    | Yes        | The provided CVC code was incorrect                             |
| `INCORRECT_NUMBER`                 | Yes        | The card number was entered incorrectly                         |
| `INSUFFICIENT_FUNDS`               | Yes        | The account has insufficient funds to complete the transaction  |
| `INVALID_ACCOUNT`                  | Yes        | The account details provided are invalid                        |
| `INVALID_AMOUNT`                   | Yes        | The transaction amount is invalid                               |
| `INVALID_CARD_NUMBER`              | Yes        | The card number format is invalid                               |
| `INVALID_CARD_OWNER`               | Yes        | The card owner information is invalid                           |
| `INVALID_CVC`                      | Yes        | The CVC format is invalid                                       |
| `INVALID_EXPIRY_YEAR`              | Yes        | The card expiry year is invalid                                 |
| `INVALID_PIN`                      | Yes        | The provided PIN is incorrect                                   |
| `INVALID_REQUEST`                  | Yes        | The transaction request contains invalid data                   |
| `INVALID_UPI_ID`                   | Yes        | The UPI ID provided is invalid                                  |
| `LIMIT_EXCEEDED`                   | Yes        | The transaction exceeds the card or account limit               |
| `LIVE_MODE_TEST_CARD`              | Yes        | A test card was used in live mode                               |
| `LOST_CARD`                        | Yes        | The card has been reported as lost                              |
| `MANDATE_INVALID`                  | Yes        | The payment mandate is invalid                                  |
| `MANDATE_REQUIRED`                 | Yes        | A mandate is required for this transaction                      |
| `MANDATE_REQUIRED_SYSTEM`          | No         | System requires a mandate for this transaction type             |
| `NETWORK_ERROR`                    | No         | A network error occurred during the transaction                 |
| `NETWORK_TIMEOUT`                  | No         | The network request timed out                                   |
| `ORDER_CREATION_FAILED`            | No         | Failed to create the order for the transaction                  |
| `PAYMENT_METHOD_PROVIDER_DECLINED` | Yes        | The payment method provider declined the transaction            |
| `PAYMENT_METHOD_UNSUPPORTED`       | Yes        | The payment method is not supported for this transaction        |
| `PICKUP_CARD`                      | Yes        | The card has been reported as stolen and should be picked up    |
| `PROCESSING_ERROR`                 | No         | An error occurred while processing the transaction              |
| `PROVIDER_UNSUPPORTED`             | No         | The payment provider does not support this transaction type     |
| `REENTER_TRANSACTION`              | Yes        | The transaction needs to be re-entered                          |
| `REVOCATION_OF_AUTHORIZATION`      | Yes        | The authorization for the transaction was revoked               |
| `STOLEN_CARD`                      | Yes        | The card has been reported as stolen                            |
| `TRANSACTION_NOT_ALLOWED`          | Yes        | The transaction is not allowed for this card or account         |
| `TRANSACTION_NOT_APPROVED`         | Yes        | The transaction was not approved                                |
| `TRY_AGAIN_LATER`                  | No         | The transaction should be retried later                         |
| `UNKNOWN_ERROR`                    | No         | An unknown error occurred                                       |

<Note>
  **User Error** indicates whether the payment decline can be resolved by the customer. When `true`, the customer can take action to fix the issue (e.g., entering correct card details). When `false`, the decline is due to system-level issues or bank restrictions that cannot be resolved by the customer.
</Note>

## Support

For additional help with transaction failures or integration issues, please contact our support team at [support@dodopayments.com](mailto:support@dodopayments.com).


# Ingest Events
Source: https://docs.dodopayments.com/api-reference/usage-events/ingest-events

post /events/ingest
Ingest events for usage-based billing.



# Agent Skills
Source: https://docs.dodopayments.com/developer-resources/agent-skills

Enhance your AI coding assistants with official Dodo Payments skills for seamless payment integrations, webhook handling, and billing flows.

## Overview

Agent Skills are reusable capabilities that enhance what AI coding assistants can do when working with Dodo Payments. They provide procedural knowledge and best practices that help agents accomplish specific tasks more effectively - from integrating checkout flows to setting up usage-based billing.

<Info>
  **Think of skills as plugins for your AI assistant.** They teach your agent how to implement Dodo Payments features correctly, following our recommended patterns and best practices.
</Info>

Skills work with any MCP-compatible AI agent, including:

* **Claude Code** - Anthropic's CLI coding assistant
* **OpenCode** - Open source AI coding agent
* **Cursor** - AI-first code editor
* **Other MCP clients** - Any agent supporting the skills protocol

## Available Skills

| Skill                                                                                                               | Description                                                          |
| ------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| [dodo-best-practices](https://github.com/dodopayments/skills/tree/main/dodo-payments/best-practices)                | Comprehensive guide to integrating Dodo Payments with best practices |
| [webhook-integration](https://github.com/dodopayments/skills/tree/main/dodo-payments/webhook-integration)           | Setting up and handling webhooks for payment events                  |
| [subscription-integration](https://github.com/dodopayments/skills/tree/main/dodo-payments/subscription-integration) | Implementing subscription billing flows                              |
| [checkout-integration](https://github.com/dodopayments/skills/tree/main/dodo-payments/checkout-integration)         | Creating checkout sessions and payment flows                         |
| [usage-based-billing](https://github.com/dodopayments/skills/tree/main/dodo-payments/usage-based-billing)           | Implementing metered billing with events and meters                  |
| [billing-sdk](https://github.com/dodopayments/skills/tree/main/dodo-payments/billing-sdk)                           | Using BillingSDK React components                                    |
| [license-keys](https://github.com/dodopayments/skills/tree/main/dodo-payments/license-keys)                         | Managing license keys for digital products                           |

## Installation

Choose your preferred installation method based on your AI coding assistant.

<Tabs>
  <Tab title="Skills CLI">
    Install skills using the universal skills CLI that works with any MCP-compatible agent:

    ```bash theme={null}
    # Install all Dodo Payments skills
    npx skills add dodopayments/skills
    ```

    Or install individual skills as needed:

    ```bash theme={null}
    # Best practices guide
    npx skills add dodopayments/skills/dodo-best-practices

    # Webhook integration
    npx skills add dodopayments/skills/webhook-integration

    # Subscription billing
    npx skills add dodopayments/skills/subscription-integration

    # Checkout flows
    npx skills add dodopayments/skills/checkout-integration

    # Usage-based billing
    npx skills add dodopayments/skills/usage-based-billing

    # BillingSDK components
    npx skills add dodopayments/skills/billing-sdk

    # License key management
    npx skills add dodopayments/skills/license-keys
    ```

    <Tip>
      Install only the skills you need to keep your agent focused and reduce context overhead.
    </Tip>
  </Tab>

  <Tab title="Claude Code">
    Add the Dodo Payments skills marketplace to Claude Code:

    ```bash theme={null}
    /plugin marketplace add dodopayments/skills
    ```

    Then install individual plugins:

    ```bash theme={null}
    # Install best practices
    /plugin install dodo-best-practices

    # Install webhook integration
    /plugin install webhook-integration

    # Install subscription integration
    /plugin install subscription-integration

    # Install checkout integration
    /plugin install checkout-integration

    # Install usage-based billing
    /plugin install usage-based-billing

    # Install BillingSDK
    /plugin install billing-sdk

    # Install license keys
    /plugin install license-keys
    ```
  </Tab>

  <Tab title="OpenCode">
    Skills are automatically available when configured in your OpenCode settings. Add the Dodo Payments skills repository to your configuration:

    ```json theme={null}
    {
      "skills": {
        "repositories": [
          "dodopayments/skills"
        ]
      }
    }
    ```
  </Tab>
</Tabs>

## Using Skills

Once installed, your AI assistant can leverage these skills when you ask it to implement Dodo Payments features. Here are some example prompts:

### Best Practices

```
Help me integrate Dodo Payments into my Next.js app following best practices
```

### Webhooks

```
Set up webhook handlers for payment and subscription events
```

### Subscriptions

```
Implement a subscription flow with free trial and multiple pricing tiers
```

### Checkout

```
Create a checkout session for my SaaS product
```

### Usage-Based Billing

```
Add usage-based billing to track API calls for my AI product
```

### BillingSDK

```
Add a pricing page using BillingSDK components
```

### License Keys

```
Implement license key validation for my desktop app
```

## How Skills Work

Skills provide your AI assistant with:

1. **Procedural Knowledge** - Step-by-step instructions for implementing features
2. **Code Templates** - Production-ready code patterns and snippets
3. **Best Practices** - Recommended approaches for security, error handling, and UX
4. **Context Awareness** - Understanding of how different Dodo Payments features work together

When you ask your AI assistant to implement a feature, it uses the relevant skill to:

* Understand the correct implementation approach
* Generate accurate, working code
* Follow Dodo Payments conventions
* Handle edge cases and errors properly

<Note>
  Skills complement the [MCP Server](/developer-resources/mcp-server) and [Sentra](/developer-resources/sentra). Use MCP for API operations, Sentra for guided integration, and Skills for enhanced AI assistant capabilities.
</Note>

## Comparison with Other Tools

| Tool             | Purpose                        | Best For                                    |
| ---------------- | ------------------------------ | ------------------------------------------- |
| **Agent Skills** | Enhance AI assistant knowledge | AI-assisted development with any MCP client |
| **MCP Server**   | Execute API operations         | Direct API access from AI assistants        |
| **Sentra**       | Guided integration assistant   | Interactive billing integration in IDE      |

## Resources

<CardGroup>
  <Card title="Skills Repository" icon="github" href="https://github.com/dodopayments/skills">
    Browse the source code and contribute to Dodo Payments skills
  </Card>

  <Card title="MCP Server" icon="server" href="/developer-resources/mcp-server">
    Enable AI assistants to execute Dodo Payments API operations
  </Card>

  <Card title="Sentra" icon="wand-magic-sparkles" href="/developer-resources/sentra">
    AI-powered billing assistant for your IDE
  </Card>

  <Card title="Discord Community" icon="discord" href="https://discord.gg/bYqAp4ayYh">
    Get help and share feedback with the community
  </Card>
</CardGroup>


# Billing SDK
Source: https://docs.dodopayments.com/developer-resources/billingsdk

Complete billing infrastructure for modern web applications with React components, CLI tooling, and full-stack integration

<Frame>
  <iframe title="Billing SDK | Dodo Payments" />
</Frame>

Billing SDK is a comprehensive open-source solution that provides complete billing infrastructure for modern web applications. It includes React components, CLI tooling, and full-stack integration support for multiple frameworks with Dodo Payments.

## Overview

Billing SDK offers:

* **React Components**: Pre-built, customizable billing components for React applications
* **CLI Tooling**: Command-line interface for project initialization and component management
* **Framework Support**: Integration with Next.js, Express.js, Hono, Fastify, and React
* **Payment Provider**: Full integration with Dodo Payments

## Quick Start

Get started with Billing SDK in minutes:

<Steps>
  <Step title="Install the CLI">
    Use npx to run the CLI without installation:

    ```bash theme={null}
    npx @billingsdk/cli --help
    ```

    Or install it globally for frequent use:

    ```bash theme={null}
    npm install -g @billingsdk/cli
    ```
  </Step>

  <Step title="Initialize a Project">
    Run the interactive setup to create a new billing project:

    ```bash theme={null}
    npx @billingsdk/cli init
    ```

    You'll be prompted to select:

    * Your preferred framework (Next.js, Express.js, Hono, Fastify, React)
    * Your payment provider (Dodo Payments)
  </Step>

  <Step title="Add Components">
    Add individual billing components to your project:

    ```bash theme={null}
    npx @billingsdk/cli add pricing-table-one
    npx @billingsdk/cli add subscription-management
    ```
  </Step>
</Steps>

## Supported Frameworks

Billing SDK supports multiple frameworks with comprehensive Dodo Payments integration:

| Framework  | Dodo Payments |
| ---------- | ------------- |
| Next.js    | ✅ Yes         |
| Express.js | ✅ Yes         |
| Hono       | ✅ Yes         |
| React      | ✅ Yes         |
| Fastify    | ✅ Yes         |

## CLI Commands

### `@billingsdk/cli init`

Initialize a new billing project with complete setup including framework configuration, Dodo Payments integration, and essential dependencies.

**What it does:**

1. **Framework Selection**: Choose your preferred framework
2. **Template Installation**: Downloads and installs framework-specific templates with Dodo Payments integration
3. **Dependency Management**: Automatically installs required dependencies
4. **File Generation**: Creates necessary configuration files and boilerplate code

**Example:**

```bash theme={null}
npx @billingsdk/cli init
```

### `@billingsdk/cli add`

Add individual billing components to your existing project using the shadcn/ui registry system.

**Examples:**

```bash theme={null}
# Add a pricing table
npx @billingsdk/cli add pricing-table-one

# Add subscription management
npx @billingsdk/cli add subscription-management

# Add usage monitoring
npx @billingsdk/cli add usage-meter-circle
```

**What happens:**

1. Downloads the component configuration from the registry
2. Installs the component files in your `components/billingsdk/` directory
3. Updates your project configuration if needed
4. Installs any additional dependencies

## Generated Files Structure

After running `init`, you'll get a complete project structure with:

* **API Routes**: Comprehensive endpoints for checkout, customers, products, subscriptions, and webhooks
* **Hooks**: React hooks for billing operations (if using React/Next.js)
* **Library Files**: Payment provider client initialization and utilities
* **Environment Configuration**: Example environment variable files

### Next.js Example Structure

```
your-project/
├── app/api/
│   └── (dodopayments)/
│       ├── checkout/route.ts
│       ├── customer/route.ts
│       ├── customer/payments/route.ts
│       ├── customer/subscriptions/route.ts
│       ├── product/route.ts
│       ├── products/route.ts
│       └── webhook/route.ts
├── hooks/
│   └── useBilling.ts
├── lib/
│   └── dodopayments.ts
└── .env.example
```

## Environment Configuration

Configure your environment variables after initialization:

```bash theme={null}
# DodoPayments
DODO_PAYMENTS_API_KEY=your_api_key_here
DODO_PAYMENTS_ENVIRONMENT=test_mode
DODO_PAYMENTS_WEBHOOK_KEY=your_webhook_key_here

# App URL
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

<Warning>
  Always store your API keys securely using environment variables. Never commit them to version control.
</Warning>

## Available Components

Billing SDK provides a comprehensive collection of React components:

* **Pricing Tables**: Multiple variants for displaying product pricing
* **Subscription Management**: Components for managing customer subscriptions
* **Usage Monitoring**: Visual components for tracking usage-based billing
* **Checkout Components**: Pre-built checkout flows
* **Customer Portal**: Components for customer self-service

## Open Source

Billing SDK is built on open-source principles:

* 🔍 **Transparency**: Full visibility into how components work
* 🤝 **Community**: Built by developers, for developers
* 🔒 **Security**: Open code means better security through peer review
* 📈 **Innovation**: Faster iteration through community contributions

<Info>
  Billing SDK is released under the GNU General Public License (GPL), ensuring the project remains open and free.
</Info>

## Getting Help

Need assistance with Billing SDK?

* **GitHub Issues**: [Open an issue](https://github.com/dodopayments/billingsdk/issues)
* **Documentation**: Visit [billingsdk.com/docs](https://billingsdk.com/docs)
* **LLMs Full Documentation**: [billingsdk.com/llms-full.txt](https://billingsdk.com/llms-full.txt)

## Contributing

We welcome contributions! See our [contribution guide](https://billingsdk.com/docs/contribution-open-source) for details on:

* Reporting bugs
* Requesting features
* Submitting pull requests
* Adding new components
* Improving documentation

## Learn More

<CardGroup>
  <Card title="Full Documentation" icon="book" href="https://billingsdk.com/docs">
    Complete guide to Billing SDK with examples and best practices
  </Card>

  <Card title="CLI Reference" icon="terminal" href="https://billingsdk.com/docs/cli">
    Detailed CLI documentation for all commands and options
  </Card>

  <Card title="Component Library" icon="boxes-stacked" href="https://billingsdk.com/docs/components">
    Browse all available components with live examples
  </Card>
</CardGroup>


# Build an AI Chat App with AI SDK & LLM Blueprint
Source: https://docs.dodopayments.com/developer-resources/build-an-ai-chat-app-with-usage-based-billing

Follow along as we build an AI chat app with automatic token tracking and usage-based billing

<Tip>
  <strong>Let Sentra write your integration code for you.</strong><br />
  Use our AI assistant in VS Code, Cursor, or Windsurf to generate SDK/API code, LLM Blueprint integration code, webhooks, and more - just by describing what you want.

  <a href="https://dodopayments.com/sentra">
    Try Sentra: AI-Powered Integration →
  </a>
</Tip>

In this tutorial, you'll build an **AI chat application** with automatic usage-based billing. We'll create everything from scratch: the billing meter, product configuration, and application code that powers conversations and tracks token usage in real-time.

<Note>
  This tutorial provides a complete working application with both backend and frontend. The chat app uses Google's Gemini AI and automatically tracks token usage without any manual counting required.
</Note>

By the end of this tutorial, you'll have a working chat application that:

* Powers AI conversations using Google Gemini (AI SDK)
* Automatically tracks token usage (no manual code)
* Charges customers based on actual token consumption
* Includes a beautiful chat interface

<Frame>
  <img alt="AI Chat Demo" />
</Frame>

## What We're Building

Let's start by understanding our AI chat service:

* **Service**: AI-powered chat using Google Gemini (AI SDK)
* **Pricing Model**: Pay-per-token (\$0.01 per 1,000 tokens)
* **Free Tier**: 10,000 free tokens per customer per month
* **Features**: Conversation history, automatic token tracking

<Info>
  Before we start, make sure you have:

  * A Dodo Payments account
  * A Google AI API key ([Get one from aistudio](https://aistudio.google.com/api-keys))
  * Node.js v16+ installed
</Info>

***

## Step 1: Create Your Usage Meter

We'll start by creating a meter in your Dodo Payments dashboard that will track AI token usage.

<Tip>
  **What we're building**: A meter named "AI Token Usage Meter" that sums up all tokens consumed in chat conversations.
</Tip>

<Steps>
  <Step title="Open the Meters section">
    1. Log into your Dodo Payments dashboard
    2. Click on Products in the left sidebar
    3. Click on **Meters**
    4. Click the **Create Meter** button

    <Frame>
      <img alt="Create Meter" />
    </Frame>

    You should see a form where we'll configure our token tracking.
  </Step>

  <Step title="Fill in the basic meter information">
    Now we'll enter the specific details for our AI chat service:

    **Meter Name** → `AI Token Usage Meter`

    **Description** → `Tracks token consumption from AI chat conversations using AI SDK`

    **Event Name** → `ai_chat_usage`

    <Warning>
      The event name `ai_chat_usage` must match exactly what we'll send from our application code later. Event names are case-sensitive!
    </Warning>
  </Step>

  <Step title="Configure how we count tokens">
    Set up the aggregation (how the meter counts our events):

    **Aggregation Type**: Select **Sum** from the dropdown

    **Aggregate Over**: Type → `totalTokens`

    **Measurement Unit**: Type → `tokens`

    <Info>
      We're using "Sum" because we want to add up all tokens consumed across multiple chat messages. The SDK automatically sends `totalTokens` in each event.
    </Info>
  </Step>

  <Step title="Create your meter">
    1. Double-check all your settings match the values above
    2. Click **Create Meter**

    <Frame>
      <img alt="Meter Configuration" />
    </Frame>

    <Check>
      **Meter created!** Your "AI Token Usage Meter" is now ready to start counting tokens. Next, we'll connect it to a billing product.
    </Check>
  </Step>
</Steps>

## Step 2: Get Your API Keys

Before we build the app, let's gather the API keys we'll need.

<Steps>
  <Step title="Get Dodo Payments API Key">
    1. In your Dodo Payments dashboard, go to **Developers** → **API Keys**
    2. Click **Create API Key**
    3. Copy the API key - it will look like `test_abc123...`

    <Note>
      Save this API key - we'll add it to our `.env` file later.
    </Note>
  </Step>

  <Step title="Get Google AI API Key">
    1. Visit [aistudio.google.com](https://aistudio.google.com/api-keys)
    2. Click **Get API Key**
    3. Create a new API key or use an existing one
    4. Copy the key

    <Note>
      Keep this key safe - we'll also add it to our `.env` file.
    </Note>
  </Step>
</Steps>

***

## Step 3: Create Your Billing Product

Now we need to create a product that defines our pricing (\$0.01 per 1,000 tokens with 10,000 free tokens). This connects our meter to actual billing.

<Tip>
  **What we're building**: A product called "AI Chat Service" that charges based on token consumption with a generous free tier.
</Tip>

<Steps>
  <Step title="Navigate to Products">
    1. In your Dodo Payments dashboard, click **Products** in the left sidebar
    2. Click **Create Product**
    3. Select **Usage-Based** as the product type

    This tells Dodo Payments that billing will be based on meter usage, not a fixed subscription.
  </Step>

  <Step title="Enter product details">
    Fill in the required details:

    **Product Name**: → `AI Chat Service`

    **Description**: → `AI-powered chat service with automatic token-based billing`

    **Product Image**: Upload a relevant image

    <Info>
      These will appear on customer invoices, so make them clear and professional.
    </Info>
  </Step>

  <Step title="Connect your meter">
    Before connecting your meter, make sure you have selected **Usage Based Billing** as the price type for your product.

    Additionally, set the **Fixed Price** to `0` to ensure customers are only charged based on their usage, with no base fee.

    Now, link the meter you just created:

    1. Scroll down to the **Associated Meter** section
    2. Click **Add Meters**
    3. From the dropdown, select **"AI Token Usage Meter"** (the one you created earlier)
    4. Confirm that it appears in your product configuration

    <Check>
      Your meter is now successfully connected to this product.
    </Check>
  </Step>

  <Step title="Set your pricing">
    Here's where we define our business model:

    **Price Per Unit**: Enter → `0.00001` (this is $0.01 per 1,000 tokens or $0.00001 per token)

    **Free Threshold**: Enter → `10000` (customers get 10,000 free tokens per month)

    <Frame>
      <img alt="Product Pricing" />
    </Frame>

    <Tip>
      **How billing works**: If a customer uses 25,000 tokens in a month, they'll be charged for 15,000 tokens (25,000 - 10,000 free) = 15,000 × $0.00001 = $0.15
    </Tip>
  </Step>

  <Step title="Save your product">
    1. Review all your settings:
       * Name: AI Chat Service
       * Meter: AI Token Usage Meter
       * Price: \$0.01 per 1,000 tokens
       * Free tier: 10,000 tokens
    2. Click **Save Changes**

    <Check>
      **Product created!** Your billing is now configured. Customers will automatically be charged based on their token usage.
    </Check>
  </Step>
</Steps>

## Step 4: Make a Test Purchase

Before we start building the app, let's create a test customer by making a purchase.

<Steps>
  <Step title="Get your payment link">
    1. In your Dodo Payments dashboard, go to **Products**
    2. Find your "AI Chat Service" product
    3. Click the **Share** button next to your product
    4. Copy the payment link that appears
  </Step>

  <Step title="Complete a test purchase">
    1. Open the payment link in a new browser tab
    2. Enter test payment details and complete purchase

    <Check>
      After successful payment, you'll have a customer ID that we'll use in our application code.
    </Check>
  </Step>

  <Step title="Find your customer ID">
    1. Go back to your Dodo Payments dashboard
    2. Navigate to **Sales** -> **Customers** in the left sidebar
    3. Find the customer you just created (with the test email)
    4. Copy the customer ID - it will look like `cus_123`

    <Note>
      Save this customer ID - we'll use it when testing our chat application.
    </Note>
  </Step>
</Steps>

## Step 5: Build the Chat Application

Now we have our billing setup complete and a test customer created. Let's build the AI chat application with automatic token tracking.

<Steps>
  <Step title="Set up your project">
    Create a new directory and initialize the project:

    ```bash theme={null}
    mkdir ai-chat-app
    cd ai-chat-app
    npm init -y
    ```
  </Step>

  <Step title="Install dependencies">
    Install the packages we need:

    ```bash theme={null}
    npm install express ai @ai-sdk/google @dodopayments/ingestion-blueprints dotenv
    npm install --save-dev typescript @types/express @types/node tsx
    ```
  </Step>

  <Step title="Configure TypeScript">
    Create `tsconfig.json`:

    ```json tsconfig.json theme={null}
    {
      "compilerOptions": {
        "target": "ES2020",
        "module": "ESNext",
        "moduleResolution": "node",
        "esModuleInterop": true,
        "strict": true,
        "skipLibCheck": true,
        "outDir": "./dist",
        "rootDir": "./src"
      },
      "include": ["src/**/*"],
      "exclude": ["node_modules"]
    }
    ```

    Update `package.json` to add the module type and scripts:

    ```json package.json theme={null}
    {
      "type": "module",
      "scripts": {
        "dev": "tsx src/server.ts",
        "build": "tsc",
        "start": "node dist/server.js"
      }
    }
    ```
  </Step>

  <Step title="Create project structure">
    Create the folders and files:

    ```bash theme={null}
    mkdir src public
    ```
  </Step>

  <Step title="Set up environment variables">
    Create a `.env` file in your project root:

    ```bash .env theme={null}
    DODO_PAYMENTS_API_KEY=your_dodo_api_key_here
    DODO_ENVIRONMENT=test_mode
    GOOGLE_GENERATIVE_AI_API_KEY=your_google_api_key_here
    PORT=3000
    ```

    Replace the placeholder values with your actual API keys from Step 2.
  </Step>

  <Step title="Create the backend server">
    Create `src/server.ts` and copy this complete server code:
  </Step>
</Steps>

Here's the complete AI chat server with integrated billing:

<CodeGroup>
  ```typescript src/server.ts expandable theme={null}
  import express, { Request, Response } from 'express';
  import { generateText } from 'ai';
  import { google } from '@ai-sdk/google';
  import { createLLMTracker } from '@dodopayments/ingestion-blueprints';
  import 'dotenv/config';

  const app = express();
  app.use(express.json());
  app.use(express.static('public'));

  // Replace with your test customer ID
  const CUSTOMER_ID = 'cus_123';

  // Create tracker once with your meter event name
  const llmTracker = createLLMTracker({
    apiKey: process.env.DODO_PAYMENTS_API_KEY!,
    environment: process.env.DODO_ENVIRONMENT as 'test_mode' | 'live_mode',
    eventName: 'ai_chat_usage', // Must match your meter configuration
  });

  // Chat endpoint with conversation support
  app.post('/chat', async (req: Request, res: Response) => {
    try {
      const { messages } = req.body;

      if (!messages || !Array.isArray(messages)) {
        return res.status(400).json({ 
          error: 'Missing required field: messages (array)' 
        });
      }

      // Wrap AI SDK with automatic token tracking
      const trackedClient = llmTracker.wrap({
        client: { generateText },
        customerId: CUSTOMER_ID
      });

      // Generate AI response - tokens are automatically tracked!
      const response = await trackedClient.generateText({
        model: google('gemini-2.5-flash'),
        messages: messages
      });

      res.json({
        message: response.text,
        usage: {
          totalTokens: response.usage.totalTokens
        }
      });

    } catch (error: any) {
      console.error('Chat error:', error);
      res.status(500).json({ 
        error: 'Failed to process chat',
        details: error.message 
      });
    }
  });

  const PORT = process.env.PORT || 3000;
  app.listen(PORT, () => {
    console.log(`🚀 Server running at http://localhost:${PORT}`);
    console.log(`📊 Tracking event: ai_chat_usage`);
    console.log(`👤 Customer ID: ${CUSTOMER_ID}`);
    console.log(`🔧 Environment: ${process.env.DODO_ENVIRONMENT}`);
  });
  ```

  ```bash .env theme={null}
  # Add your API keys here
  DODO_PAYMENTS_API_KEY=your_dodo_api_key_here
  DODO_ENVIRONMENT=test_mode
  GOOGLE_GENERATIVE_AI_API_KEY=your_google_api_key_here
  PORT=3000
  ```

  ```json package.json expandable theme={null}
  {
    "name": "ai-chat-app",
    "version": "1.0.0",
    "type": "module",
    "scripts": {
      "dev": "tsx src/server.ts",
      "build": "tsc",
      "start": "node dist/server.js"
    },
    "dependencies": {
      "express": "^4.18.2",
      "ai": "^3.0.0",
      "@ai-sdk/google": "^0.0.15",
      "@dodopayments/ingestion-blueprints": "latest",
      "dotenv": "^16.0.3"
    },
    "devDependencies": {
      "typescript": "^5.0.0",
      "@types/express": "^4.17.17",
      "@types/node": "^20.0.0",
      "tsx": "^3.12.7"
    }
  }
  ```
</CodeGroup>

***

## Step 6: Add the Chat Interface

Now let's add a beautiful chat interface with full conversation history! Create `public/index.html`:

```html public/index.html expandable theme={null}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Chat with Usage Billing</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        background: #0f0f1e;
        background-image: radial-gradient(
            at 0% 0%,
            rgba(102, 126, 234, 0.15) 0px,
            transparent 50%
          ),
          radial-gradient(
            at 100% 100%,
            rgba(118, 75, 162, 0.15) 0px,
            transparent 50%
          ),
          radial-gradient(
            at 50% 50%,
            rgba(102, 126, 234, 0.05) 0px,
            transparent 50%
          );
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0;
        position: relative;
        overflow: hidden;
        margin: 0;
      }

      .chat-container {
        background: rgba(22, 22, 35, 0.95);
        border: 1px solid rgba(102, 126, 234, 0.2);
        border-radius: 0;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        width: 100%;
        max-width: 100%;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        position: relative;
        z-index: 1;
      }

      .chat-header {
        background: linear-gradient(
          135deg,
          rgba(102, 126, 234, 0.15) 0%,
          rgba(118, 75, 162, 0.15) 100%
        );
        border-bottom: 1px solid rgba(102, 126, 234, 0.2);
        color: white;
        padding: 24px 28px;
        position: relative;
        overflow: hidden;
      }

      .chat-header h1 {
        font-size: 26px;
        margin-bottom: 6px;
        font-weight: 700;
        letter-spacing: -0.5px;
        color: #fff;
      }

      .chat-header p {
        font-size: 13px;
        opacity: 0.6;
        font-weight: 500;
        letter-spacing: 0.3px;
      }

      .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 32px 10%;
        background: transparent;
        will-change: scroll-position;
        scroll-behavior: smooth;
      }

      .chat-messages::-webkit-scrollbar {
        width: 6px;
      }

      .chat-messages::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
      }

      .chat-messages::-webkit-scrollbar-thumb {
        background: rgba(102, 126, 234, 0.3);
        border-radius: 3px;
      }

      .chat-messages::-webkit-scrollbar-thumb:hover {
        background: rgba(102, 126, 234, 0.5);
      }

      .message {
        margin-bottom: 20px;
        display: flex;
        gap: 12px;
        animation: slideIn 0.2s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }

        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .message.user {
        flex-direction: row-reverse;
      }

      .message-avatar {
        width: 40px;
        height: 40px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        flex-shrink: 0;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }

      .message.user .message-avatar {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }

      .message.assistant .message-avatar {
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      }

      .message-content {
        max-width: 65%;
      }

      .message-bubble {
        padding: 14px 18px;
        border-radius: 18px;
        line-height: 1.6;
        word-wrap: break-word;
        font-size: 15px;
        position: relative;
      }

      .message.user .message-bubble {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-bottom-right-radius: 6px;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
      }

      .message.assistant .message-bubble {
        background: rgba(255, 255, 255, 0.05);
        color: rgba(255, 255, 255, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-bottom-left-radius: 6px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }

      .message-meta {
        display: flex;
        gap: 10px;
        margin-top: 8px;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.4);
        font-weight: 500;
      }

      .message.user .message-meta {
        justify-content: flex-end;
      }

      .token-badge {
        background: rgba(102, 126, 234, 0.2);
        color: #a8b9ff;
        padding: 4px 10px;
        border-radius: 12px;
        font-weight: 600;
        border: 1px solid rgba(102, 126, 234, 0.3);
      }

      .chat-input-area {
        padding: 24px 10% 32px;
        background: rgba(22, 22, 35, 0.95);
        border-top: 1px solid rgba(102, 126, 234, 0.2);
      }

      .input-wrapper {
        display: flex;
        gap: 12px;
        align-items: flex-end;
      }

      #messageInput {
        flex: 1;
        background: rgba(255, 255, 255, 0.05);
        border: 2px solid rgba(102, 126, 234, 0.2);
        border-radius: 16px;
        padding: 14px 20px;
        font-size: 15px;
        font-family: inherit;
        resize: none;
        max-height: 120px;
        transition: border-color 0.2s ease, background 0.2s ease;
        color: white;
        will-change: border-color;
        overflow: hidden;
        scrollbar-width: none;
        /* Firefox */
      }

      #messageInput::-webkit-scrollbar {
        display: none;
      }

      #messageInput::placeholder {
        color: rgba(255, 255, 255, 0.3);
      }

      #messageInput:focus {
        outline: none;
        border-color: #667eea;
        background: rgba(255, 255, 255, 0.08);
      }

      #sendBtn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        width: 52px;
        height: 52px;
        border-radius: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 22px;
        transition: transform 0.1s ease, box-shadow 0.1s ease;
        flex-shrink: 0;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        position: relative;
      }

      #sendBtn:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
      }

      #sendBtn:active:not(:disabled) {
        transform: translateY(0);
      }

      #sendBtn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        box-shadow: none;
      }

      .typing-indicator {
        display: none;
        padding: 14px 18px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 18px;
        border-bottom-left-radius: 6px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        width: fit-content;
      }

      .typing-indicator.show {
        display: block;
      }

      .typing-dots {
        display: flex;
        gap: 6px;
      }

      .typing-dots span {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #667eea;
        animation: typing 1.4s infinite ease-in-out;
        will-change: transform, opacity;
      }

      .typing-dots span:nth-child(2) {
        animation-delay: 0.2s;
      }

      .typing-dots span:nth-child(3) {
        animation-delay: 0.4s;
      }

      @keyframes typing {
        0%,
        60%,
        100% {
          transform: translateY(0) scale(1);
          opacity: 0.6;
        }

        30% {
          transform: translateY(-12px) scale(1.1);
          opacity: 1;
        }
      }

      .error-message {
        background: rgba(239, 68, 68, 0.15);
        color: #fca5a5;
        padding: 14px 18px;
        border-radius: 12px;
        margin-bottom: 12px;
        display: none;
        border: 1px solid rgba(239, 68, 68, 0.3);
        font-size: 14px;
        font-weight: 500;
      }

      .error-message.show {
        display: block;
        animation: slideIn 0.3s ease;
      }

      .empty-state {
        text-align: center;
        padding: 80px 20px;
        color: rgba(255, 255, 255, 0.5);
      }

      .empty-state-icon {
        font-size: 72px;
        margin-bottom: 20px;
        animation: float 3s ease-in-out infinite;
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0px);
        }

        50% {
          transform: translateY(-10px);
        }
      }

      .empty-state h2 {
        font-size: 24px;
        margin-bottom: 10px;
        color: rgba(255, 255, 255, 0.9);
        font-weight: 700;
        letter-spacing: -0.5px;
      }

      .empty-state p {
        font-size: 15px;
        color: rgba(255, 255, 255, 0.4);
        font-weight: 500;
      }
    </style>
  </head>

  <body>
    <div class="chat-container">
      <div class="chat-header">
        <h1>🤖 AI Chat Assistant</h1>
        <p>Powered by AI-SDK & Dodo Payments</p>
      </div>

      <div class="chat-messages" id="chatMessages">
        <div class="empty-state" id="emptyState">
          <div class="empty-state-icon">💬</div>
          <h2>Start a Conversation</h2>
          <p>Ask me anything! Your token usage is automatically tracked.</p>
        </div>
      </div>

      <div class="chat-input-area">
        <div class="error-message" id="errorMessage"></div>
        <div class="input-wrapper">
          <textarea
            id="messageInput"
            placeholder="Type your message here..."
            rows="1"
          ></textarea>
          <button id="sendBtn" onclick="sendMessage()">➤</button>
        </div>
      </div>
    </div>

    <script>
      let conversationHistory = [];

      const messageInput = document.getElementById("messageInput");
      let resizeTimeout;
      messageInput.addEventListener("input", function () {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          this.style.height = "auto";
          this.style.height = Math.min(this.scrollHeight, 120) + "px";
        }, 10);
      });

      // Send message on Enter (Shift+Enter for new line)
      messageInput.addEventListener("keydown", function (e) {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });

      async function sendMessage() {
        const input = document.getElementById("messageInput");
        const message = input.value.trim();

        if (!message) return;

        // Hide empty state
        document.getElementById("emptyState").style.display = "none";

        // Hide error
        document.getElementById("errorMessage").classList.remove("show");

        // Add user message to UI
        addMessage("user", message);

        // Add to conversation history
        conversationHistory.push({
          role: "user",
          content: message,
        });

        // Clear input
        input.value = "";
        input.style.height = "auto";

        // Show typing indicator
        showTypingIndicator();

        // Disable send button
        const sendBtn = document.getElementById("sendBtn");
        sendBtn.disabled = true;

        try {
          const response = await fetch("/chat", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              messages: conversationHistory,
            }),
          });

          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to get response");
          }

          // Hide typing indicator
          hideTypingIndicator();

          // Add assistant response to UI
          addMessage("assistant", data.message, data.usage);

          // Add to conversation history
          conversationHistory.push({
            role: "assistant",
            content: data.message,
          });
        } catch (error) {
          hideTypingIndicator();
          showError(error.message);
          // Remove the last user message from history since it failed
          conversationHistory.pop();
        } finally {
          sendBtn.disabled = false;
        }
      }

      function addMessage(role, content, usage = null) {
        const messagesDiv = document.getElementById("chatMessages");

        const messageDiv = document.createElement("div");
        messageDiv.className = `message ${role}`;

        const avatar = role === "user" ? "👤" : "🤖";

        let metaHTML = "";
        if (usage) {
          metaHTML = `
                    <div class="message-meta">
                        <span class="token-badge">📊 ${usage.totalTokens} tokens</span>
                    </div>
                `;
        }

        messageDiv.innerHTML = `
                <div class="message-avatar">${avatar}</div>
                <div class="message-content">
                    <div class="message-bubble">${escapeHtml(content)}</div>
                    ${metaHTML}
                </div>
            `;

        messagesDiv.appendChild(messageDiv);
        requestAnimationFrame(() => {
          messagesDiv.scrollTop = messagesDiv.scrollHeight;
        });
      }

      function showTypingIndicator() {
        const messagesDiv = document.getElementById("chatMessages");

        const typingDiv = document.createElement("div");
        typingDiv.className = "message assistant";
        typingDiv.id = "typingIndicator";
        typingDiv.innerHTML = `
                <div class="message-avatar">🤖</div>
                <div class="typing-indicator show">
                    <div class="typing-dots">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            `;

        messagesDiv.appendChild(typingDiv);
        requestAnimationFrame(() => {
          messagesDiv.scrollTop = messagesDiv.scrollHeight;
        });
      }

      function hideTypingIndicator() {
        const typingIndicator = document.getElementById("typingIndicator");
        if (typingIndicator) {
          typingIndicator.remove();
        }
      }

      function showError(message) {
        const errorDiv = document.getElementById("errorMessage");
        errorDiv.textContent = "❌ " + message;
        errorDiv.classList.add("show");
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML.replace(/\n/g, "<br>");
      }
    </script>
  </body>
</html>
```

***

## Step 7: Test Your Chat Application

Time to test our AI chat app and see the billing in action! Let's make sure everything works end-to-end.

<Tip>
  **What we're testing**: We'll have some conversations with the AI, verify the token events reach Dodo Payments, and confirm billing calculations are correct.
</Tip>

<Steps>
  <Step title="Start the server">
    First, make sure everything is set up:

    1. Verify your `.env` file has all the API keys from Step 2
    2. Start the development server:

    ```bash theme={null}
    npm run dev
    ```

    You should see:

    ```
    🚀 Server running at http://localhost:3000
    📊 Tracking event: ai_chat_usage
    👤 Customer ID: {YOUR CUSTOMER_ID}
    🔧 Environment: test_mode
    ```

    <Check>
      Server is running! Time to chat.
    </Check>
  </Step>

  <Step title="Open the chat interface">
    1. Open your browser
    2. Navigate to `http://localhost:3000`
    3. You should see the beautiful chat interface

    <Note>
      Make sure you update the `CUSTOMER_ID` in `server.ts` with your actual test customer ID from Step 4.
    </Note>
  </Step>

  <Step title="Have your first conversation">
    Let's test it out! Try these messages:

    1. **"What is artificial intelligence?"**
    2. **"How does machine learning work?"**
    3. **"Can you explain neural networks?"**

    Watch the token usage display update after each response!

    <Check>
      If you see the AI responding and token counts appearing, your app is working!
    </Check>
  </Step>

  <Step title="Check your Dodo Payments dashboard">
    Now let's verify the events are being received:

    1. Open your Dodo Payments dashboard
    2. Go to **Usage Billing** → **AI Token Usage Meter**
    3. Click on the **Events** tab
    4. You should see your chat events listed

    **What to look for:**

    * Event names: `ai_chat_usage`
    * Customer ID: Your test customer id

    <Frame>
      <img alt="Meter Events" />
    </Frame>

    <Check>
      You should see one event for each message you sent!
    </Check>
  </Step>

  <Step title="Verify token counting">
    Let's send some more messages and check if the token aggregation is working:

    1. In your meter, go to the **Customers** tab
    2. Find your test customer
    3. Check the "Consumed Units" column - it should show the total tokens used

    <Frame>
      <img alt="Meter Customer Tokens" />
    </Frame>

    <Info>
      The meter is summing up all `totalTokens` values automatically!
    </Info>
  </Step>

  <Step title="Test the free tier">
    Let's use enough tokens to exceed the free tier:

    1. Have several more conversations (aim for \~15,000+ total tokens)
    2. Check your **Customers** tab in meter dashboard again
    3. You should now see:
       * Consumed Units: 15,000+ tokens
       * Chargeable Units: 5,000 (10,000 free tokens applied)
       * Total Price: \~\$0.05

    <Frame>
      <img alt="Free Tier Test" />
    </Frame>

    <Check>
      **Success!** Your usage-based billing is working perfectly. Customers will be automatically charged based on their actual token consumption.
    </Check>
  </Step>
</Steps>

***

## Troubleshooting

Common issues and their solutions:

<AccordionGroup>
  <Accordion title="Events not appearing in dashboard">
    **Possible causes:**

    * Event name doesn't match meter configuration exactly
    * Customer ID doesn't exist in your account
    * API key is invalid or expired
    * Network connectivity issues

    **Solutions:**

    1. Verify event name matches meter configuration exactly (case-sensitive: `ai_chat_usage`)
    2. Check that customer ID exists in Dodo Payments dashboard
    3. Test API key with a simple API call
    4. Check server logs for error messages
  </Accordion>

  <Accordion title="Token counts showing zero">
    **Possible causes:**

    * Model not returning usage information
    * Incorrect SDK version

    **Solutions:**

    1. Test if model returns usage:

    ```typescript theme={null}
    const response = await generateText({...});
    console.log('Usage:', response.usage);
    ```

    2. Update to latest Blueprints SDK: `npm install @dodopayments/ingestion-blueprints@latest`
  </Accordion>

  <Accordion title="API key invalid error">
    **Possible causes:**

    * Wrong API key for environment
    * Extra spaces or quotes in `.env` file

    **Solutions:**

    * Ensure test key starts with `test_`, live key starts with `live_`
    * Remove any quotes around keys in `.env` file
    * Generate a new key if needed
  </Accordion>
</AccordionGroup>

Need help?

* [Discord Community](https://discord.gg/bYqAp4ayYh)
* [support@dodopayments.com](mailto:support@dodopayments.com)

***

## Congratulations! You Built an AI Chat App

You now have a fully functional AI chat application with automatic token usage tracking and billing powered by Dodo Payments. 🎉

### Learn More

<CardGroup>
  <Card title="LLM Blueprint" icon="robot" href="/developer-resources/ingestion-blueprints/llm">
    Learn more about LLM Ingestion Blueprint
  </Card>

  <Card title="Ingestion Blueprints SDK" icon="github" href="https://github.com/dodopayments/ingestion-blueprints">
    Check out the GitHub repository for more examples
  </Card>

  <Card title="Join Community" icon="discord" href="https://discord.gg/bYqAp4ayYh">
    Get help and share your projects on Discord
  </Card>
</CardGroup>


# Checkout Sessions
Source: https://docs.dodopayments.com/developer-resources/checkout-session

Create secure, hosted checkout experiences that handle the complete payment flow for both one-time purchases and subscriptions with full customization control.

<CardGroup>
  <Card title="Quick Start Guide" icon="rocket" href="#creating-your-first-checkout-session">
    Get your first checkout session running in under 5 minutes
  </Card>

  <Card title="API Reference & Live Testing" icon="code" href="/api-reference/checkout-sessions/create">
    Explore the full API documentation and interactively test Checkout Session requests and responses.
  </Card>

  <Card title="Preview Checkout" icon="eye" href="/api-reference/checkout-sessions/preview">
    Calculate pricing, taxes, and totals before creating a session.
  </Card>
</CardGroup>

<Info>
  **Session Validity**: Checkout sessions are valid for 24 hours by default. If you pass `confirm=true` in your request, the session will only be valid for 15 minutes.
</Info>

## Prerequisites

<Steps>
  <Step title="Dodo Payments Account">
    You'll need an active Dodo Payments merchant account with API access.
  </Step>

  <Step title="API Credentials">
    Generate your API credentials from the Dodo Payments dashboard:
  </Step>

  <Step title="Products Setup">
    Create your products in the Dodo Payments dashboard before implementing checkout sessions.
  </Step>
</Steps>

## Creating Your First Checkout Session

<Tabs>
  <Tab title="Node.js SDK">
    ```javascript expandable theme={null}
    import DodoPayments from 'dodopayments';

    // Initialize the Dodo Payments client
    const client = new DodoPayments({
      bearerToken: process.env.DODO_PAYMENTS_API_KEY,
      environment: 'test_mode', // defaults to 'live_mode'
    });

    async function createCheckoutSession() {
      try {
        const session = await client.checkoutSessions.create({
          // Products to sell - use IDs from your Dodo Payments dashboard
          product_cart: [
            {
              product_id: 'prod_123', // Replace with your actual product ID
              quantity: 1
            }
          ],
          
          // Pre-fill customer information to reduce friction
          customer: {
            email: 'customer@example.com',
            name: 'John Doe',
            phone_number: '+1234567890'
          },
          
          // Billing address for tax calculation and compliance
          billing_address: {
            street: '123 Main St',
            city: 'San Francisco',
            state: 'CA',
            country: 'US', // Required: ISO 3166-1 alpha-2 country code
            zipcode: '94102'
          },
          
          // Where to redirect after successful payment
          return_url: 'https://yoursite.com/checkout/success',
          
          // Custom data for your internal tracking
          metadata: {
            order_id: 'order_123',
            source: 'web_app'
          }
        });

        // Redirect your customer to this URL to complete payment
        console.log('Checkout URL:', session.checkout_url);
        console.log('Session ID:', session.session_id);
        
        return session;
        
      } catch (error) {
        console.error('Failed to create checkout session:', error);
        throw error;
      }
    }

    // Example usage in an Express.js route
    app.post('/create-checkout', async (req, res) => {
      try {
        const session = await createCheckoutSession();
        res.json({ checkout_url: session.checkout_url });
      } catch (error) {
        res.status(500).json({ error: 'Failed to create checkout session' });
      }
    });
    ```
  </Tab>

  <Tab title="Python SDK">
    ```python expandable theme={null}
    import os
    from dodopayments import DodoPayments

    # Initialize the Dodo Payments client
    client = DodoPayments(
        bearer_token=os.environ.get("DODO_PAYMENTS_API_KEY"),  # This is the default and can be omitted
        environment="test_mode",  # defaults to "live_mode"
    )

    def create_checkout_session():
        """
        Create a checkout session for a single product with customer data pre-filled.
        Returns the session object containing checkout_url for customer redirection.
        """
        try:
            session = client.checkout_sessions.create(
                # Products to sell - use IDs from your Dodo Payments dashboard
                product_cart=[
                    {
                        "product_id": "prod_123",  # Replace with your actual product ID
                        "quantity": 1
                    }
                ],
                
                # Pre-fill customer information to reduce checkout friction
                customer={
                    "email": "customer@example.com",
                    "name": "John Doe",
                    "phone_number": "+1234567890"
                },
                
                # Billing address for tax calculation and compliance
                billing_address={
                    "street": "123 Main St",
                    "city": "San Francisco", 
                    "state": "CA",
                    "country": "US",  # Required: ISO 3166-1 alpha-2 country code
                    "zipcode": "94102"
                },
                
                # Where to redirect after successful payment
                return_url="https://yoursite.com/checkout/success",
                
                # Custom data for your internal tracking
                metadata={
                    "order_id": "order_123",
                    "source": "web_app"
                }
            )
            
            # Redirect your customer to this URL to complete payment
            print(f"Checkout URL: {session.checkout_url}")
            print(f"Session ID: {session.session_id}")
            
            return session
            
        except Exception as error:
            print(f"Failed to create checkout session: {error}")
            raise error

    # Example usage in a Flask route
    from flask import Flask, jsonify, request

    app = Flask(__name__)

    @app.route('/create-checkout', methods=['POST'])
    def create_checkout():
        try:
            session = create_checkout_session()
            return jsonify({"checkout_url": session.checkout_url})
        except Exception as error:
            return jsonify({"error": "Failed to create checkout session"}), 500
    ```
  </Tab>

  <Tab title="REST API">
    ```javascript expandable theme={null}
    // Direct API call using fetch - useful for any JavaScript environment
    async function createCheckoutSession() {
      try {
        const response = await fetch('https://test.dodopayments.com/checkouts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${process.env.DODO_PAYMENTS_API_KEY}`
          },
          body: JSON.stringify({
            // Products to sell - use IDs from your Dodo Payments dashboard
            product_cart: [
              {
                product_id: 'prod_123', // Replace with your actual product ID
                quantity: 1
              }
            ],
            
            // Pre-fill customer information to reduce checkout friction
            customer: {
              email: 'customer@example.com',
              name: 'John Doe',
              phone_number: '+1234567890'
            },
            
            // Billing address for tax calculation and compliance
            billing_address: {
              street: '123 Main St',
              city: 'San Francisco',
              state: 'CA', 
              country: 'US', // Required: ISO 3166-1 alpha-2 country code
              zipcode: '94102'
            },
            
            // Where to redirect after successful payment
            return_url: 'https://yoursite.com/checkout/success',
            
            // Custom data for your internal tracking
            metadata: {
              order_id: 'order_123',
              source: 'web_app'
            }
          })
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const session = await response.json();
        
        // Redirect your customer to this URL to complete payment
        console.log('Checkout URL:', session.checkout_url);
        console.log('Session ID:', session.session_id);
        
        return session;
        
      } catch (error) {
        console.error('Failed to create checkout session:', error);
        throw error;
      }
    }

    // Example: Redirect user to checkout
    createCheckoutSession().then(session => {
      window.location.href = session.checkout_url;
    });
    ```
  </Tab>
</Tabs>

### API Response

All methods above return the same response structure:

```json theme={null}
{
  "session_id": "cks_Gi6KGJ2zFJo9rq9Ukifwa",
  "checkout_url": "https://test.checkout.dodopayments.com/session/cks_Gi6KGJ2zFJo9rq9Ukifwa"
}
```

<Steps>
  <Step title="Get the checkout URL">
    Extract the `checkout_url` from the API response.
  </Step>

  <Step title="Redirect your customer">
    Direct your customer to the checkout URL to complete their purchase.

    ```javascript theme={null}
    // Redirect immediately
    window.location.href = session.checkout_url;

    // Or open in new window
    window.open(session.checkout_url, '_blank');
    ```

    <Tip>
      **Alternative Integration Options**: Instead of redirecting, you can embed the checkout directly in your page using [Overlay Checkout](/developer-resources/overlay-checkout) (modal overlay) or [Inline Checkout](/developer-resources/inline-checkout) (fully embedded). Both options use the same checkout session URL.
    </Tip>
  </Step>

  <Step title="Handle the return">
    After payment, customers are redirected to your `return_url` with additional query parameters for payment status.
  </Step>
</Steps>

## Request Body

<CardGroup>
  <Card title="Required Fields" icon="asterisk">
    Essential fields needed for every checkout session
  </Card>

  <Card title="Optional Fields" icon="gear">
    Additional configuration to customize your checkout experience
  </Card>
</CardGroup>

### Required Fields

<ParamField type="array">
  Array of products to include in the checkout session. Each product must have a valid `product_id` from your Dodo Payments dashboard.

  <Tip>
    **Mixed Checkout**: You can combine one-time payment products and subscription products in the same checkout session. This enables powerful use cases like setup fees with subscriptions, hardware bundles with SaaS, and more.
  </Tip>

  <Expandable title="Product Cart Item Properties">
    <ParamField type="string">
      The unique identifier of the product from your Dodo Payments dashboard.

      **Example:** `"prod_123abc456def"`
    </ParamField>

    <ParamField type="integer">
      Quantity of the product.

      **Example:** `1` for single item, `3` for multiple quantities
    </ParamField>

    <ParamField type="array">
      Array of addons to attach to the product. Only valid if the product is a subscription.

      <Expandable title="Addon item properties">
        <ParamField type="string" />

        <ParamField type="integer" />
      </Expandable>
    </ParamField>

    <ParamField type="integer">
      Amount the customer pays if pay\_what\_you\_want is enabled. If disabled, this field will be ignored.

      **Format**: Represented in the lowest denomination of the currency (e.g., cents for USD). For example, to charge \$1.00, pass `100`.
    </ParamField>
  </Expandable>
</ParamField>

<Tip>
  **Find Your Product IDs**: You can find product IDs in your Dodo Payments dashboard under Products → View Details, or by using the [List Products API](/api-reference/products/get-products).
</Tip>

### Optional Fields

Configure these fields to customize the checkout experience and add business logic to your payment flow.

<AccordionGroup>
  <Accordion title="Customer Information">
    <ParamField type="object">
      Customer information. You can either attach an existing customer using their ID or create a new customer record during checkout.

      <Tabs>
        <Tab title="Attach Existing Customer">
          Attach an existing customer to the checkout session using their ID.

          <Expandable title="Existing Customer Properties">
            <ParamField type="string">
              The unique identifier of an existing customer. Use this to attach the checkout session to an existing customer instead of creating a new one.
            </ParamField>
          </Expandable>
        </Tab>

        <Tab title="New Customer">
          Create a new customer record during checkout.

          <Expandable title="New Customer Properties">
            <ParamField type="string">
              Customer's email address. Required when creating a new customer.
            </ParamField>

            <ParamField type="string">
              Customer's full name as it should appear on receipts and invoices.

              **Example**: `"John Doe"` or `"Jane Smith"`
            </ParamField>

            <ParamField type="string">
              Customer's phone number in international format. Required for some payment methods and fraud prevention.

              **Format**: Include country code, e.g., `"+1234567890"` for US numbers
            </ParamField>
          </Expandable>
        </Tab>
      </Tabs>
    </ParamField>

    <ParamField type="object">
      Billing address information for accurate tax calculation, fraud prevention, and regulatory compliance.

      <Info>
        When `confirm` is set to `true`, all billing address fields become required for successful session creation.
      </Info>

      <Expandable title="Billing address object properties">
        <ParamField type="string">
          Complete street address including house number, street name, and apartment/unit number if applicable.

          **Example**: `"123 Main St, Apt 4B"` or `"456 Oak Avenue"`
        </ParamField>

        <ParamField type="string">
          City or municipality name.

          **Example**: `"San Francisco"`, `"New York"`, `"London"`
        </ParamField>

        <ParamField type="string">
          State, province, or region name. Use full names or standard abbreviations.

          **Example**: `"California"` or `"CA"`, `"Ontario"` or `"ON"`
        </ParamField>

        <ParamField type="string">
          Two-letter ISO country code (ISO 3166-1 alpha-2). This field is always required when billing\_address is provided.

          **Examples**: `"US"` (United States), `"CA"` (Canada), `"GB"` (United Kingdom), `"DE"` (Germany)

          <Card title="Country Code Reference" icon="globe" href="/api-reference/misc/supported-countries">
            View complete list of supported countries and their ISO codes
          </Card>
        </ParamField>

        <ParamField type="string">
          Postal code, ZIP code, or equivalent based on country requirements.

          **Examples**: `"94102"` (US), `"M5V 3A8"` (Canada), `"SW1A 1AA"` (UK)
        </ParamField>
      </Expandable>
    </ParamField>
  </Accordion>

  <Accordion title="Payment Configuration">
    <ParamField type="array">
      Control which payment methods are available to customers during checkout. This helps optimize for specific markets or business requirements.

      **Available Options**: `credit`, `debit`, `upi_collect`, `apple_pay`, `google_pay`, `amazon_pay`, `klarna`, `affirm`, `afterpay_clearpay`, `cashapp`, `multibanco`, `bancontact_card`, `eps`, `ideal`, `przelewy24`, `paypal`

      <Warning>
        **Critical**: Always include `credit` and `debit` as fallback options to prevent checkout failures when preferred payment methods are unavailable.
      </Warning>

      **Example**:

      ```json expandable theme={null}
      ["apple_pay", "google_pay", "credit", "debit"]
      ```
    </ParamField>

    <ParamField type="string">
      Override the default currency selection with a fixed billing currency. Uses ISO 4217 currency codes.

      **Supported Currencies**: `USD`, `EUR`, `GBP`, `CAD`, `AUD`, `INR`, and more

      **Example**: `"USD"` for US Dollars, `"EUR"` for Euros

      <Note>
        This field is only effective when adaptive pricing is enabled. If adaptive pricing is disabled, the product's default currency will be used.
      </Note>
    </ParamField>

    <ParamField type="boolean">
      Display previously saved payment methods for returning customers, improving checkout speed and user experience.
    </ParamField>
  </Accordion>

  <Accordion title="Session Management">
    <ParamField type="string">
      URL to redirect customers after successful payment or cancellation.
    </ParamField>

    <ParamField type="boolean">
      If true, finalizes all session details immediately. API will throw an error if required data is missing.
    </ParamField>

    <ParamField type="string">
      Apply a discount code to the checkout session.
    </ParamField>

    <ParamField type="object">
      Custom key-value pairs to store additional information about the session.
    </ParamField>

    <ParamField type="boolean">
      Override merchant default 3DS behaviour for this session.
    </ParamField>

    <ParamField type="boolean">
      Enable minimal address collection mode. When enabled, the checkout only collects:

      * **Country**: Always required for tax determination
      * **ZIP/Postal code**: Only in regions where it's necessary for sales tax, VAT, or GST calculation

      This significantly reduces checkout friction by eliminating unnecessary form fields.

      <Tip>
        Enable minimal address for faster checkout completion. Full address collection remains available for businesses that require complete billing details.
      </Tip>
    </ParamField>
  </Accordion>

  <Accordion title="UI Customization & Features">
    <ParamField type="object">
      Customize the appearance and behavior of the checkout interface.

      <Expandable title="Customization object properties">
        <ParamField type="string">
          Theme for the checkout interface. Options: `light`, `dark`, or `system`.
        </ParamField>

        <ParamField type="boolean">
          Display order details section in the checkout interface.
        </ParamField>

        <ParamField type="boolean">
          Show the "on-demand" tag for applicable products.
        </ParamField>

        <ParamField type="string">
          Force the checkout interface to render in a specific language. By default, the checkout auto-detects the customer's browser language.

          **Supported language codes:**
          `ar` (Arabic), `ca` (Catalan), `de` (German), `en` (English), `es` (Spanish), `fr` (French), `he` (Hebrew), `id` (Indonesian), `it` (Italian), `ja` (Japanese), `ko` (Korean), `ms` (Malay), `nl` (Dutch), `pl` (Polish), `pt` (Portuguese), `ro` (Romanian), `ru` (Russian), `sv` (Swedish), `th` (Thai), `tr` (Turkish), `zh` (Chinese)

          **Example**: `"es"` for Spanish, `"ja"` for Japanese
        </ParamField>
      </Expandable>
    </ParamField>

    <ParamField type="object">
      Configure specific features and behaviors for the checkout session.

      <Expandable title="Feature flags object properties">
        <ParamField type="boolean">
          Allow customers to select their preferred currency during checkout.
        </ParamField>

        <ParamField type="boolean">
          Show discount code input field in the checkout interface.
        </ParamField>

        <ParamField type="boolean">
          Collect customer phone numbers during checkout.
        </ParamField>

        <ParamField type="boolean">
          Allow customers to enter tax identification numbers.
        </ParamField>

        <ParamField type="boolean">
          Force creation of a new customer record instead of updating existing ones.
        </ParamField>

        <ParamField type="boolean">
          Allow customers to edit their email address during checkout.
        </ParamField>

        <ParamField type="boolean">
          Allow customers to edit their name during checkout.
        </ParamField>

        <ParamField type="boolean">
          Allow customers to edit the street address during checkout.
        </ParamField>

        <ParamField type="boolean">
          Allow customers to edit the city during checkout.
        </ParamField>

        <ParamField type="boolean">
          Allow customers to edit the state during checkout.
        </ParamField>

        <ParamField type="boolean">
          Allow customers to edit the country during checkout.
        </ParamField>

        <ParamField type="boolean">
          Allow customers to edit the zipcode during checkout.
        </ParamField>

        <ParamField type="boolean">
          Enable minimal address collection mode. When enabled, the checkout only collects:

          * **Country**: Always required for tax determination
          * **ZIP/Postal code**: Only in regions where it's necessary for sales tax, VAT, or GST calculation

          This significantly reduces checkout friction by eliminating unnecessary form fields.

          <Tip>
            Enable minimal address for faster checkout completion. Full address collection remains available for businesses that require complete billing details.
          </Tip>
        </ParamField>

        <ParamField type="boolean">
          Skip the default payment success page and redirect customers immediately to your `return_url` after payment completion.

          <Tip>
            Use this when you have a custom success page that provides a better user experience, or for mobile apps and embedded checkout flows.
          </Tip>
        </ParamField>
      </Expandable>
    </ParamField>
  </Accordion>

  <Accordion title="Custom Fields">
    <ParamField type="array">
      Collect additional information from customers during checkout with custom form fields. You can define up to 5 custom fields per checkout session. Customer responses are included in webhook payloads and available via the API.

      <Expandable title="Custom field object properties">
        <ParamField type="string">
          Unique identifier for this field. Used as the key in webhook payloads and API responses.

          **Example**: `"company_name"`, `"referral_source"`, `"team_size"`
        </ParamField>

        <ParamField type="string">
          Display label shown to the customer on the checkout form.

          **Example**: `"Company Name"`, `"How did you hear about us?"`, `"Team Size"`
        </ParamField>

        <ParamField type="string">
          Type of field determining input validation rules.

          **Available types**:

          * `text` - Single-line text input
          * `number` - Numeric input
          * `email` - Email address with validation
          * `url` - URL with validation
          * `date` - Date picker
          * `dropdown` - Select from predefined options
          * `boolean` - Yes/No toggle
        </ParamField>

        <ParamField type="boolean">
          Whether this field must be filled before checkout can complete.
        </ParamField>

        <ParamField type="string">
          Placeholder text displayed in the input field.
        </ParamField>

        <ParamField type="array">
          List of options for `dropdown` field type. Required when `field_type` is `dropdown`, ignored for other types.

          **Example**: `["Google", "Twitter", "Friend referral", "Other"]`
        </ParamField>
      </Expandable>
    </ParamField>

    <Info>
      Customer responses to custom fields are included in:

      * **Webhooks**: `payment.succeeded`, `subscription.created`, and other relevant event payloads contain the `custom_field_responses` array
      * **API responses**: Payment and subscription objects include `custom_field_responses`
    </Info>
  </Accordion>

  <Accordion title="Subscription Configuration">
    <ParamField type="object">
      Additional configuration for checkout sessions containing subscription products.

      <Expandable title="Subscription data object properties">
        <ParamField type="integer">
          Number of days for the trial period before the first charge. Must be between 0 and 10000 days.
        </ParamField>

        <ParamField type="object">
          On-demand subscription configuration for usage-based or metered billing.

          <Expandable title="On-demand object properties">
            <ParamField type="boolean">
              If set to true, does not perform any charge and only authorizes payment method details for future use.
            </ParamField>

            <ParamField type="integer">
              Product price for the initial charge to customer. If not specified, the stored price of the product will be used.

              **Format**: Represented in the lowest denomination of the currency (e.g., cents for USD). For example, to charge \$1.00, pass `100`.
            </ParamField>

            <ParamField type="string">
              Optional currency of the product price. If not specified, defaults to the currency of the product.
            </ParamField>

            <ParamField type="string">
              Optional product description override for billing and line items. If not specified, the stored description of the product will be used.
            </ParamField>

            <ParamField type="boolean">
              Whether adaptive currency fees should be included in the product price (true) or added on top (false). Ignored if adaptive pricing is not enabled.
            </ParamField>
          </Expandable>
        </ParamField>
      </Expandable>
    </ParamField>
  </Accordion>
</AccordionGroup>

## Usage Examples

Here are 10 comprehensive examples showcasing different checkout session configurations for various business scenarios:

### 1. Simple Single Product Checkout

```javascript expandable theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_ebook_guide',
      quantity: 1
    }
  ],
  customer: {
    email: 'customer@example.com',
    name: 'John Doe'
  },
  return_url: 'https://yoursite.com/success'
});
```

### 2. Multi-Product Cart

```javascript expandable theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_laptop',
      quantity: 1
    },
    {
      product_id: 'prod_mouse',
      quantity: 2
    },
    {
      product_id: 'prod_warranty',
      quantity: 1
    }
  ],
  customer: {
    email: 'customer@example.com',
    name: 'John Doe',
    phone_number: '+1234567890'
  },
  billing_address: {
    street: '123 Tech Street',
    city: 'San Francisco',
    state: 'CA',
    country: 'US',
    zipcode: '94102'
  },
  return_url: 'https://electronics-store.com/order-confirmation'
});
```

### 3. Subscription with Trial Period

```javascript expandable theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_monthly_plan',
      quantity: 1
    }
  ],
  subscription_data: {
    trial_period_days: 14
  },
  customer: {
    email: 'user@startup.com',
    name: 'Jane Smith'
  },
  return_url: 'https://saas-app.com/onboarding',
  metadata: {
    plan_type: 'professional',
    referral_source: 'google_ads'
  }
});
```

### 4. Pre-confirmed Checkout

<Note>
  When `confirm` is set to `true`, the customer will be taken directly to the checkout page, bypassing any confirmation steps.
</Note>

```javascript expandable theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_premium_course',
      quantity: 1
    }
  ],
  customer: {
    email: 'student@university.edu',
    name: 'Alex Johnson',
    phone_number: '+1555123456'
  },
  billing_address: {
    street: '456 University Ave',
    city: 'Boston',
    state: 'MA',
    country: 'US',
    zipcode: '02134'
  },
  confirm: true,
  return_url: 'https://learning-platform.com/course-access',
  metadata: {
    course_category: 'programming',
    enrollment_date: '2024-01-15'
  }
});
```

### 5. Checkout with Currency Override

<Note>
  The `billing_currency` override only takes effect when adaptive currency is enabled in your account settings. If adaptive currency is disabled, this parameter will have no effect.
</Note>

```javascript expandable theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_consulting_service',
      quantity: 1
    }
  ],
  customer: {
    email: 'client@company.co.uk',
    name: 'Oliver Williams'
  },
  billing_address: {
    street: '789 Business Park',
    city: 'London',
    state: 'England',
    country: 'GB',
    zipcode: 'SW1A 1AA'
  },
  billing_currency: 'GBP',
  feature_flags: {
    allow_currency_selection: true,
    allow_tax_id: true
  },
  return_url: 'https://consulting-firm.com/service-confirmation'
});
```

### 6. Saved Payment Methods for Returning Customers

```javascript expandable theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_monthly_subscription',
      quantity: 1
    }
  ],
  customer: {
    email: 'returning.customer@example.com',
    name: 'Robert Johnson',
    phone_number: '+1555987654'
  },
  show_saved_payment_methods: true,
  feature_flags: {
    allow_phone_number_collection: true,
    always_create_new_customer: false
  },
  return_url: 'https://subscription-service.com/welcome-back',
  metadata: {
    customer_tier: 'premium',
    account_age: 'returning'
  }
});
```

### 7. B2B Checkout with Tax ID Collection

```javascript expandable theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_enterprise_license',
      quantity: 5
    }
  ],
  customer: {
    email: 'procurement@enterprise.com',
    name: 'Sarah Davis',
    phone_number: '+1800555000'
  },
  billing_address: {
    street: '1000 Corporate Blvd',
    city: 'New York',
    state: 'NY',
    country: 'US',
    zipcode: '10001'
  },
  feature_flags: {
    allow_tax_id: true,
    allow_phone_number_collection: true,
    always_create_new_customer: false
  },
  return_url: 'https://enterprise-software.com/license-delivery',
  metadata: {
    customer_type: 'enterprise',
    contract_id: 'ENT-2024-001',
    sales_rep: 'john.sales@company.com'
  }
});
```

### 8. Dark Theme Checkout with Discount Code

```javascript expandable theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_gaming_chair',
      quantity: 1
    }
  ],
  discount_code: 'BLACKFRIDAY2024',
  customization: {
    theme: 'dark',
    show_order_details: true,
    show_on_demand_tag: false
  },
  feature_flags: {
    allow_discount_code: true
  },
  customer: {
    email: 'gamer@example.com',
    name: 'Mike Chen'
  },
  return_url: 'https://gaming-store.com/order-complete'
});
```

### 9. Regional Payment Methods (UPI for India)

For detailed information about UPI configuration and testing, see the <a href="/features/payment-methods/india">India Payment Methods</a> page.

```javascript expandable theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_online_course_hindi',
      quantity: 1
    }
  ],
  allowed_payment_method_types: [
    'upi_collect',
    'credit',
    'debit'
  ],
  customer: {
    email: 'student@example.in',
    name: 'Priya Sharma',
    phone_number: '+919876543210'
  },
  billing_address: {
    street: 'MG Road',
    city: 'Bangalore',
    state: 'Karnataka',
    country: 'IN',
    zipcode: '560001'
  },
  billing_currency: 'INR',
  return_url: 'https://education-platform.in/course-access',
  metadata: {
    region: 'south_india',
    language: 'hindi'
  }
});
```

### 10. BNPL (Buy Now Pay Later) Checkout

For detailed information about BNPL configuration and testing, see the <a href="/features/payment-methods/bnpl">Buy Now Pay Later (BNPL)</a> page.

```javascript expandable theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_luxury_watch',
      quantity: 1
    }
  ],
  allowed_payment_method_types: [
    'klarna',
    'afterpay_clearpay',
    'credit',
    'debit'
  ],
  customer: {
    email: 'fashion.lover@example.com',
    name: 'Emma Thompson',
    phone_number: '+1234567890'
  },
  billing_address: {
    street: '555 Fashion Ave',
    city: 'Los Angeles',
    state: 'CA',
    country: 'US',
    zipcode: '90210'
  },
  feature_flags: {
    allow_phone_number_collection: true
  },
  return_url: 'https://luxury-store.com/purchase-confirmation',
  metadata: {
    product_category: 'luxury',
    price_range: 'high_value'
  }
});
```

### 11. Using Existing Payment Methods for Instant Checkout

Use a customer's saved payment method to create a checkout session that processes immediately, skipping payment method collection:

```javascript expandable theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_premium_plan',
      quantity: 1
    }
  ],
  customer: {
    customer_id: 'cus_123'  // Required when using payment_method_id
  },
  payment_method_id: 'pm_abc123',  // Use customer's saved payment method
  confirm: true,  // Required when using payment_method_id
  return_url: 'https://yourapp.com/success'
});
```

<Warning>
  When using `payment_method_id`, `confirm` must be set to `true` and an existing `customer_id` must be provided. The payment method will be validated for eligibility with the payment's currency.
</Warning>

<Info>
  The payment method must belong to the customer and be compatible with the payment currency. This enables one-click purchases for returning customers.
</Info>

### 12. Short Links for Cleaner Payment URLs

Generate shortened, shareable payment links with custom slugs:

```javascript expandable theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_monthly_subscription',
      quantity: 1
    }
  ],
  short_link: true,  // Generate a shortened payment link
  return_url: 'https://yourapp.com/success',
  customer: {
    email: 'customer@example.com',
    name: 'John Doe'
  }
});

// The checkout_url will be a shortened, cleaner link
console.log(session.checkout_url);  // e.g., https://checkout.dodopayments.com/buy/abc123
```

<Tip>
  Short links are perfect for SMS, email, or social media sharing. They're easier to remember and build more customer trust than long URLs.
</Tip>

### 13. Skip Payment Success Page with Immediate Redirect

Redirect customers immediately after payment completion, bypassing the default success page:

```javascript expandable theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_digital_product',
      quantity: 1
    }
  ],
  feature_flags: {
    redirect_immediately: true  // Skip success page, redirect immediately
  },
  return_url: 'https://yourapp.com/success',
  customer: {
    email: 'customer@example.com',
    name: 'Jane Smith'
  }
});
```

<Tip>
  Use `redirect_immediately: true` when you have a custom success page that provides better user experience than the default payment success page. This is especially useful for mobile apps and embedded checkout flows.
</Tip>

<Note>
  When `redirect_immediately` is enabled, customers are redirected to your `return_url` immediately after payment completion, skipping the default success page entirely.
</Note>

### 14. Forcing a Language

Force the checkout to display in a specific language, overriding the customer's browser language detection:

```javascript expandable theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_subscription',
      quantity: 1
    }
  ],
  customization: {
    force_language: 'ja'  // Force Japanese language
  },
  customer: {
    email: 'customer@example.jp',
    name: 'Tanaka Yuki'
  },
  return_url: 'https://yourapp.com/success'
});
```

<Tip>
  Use `force_language` when you know your customer's preferred language (e.g., from their account settings) or when targeting specific regional markets.
</Tip>

**Supported languages:** Arabic (`ar`), Catalan (`ca`), Chinese (`zh`), Dutch (`nl`), English (`en`), French (`fr`), German (`de`), Hebrew (`he`), Indonesian (`id`), Italian (`it`), Japanese (`ja`), Korean (`ko`), Malay (`ms`), Polish (`pl`), Portuguese (`pt`), Romanian (`ro`), Russian (`ru`), Spanish (`es`), Swedish (`sv`), Thai (`th`), Turkish (`tr`)

### 15. Collecting Custom Fields

Collect additional information from customers during checkout using custom fields:

```javascript expandable theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [
    {
      product_id: 'prod_saas_plan',
      quantity: 1
    }
  ],
  custom_fields: [
    {
      key: 'company_name',
      label: 'Company Name',
      field_type: 'text',
      required: true,
      placeholder: 'Acme Inc.'
    },
    {
      key: 'team_size',
      label: 'Team Size',
      field_type: 'dropdown',
      required: true,
      options: ['1-10', '11-50', '51-200', '201-500', '500+']
    },
    {
      key: 'referral_source',
      label: 'How did you hear about us?',
      field_type: 'dropdown',
      required: false,
      options: ['Google', 'Twitter', 'Friend referral', 'Blog post', 'Other']
    },
    {
      key: 'website',
      label: 'Company Website',
      field_type: 'url',
      required: false,
      placeholder: 'https://example.com'
    }
  ],
  customer: {
    email: 'buyer@company.com',
    name: 'Jane Doe'
  },
  return_url: 'https://yourapp.com/success'
});
```

<Info>
  Custom field responses are automatically included in webhook payloads (`payment.succeeded`, `subscription.created`, etc.) and can be retrieved via the API. Use them to enrich your CRM, trigger onboarding flows, or customize the customer experience.
</Info>

**Available field types:** `text`, `number`, `email`, `url`, `date`, `dropdown`, `boolean`

## Previewing Checkout Sessions

Before creating a checkout session, you can preview the pricing breakdown including taxes, discounts, and totals. This is useful for displaying accurate pricing to customers before they proceed to checkout.

<Tabs>
  <Tab title="Node.js SDK">
    ```javascript theme={null}
    const preview = await client.checkoutSessions.preview({
      product_cart: [
        { product_id: 'prod_123', quantity: 1 }
      ],
      billing_address: {
        country: 'US',
        state: 'CA',
        zipcode: '94102'
      },
      discount_code: 'SAVE20'
    });

    console.log('Subtotal:', preview.subtotal);
    console.log('Tax:', preview.tax);
    console.log('Discount:', preview.discount);
    console.log('Total:', preview.total);
    ```
  </Tab>

  <Tab title="Python SDK">
    ```python theme={null}
    preview = client.checkout_sessions.preview(
        product_cart=[
            {"product_id": "prod_123", "quantity": 1}
        ],
        billing_address={
            "country": "US",
            "state": "CA",
            "zipcode": "94102"
        },
        discount_code="SAVE20"
    )

    print(f"Subtotal: {preview.subtotal}")
    print(f"Tax: {preview.tax}")
    print(f"Discount: {preview.discount}")
    print(f"Total: {preview.total}")
    ```
  </Tab>
</Tabs>

<Card title="Preview API Reference" icon="code" href="/api-reference/checkout-sessions/preview">
  View the complete preview endpoint documentation.
</Card>

## Moving from Dynamic Links to Checkout Sessions

### Key Differences

Previously, when creating a payment link with Dynamic Links, you were required to provide the customer's complete billing address.

With Checkout Sessions, this is no longer necessary. You can simply pass along whatever information you have, and we'll handle the rest. For example:

* If you only know the customer's billing country, just provide that.
* The checkout flow will automatically collect the missing details before moving the customer to the payment page.
* On the other hand, if you already have all the required information and want to skip directly to the payment page, you can pass the full data set and include `confirm=true` in your request body.

### Migration Process

Migrating from Dynamic Links to Checkout Sessions is straightforward:

<Steps>
  <Step title="Update your integration">
    Update your integration to use the new API or SDK method.
  </Step>

  <Step title="Adjust request payload">
    Adjust the request payload according to the Checkout Sessions format.
  </Step>

  <Step title="That's it!">
    Yes. No additional handling or special migration steps are needed on your side.
  </Step>
</Steps>


# Sync with your Database
Source: https://docs.dodopayments.com/developer-resources/dodo-sync

Automatically sync your Dodo Payments data to your own database for analytics, reporting, and integrations.

Dodo Payments provides a built-in database sync feature that automatically synchronizes your payment data with your own database. You can sync **payments**, **customers**, **subscriptions**, and **licenses** to maintain a local copy of your data for analytics, reporting, or integration with other systems.

<Info>
  **Implementation**: Available via [npm package](https://www.npmjs.com/package/dodo-sync) | **Source Code**: [GitHub](https://github.com/dodopayments/dodo-sync)
</Info>

## What Can You Sync?

Our database sync feature supports synchronizing the following Dodo Payments entities to your database:

<CardGroup>
  <Card title="Payments" icon="credit-card">
    Sync all payment transactions, including one-time payments, refunds, and payment status updates.
  </Card>

  <Card title="Customers" icon="users">
    Keep your customer data in sync, including customer profiles, contact information, and metadata.
  </Card>

  <Card title="Subscriptions" icon="repeat">
    Synchronize subscription data, including active subscriptions, billing cycles, and subscription status changes.
  </Card>

  <Card title="Licenses" icon="key">
    Sync license information, including license keys, activations, and license status updates.
  </Card>
</CardGroup>

You can sync any combination of these entities by specifying them in the `scopes` parameter. All sync operations are incremental and only transfer new or updated records for optimal performance.

## Database Support

We currently support **MongoDB**, **PostgreSQL**, **MySQL**, and **ClickHouse**.

We are actively working on expanding support for:

* **Databases**: Snowflake and others.
* **Pipelines**: ETL pipelines, Realtime sync.

<Tip>
  We're continuously expanding database support. If you'd like to contribute a new database integration, please submit a Pull Request to our [GitHub repository](https://github.com/dodopayments/dodo-sync).
</Tip>

## Getting Started

You can use our database sync feature via the **CLI** or programmatically in your **code**. Both methods provide the same functionality—choose the one that best fits your workflow.

### Using the CLI

The CLI tool provides a quick way to set up and run database synchronization. Install it globally to use it from anywhere in your terminal:

<CodeGroup>
  ```bash npm theme={null}
  npm install -g dodo-sync
  ```

  ```bash bun theme={null}
  bun add -g dodo-sync
  ```
</CodeGroup>

#### Running the CLI

The CLI supports two modes: **Interactive Mode** for guided setup, and **Manual Mode** for direct configuration.

**Interactive Mode**: Simply run the command without arguments to start the interactive setup wizard.

```bash theme={null}
dodo-sync
```

**Manual Mode**: Pass arguments directly to skip the wizard.

```bash theme={null}
dodo-sync -i [interval] -d [database] -u [database_uri] --scopes [scopes] --api-key [api_key] --env [environment]
```

**Examples:**

```bash theme={null}
# MongoDB
dodo-sync -i 600 -d mongodb -u mongodb://mymongodb.url --scopes "licences,payments,customers,subscriptions" --api-key YOUR_API_KEY --env test_mode

# PostgreSQL
dodo-sync -i 600 -d postgres -u postgresql://user:password@localhost:5432/mydb --scopes "licences,payments,customers,subscriptions" --api-key YOUR_API_KEY --env test_mode

# MySQL
dodo-sync -i 600 -d mysql -u mysql://user:password@localhost:3306/mydb --scopes "licences,payments,customers,subscriptions" --api-key YOUR_API_KEY --env test_mode

# ClickHouse
dodo-sync -i 600 -d clickhouse -u http://localhost:8123 --scopes "licences,payments,customers,subscriptions" --api-key YOUR_API_KEY --env test_mode
```

#### CLI Arguments

<ParamField type="number">
  Sync interval in seconds. Determines how frequently the sync operation runs. If not provided, the sync will run once and exit.
</ParamField>

<ParamField type="string">
  Database type to use. Supported values: `"mongodb"`, `"postgres"`, `"mysql"`, or `"clickhouse"`.
</ParamField>

<ParamField type="string">
  Connection URI for your database:

  * **MongoDB**: `mongodb://localhost:27017` or `mongodb+srv://user:pass@cluster.mongodb.net/`
  * **PostgreSQL**: `postgresql://user:password@localhost:5432/mydb`
  * **MySQL**: `mysql://user:password@localhost:3306/mydb`
  * **ClickHouse**: `http://localhost:8123`
</ParamField>

<ParamField type="string">
  Comma-separated list of data entities to sync. Available scopes: `licences`, `payments`, `customers`, `subscriptions`. Example: `"payments,customers"`.
</ParamField>

<ParamField type="string">
  Your Dodo Payments API key. Should start with `dp_live_` for live mode or `dp_test_` for test mode.
</ParamField>

<ParamField type="string">
  Environment target. Must be either `"live_mode"` or `"test_mode"`. This determines which Dodo Payments environment to sync from.
</ParamField>

<ParamField type="number">
  Rate limit in requests per second. Controls how fast the sync engine makes API requests to avoid overwhelming the Dodo Payments API.
</ParamField>

### Using in Your Code

For programmatic control, integrate the sync feature directly into your application. Install it as a dependency in your project:

<CodeGroup>
  ```bash npm theme={null}
  npm install dodo-sync
  ```

  ```bash bun theme={null}
  bun add dodo-sync
  ```
</CodeGroup>

#### Automatic Sync (Interval-based)

Use automatic sync when you want the sync to run continuously at regular intervals:

```typescript theme={null}
import { DodoSync } from 'dodo-sync';

const syncDodoPayments = new DodoSync({
  interval: 60, // Sync every 60 seconds
  database: 'mongodb',
  databaseURI: process.env.MONGODB_URI, // e.g., 'mongodb://localhost:27017'
  scopes: ['licences', 'payments', 'customers', 'subscriptions'],
  dodoPaymentsOptions: {
    bearerToken: process.env.DODO_PAYMENTS_API_KEY,
    environment: 'test_mode' // or 'live_mode'
  }
});

// Initialize connection
await syncDodoPayments.init();

// Start the sync loop
syncDodoPayments.start();
```

<Tip>
  The `interval` option is required when using `.start()` for automatic syncing. The sync will run continuously at the specified interval until the process is stopped.
</Tip>

#### Manual Sync

Use manual sync when you want to trigger sync operations on-demand (e.g., from a cron job or API endpoint):

```typescript theme={null}
import { DodoSync } from 'dodo-sync';

const syncDodoPayments = new DodoSync({
  database: 'mongodb',
  databaseURI: process.env.MONGODB_URI,
  scopes: ['licences', 'payments', 'customers', 'subscriptions'],
  dodoPaymentsOptions: {
    bearerToken: process.env.DODO_PAYMENTS_API_KEY,
    environment: 'test_mode'
  }
});

// Initialize connection
await syncDodoPayments.init();

// Trigger a single sync operation
await syncDodoPayments.run();
```

<Tip>
  When using manual sync, the `interval` option is not required. You can call `.run()` whenever you need to perform a sync operation.
</Tip>

#### PostgreSQL Example

Here's how to use `dodo-sync` with PostgreSQL:

```typescript theme={null}
import { DodoSync } from 'dodo-sync';

const syncDodoPayments = new DodoSync({
  interval: 60,
  database: 'postgres',
  databaseURI: process.env.POSTGRES_URI, // e.g., 'postgresql://user:password@localhost:5432/mydb'
  scopes: ['licences', 'payments', 'customers', 'subscriptions'],
  dodoPaymentsOptions: {
    bearerToken: process.env.DODO_PAYMENTS_API_KEY,
    environment: 'test_mode'
  }
});

await syncDodoPayments.init();
syncDodoPayments.start();
```

#### MySQL Example

Here's how to use `dodo-sync` with MySQL:

```typescript theme={null}
import { DodoSync } from 'dodo-sync';

const syncDodoPayments = new DodoSync({
  interval: 60,
  database: 'mysql',
  databaseURI: process.env.MYSQL_URI, // e.g., 'mysql://user:password@localhost:3306/mydb'
  scopes: ['licences', 'payments', 'customers', 'subscriptions'],
  dodoPaymentsOptions: {
    bearerToken: process.env.DODO_PAYMENTS_API_KEY,
    environment: 'test_mode'
  }
});

await syncDodoPayments.init();
syncDodoPayments.start();
```

#### ClickHouse Example

Here's how to use `dodo-sync` with ClickHouse:

```typescript theme={null}
import { DodoSync } from 'dodo-sync';

const syncDodoPayments = new DodoSync({
  interval: 60,
  database: 'clickhouse',
  databaseURI: process.env.CLICKHOUSE_URI, // e.g., 'http://localhost:8123'
  scopes: ['licences', 'payments', 'customers', 'subscriptions'],
  dodoPaymentsOptions: {
    bearerToken: process.env.DODO_PAYMENTS_API_KEY,
    environment: 'test_mode'
  }
});

await syncDodoPayments.init();
syncDodoPayments.start();
```

#### Constructor Options

<ParamField type="string">
  Name of the database to use. Supported values: `"mongodb"`, `"postgres"`, `"mysql"`, or `"clickhouse"`.
</ParamField>

<ParamField type="string">
  Connection string for your database:

  * **MongoDB**: `mongodb://localhost:27017` or `mongodb+srv://...`
  * **PostgreSQL**: `postgresql://user:password@localhost:5432/mydb`
  * **MySQL**: `mysql://user:password@localhost:3306/mydb`
  * **ClickHouse**: `http://localhost:8123`
</ParamField>

<ParamField type="string[]">
  Array of entities to sync. Available options: `"licences"`, `"payments"`, `"customers"`, `"subscriptions"`. You can include any combination of these.
</ParamField>

<ParamField type="object">
  Dodo Payments API configuration for authentication and environment selection. See the [TypeScript SDK types](https://github.com/dodopayments/dodopayments-typescript/blob/main/src/client.ts) for complete options.

  **Required properties:**

  * `bearerToken`: Your Dodo Payments API key
  * `environment`: Either `"test_mode"` or `"live_mode"`
</ParamField>

<ParamField type="number">
  Time in seconds between automatic syncs. Required when using `.start()` for automatic syncing. Optional when using `.run()` for manual syncing.
</ParamField>

<ParamField type="number">
  Number of requests per second. Controls how fast the sync engine makes API requests to avoid overwhelming the Dodo Payments API.
</ParamField>

## Important Information

<Warning>
  **MongoDB**: A database named `dodopayments_sync` will be automatically created on your database server. All sync data will be stored there. This database name is currently fixed and cannot be changed.

  **PostgreSQL**: Tables (`Subscriptions`, `Payments`, `Licenses`, `Customers`) will be created in the database specified in your connection URI. Data is stored as JSONB.

  **MySQL**: Tables (`Subscriptions`, `Payments`, `Licenses`, `Customers`) will be created in the database specified in your connection URI. Data is stored as JSON.

  **ClickHouse**: Tables (`Subscriptions`, `Payments`, `Licenses`, `Customers`) will be created using the ReplacingMergeTree engine. When querying, use the `FINAL` keyword to ensure deduplicated results.
</Warning>

<Info>
  The sync engine tracks changes and only syncs new or updated records, making subsequent syncs efficient even with large datasets.
</Info>

## Additional Resources

<CardGroup>
  <Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/dodo-sync">
    View source code, report issues, or contribute improvements
  </Card>

  <Card title="npm Package" icon="box-open" href="https://www.npmjs.com/package/dodo-sync">
    View package details and installation instructions
  </Card>
</CardGroup>


# Dynamic Pricing Checkout with Pay What You Want
Source: https://docs.dodopayments.com/developer-resources/dynamic-pricing-checkout

Create flexible checkout links with variable pricing using a single product. Enable Pay What You Want to let customers choose their price or set dynamic amounts programmatically.

**Dynamic pricing** allows you to offer variable pricing for your products without creating multiple product entries. By enabling **Pay What You Want (PWYW)** on a single product, you can set minimum and maximum price bounds, then pass dynamic amounts when creating checkout session links.

This approach is ideal when you need:

* **Variable pricing** without managing multiple products
* **Customer-driven pricing** where buyers choose their amount
* **Programmatic price control** where you set the amount dynamically via API
* **Flexible pricing models** for digital products, donations, or experimental launches

<Warning>
  Pay What You Want is only available for **Single Payment** (one-time) products. It cannot be used with subscription products.
</Warning>

## How It Works

With Pay What You Want enabled, you can:

1. **Set price bounds**: Define a minimum price (required) and optionally a maximum price
2. **Pass dynamic amounts**: Include an `amount` field in the product cart when creating checkout sessions
3. **Let customers choose**: If no amount is provided, customers can enter their own price (within your bounds)

<Info>
  When you pass an `amount` in the product cart, that amount is used for the checkout. If you omit the `amount` field, customers can select their own price during checkout (subject to your minimum/maximum settings).
</Info>

## Step 1: Create a Product with Pay What You Want

First, create a one-time product in your Dodo Payments dashboard and enable Pay What You Want pricing.

<Steps>
  <Step title="Create a new product">
    Navigate to **Products** in your Dodo Payments dashboard and click **Add Product**.
  </Step>

  <Step title="Configure product details">
    Fill in the required product information:

    * **Product Name**: Display name for your product
    * **Product Description**: Clear description of what customers are purchasing
    * **Product Image**: Upload an image (PNG/JPG/WebP, up to 3 MB)
    * **Tax Category**: Select the appropriate tax category
  </Step>

  <Step title="Set pricing type">
    Select **Pricing Type** as **Single Payment** (one-time payment).
  </Step>

  <Step title="Enable Pay What You Want">
    In the **Pricing** section, enable the **Pay What You Want** toggle.
  </Step>

  <Step title="Set minimum price">
    Enter the **Minimum Price** that customers must pay. This is required and ensures you maintain a revenue floor.

    **Example**: If your minimum is \$5.00, enter `5.00` (or `500` cents).
  </Step>

  <Step title="Set maximum price (optional)">
    Optionally, set a **Maximum Price** to cap the amount customers can pay.
  </Step>

  <Step title="Set suggested price (optional)">
    Optionally, enter a **Suggested Price** that will be displayed to guide customers. This helps anchor expectations and can improve average order value.
  </Step>

  <Step title="Save the product">
    Click **Add Product** to save. Note your product ID (e.g., `pdt_123abc456def`) for use in checkout sessions.
  </Step>
</Steps>

<Tip>
  You can find your product ID in the dashboard under **Products** → **View Details**, or by using the [List Products API](/api-reference/products/get-products).
</Tip>

## Step 2: Create Checkout Sessions with Dynamic Pricing

Once your product is configured with Pay What You Want, you can create checkout sessions with dynamic amounts. The `amount` field in the product cart allows you to set the price programmatically for each checkout session.

### Understanding the Amount Field

When creating a checkout session, you can include an `amount` field in each product cart item:

* **If `amount` is provided**: The checkout uses this exact amount (must be within your minimum/maximum bounds)
* **If `amount` is omitted**: Customers can enter their own price during checkout (within your bounds)

<Warning>
  The `amount` field is only applicable for Pay What You Want products. For regular products, this field is ignored.
</Warning>

### Code Examples

<CodeGroup>
  ```typescript TypeScript theme={null}
  import DodoPayments from 'dodopayments';

  // Initialize the Dodo Payments client
  const client = new DodoPayments({
    bearerToken: process.env.DODO_PAYMENTS_API_KEY,
  });

  async function createDynamicPricingCheckout(
    productId: string,
    amountInCents: number,
    returnUrl: string
  ) {
    try {
      const session = await client.checkoutSessions.create({
        product_cart: [
          {
            product_id: productId,
            quantity: 1,
            // Dynamic amount in cents (e.g., 1500 = $15.00)
            amount: amountInCents
          }
        ],
        return_url: returnUrl,
        // Optional: Pre-fill customer information
        customer: {
          email: 'customer@example.com',
          name: 'John Doe'
        },
        // Optional: Add metadata for tracking
        metadata: {
          order_id: 'order_123',
          pricing_tier: 'custom'
        }
      });

      console.log('Checkout URL:', session.checkout_url);
      console.log('Session ID:', session.session_id);
      
      return session;
    } catch (error) {
      console.error('Failed to create checkout session:', error);
      throw error;
    }
  }

  // Example: Create checkout with $25.00 (2500 cents)
  const session = await createDynamicPricingCheckout(
    'prod_123abc456def',
    2500, // $25.00 in cents
    'https://yoursite.com/checkout/success'
  );

  // Example: Create checkout with $10.00 (1000 cents)
  const session2 = await createDynamicPricingCheckout(
    'prod_123abc456def',
    1000, // $10.00 in cents
    'https://yoursite.com/checkout/success'
  );
  ```

  ```python Python theme={null}
  import os
  from dodopayments import DodoPayments

  # Initialize the Dodo Payments client
  client = DodoPayments(
      bearer_token=os.environ.get("DODO_PAYMENTS_API_KEY"),
  )

  def create_dynamic_pricing_checkout(
      product_id: str,
      amount_in_cents: int,
      return_url: str
  ):
      """
      Create a checkout session with dynamic pricing.
      
      Args:
          product_id: The product ID with Pay What You Want enabled
          amount_in_cents: The amount in cents (e.g., 2500 for $25.00)
          return_url: URL to redirect after payment completion
      
      Returns:
          Session object with checkout_url and session_id
      """
      try:
          session = client.checkout_sessions.create(
              product_cart=[
                  {
                      "product_id": product_id,
                      "quantity": 1,
                      # Dynamic amount in cents (e.g., 1500 = $15.00)
                      "amount": amount_in_cents
                  }
              ],
              return_url=return_url,
              # Optional: Pre-fill customer information
              customer={
                  "email": "customer@example.com",
                  "name": "John Doe"
              },
              # Optional: Add metadata for tracking
              metadata={
                  "order_id": "order_123",
                  "pricing_tier": "custom"
              }
          )
          
          print(f"Checkout URL: {session.checkout_url}")
          print(f"Session ID: {session.session_id}")
          
          return session
      except Exception as error:
          print(f"Failed to create checkout session: {error}")
          raise error

  # Example: Create checkout with $25.00 (2500 cents)
  session = create_dynamic_pricing_checkout(
      "prod_123abc456def",
      2500,  # $25.00 in cents
      "https://yoursite.com/checkout/success"
  )

  # Example: Create checkout with $10.00 (1000 cents)
  session2 = create_dynamic_pricing_checkout(
      "prod_123abc456def",
      1000,  # $10.00 in cents
      "https://yoursite.com/checkout/success"
  )
  ```
</CodeGroup>

<Note>
  **Amount Format**: The `amount` field must be in the lowest denomination of the currency. For USD, this means cents (e.g., \$25.00 = `2500`). For other currencies, use the smallest unit (e.g., paise for INR).
</Note>

## Step 3: Let Customers Choose Their Price

If you want customers to select their own price during checkout, simply omit the `amount` field from the product cart. The checkout page will display an input field where customers can enter any amount within your minimum and maximum bounds.

<CodeGroup>
  ```typescript TypeScript theme={null}
  async function createCustomerChoiceCheckout(
    productId: string,
    returnUrl: string
  ) {
    try {
      const session = await client.checkoutSessions.create({
        product_cart: [
          {
            product_id: productId,
            quantity: 1
            // No amount field - customer will choose their price
          }
        ],
        return_url: returnUrl,
        customer: {
          email: 'customer@example.com',
          name: 'John Doe'
        }
      });

      return session;
    } catch (error) {
      console.error('Failed to create checkout session:', error);
      throw error;
    }
  }
  ```

  ```python Python theme={null}
  def create_customer_choice_checkout(
      product_id: str,
      return_url: str
  ):
      """
      Create a checkout session where customers choose their own price.
      """
      try:
          session = client.checkout_sessions.create(
              product_cart=[
                  {
                      "product_id": product_id,
                      "quantity": 1
                      # No amount field - customer will choose their price
                  }
              ],
              return_url=return_url,
              customer={
                  "email": "customer@example.com",
                  "name": "John Doe"
              }
          )
          
          return session
      except Exception as error:
          print(f"Failed to create checkout session: {error}")
          raise error
  ```
</CodeGroup>

## Common Use Cases

### Use Case 1: Tiered Pricing Based on User Type

Offer different prices to different customer segments using the same product:

```typescript theme={null}
// Student discount: $10.00
const studentSession = await createDynamicPricingCheckout(
  'prod_123abc456def',
  1000, // $10.00
  'https://yoursite.com/success'
);

// Regular price: $25.00
const regularSession = await createDynamicPricingCheckout(
  'prod_123abc456def',
  2500, // $25.00
  'https://yoursite.com/success'
);

// Premium price: $50.00
const premiumSession = await createDynamicPricingCheckout(
  'prod_123abc456def',
  5000, // $50.00
  'https://yoursite.com/success'
);
```

### Use Case 2: Dynamic Pricing Based on Quantity

Adjust price based on quantity purchased:

```typescript theme={null}
async function createQuantityBasedCheckout(
  productId: string,
  quantity: number
) {
  // Base price: $20.00 per unit
  // Discount: 10% for 2+ items, 20% for 5+ items
  const basePrice = 2000; // $20.00 in cents
  let discount = 0;
  
  if (quantity >= 5) {
    discount = 0.20; // 20% off
  } else if (quantity >= 2) {
    discount = 0.10; // 10% off
  }
  
  const totalAmount = Math.round(basePrice * quantity * (1 - discount));
  
  const session = await client.checkoutSessions.create({
    product_cart: [
      {
        product_id: productId,
        quantity: quantity,
        amount: totalAmount
      }
    ],
    return_url: 'https://yoursite.com/success'
  });
  
  return session;
}
```

### Use Case 3: Time-Based or Promotional Pricing

Apply promotional pricing during specific periods:

```typescript theme={null}
async function createPromotionalCheckout(productId: string) {
  const isPromoActive = checkIfPromotionActive(); // Your logic
  const regularPrice = 3000; // $30.00
  const promoPrice = 2000; // $20.00
  
  const amount = isPromoActive ? promoPrice : regularPrice;
  
  const session = await client.checkoutSessions.create({
    product_cart: [
      {
        product_id: productId,
        quantity: 1,
        amount: amount
      }
    ],
    return_url: 'https://yoursite.com/success',
    metadata: {
      pricing_type: isPromoActive ? 'promotional' : 'regular'
    }
  });
  
  return session;
}
```

## Best Practices

<CardGroup>
  <Card title="Set Reasonable Bounds" icon="sliders">
    Choose a minimum price that covers your costs while remaining accessible. Use a suggested price to guide customer expectations.
  </Card>

  <Card title="Validate Amounts" icon="shield-check">
    Always validate that dynamic amounts fall within your product's minimum and maximum bounds before creating checkout sessions.
  </Card>

  <Card title="Track Pricing Decisions" icon="chart-line">
    Use metadata to track why specific amounts were chosen (e.g., `pricing_tier`, `discount_code`, `user_segment`).
  </Card>

  <Card title="Handle Edge Cases" icon="exclamation-triangle">
    Ensure your application handles cases where amounts exceed maximum bounds or fall below minimums gracefully.
  </Card>
</CardGroup>

## Validation and Error Handling

Always validate amounts against your product's minimum and maximum settings:

<CodeGroup>
  ```typescript TypeScript theme={null}
  async function createValidatedCheckout(
    productId: string,
    amountInCents: number,
    minAmount: number,
    maxAmount: number | null
  ) {
    // Validate minimum
    if (amountInCents < minAmount) {
      throw new Error(
        `Amount ${amountInCents} is below minimum ${minAmount}`
      );
    }
    
    // Validate maximum (if set)
    if (maxAmount !== null && amountInCents > maxAmount) {
      throw new Error(
        `Amount ${amountInCents} exceeds maximum ${maxAmount}`
      );
    }
    
    // Create checkout session
    return await client.checkoutSessions.create({
      product_cart: [
        {
          product_id: productId,
          quantity: 1,
          amount: amountInCents
        }
      ],
      return_url: 'https://yoursite.com/success'
    });
  }
  ```

  ```python Python theme={null}
  def create_validated_checkout(
      product_id: str,
      amount_in_cents: int,
      min_amount: int,
      max_amount: int | None
  ):
      """
      Create a checkout session with amount validation.
      """
      # Validate minimum
      if amount_in_cents < min_amount:
          raise ValueError(
              f"Amount {amount_in_cents} is below minimum {min_amount}"
          )
      
      # Validate maximum (if set)
      if max_amount is not None and amount_in_cents > max_amount:
          raise ValueError(
              f"Amount {amount_in_cents} exceeds maximum {max_amount}"
          )
      
      # Create checkout session
      return client.checkout_sessions.create(
          product_cart=[
              {
                  "product_id": product_id,
                  "quantity": 1,
                  "amount": amount_in_cents
              }
          ],
          return_url="https://yoursite.com/success"
      )
  ```
</CodeGroup>

## API Reference

<CardGroup>
  <Card title="Pay What You Want Feature" icon="dollar-sign" href="/features/pay-what-you-want">
    Learn more about the Pay What You Want pricing model and its capabilities.
  </Card>

  <Card title="Checkout Sessions Guide" icon="cart-shopping" href="/developer-resources/checkout-session">
    Explore advanced checkout session features and customization options.
  </Card>
</CardGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Amount is being ignored">
    If your `amount` field is being ignored, verify that:

    * The product has **Pay What You Want** enabled in the dashboard
    * The product is a **Single Payment** (one-time) product, not a subscription
    * The amount is in the correct format (lowest currency denomination, e.g., cents for USD)
  </Accordion>

  <Accordion title="Amount exceeds maximum or is below minimum">
    The API will reject checkout sessions where the amount violates your product's price bounds. Always validate amounts before creating checkout sessions, or let customers choose their price by omitting the `amount` field.
  </Accordion>

  <Accordion title="Customer can't enter their own price">
    If customers aren't seeing the price input field, ensure you've omitted the `amount` field from the product cart. When `amount` is provided, the checkout uses that exact amount.
  </Accordion>
</AccordionGroup>


# Inline Checkout
Source: https://docs.dodopayments.com/developer-resources/inline-checkout

Embed Dodo Payments checkout directly into your website for a seamless, branded payment experience.

## Overview

Inline checkout lets you create fully integrated checkout experiences that blend seamlessly with your website or application. Unlike the [overlay checkout](/developer-resources/overlay-checkout), which opens as a modal on top of your page, inline checkout embeds the payment form directly into your page layout.

Using inline checkout, you can:

* Create checkout experiences that are fully integrated with your app or website
* Let Dodo Payments securely capture customer and payment information in an optimized checkout frame
* Display items, totals, and other information from Dodo Payments on your page
* Use SDK methods and events to build advanced checkout experiences

<Frame>
  <img alt="Inline Checkout Cover Image" />
</Frame>

## How It Works

Inline checkout works by embedding a secure Dodo Payments frame into your website or app.

The checkout frame handles collecting customer information and capturing payment details. Your page displays the items list, totals, and options for changing what's on the checkout. The SDK lets your page and the checkout frame interact with each other.

Dodo Payments automatically creates a subscription when a checkout completes, ready for you to provision.

<Note>
  The inline checkout frame securely handles all sensitive payment information, ensuring PCI compliance without additional certification on your end.
</Note>

## What Makes a Good Inline Checkout?

It's important that customers know who they're buying from, what they're buying, and how much they're paying.

To build an inline checkout that's compliant and optimized for conversion, your implementation must include:

<Frame>
  <img alt="Inline checkout example with required elements labeled" />
</Frame>

1. **Recurring information**: If recurring, how often it recurs and the total to pay on renewal. If a trial, how long the trial lasts.
2. **Item descriptions**: A description of what's being purchased.
3. **Transaction totals**: Transaction totals, including subtotal, total tax, and grand total. Be sure to include the currency too.
4. **Dodo Payments footer**: The full inline checkout frame, including the checkout footer that has information about Dodo Payments, our terms of sale, and our privacy policy.
5. **Refund policy**: A link to your refund policy, if it differs from the Dodo Payments standard refund policy.

<Warning>
  Always display the complete inline checkout frame, including the footer. Removing or hiding legal information violates compliance requirements.
</Warning>

## Customer Journey

The checkout flow is determined by your checkout session configuration. Depending on how you configure the checkout session, customers will experience a checkout that may present all information on a single page or across multiple steps.

<Steps>
  <Step title="Customer opens checkout">
    You can open inline checkout by passing items or an existing transaction. Use the SDK to show and update on-page information, and SDK methods to update items based on customer interaction.

    <img alt="Initial checkout page with items list and payment form" />
  </Step>

  <Step title="Customer enters their details">
    Inline checkout first asks customers to enter their email address, select their country, and (where required) enter their ZIP or postal code. This step gathers all necessary information to determine taxes and available payment options.

    You can prefill customer details and present saved addresses to streamline the experience.
  </Step>

  <Step title="Customer selects payment method">
    After entering their details, customers are presented with available payment methods and the payment form. Options may include credit or debit card, PayPal, Apple Pay, Google Pay, and other local payment methods based on their location.

    Display saved payment methods if available to speed up checkout.

    <img alt="Available payment methods and card details form" />
  </Step>

  <Step title="Checkout completed">
    Dodo Payments routes every payment to the best acquirer for that sale to get the best possible chance of success. Customers enter a success workflow that you can build.

    <img alt="Success screen with confirmation checkmark" />
  </Step>

  <Step title="Dodo Payments creates subscription">
    Dodo Payments automatically creates a subscription for the customer, ready for you to provision. The payment method the customer used is held on file for renewals or subscription changes.

    <img alt="Subscription created with webhook notification" />
  </Step>
</Steps>

## Quick Start

Get started with the Dodo Payments Inline Checkout in just a few lines of code:

```typescript theme={null}
import { DodoPayments } from "dodopayments-checkout";

// Initialize the SDK for inline mode
DodoPayments.Initialize({
  mode: "test",
  displayType: "inline",
  onEvent: (event) => {
    console.log("Checkout event:", event);
  },
});

// Open checkout in a specific container
DodoPayments.Checkout.open({
  checkoutUrl: "https://test.dodopayments.com/session/cks_123",
  elementId: "dodo-inline-checkout" // ID of the container element
});
```

<Tip>
  Ensure you have a container element with the corresponding `id` on your page: `<div id="dodo-inline-checkout"></div>`.
</Tip>

## Step-by-Step Integration Guide

<Steps>
  <Step title="Install the SDK">
    Install the Dodo Payments Checkout SDK:

    <CodeGroup>
      ```bash npm theme={null}
      npm install dodopayments-checkout
      ```

      ```bash yarn theme={null}
      yarn add dodopayments-checkout
      ```

      ```bash pnpm theme={null}
      pnpm add dodopayments-checkout
      ```
    </CodeGroup>
  </Step>

  <Step title="Initialize the SDK for Inline Display">
    Initialize the SDK and specify `displayType: 'inline'`. You should also listen for the `checkout.breakdown` event to update your UI with real-time tax and total calculations.

    ```typescript theme={null}
    import { DodoPayments } from "dodopayments-checkout";

    DodoPayments.Initialize({
      mode: "test",
      displayType: "inline",
      onEvent: (event) => {
        if (event.event_type === "checkout.breakdown") {
          const breakdown = event.data?.message;
          // Update your UI with breakdown.subTotal, breakdown.tax, breakdown.total, etc.
        }
      },
    });
    ```
  </Step>

  <Step title="Create a Container Element">
    Add an element to your HTML where the checkout frame will be injected:

    ```html theme={null}
    <div id="dodo-inline-checkout"></div>
    ```
  </Step>

  <Step title="Open the Checkout">
    Call `DodoPayments.Checkout.open()` with the `checkoutUrl` and the `elementId` of your container:

    ```typescript theme={null}
    DodoPayments.Checkout.open({
      checkoutUrl: "https://test.dodopayments.com/session/cks_123",
      elementId: "dodo-inline-checkout"
    });
    ```
  </Step>

  <Step title="Test Your Integration">
    1. Start your development server:

    ```bash theme={null}
    npm run dev
    ```

    2. Test the checkout flow:
       * Enter your email and address details in the inline frame.
       * Verify that your custom order summary updates in real-time.
       * Test the payment flow using test credentials.
       * Confirm redirects work correctly.

    <Check>
      You should see `checkout.breakdown` events logged in your browser console if you added a console log in the `onEvent` callback.
    </Check>
  </Step>

  <Step title="Go Live">
    When you're ready for production:

    1. Change the mode to `'live'`:

    ```typescript theme={null}
    DodoPayments.Initialize({
      mode: "live",
      displayType: "inline",
      onEvent: (event) => {
        // Handle events
      }
    });
    ```

    2. Update your checkout URLs to use live checkout sessions from your backend.
    3. Test the complete flow in production.
  </Step>
</Steps>

## Complete React Example

This example demonstrates how to implement a custom order summary alongside the inline checkout, keeping them in sync using the `checkout.breakdown` event.

```tsx theme={null}
"use client";

import { useEffect, useState } from 'react';
import { DodoPayments, CheckoutBreakdownData } from 'dodopayments-checkout';

export default function CheckoutPage() {
  const [breakdown, setBreakdown] = useState<Partial<CheckoutBreakdownData>>({});

  useEffect(() => {
    // 1. Initialize the SDK
    DodoPayments.Initialize({
      mode: 'test',
      displayType: 'inline',
      onEvent: (event) => {
        // 2. Listen for the 'checkout.breakdown' event
        if (event.event_type === "checkout.breakdown") {
          const message = event.data?.message as CheckoutBreakdownData;
          if (message) setBreakdown(message);
        }
      }
    });

    // 3. Open the checkout in the specified container
    DodoPayments.Checkout.open({
      checkoutUrl: 'https://test.dodopayments.com/session/cks_123',
      elementId: 'dodo-inline-checkout'
    });

    return () => DodoPayments.Checkout.close();
  }, []);

  const format = (amt: number | null | undefined, curr: string | null | undefined) => 
    amt != null && curr ? `${curr} ${(amt/100).toFixed(2)}` : '0.00';

  const currency = breakdown.currency ?? breakdown.finalTotalCurrency ?? '';

  return (
    <div className="flex flex-col md:flex-row min-h-screen">
      {/* Left Side - Checkout Form */}
      <div className="w-full md:w-1/2 flex items-center">
        <div id="dodo-inline-checkout" className='w-full' />
      </div>

      {/* Right Side - Custom Order Summary */}
      <div className="w-full md:w-1/2 p-8 bg-gray-50">
        <h2 className="text-2xl font-bold mb-4">Order Summary</h2>
        <div className="space-y-2">
          {breakdown.subTotal && (
            <div className="flex justify-between">
              <span>Subtotal</span>
              <span>{format(breakdown.subTotal, currency)}</span>
            </div>
          )}
          {breakdown.discount && (
            <div className="flex justify-between">
              <span>Discount</span>
              <span>{format(breakdown.discount, currency)}</span>
            </div>
          )}
          {breakdown.tax != null && (
            <div className="flex justify-between">
              <span>Tax</span>
              <span>{format(breakdown.tax, currency)}</span>
            </div>
          )}
          <hr />
          {(breakdown.finalTotal ?? breakdown.total) && (
            <div className="flex justify-between font-bold text-xl">
              <span>Total</span>
              <span>{format(breakdown.finalTotal ?? breakdown.total, breakdown.finalTotalCurrency ?? currency)}</span>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

```

## API Reference

### Configuration

#### Initialize Options

```typescript theme={null}
interface InitializeOptions {
  mode: "test" | "live";
  displayType: "inline"; // Required for inline checkout
  onEvent: (event: CheckoutEvent) => void;
}
```

| Option        | Type                    | Required | Description                                      |
| ------------- | ----------------------- | -------- | ------------------------------------------------ |
| `mode`        | `"test" \| "live"`      | Yes      | Environment mode.                                |
| `displayType` | `"inline" \| "overlay"` | Yes      | Must be set to `"inline"` to embed the checkout. |
| `onEvent`     | `function`              | Yes      | Callback function for handling checkout events.  |

#### Checkout Options

```typescript theme={null}
export type FontSize = "xs" | "sm" | "md" | "lg" | "xl" | "2xl";
export type FontWeight = "normal" | "medium" | "bold" | "extraBold";

interface CheckoutOptions {
  checkoutUrl: string;
  elementId: string; // Required for inline checkout
  options?: {
    showTimer?: boolean;
    showSecurityBadge?: boolean;
    manualRedirect?: boolean;
    themeConfig?: ThemeConfig;
    payButtonText?: string;
    fontSize?: FontSize;
    fontWeight?: FontWeight;
  };
}
```

| Option                      | Type          | Required | Description                                                                                                                                                                                        |
| --------------------------- | ------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `checkoutUrl`               | `string`      | Yes      | Checkout session URL.                                                                                                                                                                              |
| `elementId`                 | `string`      | Yes      | The `id` of the DOM element where the checkout should be rendered.                                                                                                                                 |
| `options.showTimer`         | `boolean`     | No       | Show or hide the checkout timer. Defaults to `true`. When disabled, you will receive the `checkout.link_expired` event when the session expires.                                                   |
| `options.showSecurityBadge` | `boolean`     | No       | Show or hide the security badge. Defaults to `true`.                                                                                                                                               |
| `options.manualRedirect`    | `boolean`     | No       | When enabled, the checkout will not automatically redirect after completion. Instead, you will receive `checkout.status` and `checkout.redirect_requested` events to handle the redirect yourself. |
| `options.themeConfig`       | `ThemeConfig` | No       | Custom theme configuration.                                                                                                                                                                        |
| `options.payButtonText`     | `string`      | No       | Custom text to display on the pay button.                                                                                                                                                          |
| `options.fontSize`          | `FontSize`    | No       | Global font size for the checkout.                                                                                                                                                                 |
| `options.fontWeight`        | `FontWeight`  | No       | Global font weight for the checkout.                                                                                                                                                               |

### Methods

#### Open Checkout

Opens the checkout frame in the specified container.

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://test.dodopayments.com/session/cks_123",
  elementId: "dodo-inline-checkout"
});
```

You can also pass additional options to customize the checkout behavior:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://test.dodopayments.com/session/cks_123",
  elementId: "dodo-inline-checkout",
  options: {
    showTimer: false,
    showSecurityBadge: false,
    manualRedirect: true,
    payButtonText: "Pay Now",
  },
});
```

When using `manualRedirect`, handle the checkout completion in your `onEvent` callback:

```typescript theme={null}
DodoPayments.Initialize({
  mode: "test",
  displayType: "inline",
  onEvent: (event) => {
    if (event.event_type === "checkout.status") {
      const status = event.data?.message?.status;
      // Handle status: "succeeded", "failed", or "processing"
    }
    if (event.event_type === "checkout.redirect_requested") {
      const redirectUrl = event.data?.message?.redirect_to;
      // Redirect the customer manually
      window.location.href = redirectUrl;
    }
    if (event.event_type === "checkout.link_expired") {
      // Handle expired checkout session
    }
  },
});
```

#### Close Checkout

Programmatically removes the checkout frame and cleans up event listeners.

```typescript theme={null}
DodoPayments.Checkout.close();
```

#### Check Status

Returns whether the checkout frame is currently injected.

```typescript theme={null}
const isOpen = DodoPayments.Checkout.isOpen();
// Returns: boolean
```

### Events

The SDK provides real-time events through the `onEvent` callback. For inline checkout, `checkout.breakdown` is particularly useful for syncing your UI.

| Event Type                            | Description                                                                                                    |
| ------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| `checkout.opened`                     | Checkout frame has been loaded.                                                                                |
| `checkout.form_ready`                 | Checkout form is ready to receive user input. Useful for hiding loading states and showing the checkout UI.    |
| `checkout.breakdown`                  | Fired when prices, taxes, or discounts are updated.                                                            |
| `checkout.customer_details_submitted` | Customer details have been submitted.                                                                          |
| `checkout.pay_button_clicked`         | Fired when the customer clicks the pay button. Useful for analytics and tracking conversion funnels.           |
| `checkout.redirect`                   | Checkout will perform a redirect (e.g., to a bank page).                                                       |
| `checkout.error`                      | An error occurred during checkout.                                                                             |
| `checkout.link_expired`               | Fired when the checkout session expires. Only received when `showTimer` is set to `false`.                     |
| `checkout.status`                     | Fired when `manualRedirect` is enabled. Contains the checkout status (`succeeded`, `failed`, or `processing`). |
| `checkout.redirect_requested`         | Fired when `manualRedirect` is enabled. Contains the URL to redirect the customer to.                          |

#### Checkout Breakdown Data

The `checkout.breakdown` event provides the following data:

```typescript theme={null}
interface CheckoutBreakdownData {
  subTotal?: number;          // Amount in cents
  discount?: number;         // Amount in cents
  tax?: number;              // Amount in cents
  total?: number;            // Amount in cents
  currency?: string;         // e.g., "USD"
  finalTotal?: number;       // Final amount including adjustments
  finalTotalCurrency?: string; // Currency for the final total
}
```

#### Checkout Status Event Data

When `manualRedirect` is enabled, you receive the `checkout.status` event with the following data:

```typescript theme={null}
interface CheckoutStatusEventData {
  message: {
    status?: "succeeded" | "failed" | "processing";
  };
}
```

#### Checkout Redirect Requested Event Data

When `manualRedirect` is enabled, you receive the `checkout.redirect_requested` event with the following data:

```typescript theme={null}
interface CheckoutRedirectRequestedEventData {
  message: {
    redirect_to?: string;
  };
}
```

#### Understanding the Breakdown Event

The `checkout.breakdown` event is the primary way to keep your application's UI in sync with the Dodo Payments checkout state.

**When it fires:**

* **On initialization**: Immediately after the checkout frame is loaded and ready.
* **On address change**: Whenever the customer selects a country or enters a postal code that results in a tax recalculation.

**Field Details:**

| Field                | Description                                                                                                                                                                     |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `subTotal`           | The sum of all line items in the session before any discounts or taxes are applied.                                                                                             |
| `discount`           | The total value of all applied discounts.                                                                                                                                       |
| `tax`                | The calculated tax amount. In `inline` mode, this updates dynamically as the user interacts with the address fields.                                                            |
| `total`              | The mathematical result of `subTotal - discount + tax` in the session's base currency.                                                                                          |
| `currency`           | The ISO currency code (e.g., `"USD"`) for the standard subtotal, discount, and tax values.                                                                                      |
| `finalTotal`         | The actual amount the customer is charged. This may include additional foreign exchange adjustments or local payment method fees that aren't part of the basic price breakdown. |
| `finalTotalCurrency` | The currency in which the customer is actually paying. This can differ from `currency` if purchasing power parity or local currency conversion is active.                       |

**Key Integration Tips:**

1. **Currency Formatting**: Prices are always returned as integers in the smallest currency unit (e.g., cents for USD, yen for JPY). To display them, divide by 100 (or the appropriate power of 10) or use a formatting library like `Intl.NumberFormat`.
2. **Handling Initial States**: When the checkout first loads, `tax` and `discount` may be `0` or `null` until the user provides their billing information or applies a code. Your UI should handle these states gracefully (e.g., showing a dash `—` or hiding the row).
3. **The "Final Total" vs "Total"**: While `total` gives you the standard price calculation, `finalTotal` is the source of truth for the transaction. If `finalTotal` is present, it reflects exactly what will be charged to the customer's card, including any dynamic adjustments.
4. **Real-time Feedback**: Use the `tax` field to show users that taxes are being calculated in real-time. This provides a "live" feel to your checkout page and reduces friction during the address entry step.

## Implementation Options

### Package Manager Installation

Install via npm, yarn, or pnpm as shown in the [Step-by-Step Integration Guide](#step-by-step-integration-guide).

### CDN Implementation

For quick integration without a build step, you can use our CDN:

```html theme={null}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dodo Payments Inline Checkout</title>
    
    <!-- Load DodoPayments -->
    <script src="https://cdn.jsdelivr.net/npm/dodopayments-checkout@latest/dist/index.js"></script>
    <script>
        // Initialize the SDK
        DodoPaymentsCheckout.DodoPayments.Initialize({
            mode: "test",
            displayType: "inline",
            onEvent: (event) => {
                console.log('Checkout event:', event);
            }
        });
    </script>
</head>
<body>
    <div id="dodo-inline-checkout"></div>

    <script>
        // Open the checkout
        DodoPaymentsCheckout.DodoPayments.Checkout.open({
            checkoutUrl: "https://test.dodopayments.com/session/cks_123",
            elementId: "dodo-inline-checkout"
        });
    </script>
</body>
</html>
```

### Theme Customization

You can customize the checkout appearance by passing a `themeConfig` object in the `options` parameter when opening checkout. The theme configuration supports both light and dark modes, allowing you to customize colors, borders, text, buttons, and border radius.

#### Basic Theme Configuration

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    themeConfig: {
      light: {
        bgPrimary: "#FFFFFF",
        textPrimary: "#344054",
        buttonPrimary: "#A6E500",
      },
      dark: {
        bgPrimary: "#0D0D0D",
        textPrimary: "#FFFFFF",
        buttonPrimary: "#A6E500",
      },
      radius: "8px",
    },
  },
});
```

#### Complete Theme Configuration

All available theme properties:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    themeConfig: {
      light: {
        // Background colors
        bgPrimary: "#FFFFFF",        // Primary background color
        bgSecondary: "#F9FAFB",      // Secondary background color (e.g., tabs)
        
        // Border colors
        borderPrimary: "#D0D5DD",     // Primary border color
        borderSecondary: "#6B7280",  // Secondary border color
        inputFocusBorder: "#D0D5DD", // Input focus border color
        
        // Text colors
        textPrimary: "#344054",       // Primary text color
        textSecondary: "#6B7280",    // Secondary text color
        textPlaceholder: "#667085",  // Placeholder text color
        textError: "#D92D20",        // Error text color
        textSuccess: "#10B981",      // Success text color
        
        // Button colors
        buttonPrimary: "#A6E500",           // Primary button background
        buttonPrimaryHover: "#8CC500",      // Primary button hover state
        buttonTextPrimary: "#0D0D0D",       // Primary button text color
        buttonSecondary: "#F3F4F6",         // Secondary button background
        buttonSecondaryHover: "#E5E7EB",     // Secondary button hover state
        buttonTextSecondary: "#344054",     // Secondary button text color
      },
      dark: {
        // Background colors
        bgPrimary: "#0D0D0D",
        bgSecondary: "#1A1A1A",
        
        // Border colors
        borderPrimary: "#323232",
        borderSecondary: "#D1D5DB",
        inputFocusBorder: "#323232",
        
        // Text colors
        textPrimary: "#FFFFFF",
        textSecondary: "#909090",
        textPlaceholder: "#9CA3AF",
        textError: "#F97066",
        textSuccess: "#34D399",
        
        // Button colors
        buttonPrimary: "#A6E500",
        buttonPrimaryHover: "#8CC500",
        buttonTextPrimary: "#0D0D0D",
        buttonSecondary: "#2A2A2A",
        buttonSecondaryHover: "#3A3A3A",
        buttonTextSecondary: "#FFFFFF",
      },
      radius: "8px", // Border radius for inputs, buttons, and tabs
    },
  },
});
```

#### Light Mode Only

If you only want to customize the light theme:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    themeConfig: {
      light: {
        bgPrimary: "#FFFFFF",
        textPrimary: "#000000",
        buttonPrimary: "#0070F3",
      },
      radius: "12px",
    },
  },
});
```

#### Dark Mode Only

If you only want to customize the dark theme:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    themeConfig: {
      dark: {
        bgPrimary: "#000000",
        textPrimary: "#FFFFFF",
        buttonPrimary: "#0070F3",
      },
      radius: "12px",
    },
  },
});
```

#### Partial Theme Override

You can override only specific properties. The checkout will use default values for properties you don't specify:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    themeConfig: {
      light: {
        buttonPrimary: "#FF6B6B", // Only override primary button color
      },
      radius: "16px", // Override border radius
    },
  },
});
```

#### Theme Configuration with Other Options

You can combine theme configuration with other checkout options:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    showTimer: true,
    showSecurityBadge: true,
    manualRedirect: false,
    themeConfig: {
      light: {
        bgPrimary: "#FFFFFF",
        buttonPrimary: "#A6E500",
      },
      dark: {
        bgPrimary: "#0D0D0D",
        buttonPrimary: "#A6E500",
      },
      radius: "8px",
    },
  },
});
```

#### TypeScript Types

For TypeScript users, all theme configuration types are exported:

```typescript theme={null}
import { ThemeConfig, ThemeModeConfig } from "dodopayments-checkout";

const themeConfig: ThemeConfig = {
  light: {
    bgPrimary: "#FFFFFF",
    // ... other properties
  },
  dark: {
    bgPrimary: "#0D0D0D",
    // ... other properties
  },
  radius: "8px",
};
```

## Error Handling

The SDK provides detailed error information through the event system. Always implement proper error handling in your `onEvent` callback:

```typescript theme={null}
DodoPayments.Initialize({
  mode: "test",
  displayType: "inline",
  onEvent: (event: CheckoutEvent) => {
    if (event.event_type === "checkout.error") {
      console.error("Checkout error:", event.data?.message);
      // Handle error appropriately
    }
  }
});
```

<Warning>
  Always handle the `checkout.error` event to provide a good user experience when issues occur.
</Warning>

## Best Practices

1. **Responsive Design**: Ensure your container element has enough width and height. The iframe will typically expand to fill its container.
2. **Synchronization**: Use the `checkout.breakdown` event to keep your custom order summary or pricing tables in sync with what the user sees in the checkout frame.
3. **Skeleton States**: Show a loading indicator in your container until the `checkout.opened` event fires.
4. **Cleanup**: Call `DodoPayments.Checkout.close()` when your component unmounts to clean up the iframe and event listeners.

<Info>
  For dark mode implementations, it's recommended to use `#0d0d0d` as the background color for optimal visual integration with the inline checkout frame.
</Info>

## Payment Status Validation

<Warning>
  Do not rely solely on inline checkout events to determine payment success or failure. Always implement server-side validation using webhooks and/or polling.
</Warning>

### Why Server-Side Validation is Essential

While inline checkout events like `checkout.status` provide real-time feedback, they should **not** be your only source of truth for payment status. Network issues, browser crashes, or users closing the page can cause events to be missed. To ensure reliable payment validation:

1. **Your server should listen to webhook events** - Dodo Payments sends webhooks for payment status changes
2. **Implement a polling mechanism** - Your frontend should poll your server for status updates
3. **Combine both approaches** - Use webhooks as the primary source and polling as a fallback

### Recommended Architecture

```mermaid theme={null}
flowchart TB
    subgraph Frontend["Your Frontend"]
        IC[Inline Checkout<br/>Dodo iframe]
        CP[Your Checkout Page]
        IC -->|events| CP
    end

    subgraph Server["Your Server"]
        WH[Webhook Handler]
        DB[(Database)]
        API[Status API]
        WH --> DB
        API --> DB
    end

    subgraph Dodo["Dodo Payments"]
        PP[Payment Processor]
    end

    CP -->|Poll for status| API
    PP -->|Webhooks| WH
    IC -.->|Payment request| PP
```

### Implementation Steps

**1. Listen for checkout events** - When the user clicks pay, start preparing to verify the status:

```typescript theme={null}
onEvent: (event) => {
  if (event.event_type === 'checkout.status') {
    // Start polling your server for confirmed status
    startPolling();
  }
}
```

**2. Poll your server** - Create an endpoint that checks your database for the payment status (updated by webhooks):

```typescript theme={null}
// Poll every 2 seconds until status is confirmed
const interval = setInterval(async () => {
  const { status } = await fetch(`/api/payments/${paymentId}/status`).then(r => r.json());
  if (status === 'succeeded' || status === 'failed') {
    clearInterval(interval);
    handlePaymentResult(status);
  }
}, 2000);
```

**3. Handle webhooks server-side** - Update your database when Dodo sends `payment.succeeded` or `payment.failed` webhooks. See our [Webhooks documentation](/developer-resources/webhooks) for details.

### Handling Redirects (3DS, Google Pay, UPI)

When using `manualRedirect: true`, certain payment methods require redirecting the user away from your page for authentication:

* **3D Secure (3DS)** - Card authentication
* **Google Pay** - Wallet authentication on some flows
* **UPI** - Indian payment method redirects

When a redirect is required, you'll receive the `checkout.redirect_requested` event. Redirect the user to the provided URL:

```typescript theme={null}
if (event.event_type === 'checkout.redirect_requested') {
  const redirectUrl = event.data?.message?.redirect_to;
  // Save payment ID before redirect, then redirect
  sessionStorage.setItem('pendingPaymentId', paymentId);
  window.location.href = redirectUrl;
}
```

After authentication completes (success or failure), the user returns to your page. **Do not assume success just because the user returned.** Instead:

1. Check if the user is returning from a redirect (e.g., via `sessionStorage`)
2. Start polling your server for the confirmed payment status
3. Show a "Verifying payment..." state while polling
4. Display success/failure UI based on the server-confirmed status

<Tip>
  Always verify payment status server-side after redirects. The user returning to your page only means authentication completed—it doesn't indicate whether the payment succeeded or failed.
</Tip>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Checkout frame is not appearing">
    * Verify that `elementId` matches the `id` of a `div` that actually exists in the DOM.
    * Ensure `displayType: 'inline'` was passed to `Initialize`.
    * Check that the `checkoutUrl` is valid.
  </Accordion>

  <Accordion title="Taxes are not updating in my UI">
    * Ensure you are listening for the `checkout.breakdown` event.
    * Taxes are only calculated after the user enters a valid country and postal code in the checkout frame.
  </Accordion>
</AccordionGroup>

## Enabling Digital Wallets

For detailed information about setting up Apple Pay, Google Pay, and other digital wallets, see the <a href="/features/payment-methods/digital-wallets">Digital Wallets</a> page.

### Quick Setup for Apple Pay

<Steps>
  <Step title="Download domain association file">
    Download the [Apple Pay domain association file](http://checkout.dodopayments.com/.well-known/apple-developer-merchantid-domain-association).
  </Step>

  <Step title="Request activation">
    Email **[support@dodopayments.com](mailto:support@dodopayments.com)** with your production domain URL and request Apple Pay activation.
  </Step>

  <Step title="Test after confirmation">
    Once confirmed, verify Apple Pay appears in checkout and test the complete flow.
  </Step>
</Steps>

<Warning>
  Apple Pay requires domain verification before it appears in production. Contact support before going live if you plan to offer Apple Pay.
</Warning>

## Browser Support

The Dodo Payments Checkout SDK supports the following browsers:

* Chrome (latest)
* Firefox (latest)
* Safari (latest)
* Edge (latest)
* IE11+

## Inline vs Overlay Checkout

Choose the right checkout type for your use case:

| Feature               | Inline Checkout                              | Overlay Checkout                  |
| --------------------- | -------------------------------------------- | --------------------------------- |
| Integration depth     | Fully embedded in page                       | Modal on top of page              |
| Layout control        | Full control                                 | Limited                           |
| Branding              | Seamless                                     | Separate from page                |
| Implementation effort | Higher                                       | Lower                             |
| Best for              | Custom checkout pages, high-conversion flows | Quick integration, existing pages |

<Tip>
  Use **inline checkout** when you want maximum control over the checkout experience and seamless branding. Use **overlay checkout** for faster integration with minimal changes to your existing pages.
</Tip>

## Related Resources

<CardGroup>
  <Card title="Overlay Checkout" icon="layer-group" href="/developer-resources/overlay-checkout">
    Use the overlay checkout for quick modal-based integration.
  </Card>

  <Card title="Checkout Sessions API" icon="code" href="/api-reference/checkout-sessions/create">
    Create checkout sessions to power your checkout experiences.
  </Card>

  <Card title="Webhooks" icon="webhook" href="/developer-resources/webhooks">
    Handle payment events server-side with webhooks.
  </Card>

  <Card title="Integration Guide" icon="book" href="/developer-resources/integration-guide">
    Complete guide to integrating Dodo Payments.
  </Card>
</CardGroup>

For more help, visit our [Discord community](https://discord.gg/bYqAp4ayYh) or contact our developer support team.


# One-time Payments Integration Guide
Source: https://docs.dodopayments.com/developer-resources/integration-guide

This guide will help you integrate the Dodo Payments API into your website.

## Prerequisites

To integrate the Dodo Payments API, you'll need:

* A Dodo Payments merchant account
* API Credentials (API key and webhook secret key) from dashboard

## Dashboard Setup

1. Navigate to the [Dodo Payments Dashboard](https://app.dodopayments.com/)

2. Create a product (one-time payment or subscription)

3. Generate your API key:
   * Go to Developer > API
   * [Detailed Guide](/api-reference/introduction#api-key-generation)
   * Copy the API key the in env named DODO\_PAYMENTS\_API\_KEY

4. Configure webhooks:
   * Go to Developer > Webhooks
   * Create a webhook URL for payment notifications
   * Copy the webhook secret key in env

## Integration

### Payment Links

Choose the integration path that fits your use case:

* **Checkout Sessions (recommended)**: Best for most integrations. Create a session on your server and redirect customers to a secure, hosted checkout.
* **Overlay Checkout**: Use when you need an in-page experience that opens checkout as a modal overlay on your site.
* **Inline Checkout**: Embed checkout directly into your page layout for fully integrated, branded checkout experiences.
* **Static Payment Links**: No-code, instantly shareable URLs for quick payment collection.
* **Dynamic Payment Links**: Programmatically created links. However, Checkout Sessions are recommended and provide more flexibility.

#### 1. Checkout Sessions

Use Checkout Sessions to create a secure, hosted checkout experience for one-time payments or subscriptions. You create a session on your server, then redirect the customer to the returned `checkout_url`.

<Info>
  Checkout sessions are valid for 24 hours by default. If you pass <code>confirm=true</code>, sessions are valid for 15 minutes and all required fields must be provided.
</Info>

<Steps>
  <Step title="Create a checkout session">
    Choose your preferred SDK or call the REST API.

    <Tabs>
      <Tab title="Node.js SDK">
        ```javascript theme={null}
        import DodoPayments from 'dodopayments';

        const client = new DodoPayments({
          bearerToken: process.env.DODO_PAYMENTS_API_KEY,
          environment: 'test_mode', // defaults to 'live_mode'
        });

        const session = await client.checkoutSessions.create({
          product_cart: [{ product_id: 'prod_123', quantity: 1 }],
          customer: { email: 'customer@example.com', name: 'John Doe' },
          return_url: 'https://yourapp.com/checkout/success',
        });
        ```
      </Tab>

      <Tab title="Python SDK">
        ```python theme={null}
        import os
        from dodopayments import DodoPayments

        client = DodoPayments(
            bearer_token=os.environ.get("DODO_PAYMENTS_API_KEY"),
            environment="test_mode",  # defaults to "live_mode"
        )

        session = client.checkout_sessions.create(
            product_cart=[{"product_id": "prod_123", "quantity": 1}],
            customer={"email": "customer@example.com", "name": "John Doe"},
            return_url="https://yourapp.com/checkout/success",
        )
        ```
      </Tab>

      <Tab title="REST API">
        ```javascript theme={null}
        const response = await fetch('https://test.dodopayments.com/checkouts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${process.env.DODO_PAYMENTS_API_KEY}`,
          },
          body: JSON.stringify({
            product_cart: [{ product_id: 'prod_123', quantity: 1 }],
            customer: { email: 'customer@example.com', name: 'John Doe' },
            return_url: 'https://yourapp.com/checkout/success',
          }),
        });
        const session = await response.json();
        ```
      </Tab>
    </Tabs>
  </Step>

  <Step title="Redirect customer to checkout">
    After session creation, redirect to the `checkout_url` to start the hosted flow.

    ```javascript theme={null}
    // Example in a browser context
    window.location.href = session.checkout_url;
    ```
  </Step>
</Steps>

<Tip>
  Prefer Checkout Sessions for the fastest, most reliable way to start taking payments. For advanced customization, see the full <a href="/developer-resources/checkout-session">Checkout Sessions guide</a> and the <a href="/api-reference/checkout-sessions/create">API Reference</a>.
</Tip>

#### 2. Overlay Checkout

For a seamless in-page checkout experience, explore our [Overlay Checkout](/developer-resources/overlay-checkout) integration that allows customers to complete payments without leaving your website.

#### 3. Inline Checkout

For fully integrated checkout experiences embedded directly in your page, use our [Inline Checkout](/developer-resources/inline-checkout) integration. This allows you to build custom order summaries and have complete control over the checkout layout while Dodo Payments securely handles payment collection.

#### 4. Static Payment Links

Static payment links let you quickly accept payments by sharing a simple URL. You can customize the checkout experience by passing query parameters to pre-fill customer details, control form fields, and add custom metadata.

<Steps>
  <Step title="Construct your payment link">
    Start with the base URL and append your product ID:

    ```text theme={null}
    https://checkout.dodopayments.com/buy/{productid}
    ```
  </Step>

  <Step title="Add core parameters">
    Include essential query parameters:

    * <ParamField type="integer">Number of items to purchase.</ParamField>
    * <ParamField type="string">URL to redirect after payment completion.</ParamField>

    <Note>
      The redirect URL will include payment details as query parameters, for example:<br />
      <code>[https://example.com/?payment\_id=pay\_ts2ySpzg07phGeBZqePbH\&status=succeeded](https://example.com/?payment_id=pay_ts2ySpzg07phGeBZqePbH\&status=succeeded)</code>
    </Note>
  </Step>

  <Step title="Pre-fill customer information (optional)">
    Add customer or billing fields as query parameters to streamline checkout.

    <AccordionGroup>
      <Accordion title="Supported Customer Fields">
        * <ParamField type="string">Customer's full name (ignored if firstName or lastName is provided).</ParamField>
        * <ParamField type="string">Customer's first name.</ParamField>
        * <ParamField type="string">Customer's last name.</ParamField>
        * <ParamField type="string">Customer's email address.</ParamField>
        * <ParamField type="string">Customer's country.</ParamField>
        * <ParamField type="string">Street address.</ParamField>
        * <ParamField type="string">City.</ParamField>
        * <ParamField type="string">State or province.</ParamField>
        * <ParamField type="string">Postal/ZIP code.</ParamField>
        * <ParamField type="boolean">true or false</ParamField>
      </Accordion>
    </AccordionGroup>
  </Step>

  <Step title="Control form fields (optional)">
    <Info>
      You can disable specific fields to make them read-only for the customer. This is useful when you already have the customer's details (e.g., logged-in users).
    </Info>

    To disable a field, provide its value and set the corresponding <code>disable...</code> flag to <code>true</code>:

    <CodeGroup>
      ```text Example theme={null}
      &email=alice@example.com&disableEmail=true
      ```
    </CodeGroup>

    <Tabs>
      <Tab title="Disable Flags Table">
        | Field        | Disable Flag         | Required Parameter |
        | ------------ | -------------------- | ------------------ |
        | Full Name    | `disableFullName`    | `fullName`         |
        | First Name   | `disableFirstName`   | `firstName`        |
        | Last Name    | `disableLastName`    | `lastName`         |
        | Email        | `disableEmail`       | `email`            |
        | Country      | `disableCountry`     | `country`          |
        | Address Line | `disableAddressLine` | `addressLine`      |
        | City         | `disableCity`        | `city`             |
        | State        | `disableState`       | `state`            |
        | ZIP Code     | `disableZipCode`     | `zipCode`          |
      </Tab>
    </Tabs>

    <Tip>
      Disabling fields helps prevent accidental changes and ensures data consistency.
    </Tip>

    <Note>
      Setting <code>showDiscounts=false</code> will disable and hide the discounts section in the checkout form. Use this if you want to prevent customers from entering coupon or promo codes during checkout.
    </Note>
  </Step>

  <Step title="Add advanced controls (optional)">
    * <ParamField type="string">Specifies the payment currency. Defaults to the billing country's currency.</ParamField>
    * <ParamField type="boolean">Show or hide the currency selector.</ParamField>
    * <ParamField type="integer">Amount in cents (for Pay What You Want pricing only).</ParamField>
    * <ParamField type="string">Custom metadata fields (e.g., <code>metadata\_orderId=123</code>).</ParamField>
  </Step>

  <Step title="Share the link">
    Send the completed payment link to your customer. When they visit, all query parameters are collected and stored with a session ID. The URL is then simplified to include just the session parameter (e.g., <code>?session=sess\_1a2b3c4d</code>). The stored information persists through page refreshes and is accessible throughout the checkout process.

    <Check>
      The customer's checkout experience is now streamlined and personalized based on your parameters.
    </Check>
  </Step>
</Steps>

#### 4. Dynamic Payment Links

<Tip>
  Prefer Checkout Sessions for most use cases, they offer more flexibility and control.
</Tip>

Created via API call or our SDK with customer details. Here's an example:

There are two APIs for creating dynamic payment links:

* One-time Payment Link API [API reference](/api-reference/payments/post-payments)
* Subscription Payment Link API [API reference](/api-reference/subscriptions/post-subscriptions)

The guide below is for one-time payment link creation.

For detailed instructions on integrating subscriptions, refer to this [Subscription Integration Guide](/developer-resources/subscription-integration-guide).

<Info>Make sure you are passing `payment_link = true` to get payment link </Info>

<Tabs>
  <Tab title="Node.js SDK">
    ```javascript theme={null}
    import DodoPayments from 'dodopayments';

    const client = new DodoPayments({
    bearerToken: process.env['DODO_PAYMENTS_API_KEY'], // This is the default and can be omitted
    environment: 'test_mode', // defaults to 'live_mode'
    });

    async function main() {
    const payment = await client.payments.create({
    payment_link: true,
    billing: { city: 'city', country: 'AF', state: 'state', street: 'street', zipcode: 0 },
    customer: { email: 'email@email.com', name: 'name' },
    product_cart: [{ product_id: 'product_id', quantity: 0 }],
    });

    console.log(payment.payment_id);
    }

    main();
    ```
  </Tab>

  <Tab title="Python SDK">
    ```python theme={null}
    import os
    from dodopayments import DodoPayments

    client = DodoPayments(
    bearer_token=os.environ.get("DODO_PAYMENTS_API_KEY"),  # This is the default and can be omitted (if using same name `DODO_PAYMENTS_API_KEY`)
    environment="test_mode",  # defaults to "live_mode"
    )
    payment = client.payments.create(
    payment_link=True,
    billing={
        "city": "city",
        "country": "AF",
        "state": "state",
        "street": "street",
        "zipcode": 0,
    },
    customer={
        "email": "email@email.com",
        "name": "name",
    },
    product_cart=[{
        "product_id": "product_id",
        "quantity": 0,
    }],
    )
    print(payment.payment_link)
    ```
  </Tab>

  <Tab title="Go SDK">
    ```go theme={null}
    package main

    import (
    "context"
    "fmt"

    "github.com/dodopayments/dodopayments-go"
    "github.com/dodopayments/dodopayments-go/option"
    )

    func main() {
    client := dodopayments.NewClient(
    option.WithBearerToken("My Bearer Token"), // defaults to os.LookupEnv("DODO_PAYMENTS_API_KEY")
    )
    payment, err := client.Payments.New(context.TODO(), dodopayments.PaymentNewParams{
    PaymentLink: dodopayments.F(true),
    Billing: dodopayments.F(dodopayments.PaymentNewParamsBilling{
      City: dodopayments.F("city"),
      Country: dodopayments.F(dodopayments.CountryCodeAf),
      State: dodopayments.F("state"),
      Street: dodopayments.F("street"),
      Zipcode: dodopayments.F(int64(0)),
    }),
    Customer: dodopayments.F(dodopayments.PaymentNewParamsCustomer{
      Email: dodopayments.F("email"),
      Name: dodopayments.F("name"),
    }),
    ProductCart: dodopayments.F([]dodopayments.PaymentNewParamsProductCart{dodopayments.PaymentNewParamsProductCart{
      ProductID: dodopayments.F("product_id"),
      Quantity: dodopayments.F(int64(0)),
    }}),
    })
    if err != nil {
    panic(err.Error())
    }
    fmt.Printf("%+v\n", payment.PaymentLink)
    }

    ```
  </Tab>

  <Tab title="Api Reference">
    ```javascript theme={null}
    import { NextRequest, NextResponse } from "next/server";      

    export async function POST(request: NextRequest) {
    try {
    const body = await request.json();
    const { formData, cartItems } = paymentRequestSchema.parse(body);

    const response = await fetch(`${process.env.NEXT_PUBLIC_DODO_TEST_API}/payments`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${process.env.DODO_API_KEY}`, // Replace with your API secret key generated from the Dodo Payments Dashboard
      },
      body: JSON.stringify({
        billing: {
          city: formData.city,
          country: formData.country,
          state: formData.state,
          street: formData.addressLine,
          zipcode: parseInt(formData.zipCode),
        },
        customer: {
          email: formData.email,
          name: `${formData.firstName} ${formData.lastName}`,
          phone_number: formData.phoneNumber || undefined,
        },
        payment_link: true,
        product_cart: cartItems.map((id) => ({
          product_id: id,
          quantity: 1,
        })),
        return_url: process.env.NEXT_PUBLIC_RETURN_URL,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => null);
      return NextResponse.json(
        { error: "Payment link creation failed", details: errorData },
        { status: response.status }
      );
    }

    const data = await response.json();
    return NextResponse.json({ paymentLink: data.payment_link });
    } catch (err) {
    console.error("Payment error:", err);
    return NextResponse.json(
      {
        error: err instanceof Error ? err.message : "An unknown error occurred",
      },
      { status: 500 }
    );
    }
    }
    ```
  </Tab>
</Tabs>

<Info>After creating the payment link, redirect your customers to complete their payment.</Info>

### Implementing Webhooks

Set up an API endpoint to receive payment notifications. Here's an example using Next.js:

```javascript theme={null}
import { Webhook } from "standardwebhooks";
import { headers } from "next/headers";
import { WebhookPayload } from "@/types/api-types";

const webhook = new Webhook(process.env.DODO_WEBHOOK_KEY!); // Replace with your secret key generated from the Dodo Payments Dashboard

export async function POST(request: Request) {
  const headersList = headers();
  const rawBody = await request.text();

  const webhookHeaders = {
    "webhook-id": headersList.get("webhook-id") || "",
    "webhook-signature": headersList.get("webhook-signature") || "",
    "webhook-timestamp": headersList.get("webhook-timestamp") || "",
  };

  await webhook.verify(rawBody, webhookHeaders);
  const payload = JSON.parse(rawBody) as WebhookPayload;
  
  // Process the payload according to your business logic
}
```

Our webhook implementation follows the [Standard Webhooks](https://standardwebhooks.com/) specification. For webhook type definitions, refer to our [Webhook Event Guide](/developer-resources/webhooks/intents/webhook-events-guide).

You can refer to this project with demo implementation on [GitHub](https://github.com/dodopayments/dodo-checkout-demo) using Next.js and TypeScript.

You can check out the live implementation [here](https://atlas.dodopayments.com/).


# MCP Server
Source: https://docs.dodopayments.com/developer-resources/mcp-server

Enable AI assistants to interact with the Dodo Payments API through the Model Context Protocol (MCP) for seamless payment operations, subscription management, and customer interactions.

## Overview

The Model Context Protocol (MCP) is an open standard that enables AI applications to securely connect to external data sources and APIs. The Dodo Payments MCP Server provides AI assistants like Claude, Cursor, and other MCP-compatible clients with structured access to your payment infrastructure.

The Dodo Payments MCP Server is built with [Stainless](https://www.stainless.com/) and uses the **Code Mode** architecture, which enables AI agents to write and execute TypeScript code against the Dodo Payments SDK in an isolated sandbox environment.

### Key capabilities

* **Payment Operations**: Create, retrieve, and manage payments and refunds
* **Subscription Management**: Handle recurring billing, upgrades, and cancellations
* **Customer Administration**: Manage customer data and portal access
* **Product Catalog**: Create and update products, pricing, and discounts
* **License Management**: Activate, validate, and manage software licenses
* **Usage-Based Billing**: Track and bill for metered usage

## How Code Mode Works

The Dodo Payments MCP Server uses Code Mode, providing your AI agent with two powerful tools:

1. **Docs Search Tool**: Query documentation about the Dodo Payments API and SDK to understand available operations and parameters
2. **Code Execution Tool**: Write TypeScript code against the SDK that executes in a secure sandbox environment without web or filesystem access

This architecture enables AI agents to perform complex, multi-step payment operations deterministically and repeatably.

<Tip>
  Using Code Mode, agents can chain multiple API calls, handle conditional logic, and perform calculations—all in a single tool invocation.
</Tip>

## Dodo Knowledge MCP

In addition to the Dodo Payments MCP Server (for executing API operations), we provide **Dodo Knowledge MCP** - a semantic search server that gives AI assistants instant access to Dodo Payments documentation and knowledge base.

<Info>
  **Built with [ContextMCP.ai](https://contextmcp.ai)**: Dodo Knowledge MCP is powered by ContextMCP, enabling fast semantic search across our documentation using vector embeddings.
</Info>

### What is Dodo Knowledge MCP?

Dodo Knowledge MCP is a remote MCP server that provides:

* **Semantic Documentation Search**: Find relevant documentation using natural language queries
* **Contextual Answers**: AI assistants get accurate, up-to-date information about Dodo Payments
* **Zero Setup**: No API keys or local installation required - just connect and start querying

### Quick Setup

Connect to Dodo Knowledge MCP in your AI client:

<Tabs>
  <Tab title="Cursor">
    Add to `~/.cursor/mcp.json`:

    ```json theme={null}
    {
      "mcpServers": {
        "dodo-knowledge": {
          "command": "npx",
          "args": ["-y", "mcp-remote@latest", "https://knowledge.dodopayments.com/mcp"]
        }
      }
    }
    ```
  </Tab>

  <Tab title="Claude Desktop">
    Add to your Claude Desktop configuration:

    ```json theme={null}
    {
      "mcpServers": {
        "dodo-knowledge": {
          "command": "npx",
          "args": ["-y", "mcp-remote@latest", "https://knowledge.dodopayments.com/mcp"]
        }
      }
    }
    ```

    Configuration file locations:

    * **macOS**: `~/Library/Application Support/Claude/claude_desktop_config.json`
    * **Windows**: `%APPDATA%\Claude\claude_desktop_config.json`
    * **Linux**: `~/.config/Claude/claude_desktop_config.json`
  </Tab>

  <Tab title="Windsurf">
    Add to `~/.codeium/windsurf/mcp_config.json`:

    ```json theme={null}
    {
      "mcpServers": {
        "dodo-knowledge": {
          "command": "npx",
          "args": ["-y", "mcp-remote@latest", "https://knowledge.dodopayments.com/mcp"]
        }
      }
    }
    ```
  </Tab>

  <Tab title="Claude Code">
    Run in your terminal:

    ```bash theme={null}
    claude mcp add dodo-knowledge -- npx -y mcp-remote@latest https://knowledge.dodopayments.com/mcp
    ```
  </Tab>
</Tabs>

<Note>
  Requires Node.js 18 or higher. The `mcp-remote` package handles the connection to the remote MCP server.
</Note>

### Using Both MCP Servers Together

For the best AI-assisted development experience, we recommend using both MCP servers:

| Server                 | Purpose              | Use Case                                                           |
| ---------------------- | -------------------- | ------------------------------------------------------------------ |
| **Dodo Knowledge MCP** | Documentation search | "How do I handle webhooks?", "What payment methods are supported?" |
| **Dodo Payments MCP**  | API operations       | Create payments, manage subscriptions, handle refunds              |

```json theme={null}
{
  "mcpServers": {
    "dodo-knowledge": {
      "command": "npx",
      "args": ["-y", "mcp-remote@latest", "https://knowledge.dodopayments.com/mcp"]
    },
    "dodopayments": {
      "command": "npx",
      "args": ["-y", "mcp-remote@latest", "https://mcp.dodopayments.com/sse"]
    }
  }
}
```

<Tip>
  With both servers configured, your AI assistant can first search documentation to understand how to implement a feature, then execute the actual API calls—all in a single conversation.
</Tip>

### Troubleshooting Knowledge MCP

If you encounter connection issues:

1. **Clear MCP authentication cache**: `rm -rf ~/.mcp-auth`
2. **Restart your client application**
3. **Check client logs** for error messages
4. **Verify Node.js version**: Requires Node.js 18+

<Card title="Knowledge MCP Server" icon="book-open" href="https://knowledge.dodopayments.com">
  Access the Dodo Knowledge MCP configuration page
</Card>

## Installation

Choose the installation method that best fits your workflow.

### Remote MCP Server (Recommended)

Access the hosted MCP server without any local setup or installation. This is the fastest way to get started.

<Frame>
  <iframe title="Using Dodo Payment's Remote MCP Server" />
</Frame>

<Steps>
  <Step title="Access the remote server">
    Navigate to [https://mcp.dodopayments.com](https://mcp.dodopayments.com) in your browser.
  </Step>

  <Step title="Configure your MCP client">
    Copy the provided JSON configuration for your specific client. For Cursor or Claude Desktop, add this to your MCP settings:

    ```json theme={null}
    {
      "mcpServers": {
        "dodopayments_api": {
          "command": "npx",
          "args": ["-y", "mcp-remote@latest", "https://mcp.dodopayments.com/sse"]
        }
      }
    }
    ```
  </Step>

  <Step title="Authenticate and configure">
    The OAuth flow will prompt you to:

    * Enter your Dodo Payments API key
    * Select your environment (test or live)
    * Choose your MCP client type

    <Warning>
      Keep your API key secure. Use test mode keys during development.
    </Warning>
  </Step>

  <Step title="Complete setup">
    Click **Login and Approve** to authorize the connection.

    <Check>
      Once connected, your AI assistant can interact with the Dodo Payments API on your behalf.
    </Check>
  </Step>
</Steps>

### NPM Package

Install and run the MCP server locally using NPM.

<Tabs>
  <Tab title="NPX (No Installation)">
    ```bash theme={null}
    # Set your environment variables
    export DODO_PAYMENTS_API_KEY="dodo_test_..."
    export DODO_PAYMENTS_WEBHOOK_KEY="your_webhook_key"
    export DODO_PAYMENTS_ENVIRONMENT="live_mode"

    # Run the latest version
    npx -y dodopayments-mcp@latest
    ```
  </Tab>

  <Tab title="MCP Client Configuration">
    ```json theme={null}
    {
      "mcpServers": {
        "dodopayments_api": {
          "command": "npx",
          "args": ["-y", "dodopayments-mcp@latest"],
          "env": {
            "DODO_PAYMENTS_API_KEY": "dodo_test_...",
            "DODO_PAYMENTS_WEBHOOK_KEY": "your_webhook_key",
            "DODO_PAYMENTS_ENVIRONMENT": "live_mode"
          }
        }
      }
    }
    ```
  </Tab>
</Tabs>

<Tip>
  Use `@latest` to always pull the most recent version, or pin to a specific version like `@1.0.0` for stability.
</Tip>

### Docker

Run the MCP server in a containerized environment for consistent deployment.

<CodeGroup>
  ```bash Docker theme={null}
  # Pull the latest image
  docker pull ghcr.io/dodopayments/mcp:latest

  # Run the container
  docker run -e DODO_PAYMENTS_API_KEY="dodo_test_..." \
    -e DODO_PAYMENTS_WEBHOOK_KEY="your_webhook_key" \
    -e DODO_PAYMENTS_ENVIRONMENT="live_mode" \
    ghcr.io/dodopayments/mcp:latest
  ```

  ```yaml Docker Compose theme={null}
  services:
    dodopayments-mcp:
      image: ghcr.io/dodopayments/mcp:latest
      environment:
        - DODO_PAYMENTS_API_KEY=dodo_test_...
        - DODO_PAYMENTS_WEBHOOK_KEY=your_webhook_key
        - DODO_PAYMENTS_ENVIRONMENT=live_mode
      restart: unless-stopped
  ```
</CodeGroup>

<Note>
  Docker images are available on [GitHub Container Registry](https://github.com/orgs/dodopayments/packages/container/package/mcp).
</Note>

## Client Configuration

Configure the Dodo Payments MCP server in your preferred AI client.

<Tabs>
  <Tab title="Cursor">
    Set up the Dodo Payments MCP server in Cursor to enable conversational access to your payments data.

    **One-Click Install**

    Use the button below to install the MCP server directly in Cursor:

    [![Add to Cursor](https://cursor.com/deeplink/mcp-install-dark.svg)](https://cursor.com/en-US/install-mcp?name=dodopayments-mcp\&config=eyJjb21tYW5kIjoibnB4IiwiYXJncyI6WyIteSIsImRvZG9wYXltZW50cy1tY3AiXSwiZW52Ijp7IkRPRE9fUEFZTUVOVFNfQVBJX0tFWSI6IlNldCB5b3VyIERPRE9fUEFZTUVOVFNfQVBJX0tFWSBoZXJlLiIsIkRPRE9fUEFZTUVOVFNfV0VCSE9PS19LRVkiOiJTZXQgeW91ciBET0RPX1BBWU1FTlRTX1dFQkhPT0tfS0VZIGhlcmUuIn19)

    After clicking, set your environment variables in Cursor's `mcp.json` via **Cursor Settings** > **Tools & MCP** > **New MCP Server**.

    **Manual Configuration**

    <Steps>
      <Step title="Open Cursor settings">
        Navigate to **Cursor Settings** > **Features** > **Model Context Protocol** or press `Cmd/Ctrl + Shift + P` and search for "MCP Settings".
      </Step>

      <Step title="Edit configuration">
        Click **Edit Config** to open the `mcp_config.json` file.
      </Step>

      <Step title="Add Dodo Payments configuration">
        Choose one of the following configurations:

        **Remote Server (Recommended)**

        ```json theme={null}
        {
          "mcpServers": {
            "dodopayments": {
              "command": "npx",
              "args": ["-y", "mcp-remote@latest", "https://mcp.dodopayments.com/sse"]
            }
          }
        }
        ```

        **Local NPX**

        ```json theme={null}
        {
          "mcpServers": {
            "dodopayments": {
              "command": "npx",
              "args": ["-y", "dodopayments-mcp@latest"],
              "env": {
                "DODO_PAYMENTS_API_KEY": "dodo_test_...",
                "DODO_PAYMENTS_WEBHOOK_KEY": "your_webhook_key"
              }
            }
          }
        }
        ```
      </Step>

      <Step title="Save and restart">
        Save the configuration file and restart Cursor.

        <Check>
          Verify the connection by asking the AI assistant about your Dodo Payments data.
        </Check>
      </Step>
    </Steps>
  </Tab>

  <Tab title="Claude Desktop">
    Set up the Dodo Payments MCP server in Claude Desktop to enable conversational access to your payments data.

    <Steps>
      <Step title="Locate configuration file">
        Find the Claude Desktop configuration file:

        * **macOS**: `~/Library/Application Support/Claude/claude_desktop_config.json`
        * **Windows**: `%APPDATA%\Claude\claude_desktop_config.json`
        * **Linux**: `~/.config/Claude/claude_desktop_config.json`
      </Step>

      <Step title="Edit configuration">
        Open the file in a text editor and add the Dodo Payments configuration:

        **Remote Server (Recommended)**

        ```json theme={null}
        {
          "mcpServers": {
            "dodopayments": {
              "command": "npx",
              "args": ["-y", "mcp-remote@latest", "https://mcp.dodopayments.com/sse"]
            }
          }
        }
        ```

        **Local NPX**

        ```json theme={null}
        {
          "mcpServers": {
            "dodopayments": {
              "command": "npx",
              "args": ["-y", "dodopayments-mcp@latest"],
              "env": {
                "DODO_PAYMENTS_API_KEY": "dodo_test_...",
                "DODO_PAYMENTS_WEBHOOK_KEY": "your_webhook_key"
              }
            }
          }
        }
        ```
      </Step>

      <Step title="Restart Claude Desktop">
        Close and reopen Claude Desktop for the changes to take effect.

        <Tip>
          Look for the 🔌 icon in Claude Desktop to confirm the MCP server is connected.
        </Tip>
      </Step>
    </Steps>
  </Tab>

  <Tab title="Claude Code">
    Set up the Dodo Payments MCP server in Claude Code CLI.

    Run the following command in your terminal:

    ```bash theme={null}
    claude mcp add --transport stdio dodopayments_api \
      --env DODO_PAYMENTS_API_KEY="dodo_test_..." \
      DODO_PAYMENTS_WEBHOOK_KEY="your_webhook_key" \
      -- npx -y dodopayments-mcp
    ```

    The configuration will be stored in your home directory's `.claude.json` file.

    <Tip>
      Claude Code automatically picks up environment variables from your shell, so you can also export them before running the command.
    </Tip>
  </Tab>

  <Tab title="VS Code">
    Set up the Dodo Payments MCP server in VS Code.

    **One-Click Install**

    [Open VS Code](https://vscode.stainless.com/mcp/%7B%22name%22%3A%22dodopayments-mcp%22%2C%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22-y%22%2C%22dodopayments-mcp%22%5D%2C%22env%22%3A%7B%22DODO_PAYMENTS_API_KEY%22%3A%22Set%20your%20DODO_PAYMENTS_API_KEY%20here.%22%2C%22DODO_PAYMENTS_WEBHOOK_KEY%22%3A%22Set%20your%20DODO_PAYMENTS_WEBHOOK_KEY%20here.%22%7D%7D)

    After clicking, set your environment variables in VS Code's `mcp.json` via **Command Palette** > **MCP: Open User Configuration**.

    **Manual Configuration**

    <Steps>
      <Step title="Open MCP configuration">
        Open the Command Palette (`Cmd/Ctrl + Shift + P`) and search for "MCP: Open User Configuration".
      </Step>

      <Step title="Add server configuration">
        Add the Dodo Payments MCP server:

        ```json theme={null}
        {
          "mcpServers": {
            "dodopayments": {
              "command": "npx",
              "args": ["-y", "dodopayments-mcp@latest"],
              "env": {
                "DODO_PAYMENTS_API_KEY": "dodo_test_...",
                "DODO_PAYMENTS_WEBHOOK_KEY": "your_webhook_key"
              }
            }
          }
        }
        ```
      </Step>

      <Step title="Reload window">
        Reload VS Code (`Cmd/Ctrl + Shift + P` > "Reload Window") to activate the MCP server.
      </Step>
    </Steps>
  </Tab>

  <Tab title="Cline (VS Code)">
    Set up the Dodo Payments MCP server in Cline (VS Code) to enable conversational access to your payments data.

    <Steps>
      <Step title="Open Cline settings">
        Locate the Cline configuration file:

        * **macOS**: `~/Library/Application Support/Code/User/globalStorage/saoudrizwan.claude-dev/settings/cline_mcp_settings.json`
        * **Windows**: `%APPDATA%\Code\User\globalStorage\saoudrizwan.claude-dev\settings\cline_mcp_settings.json`
        * **Linux**: `~/.config/Code/User/globalStorage/saoudrizwan.claude-dev/settings/cline_mcp_settings.json`
      </Step>

      <Step title="Configure MCP server">
        Add the Dodo Payments MCP server configuration:

        ```json theme={null}
        {
          "mcpServers": {
            "dodopayments": {
              "command": "npx",
              "args": ["-y", "dodopayments-mcp@latest"],
              "env": {
                "DODO_PAYMENTS_API_KEY": "dodo_test_...",
                "DODO_PAYMENTS_WEBHOOK_KEY": "your_webhook_key"
              }
            }
          }
        }
        ```
      </Step>

      <Step title="Reload VS Code">
        Reload the VS Code window (`Cmd/Ctrl + Shift + P` > "Reload Window") to activate the MCP server connection.
      </Step>
    </Steps>
  </Tab>

  <Tab title="Zed">
    Set up the Dodo Payments MCP server in Zed to enable conversational access to your payments data.

    <Steps>
      <Step title="Open Zed settings">
        Navigate to **Settings** > **Assistant** > **Model Context Protocol**.
      </Step>

      <Step title="Add server configuration">
        Add the following configuration:

        ```json theme={null}
        {
          "mcpServers": {
            "dodopayments": {
              "command": "npx",
              "args": ["-y", "dodopayments-mcp@latest"],
              "env": {
                "DODO_PAYMENTS_API_KEY": "dodo_test_...",
                "DODO_PAYMENTS_WEBHOOK_KEY": "your_webhook_key"
              }
            }
          }
        }
        ```
      </Step>

      <Step title="Save and verify">
        Save the configuration. The MCP server should now be available in Zed's AI assistant.
      </Step>
    </Steps>
  </Tab>

  <Tab title="Other Clients">
    Set up the Dodo Payments MCP server in other MCP-compatible clients.

    **Remote Server (Recommended)**

    ```json theme={null}
    {
      "mcpServers": {
        "dodopayments": {
          "command": "npx",
          "args": ["-y", "mcp-remote@latest", "https://mcp.dodopayments.com/sse"]
        }
      }
    }
    ```

    **Local NPX**

    ```json theme={null}
    {
      "mcpServers": {
        "dodopayments": {
          "command": "npx",
          "args": ["-y", "dodopayments-mcp@latest"],
          "env": {
            "DODO_PAYMENTS_API_KEY": "dodo_test_...",
            "DODO_PAYMENTS_WEBHOOK_KEY": "your_webhook_key"
          }
        }
      }
    }
    ```

    <Info>
      Visit [modelcontextprotocol.io/clients](https://modelcontextprotocol.io/clients) for a complete list of MCP-compatible clients and their configuration methods.
    </Info>
  </Tab>
</Tabs>

## Environment Variables

Configure the MCP server behavior using environment variables.

| Variable                    | Description                       | Required |
| --------------------------- | --------------------------------- | -------- |
| `DODO_PAYMENTS_API_KEY`     | Your Dodo Payments API key        | Yes      |
| `DODO_PAYMENTS_WEBHOOK_KEY` | Your webhook signing key          | No       |
| `DODO_PAYMENTS_ENVIRONMENT` | Set to `live_mode` for production | No       |

## Running Remotely

Deploy the MCP server as a remote HTTP server for web-based clients or agentic workflows.

```bash theme={null}
# Start as remote server
npx -y dodopayments-mcp --transport=http

# Specify a custom port
npx -y dodopayments-mcp --transport=http --port=3000
```

### Remote Server Configuration

Once deployed, clients can connect using the server URL:

```json theme={null}
{
  "mcpServers": {
    "dodopayments_api": {
      "url": "http://localhost:3000",
      "headers": {
        "Authorization": "Bearer your_api_key"
      }
    }
  }
}
```

### Authorization Headers

The remote server accepts authentication via the following headers:

| Header                    | Description                 |
| ------------------------- | --------------------------- |
| `Authorization`           | Bearer token authentication |
| `x-dodo-payments-api-key` | Direct API key header       |

## Client Capabilities

Different MCP clients have varying levels of support for the MCP specification. The server can automatically adjust tool schemas to work around these limitations.

```bash theme={null}
# Auto-detect client (default)
npx dodopayments-mcp --client=infer

# Configure for specific clients
npx dodopayments-mcp --client=cursor
npx dodopayments-mcp --client=claude
npx dodopayments-mcp --client=claude-code
npx dodopayments-mcp --client=openai-agents
```

### Available Client Presets

| Client          | Description                  |
| --------------- | ---------------------------- |
| `infer`         | Auto-detect client (default) |
| `cursor`        | Cursor editor                |
| `claude`        | Claude AI web or desktop     |
| `claude-code`   | Claude Code CLI              |
| `openai-agents` | OpenAI agents platform       |

### Manual Capability Configuration

For clients not listed above, manually configure capabilities:

```bash theme={null}
# Disable $ref pointer support and set max tool name length
npx dodopayments-mcp --no-capability=refs --capability=tool-name-length=40
```

Available capabilities:

* `top-level-unions` - Support for top-level union types
* `valid-json` - Correct JSON string argument parsing
* `refs` - Support for \$ref pointers in schemas
* `unions` - Support for union types (anyOf)
* `formats` - Support for format validations
* `tool-name-length=N` - Maximum tool name length

<Tip>
  Run `npx dodopayments-mcp --describe-capabilities` for detailed capability information.
</Tip>

## Tool Filtering

Control which API operations are exposed to your AI assistant to optimize performance and maintain security.

### Filter by operation type

Restrict access to read-only or write operations.

```bash theme={null}
# Only expose read operations (GET requests)
npx dodopayments-mcp --operation=read

# Only expose write operations (POST, PUT, DELETE)
npx dodopayments-mcp --operation=write
```

<Tip>
  Use `--operation=read` during development to prevent accidental modifications to your data.
</Tip>

### Filter by resource

Limit tools to specific API resources.

```bash theme={null}
# Only expose payment-related tools
npx dodopayments-mcp --resource=payments

# Expose multiple resources
npx dodopayments-mcp --resource=payments --resource=customers

# Use wildcards for resource groups
npx dodopayments-mcp --resource=subscription*
```

### Include or exclude specific tools

Fine-tune which individual tools are available.

```bash theme={null}
# Include only specific tools
npx dodopayments-mcp --tool=create_payments --tool=list_payments

# Exclude specific tools
npx dodopayments-mcp --no-tool=delete_products

# Disable the docs search tool
npx dodopayments-mcp --no-tools=docs

# List all available tools
npx dodopayments-mcp --list
```

### Combine filters

Apply multiple filters simultaneously for precise control.

```bash theme={null}
# Only payment and subscription read operations
npx dodopayments-mcp --operation=read --resource=payments --resource=subscriptions
```

### URL Query Parameter Filtering (Remote Server)

When using the remote server, apply filters via URL query parameters:

```
https://mcp.dodopayments.com/?operation=read
https://mcp.dodopayments.com/?resource=payments
```

## Dynamic Tools Mode

For large APIs, loading all tools at once can overwhelm the AI's context window. Dynamic tools mode provides a more efficient alternative.

```bash theme={null}
npx dodopayments-mcp --tools=dynamic
```

In dynamic mode, three meta-tools replace individual API tools:

1. **`list_api_endpoints`** - Discovers available methods with optional filtering
2. **`get_api_endpoint_schema`** - Gets detailed schema for a specific method
3. **`invoke_api_endpoint`** - Executes any method with appropriate parameters

<Info>
  Dynamic tools are automatically enabled for APIs with more than 50 methods. Override with `--tools=all` to include all tools.
</Info>

```bash theme={null}
# Use both dynamic tools and specific resources
npx dodopayments-mcp --tools=dynamic --resource=payments
```

## Advanced Usage

### Programmatic integration

Build custom MCP servers or extend the existing one programmatically.

```javascript theme={null}
import { server, endpoints, init } from "dodopayments-mcp/server";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";

// Initialize with all default endpoints
init({ server, endpoints });

// Start the server
const transport = new StdioServerTransport();
await server.connect(transport);
```

### Custom tool development

Extend the MCP server with your own tools and business logic.

```javascript theme={null}
import { server, init } from "dodopayments-mcp/server";
import createPayments from "dodopayments-mcp/tools/payments/create-payments";
import { zodToJsonSchema } from "zod-to-json-schema";
import { z } from "zod";

// Define a custom tool
const customTool = {
  tool: {
    name: 'calculate_payment_total',
    description: 'Calculate payment total with tax and fees',
    inputSchema: zodToJsonSchema(
      z.object({
        amount: z.number().describe('Base amount in cents'),
        tax_rate: z.number().describe('Tax rate as decimal'),
      })
    ),
  },
  handler: async (client, args) => {
    const total = args.amount * (1 + args.tax_rate);
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({ total, currency: 'usd' }),
      }],
    };
  },
};

// Initialize with custom tools
init({ 
  server, 
  endpoints: [createPayments, customTool] 
});
```

## Security Best Practices

Protect your API credentials and maintain secure integrations.

<AccordionGroup>
  <Accordion title="API Key Management">
    **Never commit credentials to version control**

    Store API keys in environment variables or secure secret management systems.

    ```bash theme={null}
    # Use environment variables
    export DODO_PAYMENTS_API_KEY="dodo_test_..."

    # Use a .env file (add to .gitignore)
    echo "DODO_PAYMENTS_API_KEY=dodo_test_..." > .env
    ```

    **Rotate keys regularly**

    Generate new API keys periodically and revoke old ones through your Dodo Payments dashboard.

    **Use test keys for development**

    Always use test mode API keys during development to avoid affecting production data.
  </Accordion>

  <Accordion title="Access Control">
    **Apply tool filtering in production**

    Limit exposed operations to only what your AI assistant needs.

    ```bash theme={null}
    # Production: read-only access
    npx dodopayments-mcp --operation=read

    # Development: full access
    npx dodopayments-mcp
    ```

    **Implement authentication for remote servers**

    When deploying remotely, always require authentication via the `Authorization` header or `x-dodo-payments-api-key` header.

    **Monitor API usage**

    Track MCP server activity through your Dodo Payments dashboard and set up alerts for unusual patterns.
  </Accordion>

  <Accordion title="Network Security">
    **Use HTTPS for remote servers**

    Always deploy remote MCP servers behind HTTPS endpoints.

    **Implement rate limiting**

    Protect against abuse by implementing rate limits at both the MCP server and API levels.

    **Restrict network access**

    Configure firewall rules to limit which clients can connect to your MCP server.
  </Accordion>
</AccordionGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Connection issues">
    **Verify your API key**

    Ensure your API key is correctly set and has the necessary permissions.

    ```bash theme={null}
    # Test your API key
    curl -H "Authorization: Bearer dodo_test_..." \
      https://api.dodopayments.com/payments
    ```

    **Check your network connection**

    Verify you can reach the Dodo Payments API endpoints.

    **Review client logs**

    Enable verbose logging in your MCP client to diagnose connection problems.
  </Accordion>

  <Accordion title="Authentication errors">
    **Confirm API key environment**

    Ensure you're using test keys with test endpoints and live keys with production endpoints.

    **Check environment variable**

    Verify `DODO_PAYMENTS_ENVIRONMENT` is set correctly (`live_mode` for production).

    **Regenerate credentials**

    If issues persist, generate a new API key through your dashboard.
  </Accordion>

  <Accordion title="Tool execution failures">
    **Validate input parameters**

    Ensure the AI assistant is providing correctly formatted parameters for each tool.

    **Review error messages**

    Check the error response from the API for specific guidance on what went wrong.

    **Test with API directly**

    Verify the operation works when calling the Dodo Payments API directly via curl or Postman.
  </Accordion>

  <Accordion title="Client compatibility issues">
    **Try a different client preset**

    If tools aren't working correctly, try specifying your client explicitly:

    ```bash theme={null}
    npx dodopayments-mcp --client=cursor
    ```

    **Check capability support**

    Some clients don't support all JSON schema features. Use `--describe-capabilities` to understand what's supported.
  </Accordion>
</AccordionGroup>

## Resources

<CardGroup>
  <Card title="API Reference" icon="book" href="/api-reference/introduction">
    Explore the complete Dodo Payments API documentation
  </Card>

  <Card title="MCP Protocol" icon="link" href="https://modelcontextprotocol.io">
    Learn more about the Model Context Protocol standard
  </Card>

  <Card title="GitHub Repository" icon="github" href="https://github.com/dodopayments/dodopayments-typescript/tree/main/packages/mcp-server">
    View the MCP server source code and contribute
  </Card>

  <Card title="NPM Package" icon="npm" href="https://www.npmjs.com/package/dodopayments-mcp">
    Install the MCP server from NPM
  </Card>
</CardGroup>


# Mobile Integration Guide
Source: https://docs.dodopayments.com/developer-resources/mobile-integration

Unified guide for integrating Dodo Payments into Android, iOS, React Native and Flutter mobile applications.

<CardGroup>
  <Card title="Quick Start" icon="rocket" href="#integration-workflow">
    Get your mobile payment integration running in 4 simple steps
  </Card>

  <Card title="Platform Examples" icon="code" href="#platform-specific-integration">
    Complete code examples for Android, iOS, React Native, and Flutter
  </Card>
</CardGroup>

## Prerequisites

Before integrating Dodo Payments into your mobile app, ensure you have:

* **Dodo Payments Account**: Active merchant account with API access
* **API Credentials**: API key and webhook secret key from your dashboard
* **Mobile App Project**: Android, iOS, React Native, or Flutter application
* **Backend Server**: To securely handle checkout session creation

## Integration Workflow

The mobile integration follows a secure 4-step process where your backend handles API calls and your mobile app manages the user experience.

<Steps>
  <Step title="Backend: Create Checkout Session">
    <Card title="Checkout Session API Docs" icon="book" href="/developer-resources/checkout-session">
      Learn how to create a checkout session in your backend using Node.js, Python, and more. See complete examples and parameter references in the dedicated <strong>Checkout Sessions API</strong> documentation.
    </Card>

    <Note>
      **Security**: Checkout sessions must be created on your backend server, never in the mobile app. This protects your API keys and ensures proper validation.
    </Note>
  </Step>

  <Step title="Mobile: Get Checkout URL">
    Your mobile app calls your backend to get the checkout URL:

    <Tabs>
      <Tab title="iOS (Swift)">
        ```swift theme={null}
        func getCheckoutURL(productId: String, customerEmail: String, customerName: String) async throws -> String {
            let url = URL(string: "https://your-backend.com/api/create-checkout-session")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            
            let requestData: [String: Any] = [
                "productId": productId,
                "customerEmail": customerEmail,
                "customerName": customerName
            ]
            request.httpBody = try JSONSerialization.data(withJSONObject: requestData)
            
            let (data, _) = try await URLSession.shared.data(for: request)
            let response = try JSONDecoder().decode(CheckoutResponse.self, from: data)
            return response.checkout_url
        }
        ```
      </Tab>

      <Tab title="Android (Kotlin)">
        ```kotlin theme={null}
        suspend fun getCheckoutURL(productId: String, customerEmail: String, customerName: String): String {
            val client = OkHttpClient()
            val requestBody = JSONObject().apply {
                put("productId", productId)
                put("customerEmail", customerEmail)
                put("customerName", customerName)
            }.toString().toRequestBody("application/json".toMediaType())
            
            val request = Request.Builder()
                .url("https://your-backend.com/api/create-checkout-session")
                .post(requestBody)
                .build()
            
            val response = client.newCall(request).execute()
            val responseBody = response.body?.string()
            val jsonResponse = JSONObject(responseBody ?: "")
            return jsonResponse.getString("checkout_url")
        }
        ```
      </Tab>

      <Tab title="React Native (JavaScript)">
        ```javascript theme={null}
        const getCheckoutURL = async (productId, customerEmail, customerName) => {
          try {
            const response = await fetch('https://your-backend.com/api/create-checkout-session', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                productId,
                customerEmail,
                customerName
              })
            });
            
            const data = await response.json();
            return data.checkout_url;
          } catch (error) {
            console.error('Failed to get checkout URL:', error);
            throw error;
          }
        };
        ```
      </Tab>
    </Tabs>

    <Note>
      **Security**: Mobile apps only communicate with your backend, never directly with Dodo Payments API.
    </Note>
  </Step>

  <Step title="Mobile: Open Checkout in Browser">
    Open the checkout URL in a secure in-app browser for payment processing.

    <Card title="See platform-specific integration examples" icon="box" href="#platform-specific-integration">
      View full code and setup instructions for Android, iOS, and Flutter mobile payments.
    </Card>
  </Step>

  <Step title="Backend: Handle Payment Completion">
    Process payment completion via webhooks and redirect URLs to confirm payment status.
  </Step>
</Steps>

## Platform-Specific Integration

Choose your mobile platform below for complete implementation examples:

<Tabs>
  <Tab title="Android">
    ### Android Integration

    #### Chrome Custom Tabs Implementation

    ```kotlin theme={null}
    // Add Chrome Custom Tabs dependency to build.gradle
    implementation 'androidx.browser:browser:1.5.0'

    // In your Activity
    class PaymentActivity : AppCompatActivity() {
        private var customTabsSession: CustomTabsSession? = null
        private var customTabsClient: CustomTabsClient? = null
        private var customTabsServiceConnection: CustomTabsServiceConnection? = null

        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            // Initialize Custom Tabs
            customTabsServiceConnection = object : CustomTabsServiceConnection() {
                override fun onCustomTabsServiceConnected(name: ComponentName, client: CustomTabsClient) {
                    customTabsClient = client
                    customTabsClient?.warmup(0L)
                    customTabsSession = customTabsClient?.newSession(object : CustomTabsCallback() {
                        override fun onNavigationEvent(navigationEvent: Int, extras: Bundle?) {
                            // Handle navigation events
                        }
                    })
                }
                override fun onServiceDisconnected(name: ComponentName) {
                    customTabsClient = null
                }
            }
            CustomTabsClient.bindCustomTabsService(
                this,
                "com.android.chrome",
                customTabsServiceConnection!!
            )
            // Get checkout URL from backend and launch
            lifecycleScope.launch {
                try {
                    val checkoutURL = getCheckoutURL("prod_123", "customer@example.com", "Customer Name")
                    val customTabsIntent = CustomTabsIntent.Builder(customTabsSession)
                        .build()
                    customTabsIntent.launchUrl(this@PaymentActivity, Uri.parse(checkoutURL))
                } catch (e: Exception) {
                    // Handle error
                    Log.e("PaymentActivity", "Failed to get checkout URL", e)
                }
            }
        }
    }
    ```
  </Tab>

  <Tab title="iOS">
    ### iOS Integration

    #### SFSafariViewController Implementation

    ```swift theme={null}
    import SafariServices
    class PaymentViewController: UIViewController {
        override func viewDidLoad() {
            super.viewDidLoad()
            Task {
                do {
                    let checkoutURL = try await getCheckoutURL(
                        productId: "prod_123",
                        customerEmail: "customer@example.com",
                        customerName: "Customer Name"
                    )
                    if let url = URL(string: checkoutURL) {
                        let safariVC = SFSafariViewController(url: url)
                        present(safariVC, animated: true, completion: nil)
                    }
                } catch {
                    // Handle error
                    print("Failed to get checkout URL: \(error)")
                }
            }
        }
    }
    ```

    #### Deep Link Handling

    Configure URL schemes to handle payment completion redirects:

    **1. Set up URL schemes in Info.plist:**

    ```xml theme={null}
    <key>CFBundleURLTypes</key>
    <array>
      <dict>
        <key>CFBundleURLName</key>
        <string>myapp</string>
        <key>CFBundleURLSchemes</key>
        <array>
          <string>myapp</string>
        </array>
      </dict>
    </array>
    ```

    **2. Handle redirects in AppDelegate:**

    ```swift theme={null}
    func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
        if url.scheme == "myapp" && url.host == "payment-status" {
            NotificationCenter.default.post(name: .paymentCompleted, object: url)
            return true
        }
        return false
    }
    ```

    **3. Listen for payment completion:**

    ```swift theme={null}
    NotificationCenter.default.addObserver(self, selector: #selector(handlePaymentCompletion(_:)), name: .paymentCompleted, object: nil)

    @objc func handlePaymentCompletion(_ notification: Notification) {
        if let url = notification.object as? URL {
            safariVC?.dismiss(animated: true)
            // Parse payment status from URL parameters
            let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
            let paymentId = components?.queryItems?.first(where: { $0.name == "payment_id" })?.value
            let status = components?.queryItems?.first(where: { $0.name == "status" })?.value
            // Handle payment completion
        }
    }
    ```
  </Tab>

  <Tab title="React Native">
    ### React Native Integration

    #### Using Checkout Links (InAppBrowser)

    Open Dodo's hosted checkout page in an in-app browser.

    ##### InAppBrowser Implementation

    ```javascript theme={null}
    import React from 'react';
    import { View, TouchableOpacity, Text, Alert } from 'react-native';
    import { InAppBrowser } from 'react-native-inappbrowser-reborn';

    const PaymentButton = ({ productId, onPaymentComplete }) => {
      const openPaymentLink = async () => {
        try {
          // Get checkout URL from backend
          const checkoutURL = await getCheckoutURL(
            productId,
            'customer@example.com',
            'Customer Name'
          );
          
          const result = await InAppBrowser.open(checkoutURL, {
            // iOS options
            dismissButtonStyle: 'cancel',
            preferredBarTintColor: '#453AA4',
            preferredControlTintColor: 'white',
            readerMode: false,
            animated: true,
            modalPresentationStyle: 'fullScreen',
            modalTransitionStyle: 'coverVertical',
            modalEnabled: true,
            enableBarCollapsing: false,
            // Android options
            showTitle: true,
            toolbarColor: '#453AA4',
            secondaryToolbarColor: 'black',
            navigationBarColor: 'black',
            navigationBarDividerColor: 'white',
            enableUrlBarHiding: true,
            enableDefaultShare: true,
            forceCloseOnRedirection: false,
            animations: {
              startEnter: 'slide_in_right',
              startExit: 'slide_out_left',
              endEnter: 'slide_in_left',
              endExit: 'slide_out_right'
            },
            headers: {
              'my-custom-header': 'my custom header value'
            }
          });

          // Handle payment completion based on result
          if (result.type === 'dismiss') {
            // User dismissed the browser
            console.log('Payment browser dismissed');
          }
        } catch (error) {
          Alert.alert('Error', 'Failed to open payment page');
          console.error('InAppBrowser error:', error);
        }
      };

      return (
        <View style={{ padding: 20 }}>
          <TouchableOpacity
            style={{
              backgroundColor: '#007AFF',
              padding: 15,
              borderRadius: 8,
              alignItems: 'center'
            }}
            onPress={openPaymentLink}
          >
            <Text style={{ color: 'white', fontSize: 16, fontWeight: 'bold' }}>
              Pay Now
            </Text>
          </TouchableOpacity>
        </View>
      );
    };

    export default PaymentButton;
    ```

    #### Deep Link Handling for Payment Callbacks

    ```javascript theme={null}
    // App.js or your main component
    import React, { useEffect } from 'react';
    import { Linking } from 'react-native';

    const App = () => {
      useEffect(() => {
        // Handle deep links when app is already running
        const handleDeepLink = (url) => {
          if (url.includes('payment-status')) {
            const urlParams = new URLSearchParams(url.split('?')[1]);
            const paymentId = urlParams.get('payment_id');
            const status = urlParams.get('status');
            
            // Handle payment completion
            handlePaymentCallback(paymentId, status);
          }
        };

        // Listen for deep links
        const subscription = Linking.addEventListener('url', ({ url }) => {
          handleDeepLink(url);
        });

        // Handle deep link if app was opened from a link
        Linking.getInitialURL().then((url) => {
          if (url) {
            handleDeepLink(url);
          }
        });

        return () => subscription?.remove();
      }, []);

      const handlePaymentCallback = (paymentId, status) => {
        if (status === 'succeeded') {
          // Navigate to success screen or show success message
          console.log('Payment successful:', paymentId);
        } else {
          // Handle payment failure
          console.log('Payment failed:', paymentId);
        }
      };

      // Your app components...
    };

    export default App;
    ```

    #### Package Dependencies

    Add this dependency to your `package.json`:

    ```json theme={null}
    {
      "dependencies": {
        "react-native-inappbrowser-reborn": "^6.4.0"
      }
    }
    ```

    #### Installation Commands

    ```bash theme={null}
    # Install InAppBrowser
    npm install react-native-inappbrowser-reborn
    cd ios && pod install
    ```

    #### Android Configuration

    Add to `android/app/src/main/AndroidManifest.xml`:

    ```xml theme={null}
    <activity
      android:name="com.reactnativeinappbrowserreborn.InAppBrowserActivity"
      android:theme="@style/Theme.AppCompat.Dialog"
      android:exported="false" />
    ```

    #### iOS Configuration

    Add to `ios/YourApp/Info.plist`:

    ```xml theme={null}
    <key>CFBundleURLTypes</key>
    <array>
      <dict>
        <key>CFBundleURLName</key>
        <string>myapp</string>
        <key>CFBundleURLSchemes</key>
        <array>
          <string>myapp</string>
        </array>
      </dict>
    </array>
    ```

    <Tip>
      Use InAppBrowser for native browser experience. Handle deep links for payment callbacks.
    </Tip>

    ***

    #### Alternative: Native Payment SDK

    For a more integrated payment experience with native UI and full customization, Dodo Payments offers a React Native SDK.

    <Warning>
      **Regional Compliance**: In-app payment SDKs have regional restrictions. On **iOS**, native payment SDKs are only legal in the **EU** (under DMA terms). On **Android**, they're legal in User Choice Billing (UCB) markets. For other regions, use the checkout links approach above to ensure App Store and Play Store compliance.
    </Warning>

    <Card title="React Native SDK Integration Guide" icon="mobile-screen" href="/developer-resources/react-native-integration">
      Complete guide for integrating Dodo's React Native SDK with native payment sheets, full customization options, and direct payment handling. Includes setup, implementation, and testing instructions.
    </Card>

    <Info>
      Review the [App Store Fee Bypass Guide](/features/bypassing-app-store-fees) to understand regional compliance requirements for in-app payment integrations.
    </Info>
  </Tab>

  <Tab title="Flutter">
    ### Flutter Integration

    ```dart theme={null}
    import 'package:flutter/material.dart';
    import 'package:webview_flutter/webview_flutter.dart';
    import 'package:http/http.dart' as http;
    import 'dart:convert';

    Future<String> getCheckoutURL(String productId, String customerEmail, String customerName) async {
      final response = await http.post(
        Uri.parse('https://your-backend.com/api/create-checkout-session'),
        headers: {'Content-Type': 'application/json'},
        body: json.encode({
          'productId': productId,
          'customerEmail': customerEmail,
          'customerName': customerName,
        }),
      );
      
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        return data['checkout_url'];
      } else {
        throw Exception('Failed to get checkout URL: ${response.statusCode}');
      }
    }
    class PaymentScreen extends StatefulWidget {
      @override
      _PaymentScreenState createState() => _PaymentScreenState();
    }
    class _PaymentScreenState extends State<PaymentScreen> {
      late WebViewController _controller;
      String? checkoutURL;
      
      @override
      void initState() {
        super.initState();
        _getCheckoutURL();
      }
      
      Future<void> _getCheckoutURL() async {
        try {
          final url = await getCheckoutURL('prod_123', 'customer@example.com', 'Customer Name');
          setState(() {
            checkoutURL = url;
          });
        } catch (e) {
          // Handle error
          print('Failed to get checkout URL: $e');
        }
      }
      
      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(title: Text('Payment')),
          body: checkoutURL == null 
            ? Center(child: CircularProgressIndicator())
            : WebView(
            initialUrl: checkoutURL,
            javascriptMode: JavascriptMode.unrestricted,
            onWebViewCreated: (WebViewController webViewController) {
              _controller = webViewController;
            },
            navigationDelegate: (NavigationRequest request) {
              if (request.url.contains('payment_id') && request.url.contains('status')) {
                // Handle payment completion
                final uri = Uri.parse(request.url);
                final paymentId = uri.queryParameters['payment_id'];
                final status = uri.queryParameters['status'];
                handlePaymentCompletion(paymentId, status);
                return NavigationDecision.prevent;
              }
              return NavigationDecision.navigate;
            },
          ),
        );
      }
      void handlePaymentCompletion(String? paymentId, String? status) {
        if (status == 'succeeded') {
          // Payment successful
        } else {
          // Payment failed
        }
      }
    }
    ```

    <Tip>
      Use WebView for payment links. Handle the redirect URL to detect payment completion.
    </Tip>
  </Tab>
</Tabs>

## Best Practices

* **Security**: Never store API keys in your app code. Use secure storage and SSL pinning.
* **User Experience**: Show loading indicators, handle errors gracefully, and provide clear messages.
* **Testing**: Use test cards, simulate network errors, and test on various devices.

## Troubleshooting

### Common Issues

* **WebView not opening payment link**: Ensure the payment link is valid and uses HTTPS.
* **Callback not received**: Check your return URL and webhook configuration.
* **API key errors**: Verify that your API key is correct and has the necessary permissions.

## Additional Resources

* [Payment Integration Guide](/developer-resources/integration-guide)
* [Webhook Documentation](/developer-resources/webhooks/intents/webhook-events-guide)
* [Testing Process](/miscellaneous/testing-process)
* [Technical FAQs](/api-reference/technical-faqs)

<Check>
  For questions or support, contact <a href="mailto:support@dodopayments.com">[support@dodopayments.com](mailto:support@dodopayments.com)</a>.
</Check>


# Overlay Checkout
Source: https://docs.dodopayments.com/developer-resources/overlay-checkout

A modern TypeScript library for embedding Dodo Payments overlay checkout and listening to checkout events in real-time.

## Overview

The Dodo Payments Checkout SDK provides a seamless way to integrate our payment overlay into your web application. Built with TypeScript and modern web standards, it offers a robust solution for handling payments with real-time event handling and customizable themes.

<Frame>
  <img alt="Overlay Checkout Cover Image" />
</Frame>

## Demo

<Card title="Interactive Demo" icon="play" href="https://atlas.dodopayments.com/pricing">
  See the overlay checkout in action with our live demo.
</Card>

## Quick Start

Get started with the Dodo Payments Checkout SDK in just a few lines of code:

```typescript theme={null}
import { DodoPayments } from "dodopayments-checkout";

// Initialize the SDK
DodoPayments.Initialize({
  mode: "test", // 'test' or 'live'
  displayType: "overlay", // Optional: defaults to 'overlay' for overlay checkout
  onEvent: (event) => {
    console.log("Checkout event:", event);
  },
});

// Open checkout
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123"
});
```

<Tip>
  Get your checkout URL from the [create checkout session API](/api-reference/checkout-sessions/create).
</Tip>

## Step-by-Step Integration Guide

<Steps>
  <Step title="Install the SDK">
    Install the Dodo Payments Checkout SDK using your preferred package manager:

    <CodeGroup>
      ```bash npm theme={null}
      npm install dodopayments-checkout
      ```

      ```bash yarn theme={null}
      yarn add dodopayments-checkout
      ```

      ```bash pnpm theme={null}
      pnpm add dodopayments-checkout
      ```
    </CodeGroup>
  </Step>

  <Step title="Initialize the SDK">
    Initialize the SDK in your application, typically in your main component or app entry point:

    ```typescript theme={null}
    import { DodoPayments } from "dodopayments-checkout";

    DodoPayments.Initialize({
      mode: "test", // Change to 'live' for production
      displayType: "overlay", // Optional: defaults to 'overlay' for overlay checkout
      onEvent: (event) => {
        console.log("Checkout event:", event);
        
        // Handle different events
        switch (event.event_type) {
          case "checkout.opened":
            // Checkout overlay has been opened
            break;
          case "checkout.closed":
            // Checkout has been closed
            break;
          case "checkout.error":
            // Handle errors
            console.error("Checkout error:", event.data?.message);
            break;
        }
      },
    });
    ```

    <Warning>
      Always initialize the SDK before attempting to open the checkout. Initialization should happen once when your application loads.
    </Warning>
  </Step>

  <Step title="Create a Checkout Button Component">
    Create a component that opens the checkout overlay:

    ```typescript theme={null}
    // components/CheckoutButton.tsx
    "use client";

    import { Button } from "@/components/ui/button";
    import { DodoPayments } from "dodopayments-checkout";
    import { useEffect, useState } from "react";

    export function CheckoutButton() {
      const [isLoading, setIsLoading] = useState(false);

      useEffect(() => {
        // Initialize the SDK
        DodoPayments.Initialize({
          mode: "test",
          displayType: "overlay",
          onEvent: (event) => {
            switch (event.event_type) {
              case "checkout.opened":
                setIsLoading(false);
                break;
              case "checkout.error":
                setIsLoading(false);
                console.error("Checkout error:", event.data?.message);
                break;
            }
          },
        });
      }, []);

      const handleCheckout = async () => {
        try {
          setIsLoading(true);
          await DodoPayments.Checkout.open({
            checkoutUrl: "https://checkout.dodopayments.com/session/cks_123"
          });
        } catch (error) {
          console.error("Failed to open checkout:", error);
          setIsLoading(false);
        }
      };

      return (
        <Button 
          onClick={handleCheckout}
          disabled={isLoading}
        >
          {isLoading ? "Loading..." : "Checkout Now"}
        </Button>
      );
    }
    ```
  </Step>

  <Step title="Add Checkout to Your Page">
    Use the checkout button component in your application:

    ```typescript theme={null}
    // app/page.tsx
    import { CheckoutButton } from "@/components/CheckoutButton";

    export default function Home() {
      return (
        <main className="flex min-h-screen flex-col items-center justify-center p-24">
          <h1>Welcome to Our Store</h1>
          <CheckoutButton />
        </main>
      );
    }
    ```
  </Step>

  <Step title="Handle Success and Failure Pages">
    Create pages to handle checkout redirects:

    ```typescript theme={null}
    // app/success/page.tsx
    export default function SuccessPage() {
      return (
        <div className="flex min-h-screen flex-col items-center justify-center">
          <h1>Payment Successful!</h1>
          <p>Thank you for your purchase.</p>
        </div>
      );
    }

    // app/failure/page.tsx
    export default function FailurePage() {
      return (
        <div className="flex min-h-screen flex-col items-center justify-center">
          <h1>Payment Failed</h1>
          <p>Please try again or contact support.</p>
        </div>
      );
    }
    ```
  </Step>

  <Step title="Test Your Integration">
    1. Start your development server:

    ```bash theme={null}
    npm run dev
    ```

    2. Test the checkout flow:
       * Click the checkout button
       * Verify the overlay appears
       * Test the payment flow using test credentials
       * Confirm redirects work correctly

    <Check>
      You should see checkout events logged in your browser console.
    </Check>
  </Step>

  <Step title="Go Live">
    When you're ready for production:

    1. Change the mode to `'live'`:

    ```typescript theme={null}
    DodoPayments.Initialize({
      mode: "live",
      displayType: "overlay",
      onEvent: (event) => {
        console.log("Checkout event:", event);
      }
    });
    ```

    2. Update your checkout URLs to use live checkout sessions from your backend
    3. Test the complete flow in production
    4. Monitor events and errors
  </Step>
</Steps>

## API Reference

### Configuration

#### Initialize Options

```typescript theme={null}
interface InitializeOptions {
  mode: "test" | "live";
  displayType?: "overlay" | "inline";
  onEvent: (event: CheckoutEvent) => void;
}
```

| Option        | Type                    | Required | Description                                                                              |
| ------------- | ----------------------- | -------- | ---------------------------------------------------------------------------------------- |
| `mode`        | `"test" \| "live"`      | Yes      | Environment mode: `'test'` for development, `'live'` for production                      |
| `displayType` | `"overlay" \| "inline"` | No       | Display type: `'overlay'` for modal checkout (default), `'inline'` for embedded checkout |
| `onEvent`     | `function`              | Yes      | Callback function for handling checkout events                                           |

#### Checkout Options

```typescript theme={null}
interface CheckoutOptions {
  checkoutUrl: string;
  options?: {
    showTimer?: boolean;
    showSecurityBadge?: boolean;
    manualRedirect?: boolean;
  };
}
```

| Option                      | Type      | Required | Description                                                                                                                                                                                        |
| --------------------------- | --------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `checkoutUrl`               | `string`  | Yes      | Checkout session URL from the [create checkout session API](/api-reference/checkout-sessions/create)                                                                                               |
| `options.showTimer`         | `boolean` | No       | Show or hide the checkout timer. Defaults to `true`. When disabled, you will receive the `checkout.link_expired` event when the session expires.                                                   |
| `options.showSecurityBadge` | `boolean` | No       | Show or hide the security badge. Defaults to `true`.                                                                                                                                               |
| `options.manualRedirect`    | `boolean` | No       | When enabled, the checkout will not automatically redirect after completion. Instead, you will receive `checkout.status` and `checkout.redirect_requested` events to handle the redirect yourself. |

### Methods

#### Open Checkout

Opens the checkout overlay with the specified checkout session URL.

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123"
});
```

You can also pass additional options to customize the checkout behavior:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    showTimer: false,
    showSecurityBadge: false,
    manualRedirect: true,
  },
});
```

When using `manualRedirect`, handle the checkout completion in your `onEvent` callback:

```typescript theme={null}
DodoPayments.Initialize({
  mode: "test",
  displayType: "overlay",
  onEvent: (event) => {
    if (event.event_type === "checkout.status") {
      const status = event.data?.message?.status;
      // Handle status: "succeeded", "failed", or "processing"
    }
    if (event.event_type === "checkout.redirect_requested") {
      const redirectUrl = event.data?.message?.redirect_to;
      // Redirect the customer manually
      window.location.href = redirectUrl;
    }
    if (event.event_type === "checkout.link_expired") {
      // Handle expired checkout session
    }
  },
});
```

#### Close Checkout

Programmatically closes the checkout overlay.

```typescript theme={null}
DodoPayments.Checkout.close();
```

#### Check Status

Returns whether the checkout overlay is currently open.

```typescript theme={null}
const isOpen = DodoPayments.Checkout.isOpen();
// Returns: boolean
```

### Events

The SDK provides real-time events that you can listen to through the `onEvent` callback:

#### Checkout Status Event Data

When `manualRedirect` is enabled, you receive the `checkout.status` event with the following data:

```typescript theme={null}
interface CheckoutStatusEventData {
  message: {
    status?: "succeeded" | "failed" | "processing";
  };
}
```

#### Checkout Redirect Requested Event Data

When `manualRedirect` is enabled, you receive the `checkout.redirect_requested` event with the following data:

```typescript theme={null}
interface CheckoutRedirectRequestedEventData {
  message: {
    redirect_to?: string;
  };
}
```

```typescript theme={null}
DodoPayments.Initialize({
  onEvent: (event: CheckoutEvent) => {
    switch (event.event_type) {
      case "checkout.opened":
        // Checkout overlay has been opened
        break;
      case "checkout.form_ready":
        // Checkout form is ready for user input
        break;
      case "checkout.payment_page_opened":
        // Payment page has been displayed
        break;
      case "checkout.customer_details_submitted":
        // Customer and billing details submitted
        break;
      case "checkout.closed":
        // Checkout has been closed
        break;
      case "checkout.redirect":
        // Checkout will perform a redirect
        break;
      case "checkout.error":
        // An error occurred
        console.error("Error:", event.data?.message);
        break;
      case "checkout.link_expired":
        // Checkout session has expired (only when showTimer is false)
        break;
      case "checkout.status":
        // Checkout status update (only when manualRedirect is enabled)
        const status = event.data?.message?.status;
        break;
      case "checkout.redirect_requested":
        // Redirect requested (only when manualRedirect is enabled)
        const redirectUrl = event.data?.message?.redirect_to;
        break;
    }
  }
});
```

| Event Type                            | Description                                                                                                    |
| ------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| `checkout.opened`                     | Checkout overlay has been opened                                                                               |
| `checkout.form_ready`                 | Checkout form is ready to receive user input. Useful for hiding loading states.                                |
| `checkout.payment_page_opened`        | Payment page has been displayed                                                                                |
| `checkout.customer_details_submitted` | Customer and billing details have been submitted                                                               |
| `checkout.closed`                     | Checkout overlay has been closed                                                                               |
| `checkout.redirect`                   | Checkout will perform a redirect                                                                               |
| `checkout.error`                      | An error occurred during checkout                                                                              |
| `checkout.link_expired`               | Fired when the checkout session expires. Only received when `showTimer` is set to `false`.                     |
| `checkout.status`                     | Fired when `manualRedirect` is enabled. Contains the checkout status (`succeeded`, `failed`, or `processing`). |
| `checkout.redirect_requested`         | Fired when `manualRedirect` is enabled. Contains the URL to redirect the customer to.                          |

## Implementation Options

### Package Manager Installation

Install via npm, yarn, or pnpm as shown in the [Step-by-Step Integration Guide](#step-by-step-integration-guide).

### CDN Implementation

For quick integration without a build step, you can use our CDN:

```html theme={null}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dodo Payments Checkout</title>
    
    <!-- Load DodoPayments -->
    <script src="https://cdn.jsdelivr.net/npm/dodopayments-checkout@latest/dist/index.js"></script>
    <script>
        // Initialize the SDK
        DodoPaymentsCheckout.DodoPayments.Initialize({
            mode: "test", // Change to 'live' for production
            displayType: "overlay",
            onEvent: (event) => {
                console.log('Checkout event:', event);
            }
        });
    </script>
</head>
<body>
    <button onclick="openCheckout()">Checkout Now</button>

    <script>
        function openCheckout() {
            DodoPaymentsCheckout.DodoPayments.Checkout.open({
                checkoutUrl: "https://checkout.dodopayments.com/session/cks_123"
            });
        }
    </script>
</body>
</html>
```

### Theme Customization

You can customize the checkout appearance by passing a `themeConfig` object in the `options` parameter when opening checkout. The theme configuration supports both light and dark modes, allowing you to customize colors, borders, text, buttons, and border radius.

#### Basic Theme Configuration

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    themeConfig: {
      light: {
        bgPrimary: "#FFFFFF",
        textPrimary: "#344054",
        buttonPrimary: "#A6E500",
      },
      dark: {
        bgPrimary: "#0D0D0D",
        textPrimary: "#FFFFFF",
        buttonPrimary: "#A6E500",
      },
      radius: "8px",
    },
  },
});
```

#### Complete Theme Configuration

All available theme properties:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    themeConfig: {
      light: {
        // Background colors
        bgPrimary: "#FFFFFF",        // Primary background color
        bgSecondary: "#F9FAFB",      // Secondary background color (e.g., tabs)
        
        // Border colors
        borderPrimary: "#D0D5DD",     // Primary border color
        borderSecondary: "#6B7280",  // Secondary border color
        
        // Text colors
        textPrimary: "#344054",       // Primary text color
        textSecondary: "#6B7280",    // Secondary text color
        textPlaceholder: "#667085",  // Placeholder text color
        textError: "#D92D20",        // Error text color
        textSuccess: "#10B981",      // Success text color
        
        // Button colors
        buttonPrimary: "#A6E500",           // Primary button background
        buttonPrimaryHover: "#8CC500",      // Primary button hover state
        buttonTextPrimary: "#0D0D0D",       // Primary button text color
        buttonSecondary: "#F3F4F6",         // Secondary button background
        buttonSecondaryHover: "#E5E7EB",     // Secondary button hover state
        buttonTextSecondary: "#344054",     // Secondary button text color
      },
      dark: {
        // Background colors
        bgPrimary: "#0D0D0D",
        bgSecondary: "#1A1A1A",
        
        // Border colors
        borderPrimary: "#323232",
        borderSecondary: "#D1D5DB",
        
        // Text colors
        textPrimary: "#FFFFFF",
        textSecondary: "#909090",
        textPlaceholder: "#9CA3AF",
        textError: "#F97066",
        textSuccess: "#34D399",
        
        // Button colors
        buttonPrimary: "#A6E500",
        buttonPrimaryHover: "#8CC500",
        buttonTextPrimary: "#0D0D0D",
        buttonSecondary: "#2A2A2A",
        buttonSecondaryHover: "#3A3A3A",
        buttonTextSecondary: "#FFFFFF",
      },
      radius: "8px", // Border radius for inputs, buttons, and tabs
    },
  },
});
```

#### Light Mode Only

If you only want to customize the light theme:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    themeConfig: {
      light: {
        bgPrimary: "#FFFFFF",
        textPrimary: "#000000",
        buttonPrimary: "#0070F3",
      },
      radius: "12px",
    },
  },
});
```

#### Dark Mode Only

If you only want to customize the dark theme:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    themeConfig: {
      dark: {
        bgPrimary: "#000000",
        textPrimary: "#FFFFFF",
        buttonPrimary: "#0070F3",
      },
      radius: "12px",
    },
  },
});
```

#### Partial Theme Override

You can override only specific properties. The checkout will use default values for properties you don't specify:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    themeConfig: {
      light: {
        buttonPrimary: "#FF6B6B", // Only override primary button color
      },
      radius: "16px", // Override border radius
    },
  },
});
```

#### Theme Configuration with Other Options

You can combine theme configuration with other checkout options:

```typescript theme={null}
DodoPayments.Checkout.open({
  checkoutUrl: "https://checkout.dodopayments.com/session/cks_123",
  options: {
    showTimer: true,
    showSecurityBadge: true,
    manualRedirect: false,
    themeConfig: {
      light: {
        bgPrimary: "#FFFFFF",
        buttonPrimary: "#A6E500",
      },
      dark: {
        bgPrimary: "#0D0D0D",
        buttonPrimary: "#A6E500",
      },
      radius: "8px",
    },
  },
});
```

#### TypeScript Types

For TypeScript users, all theme configuration types are exported:

```typescript theme={null}
import { ThemeConfig, ThemeModeConfig } from "dodopayments-checkout";

const themeConfig: ThemeConfig = {
  light: {
    bgPrimary: "#FFFFFF",
    // ... other properties
  },
  dark: {
    bgPrimary: "#0D0D0D",
    // ... other properties
  },
  radius: "8px",
};
```

## Error Handling

The SDK provides detailed error information through the event system. Always implement proper error handling in your `onEvent` callback:

```typescript theme={null}
DodoPayments.Initialize({
  mode: "test",
  displayType: "overlay",
  onEvent: (event: CheckoutEvent) => {
    if (event.event_type === "checkout.error") {
      console.error("Checkout error:", event.data?.message);
      // Handle error appropriately
      // You may want to show a user-friendly error message
      // or retry the checkout process
    }
    if (event.event_type === "checkout.link_expired") {
      // Handle expired checkout session
      console.warn("Checkout session has expired");
    }
  }
});
```

<Warning>
  Always handle the `checkout.error` event to provide a good user experience when errors occur.
</Warning>

## Best Practices

1. **Initialize once**: Initialize the SDK once when your application loads, not on every checkout attempt
2. **Error handling**: Always implement proper error handling in your event callback
3. **Test mode**: Use `test` mode during development and switch to `live` only when ready for production
4. **Event handling**: Handle all relevant events for a complete user experience
5. **Valid URLs**: Always use valid checkout URLs from the create checkout session API
6. **TypeScript**: Use TypeScript for better type safety and developer experience
7. **Loading states**: Show loading states while the checkout is opening to improve UX
8. **Manual redirects**: Use `manualRedirect` when you need custom control over post-checkout navigation
9. **Timer management**: Disable the timer (`showTimer: false`) if you want to handle session expiration manually

## Troubleshooting

<AccordionGroup>
  <Accordion title="Checkout not opening">
    **Possible causes:**

    * SDK not initialized before calling `open()`
    * Invalid checkout URL
    * JavaScript errors in console
    * Network connectivity issues

    **Solutions:**

    * Verify SDK initialization happens before opening checkout
    * Check for console errors
    * Ensure checkout URL is valid and from the create checkout session API
    * Verify network connectivity
  </Accordion>

  <Accordion title="Events not firing">
    **Possible causes:**

    * Event handler not properly set up
    * JavaScript errors preventing event propagation
    * SDK not initialized correctly

    **Solutions:**

    * Confirm event handler is properly configured in `Initialize()`
    * Check browser console for JavaScript errors
    * Verify SDK initialization completed successfully
    * Test with a simple event handler first
  </Accordion>

  <Accordion title="Styling issues">
    **Possible causes:**

    * CSS conflicts with your application styles
    * Theme settings not applied correctly
    * Responsive design issues

    **Solutions:**

    * Check for CSS conflicts in browser DevTools
    * Verify theme settings are correct
    * Test on different screen sizes
    * Ensure no z-index conflicts with overlay
  </Accordion>
</AccordionGroup>

## Enabling Digital Wallets

For detailed information about setting up Google Pay and other digital wallets, see the <a href="/features/payment-methods/digital-wallets">Digital Wallets</a> page.

<Note>
  Apple Pay is not yet supported in overlay checkout. Support for Apple Pay is coming soon.
</Note>

## Browser Support

The Dodo Payments Checkout SDK supports the following browsers:

* Chrome (latest)
* Firefox (latest)
* Safari (latest)
* Edge (latest)
* IE11+

## Overlay vs Inline Checkout

Choose the right checkout type for your use case:

| Feature               | Overlay Checkout                  | Inline Checkout                              |
| --------------------- | --------------------------------- | -------------------------------------------- |
| Integration depth     | Modal on top of page              | Fully embedded in page                       |
| Layout control        | Limited                           | Full control                                 |
| Branding              | Separate from page                | Seamless                                     |
| Implementation effort | Lower                             | Higher                                       |
| Best for              | Quick integration, existing pages | Custom checkout pages, high-conversion flows |

<Tip>
  Use **overlay checkout** for faster integration with minimal changes to your existing pages. Use **inline checkout** when you want maximum control over the checkout experience and seamless branding.
</Tip>

## Related Resources

<CardGroup>
  <Card title="Inline Checkout" icon="credit-card" href="/developer-resources/inline-checkout">
    Embed checkout directly into your page for fully integrated experiences.
  </Card>

  <Card title="Checkout Sessions API" icon="code" href="/api-reference/checkout-sessions/create">
    Create checkout sessions to power your checkout experiences.
  </Card>

  <Card title="Webhooks" icon="webhook" href="/developer-resources/webhooks">
    Handle payment events server-side with webhooks.
  </Card>

  <Card title="Integration Guide" icon="book" href="/developer-resources/integration-guide">
    Complete guide to integrating Dodo Payments.
  </Card>
</CardGroup>

For more help, visit our [Discord community](https://discord.gg/bYqAp4ayYh) or contact our developer support team.


# Seat-Based Pricing with Add-ons and Payment Links
Source: https://docs.dodopayments.com/developer-resources/seat-based-pricing

Learn how to create add-ons for seat-based pricing and generate payment links with custom add-on quantities using Dodo Payments

In this tutorial, you'll learn how to implement seat-based pricing using Dodo Payments add-ons. We'll create a subscription product with add-ons for additional seats and show you how to generate payment links with custom add-on quantities.

<Note>
  This tutorial provides sample implementation code for a Node.js/Express application. You can modify this code for your specific framework (Next.js, React, Vue, etc.) and customize the user interface according to your application's needs.
</Note>

By the end of this tutorial, you'll know how to:

* Create subscription products with seat-based pricing
* Set up add-ons for additional seats
* Generate payment links with custom add-on quantities
* Handle checkout sessions with dynamic seat counts

## What We're Building

Let's create a seat-based pricing model:

* **Base Plan**: \$49/month for up to 5 team members
* **Seat Add-on**: \$2/month per additional seat
* **Payment Links**: Dynamic checkout with custom seat quantities

<Info>
  Before we start, make sure you have:

  * A Dodo Payments account
  * Basic familiarity with TypeScript/Node.js
</Info>

## Step 1: Create Your Seat Add-On

Now we need to create an add-on that represents additional seats. This add-on will be attached to our base subscription and allow customers to purchase additional seats.

<Frame>
  <img alt="Creating base subscription product" />
</Frame>

<Tip>
  **What we're building**: An add-on that costs \$2/month per seat and can be added to any base subscription.
</Tip>

<Steps>
  <Step title="Navigate to Add-Ons">
    1. In your Dodo Payments dashboard, stay in the **Products** section
    2. Click on the **Add-Ons** tab
    3. Click **Create Add-On**

    This will open the add-on creation form.
  </Step>

  <Step title="Enter add-on details">
    Fill in these values for our seat add-on:

    **Add-On Name**: `Additional Team Seat`

    **Description**: `Add extra team members to your workspace with full access to all features`

    **Price**: Enter → `2.00`

    **Currency**: Must match your base subscription currency

    **Tax Category**: Select appropriate category for your product.
  </Step>

  <Step title="Save your add-on">
    1. Review all your settings:
       * Name: Additional Team Seat
       * Price: \$2.00/month
    2. Click **Create Add-On**

    <Check>
      **Add-on created!** Your seat add-on is now available to attach to subscriptions.
    </Check>
  </Step>
</Steps>

## Step 2: Create Your Base Subscription Product

We'll start by creating a base subscription product that includes 5 team members. This will be the foundation of our seat-based pricing model.

<Frame>
  <img alt="Creating base subscription product" />
</Frame>

<Steps>
  <Step title="Navigate to Products">
    1. Log into your Dodo Payments dashboard
    2. Click on **Products** in the left sidebar
    3. Click the **Create Product** button
    4. Select **Subscription** as the product type

    You should see a form where we'll configure our base subscription.
  </Step>

  <Step title="Fill in the subscription details">
    Now we'll enter the specific details for our base plan:

    **Product Name**: `Motion`

    **Description**: `Where your team's documentation lives.`

    **Recurring Price**: Enter → `49.00`

    **Billing Cycle**: Select → `Monthly`

    **Currency**: Select your preferred currency (e.g., `USD`)
  </Step>
</Steps>

## Step 3: Connect Add-On to Subscription

Now we need to associate our seat add-on with the base subscription so customers can purchase additional seats during checkout.

<Steps>
  <Step title="Attach the seat add-on">
    <Frame>
      <img alt="Attaching add-on to subscription" />
    </Frame>

    1. Scroll down to the **Add-Ons** section
    2. Click **Add Add-Ons**
    3. From the dropdown, select your seat add-on
    4. Confirm that it appears in your subscription configuration
  </Step>

  <Step title="Save subscription changes">
    1. Review your complete subscription setup:
       * Base plan: \$49/month for 5 seats
       * Add-on: \$2/month per additional seat
       * Free trial: 14 days
    2. Click **Save Changes**

    <Check>
      **Seat-based pricing configured!** Customers can now purchase your base plan and add extra seats as needed.
    </Check>
  </Step>
</Steps>

## Step 4: Generate Payment Links with Custom Add-on Quantities

Now let's create an Express.js application that generates payment links with custom add-on quantities. This is where the real power of seat-based pricing comes in - you can dynamically create checkout sessions with any number of additional seats.

<Steps>
  <Step title="Set up your project">
    Create a new Node.js project and install the required dependencies:

    ```bash theme={null}
    mkdir seat-based-pricing
    cd seat-based-pricing
    npm init -y
    npm install dodopayments express dotenv
    npm install -D @types/node @types/express typescript ts-node
    ```

    Create a `tsconfig.json` file:

    ```json theme={null}
    {
      "compilerOptions": {
        "target": "ES2020",
        "module": "commonjs",
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
      }
    }
    ```
  </Step>

  <Step title="Create your environment file">
    Create a `.env` file with your Dodo Payments API key:

    ```bash theme={null}
    DODO_PAYMENTS_API_KEY=your_actual_dodo_api_key_here
    ```

    <Warning>
      Never commit your API key to version control. Add `.env` to your `.gitignore` file.
    </Warning>
  </Step>

  <Step title="Implement the checkout session creation">
    Create a `src/server.ts` file with the following code:

    <CodeGroup>
      ```typescript server.ts expandable theme={null}
      // Add this new endpoint for dynamic seat quantities
      import 'dotenv/config';
      import DodoPayments from 'dodopayments';
      import express, { Request, Response } from 'express';

      const app = express();

      // Initialize the Dodo Payments client
      const client = new DodoPayments({
        bearerToken: process.env.DODO_PAYMENTS_API_KEY,
        environment: 'test_mode'
      });

      async function createCheckoutSession(seatCount: number) {
        try {
          const session = await client.checkoutSessions.create({
            // Products to sell - use IDs from your Dodo Payments dashboard
            product_cart: [
              {
                product_id: 'pdt_7Rl9OWT2Mz4wwUTKz74iZ', // Replace with your actual product ID
                quantity: 1,
                addons: [
                  {
                    addon_id: 'adn_eKQbNakKrivDpaxmI8wKI', // Replace with your actual addon ID
                    quantity: seatCount
                  }
                ]
              }
            ],
            
            // Pre-fill customer information to reduce friction
            customer: {
              email: 'steve@example.com',
              name: 'Steve Irwin',
            },
            // Where to redirect after successful payment
            return_url: 'https://example.com/checkout/success',
          });

          // Redirect your customer to this URL to complete payment
          console.log('Checkout URL:', session.checkout_url);
          console.log('Session ID:', session.session_id);
          
          return session;
          
        } catch (error) {
          console.error('Failed to create checkout session:', error);
          throw error;
        }
      }

      // Example usage in an Express.js route
      app.post('/create-checkout/:seatCount', async (req: Request, res: Response) => {
        try {
          const seatCount = parseInt(req.params.seatCount);
          const session = await createCheckoutSession(seatCount);
          res.json({ checkout_url: session.checkout_url });
        } catch (error) {
          res.status(500).json({ error: 'Failed to create checkout session' });
        }
      });

      // Add this line after your other middleware
      app.use(express.static('public'));

      // Add this route to serve the demo page
      app.get('/', (req, res) => {
        res.sendFile(__dirname + '/../public/index.html');
      });

      app.listen(3000, () => {
        console.log('Server is running on port 3000');
      });
      ```
    </CodeGroup>
  </Step>

  <Step title="Add a simple web interface">
    Create a `public/index.html` file for easy testing:

    <CodeGroup>
      ```html index.html expandable theme={null}
      <!DOCTYPE html>
      <html>
      <head>
          <title>Seat-Based Pricing Demo</title>
          <style>
              body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; }
              .form-group { margin: 20px 0; }
              label { display: block; margin-bottom: 5px; font-weight: bold; }
              input { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; }
              button { background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; }
              button:hover { background: #0056b3; }
              .result { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; }
          </style>
      </head>
      <body>
          <h1>Seat-Based Pricing Demo</h1>
          <p>Generate checkout links with custom seat quantities:</p>
          
          <div class="form-group">
              <label for="seatCount">Number of Additional Seats:</label>
              <input type="number" id="seatCount" value="3" min="0" max="50">
          </div>
          
          <button onclick="createCheckout()">Generate Checkout Link</button>
          
          <div id="result" class="result" style="display: none;">
              <h3>Checkout Link Generated!</h3>
              <p><strong>Seat Count:</strong> <span id="seatCountDisplay"></span></p>
              <p><strong>Total Cost:</strong> $<span id="totalCost"></span>/month</p>
              <p><strong>Checkout URL:</strong></p>
              <a id="checkoutUrl" href="#" target="_blank">Click here to checkout</a>
          </div>

          <script>
              async function createCheckout() {
                  const seatCount = document.getElementById('seatCount').value;
                  
                  try {
                      const response = await fetch(`/create-checkout/${seatCount}`, {
                          method: 'POST'
                      });
                      
                      const data = await response.json();
                      
                      if (response.ok) {
                          document.getElementById('seatCountDisplay').textContent = seatCount;
                          document.getElementById('totalCost').textContent = data.total_cost;
                          document.getElementById('checkoutUrl').href = data.checkout_url;
                          document.getElementById('result').style.display = 'block';
                      } else {
                          alert('Error: ' + data.error);
                      }
                  } catch (error) {
                      alert('Error creating checkout session');
                  }
              }
          </script>
      </body>
      </html>
      ```
    </CodeGroup>

    <Check>
      **Web interface created!** You now have a simple UI to test different seat quantities.
    </Check>
  </Step>

  <Step title="Serve static files">
    Add this to your `src/server.ts` to serve the HTML file:

    ```typescript theme={null}
    // Add this line after your other middleware
    app.use(express.static('public'));

    // Add this route to serve the demo page
    app.get('/', (req, res) => {
      res.sendFile(__dirname + '/../public/index.html');
    });
    ```

    <Check>
      **Static files configured!** Visit `http://localhost:3000` to see your demo interface.
    </Check>
  </Step>
</Steps>

## Step 5: Test Your Implementation

Let's test our seat-based pricing implementation to make sure everything works correctly.

<Steps>
  <Step title="Start your server">
    1. Make sure you have your `.env` file with the correct API key
    2. Update the product and add-on IDs in your code with the actual values from your Dodo Payments dashboard
    3. Start your server:

    ```bash theme={null}
    npm run dev
    ```

    <Check>
      Your server should start successfully and show "Server running on [http://localhost:3000](http://localhost:3000)"
    </Check>
  </Step>

  <Step title="Test the web interface">
    <Frame>
      <img alt="Creating base subscription product" />
    </Frame>

    1. Open your browser and go to `http://localhost:3000`
    2. You should see the seat-based pricing demo interface
    3. Try different seat quantities (0, 3, 10, etc.)
    4. Click "Generate Checkout Link" for each quantity
    5. Verify that the checkout URLs are generated correctly
  </Step>

  <Step title="Test a checkout session">
    1. Generate a checkout link with 3 additional seats
    2. Click the checkout URL to open the Dodo Payments checkout
    3. Verify that the checkout shows:
       * Base plan: \$49/month
       * Additional seats: 3 × 2 dollars = \$6/month
    4. Complete the test purchase

    <Check>
      The checkout should display the correct pricing breakdown and allow you to complete the purchase.
    </Check>
  </Step>

  <Step title="Listen for webhooks and update your DB">
    To keep your database in sync with subscription and seat changes, you need to listen for webhook events from Dodo Payments. Webhooks notify your backend when a customer completes checkout, updates their subscription, or changes seat counts.

    Follow the official Dodo Payments webhooks guide for step-by-step instructions on setting up webhook endpoints and handling events:

    <Card title="Dodo Payments Webhooks Documentation" icon="bell" href="/developer-resources/webhooks">
      Learn how to securely receive and process webhook events for subscription and seat management.
    </Card>
  </Step>
</Steps>

## Troubleshooting

Common issues and their solutions:

<AccordionGroup>
  <Accordion title="Checkout creation failing">
    **Possible causes:**

    * Invalid product ID or add-on ID
    * API key doesn't have sufficient permissions
    * Add-on not properly associated with subscription
    * Network connectivity issues

    **Solutions:**

    1. Verify product and add-on IDs exist in your Dodo Payments dashboard
    2. Check that add-on is properly attached to the subscription
    3. Ensure API key has checkout session creation permissions
    4. Test API connectivity with a simple GET request
  </Accordion>
</AccordionGroup>

## Congratulations! You've Implemented Seat-Based Pricing

You've successfully created a seat-based pricing system with Dodo Payments! Here's what you accomplished:

<CardGroup>
  <Card title="Base Subscription">
    Created a subscription product with 5 included seats at \$49/month
  </Card>

  <Card title="Seat Add-ons">
    Configured add-ons for additional seats at \$2/month per seat
  </Card>

  <Card title="Checkout">
    Built an API that generates checkout sessions with custom seat quantities
  </Card>

  <Card title="Web Interface">
    Created a simple web interface for testing different seat quantities
  </Card>
</CardGroup>

<Info>
  This example demonstrates only a minimal implementation of seat-based pricing. For production use, you should add robust error handling, authentication, data validation, security measures, and adapt the logic to fit your application's requirements.
</Info>


# Sentra
Source: https://docs.dodopayments.com/developer-resources/sentra

Install the Sentra extension for VS Code, Cursor, or Windsurf to integrate billing and payments into your app using AI-powered assistance.

<Frame>
  <iframe title="Sentra Extension Demo" />
</Frame>

## Overview

Sentra adds intelligence and execution on top of Dodo Payments' core stacks. It's an AI agent that integrates, analyzes, and acts on billing and payments. Sentra connects SDKs, APIs, and adapters across your stack (Auth, DB, CRM, etc.), surfaces revenue insights like growth drivers, and executes customer actions such as refunds, upgrades, and credits.

<Info>
  Sentra is currently in Beta. Features, APIs, and integrations may change rapidly. We welcome feedback and bug reports as we iterate!
</Info>

## Install

Sentra is available as an extension for VS Code, Cursor, and Windsurf. Choose your IDE below:

<Tabs>
  <Tab title="VS Code">
    <Steps>
      <Step title="Open Extensions Marketplace">
        1. Open VS Code.
        2. Click the Extensions icon in the sidebar (or press `Cmd+Shift+X` on macOS / `Ctrl+Shift+X` on Windows/Linux).
        3. Search for "Sentra by Dodo Payments" in the marketplace.

        <Frame>
          <img alt="VS Code Extensions Marketplace showing Sentra extension" />
        </Frame>
      </Step>

      <Step title="Install the Extension">
        1. Click on "Sentra by Dodo Payments" from the search results.
        2. Click the **Install** button.
        3. Wait for the installation to complete.
      </Step>

      <Step title="Restart VS Code">
        After installation, restart VS Code to activate the extension.

        <Tip>
          If the extension doesn't appear after installation, restarting the editor will resolve the issue in most cases.
        </Tip>
      </Step>
    </Steps>
  </Tab>

  <Tab title="Cursor">
    <Steps>
      <Step title="Open Extensions Marketplace">
        1. Open Cursor.
        2. Click the Extensions icon in the sidebar (or press `Cmd+Shift+X` on macOS / `Ctrl+Shift+X` on Windows/Linux).
        3. Search for "Sentra by Dodo Payments" in the marketplace.
      </Step>

      <Step title="Install the Extension">
        1. Click on "Sentra by Dodo Payments" from the search results.
        2. Click the **Install** button.
        3. Wait for the installation to complete.
      </Step>

      <Step title="Restart Cursor">
        After installation, restart Cursor to activate the extension.

        <Tip>
          If the extension doesn't appear after installation, restarting the editor will resolve the issue in most cases.
        </Tip>
      </Step>
    </Steps>
  </Tab>

  <Tab title="Windsurf">
    <Steps>
      <Step title="Open Extensions Marketplace">
        1. Open Windsurf.
        2. Click the Extensions icon in the sidebar (or press `Cmd+Shift+X` on macOS / `Ctrl+Shift+X` on Windows/Linux).
        3. Search for "Sentra by Dodo Payments" in the marketplace.
      </Step>

      <Step title="Install the Extension">
        1. Click on "Sentra by Dodo Payments" from the search results.
        2. Click the **Install** button.
        3. Wait for the installation to complete.
      </Step>

      <Step title="Restart Windsurf">
        After installation, restart Windsurf to activate the extension.

        <Tip>
          If the extension doesn't appear after installation, restarting the editor will resolve the issue in most cases.
        </Tip>
      </Step>
    </Steps>
  </Tab>
</Tabs>

## Setup

Once installed, you need to configure Sentra with your Dodo Payments API key and environment settings.

<Steps>
  <Step title="Get Your API Key">
    1. Log in to your [Dodo Payments dashboard](https://dashboard.dodopayments.com).
    2. Navigate to **Settings** › **API Keys**.
    3. Copy your API key.
  </Step>

  <Step title="Configure Sentra">
    1. Open your IDE (VS Code, Cursor, or Windsurf).
    2. Open the Command Palette (`Cmd+Shift+P` on macOS / `Ctrl+Shift+P` on Windows/Linux).
    3. Type "Sentra: Configure" and select it.
    4. Enter your Dodo Payments API key when prompted.

    <Frame>
      <img alt="Sentra configuration screen with API key input and environment selection" />
    </Frame>
  </Step>

  <Step title="Select Environment Mode">
    Choose your environment mode:

    * **Test Mode**: For development and testing
    * **Live Mode**: For production use

    <Warning>
      Start with Test mode to validate your setup before switching to Live mode for production data.
    </Warning>
  </Step>

  <Step title="Set Model Reasoning Effort">
    Select your preferred model reasoning effort level:

    * **Low**: Faster responses, suitable for simple tasks
    * **Medium**: Balanced performance (recommended)
    * **High**: More thorough analysis, suitable for complex integrations
  </Step>

  <Step title="Complete Setup">
    Click **Let's go!** to complete the setup and start using Sentra.

    <Check>
      Your API keys are stored securely in your IDE's Secret Storage and never exposed in your code.
    </Check>
  </Step>
</Steps>

## How It Works

Sentra follows a simple four-step process from prompt to production:

<Steps>
  <Step title="Prompt">
    Type what you want to build. For example: "Add usage-based billing with a free trial for my Pro plan."

    <Frame>
      <img alt="Sentra interface showing prompt input with example task" />
    </Frame>
  </Step>

  <Step title="Plan">
    Sentra generates the changes (SDK hooks, objects, config) and presents a plan for your review.
  </Step>

  <Step title="Approve">
    Review the generated plan and confirm the changes you want Sentra to implement.
  </Step>

  <Step title="Execute">
    Sentra applies the changes, tests them, and confirms success.
  </Step>
</Steps>

## Using Sentra

### Modes

Sentra offers three interaction modes accessible from the interface:

* **Ask**: Ask questions about Dodo Payments, billing models, API usage, and best practices
* **Build**: Integrate billing and UI into your application with guided assistance
* **Plan**: Design scalable billing architectures with architectural guidance

### Example Tasks

Here are some common tasks you can accomplish with Sentra:

* **Integrate Pricing Page**: Set up a complete pricing page with product listings and checkout
* **Implement Webhook**: Configure webhook handlers for payment events
* **Add Subscription Flow**: Create subscription management with upgrade/downgrade capabilities
* **Set Up Usage-Based Billing**: Configure meters and event ingestion for usage tracking
* **Create Customer Portal**: Build a customer self-service portal for billing management

### Auto-Approval Settings

You can configure auto-approval settings to streamline your workflow:

* **None**: Review and approve all changes manually (recommended for production)
* **Low Risk**: Auto-approve simple, low-risk changes
* **All**: Auto-approve all changes (use with caution)

## Supported Billing Models

Sentra supports all Dodo Payments billing models:

* **One-time Payments**: Single purchase transactions
* **Subscriptions**: Recurring billing with multiple intervals
* **Usage-Based Billing**: Metered billing based on consumption
* **Outcome-Based Billing**: Pay-per-result pricing models

## Who Is It For

Sentra bridges engineering and business, so every team can ship monetization without friction:

* **Developers**: Ship monetization faster inside your IDE
* **Founders & PMs**: Prototype billing models without deep infra work
* **RevOps & Finance**: Use guardrailed actions without needing engineers
* **Support & Success**: Solve billing cases safely, with approvals where needed

## Troubleshooting

<AccordionGroup>
  <Accordion title="Extension not appearing after installation">
    If Sentra doesn't appear in your IDE after installation, try the following:

    1. **Restart your editor**: Close and reopen VS Code, Cursor, or Windsurf completely
    2. **Check installation**: Verify the extension is installed by going to Extensions and searching for "Sentra"
    3. **Reload window**: Use the Command Palette (`Cmd+Shift+P` / `Ctrl+Shift+P`) and run "Developer: Reload Window"

    <Check>
      Restarting the editor resolves the issue in most cases.
    </Check>
  </Accordion>

  <Accordion title="Invalid API key or authentication errors">
    * Verify your API key is correct and active in the Dodo Payments dashboard
    * Ensure you're using the correct environment mode (Test vs Live) that matches your API key
    * Check that your API key has the necessary permissions
    * Try regenerating your API key if the issue persists
  </Accordion>

  <Accordion title="Configuration not saving">
    * Ensure you've completed all required fields in the configuration screen
    * Check that your IDE has permission to access Secret Storage
    * Try reconfiguring Sentra through the Command Palette
  </Accordion>

  <Accordion title="Plan generation fails">
    * Verify your API key is valid and has access to the required resources
    * Check your internet connection
    * Ensure you're using a supported billing model
    * Try rephrasing your prompt with more specific details
  </Accordion>

  <Accordion title="Execution errors">
    * Review the generated plan carefully before approval
    * Check that your project structure matches Sentra's expectations
    * Verify all dependencies are installed
    * Check the IDE's output panel for detailed error messages
  </Accordion>
</AccordionGroup>

<Warning>
  If you continue to experience issues after restarting your editor, contact support with details about your IDE version and the specific error messages you're seeing.
</Warning>

## Additional Resources

<CardGroup>
  <Card title="Dodo Payments Docs" icon="book" href="/introduction">
    Learn more about Dodo Payments features and capabilities.
  </Card>

  <Card title="API Reference" icon="code" href="/api-reference/introduction">
    Explore the complete Dodo Payments API reference.
  </Card>

  <Card title="Webhook Setup" icon="webhook" href="/developer-resources/webhooks">
    Understand how to configure webhooks for payment events.
  </Card>

  <Card title="Get Beta Access" icon="rocket" href="https://dodopayments.com/sentra">
    Visit the Sentra website to learn more and get beta access.
  </Card>
</CardGroup>


# Subscription Integration Guide
Source: https://docs.dodopayments.com/developer-resources/subscription-integration-guide

This guide will help you integrate the Dodo Payments Subscription Product into your website.

## Prerequisites

To integrate the Dodo Payments API, you'll need:

* A Dodo Payments merchant account
* API credentials (API key and webhook secret key) from the dashboard

For a more detailed guide on the prerequisites, check this [section](/developer-resources/integration-guide#dashboard-setup).

## API Integration

### Checkout Sessions

Use Checkout Sessions to sell subscription products with a secure, hosted checkout. Pass your subscription product in `product_cart` and redirect customers to the returned `checkout_url`.

<Tip>
  **Mixed Checkout**: You can combine subscription products with one-time products in the same checkout session. This enables use cases like setup fees with subscriptions, hardware bundles with SaaS, and more. See the [Checkout Sessions guide](/developer-resources/checkout-session) for examples.
</Tip>

<Tabs>
  <Tab title="Node.js SDK">
    ```javascript theme={null}
    import DodoPayments from 'dodopayments';

    const client = new DodoPayments({
      bearerToken: process.env.DODO_PAYMENTS_API_KEY,
      environment: 'test_mode', // defaults to 'live_mode'
    });

    async function main() {
      const session = await client.checkoutSessions.create({
        product_cart: [
          { product_id: 'prod_subscription_monthly', quantity: 1 }
        ],
        // Optional: configure trials for subscription products
        subscription_data: { trial_period_days: 14 },
        customer: {
          email: 'subscriber@example.com',
          name: 'Jane Doe',
        },
        return_url: 'https://example.com/success',
      });

      console.log(session.checkout_url);
    }

    main();
    ```
  </Tab>

  <Tab title="Python SDK">
    ```python theme={null}
    import os
    from dodopayments import DodoPayments

    client = DodoPayments(
        bearer_token=os.environ.get("DODO_PAYMENTS_API_KEY"),
        environment="test_mode",  # defaults to "live_mode"
    )

    session = client.checkout_sessions.create(
        product_cart=[
            {"product_id": "prod_subscription_monthly", "quantity": 1}
        ],
        subscription_data={"trial_period_days": 14},  # optional
        customer={
            "email": "subscriber@example.com",
            "name": "Jane Doe",
        },
        return_url="https://example.com/success",
    )

    print(session.checkout_url)
    ```
  </Tab>

  <Tab title="REST API">
    ```javascript theme={null}
    const response = await fetch('https://test.dodopayments.com/checkouts', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.DODO_PAYMENTS_API_KEY}`
      },
      body: JSON.stringify({
        product_cart: [
          { product_id: 'prod_subscription_monthly', quantity: 1 }
        ],
        subscription_data: { trial_period_days: 14 }, // optional
        customer: {
          email: 'subscriber@example.com',
          name: 'Jane Doe'
        },
        return_url: 'https://example.com/success'
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const session = await response.json();
    console.log(session.checkout_url);
    ```
  </Tab>
</Tabs>

### API Response

The following is an example of the response:

```json theme={null}
{
  "session_id": "cks_Gi6KGJ2zFJo9rq9Ukifwa",
  "checkout_url": "https://test.checkout.dodopayments.com/session/cks_Gi6KGJ2zFJo9rq9Ukifwa"
}
```

Redirect the customer to `checkout_url`.

### Webhooks

When integrating subscriptions, you'll receive webhooks to track the subscription lifecycle. These webhooks help you manage subscription states and payment scenarios effectively.

To set up your webhook endpoint, please follow our [Detailed Integration Guide](/developer-resources/integration-guide#implementing-webhooks).

#### Subscription Event Types

The following webhook events track subscription status changes:

1. **`subscription.active`** - Subscription is successfully activated.
2. **`subscription.updated`** - Subscription object was updated (fires on any field change).
3. **`subscription.on_hold`** - Subscription is put on hold due to failed renewal.
4. **`subscription.failed`** - Subscription creation failed during mandate creation.
5. **`subscription.renewed`** - Subscription is renewed for the next billing period.

For reliable subscription lifecycle management, we recommend tracking these subscription events.

<Tip>
  Use `subscription.updated` to get real-time notifications about any subscription changes, keeping your application state in sync without polling the API.
</Tip>

#### Payment Scenarios

**Successful Payment Flow**

When a payment succeeds, you'll receive the following webhooks:

1. `subscription.active` - Indicates subscription activation
2. `payment.succeeded` - Confirms the initial payment:
   * For immediate billing (0 trial days): Expect within 2-10 minutes
   * For trial days: whenever that ends
3. `subscription.renewed` - Indicates payment deduction and renewal for next cycle. (Basically, whenever payment gets deducted for subscription products, you will get `subscription.renewed` webhook along with `payment.succeeded`)

**Payment Failure Scenarios**

1. Subscription Failure

* `subscription.failed` - Subscription creation failed due to failure to create a mandate.
* `payment.failed` - Indicates failed payment.

2. Subscription On Hold

* `subscription.on_hold` - Subscription is put on hold due to failed renewal payment or failed plan change charge.
* When a subscription goes on hold, it will not renew automatically until the payment method is updated.

<Info>**Best Practice**: To simplify implementation, we recommend primarily tracking subscription events for managing the subscription lifecycle.</Info>

### Handling Subscription On Hold

When a subscription enters `on_hold` state, you need to update the payment method to reactivate it. This section explains when subscriptions go on hold and how to handle them.

#### When Subscriptions Go On Hold

A subscription is placed on hold when:

* **Renewal payment fails**: The automatic renewal charge fails due to insufficient funds, expired card, or bank decline
* **Plan change charge fails**: An immediate charge during plan upgrade/downgrade fails
* **Payment method authorization fails**: The payment method cannot be authorized for recurring charges

<Warning>
  Subscriptions in `on_hold` state will not renew automatically. You must update the payment method to reactivate the subscription.
</Warning>

#### Reactivating Subscriptions from On Hold

To reactivate a subscription from `on_hold` state, use the Update Payment Method API. This automatically:

1. Creates a charge for remaining dues
2. Generates an invoice for the charge
3. Processes the payment using the new payment method
4. Reactivates the subscription to `active` state upon successful payment

<Steps>
  <Step title="Handle subscription.on_hold webhook">
    When you receive a `subscription.on_hold` webhook, update your application state and notify the customer:

    ```javascript theme={null}
    // Webhook handler
    app.post('/webhooks/dodo', async (req, res) => {
      const event = req.body;
      
      if (event.type === 'subscription.on_hold') {
        const subscription = event.data;
        
        // Update subscription status in your database
        await updateSubscriptionStatus(subscription.subscription_id, 'on_hold');
        
        // Notify customer to update payment method
        await sendEmailToCustomer(subscription.customer_id, {
          subject: 'Payment Required - Subscription On Hold',
          message: 'Your subscription is on hold. Please update your payment method to continue service.'
        });
      }
      
      res.json({ received: true });
    });
    ```
  </Step>

  <Step title="Update payment method">
    When the customer is ready to update their payment method, call the Update Payment Method API:

    <CodeGroup>
      ```javascript Node.js theme={null}
      // Update with new payment method
      const response = await client.subscriptions.updatePaymentMethod(subscriptionId, {
        type: 'new',
        return_url: 'https://example.com/return'
      });

      // For on_hold subscriptions, a charge is automatically created
      if (response.payment_id) {
        console.log('Charge created for remaining dues:', response.payment_id);
        // Redirect customer to response.payment_link to complete payment
      }
      ```

      ```python Python theme={null}
      # Update with new payment method
      response = client.subscriptions.update_payment_method(
          subscription_id=subscription_id,
          type="new",
          return_url="https://example.com/return"
      )

      # For on_hold subscriptions, a charge is automatically created
      if response.payment_id:
          print("Charge created for remaining dues:", response.payment_id)
          # Redirect customer to response.payment_link to complete payment
      ```
    </CodeGroup>

    <Info>
      You can also use an existing payment method ID if the customer has saved payment methods:

      ```javascript theme={null}
      await client.subscriptions.updatePaymentMethod(subscriptionId, {
        type: 'existing',
        payment_method_id: 'pm_abc123'
      });
      ```
    </Info>
  </Step>

  <Step title="Monitor webhook events">
    After updating the payment method, monitor for these webhook events:

    1. **`payment.succeeded`** - The charge for remaining dues was successful
    2. **`subscription.active`** - The subscription has been reactivated

    ```javascript theme={null}
    if (event.type === 'payment.succeeded') {
      const payment = event.data;
      
      // Check if this payment is for an on_hold subscription
      if (payment.subscription_id) {
        // Wait for subscription.active webhook to confirm reactivation
      }
    }

    if (event.type === 'subscription.active') {
      const subscription = event.data;
      
      // Update subscription status in your database
      await updateSubscriptionStatus(subscription.subscription_id, 'active');
      
      // Restore customer access
      await restoreCustomerAccess(subscription.customer_id);
      
      // Notify customer of successful reactivation
      await sendEmailToCustomer(subscription.customer_id, {
        subject: 'Subscription Reactivated',
        message: 'Your subscription has been reactivated successfully.'
      });
    }
    ```
  </Step>
</Steps>

### Sample Subscription event payload

***

| Property      | Type   | Required | Description                                                                                  |
| ------------- | ------ | -------- | -------------------------------------------------------------------------------------------- |
| `business_id` | string | Yes      | The unique identifier for the business                                                       |
| `timestamp`   | string | Yes      | The timestamp of when the event occurred (not necessarily the same as when it was delivered) |
| `type`        | string | Yes      | The type of event. See [Event Types](#event-types)                                           |
| `data`        | object | Yes      | The main data payload. See [Data Object](#data-object)                                       |

## Changing Subscription Plans

You can upgrade or downgrade a subscription plan using the change plan API endpoint. This allows you to modify the subscription's product, quantity, and handle proration.

<Card title="Change Plan API Reference" icon="arrows-rotate" href="/api-reference/subscriptions/change-plan">
  For detailed information about changing subscription plans, please refer to our Change Plan API documentation.
</Card>

### Proration Options

When changing subscription plans, you have two options for handling the immediate charge:

#### 1. `prorated_immediately`

* Calculates the prorated amount based on the remaining time in the current billing cycle
* Charges the customer only for the difference between the old and new plan
* During a trial period, this will immediately switch the user to the new plan, charging the customer right away

#### 2. `full_immediately`

* Charges the customer the full subscription amount for the new plan
* Ignores any remaining time or credits from the previous plan
* Useful when you want to reset the billing cycle or charge the full amount regardless of proration

#### 3. `difference_immediately`

* When upgrading, the customer is immediately charged the difference between the two plan amounts.
* For example, if the current plan is 30 Dollars and the customer upgrades to an 80 Dollars, they are charged \$50 instantly.
* When downgrading, the unused amount from the current plan is added as internal credit and automatically applied to future subscription renewals.
* For example, if the current plan is 50 Dollars and the customer switches to a 20 Dollars plan, the remaining \$30 is credited and used toward the next billing cycle.

### Behavior

* When you invoke this API, Dodo Payments immediately initiates a charge based on your selected proration option
* If the plan change is a downgrade and you use `prorated_immediately`, credits will be automatically calculated and added to the subscription's credit balance. These credits are specific to that subscription and will only be used to offset future recurring payments of the same subscription
* The `full_immediately` option bypasses credit calculations and charges the complete new plan amount

<Tip>
  **Choose your proration option carefully**: Use `prorated_immediately` for fair billing that accounts for unused time, or `full_immediately` when you want to charge the complete new plan amount regardless of the current billing cycle.
</Tip>

### Charge Processing

* The immediate charge initiated upon plan change usually completes processing in less than 2 minutes
* If this immediate charge fails for any reason, the subscription is automatically placed on hold until the issue is resolved

## On-Demand Subscriptions

<Info>
  On-demand subscriptions let you charge customers flexibly, not just on a fixed schedule. This feature is available for all accounts.
</Info>

**To create an on-demand subscription:**

To create an on-demand subscription, use the [POST /subscriptions](/api-reference/subscriptions/post-subscriptions) API endpoint and include the `on_demand` field in your request body. This allows you to authorize a payment method without an immediate charge, or set a custom initial price.

**To charge an on-demand subscription:**

For subsequent charges, use the [POST /subscriptions/charge](/api-reference/subscriptions/create-charge) endpoint and specify the amount to charge the customer for that transaction.

<Note>
  For a complete, step-by-step guide—including request/response examples, safe retry policies, and webhook handling—see the <a href="/developer-resources/ondemand-subscriptions">On-Demand Subscriptions Guide</a>.
</Note>


# Subscription Upgrade & Downgrade Guide
Source: https://docs.dodopayments.com/developer-resources/subscription-upgrade-downgrade

Learn how to change a customer's subscription plan, handle proration, and process webhooks reliably.

<CardGroup>
  <Card title="Change Plan API Reference" icon="code" href="/api-reference/subscriptions/change-plan">
    Access the complete API documentation for changing subscription plans and test plan change requests interactively.
  </Card>

  <Card title="Preview Plan Change API" icon="eye" href="/api-reference/subscriptions/preview-change-plan">
    Preview the exact charge amount before committing to a plan change.
  </Card>

  <Card title="Subscription Integration Guide" icon="book" href="/developer-resources/subscription-integration-guide">
    Learn how to create and manage subscriptions from scratch with our comprehensive integration guide.
  </Card>
</CardGroup>

## What is a subscription upgrade or downgrade?

Changing plans lets you move a customer between subscription tiers or quantities. Use it to:

* Align pricing with usage or features
* Move from monthly to annual (or vice versa)
* Adjust quantity for seat-based products

<Info>
  Plan changes can trigger an immediate charge depending on the proration mode you choose.
</Info>

## When to use plan changes

* Upgrade when a customer needs more features, usage, or seats
* Downgrade when usage decreases
* Migrate users to a new product or price without cancelling their subscription

## Prerequisites

Before implementing subscription plan changes, ensure you have:

* A Dodo Payments merchant account with active subscription products
* API credentials (API key and webhook secret key) from the dashboard
* An existing active subscription to modify
* Webhook endpoint configured to handle subscription events

<Info>
  For detailed setup instructions, see our [Integration Guide](/developer-resources/integration-guide#dashboard-setup).
</Info>

## Step-by-Step Implementation Guide

Follow this comprehensive guide to implement subscription plan changes in your application:

<Steps>
  <Step title="Understand Plan Change Requirements">
    Before implementing, determine:

    * Which subscription products can be changed to which others
    * What proration mode fits your business model
    * How to handle failed plan changes gracefully
    * Which webhook events to track for state management

    <Tip>
      Test plan changes thoroughly in test mode before implementing in production.
    </Tip>
  </Step>

  <Step title="Choose Your Proration Strategy">
    Select the billing approach that aligns with your business needs:

    <Tabs>
      <Tab title="prorated_immediately">
        Best for: SaaS applications wanting to charge fairly for unused time

        * Calculates exact prorated amount based on remaining cycle time
        * Charges a prorated amount based on unused time remaining in the cycle
        * Provides transparent billing to customers
      </Tab>

      <Tab title="difference_immediately">
        Best for: Clear upgrade/downgrade scenarios

        * Upgrade: Charge immediate difference (e.g., $30→$80 = charge \$50)
        * Downgrade: Credit remaining value for future renewals
        * Simplifies billing logic and customer communication
      </Tab>

      <Tab title="full_immediately">
        Best for: When you want to reset the billing cycle

        * Charges full amount of new plan immediately
        * Ignores remaining time from old plan
        * Useful for annual to monthly transitions
      </Tab>
    </Tabs>
  </Step>

  <Step title="Implement the Change Plan API">
    Use the Change Plan API to modify subscription details:

    <ParamField type="string">
      The ID of the active subscription to modify.
    </ParamField>

    <ParamField type="string">
      The new product ID to change the subscription to.
    </ParamField>

    <ParamField type="integer">
      Number of units for the new plan (for seat-based products).
    </ParamField>

    <ParamField type="string">
      How to handle immediate billing: `prorated_immediately`, `full_immediately`, or `difference_immediately`.
    </ParamField>

    <ParamField type="array">
      Optional addons for the new plan. Leaving this empty removes any existing addons.
    </ParamField>
  </Step>

  <Step title="Handle Webhook Events">
    Set up webhook handling to track plan change outcomes:

    * `subscription.active`: Plan change successful, subscription updated
    * `subscription.plan_changed`: Subscription plan changed (upgrade/downgrade/addon update)
    * `subscription.on_hold`: Plan change charge failed, subscription paused
    * `payment.succeeded`: Immediate charge for plan change succeeded
    * `payment.failed`: Immediate charge failed

    <Warning>
      Always verify webhook signatures and implement idempotent event processing.
    </Warning>
  </Step>

  <Step title="Update Your Application State">
    Based on webhook events, update your application:

    * Grant/revoke features based on new plan
    * Update customer dashboard with new plan details
    * Send confirmation emails about plan changes
    * Log billing changes for audit purposes
  </Step>

  <Step title="Test and Monitor">
    Thoroughly test your implementation:

    * Test all proration modes with different scenarios
    * Verify webhook handling works correctly
    * Monitor plan change success rates
    * Set up alerts for failed plan changes

    <Check>
      Your subscription plan change implementation is now ready for production use.
    </Check>
  </Step>
</Steps>

## Preview Plan Changes

Before committing to a plan change, use the Preview API to show customers exactly what they'll be charged:

<Tabs>
  <Tab title="Node.js SDK">
    ```javascript theme={null}
    const preview = await client.subscriptions.previewChangePlan('sub_123', {
      product_id: 'prod_pro',
      quantity: 1,
      proration_billing_mode: 'prorated_immediately'
    });

    // Show customer the charge before confirming
    console.log('Immediate charge:', preview.immediate_charge.summary);
    console.log('New plan details:', preview.new_plan);
    ```
  </Tab>

  <Tab title="Python SDK">
    ```python theme={null}
    preview = client.subscriptions.preview_change_plan(
        subscription_id="sub_123",
        product_id="prod_pro",
        quantity=1,
        proration_billing_mode="prorated_immediately"
    )

    # Show customer the charge before confirming
    print("Immediate charge:", preview.immediate_charge.summary)
    print("New plan details:", preview.new_plan)
    ```
  </Tab>
</Tabs>

<Tip>
  Use the preview API to build confirmation dialogs that show customers the exact amount they'll be charged before they confirm a plan change.
</Tip>

## Change Plan API

Use the Change Plan API to modify product, quantity, and proration behavior for an active subscription.

### Quick start examples

<Tabs>
  <Tab title="Node.js SDK">
    ```javascript theme={null}
    import DodoPayments from 'dodopayments';

    const client = new DodoPayments({
      bearerToken: process.env.DODO_PAYMENTS_API_KEY,
      environment: 'test_mode', // defaults to 'live_mode'
    });

    async function changePlan() {
      const result = await client.subscriptions.changePlan('sub_123', {
        product_id: 'prod_new',
        quantity: 3,
        proration_billing_mode: 'prorated_immediately',
      });
      console.log(result.status, result.invoice_id, result.payment_id);
    }

    changePlan();
    ```
  </Tab>

  <Tab title="Python SDK">
    ```python theme={null}
    import os
    from dodopayments import DodoPayments

    client = DodoPayments(
        bearer_token=os.environ.get("DODO_PAYMENTS_API_KEY"),
        environment="test_mode",  # defaults to "live_mode"
    )

    result = client.subscriptions.change_plan(
        subscription_id="sub_123",
        product_id="prod_new",
        quantity=3,
        proration_billing_mode="prorated_immediately",
    )
    print(result.status, result.get("invoice_id"), result.get("payment_id"))
    ```
  </Tab>

  <Tab title="Go SDK">
    ```go theme={null}
    package main

    import (
      "context"
      "fmt"
      "github.com/dodopayments/dodopayments-go"
      "github.com/dodopayments/dodopayments-go/option"
    )

    func main() {
      client := dodopayments.NewClient(option.WithBearerToken("YOUR_TOKEN"))
      res, err := client.Subscriptions.ChangePlan(context.TODO(), dodopayments.SubscriptionChangePlanParams{
        SubscriptionID: dodopayments.F("sub_123"),
        ProductID:             dodopayments.F("prod_new"),
        Quantity:              dodopayments.F(int64(3)),
        ProrationBillingMode:  dodopayments.F(dodopayments.SubscriptionChangePlanParamsProrationBillingModeProratedImmediately),
      })
      if err != nil { panic(err) }
      fmt.Println(res.Status, res.InvoiceID, res.PaymentID)
    }
    ```
  </Tab>

  <Tab title="HTTP">
    ```bash theme={null}
    curl -X POST "$DODO_API_BASE/subscriptions/sub_123/change-plan" \
      -H "Authorization: Bearer $DODO_PAYMENTS_API_KEY" \
      -H "Content-Type: application/json" \
      -d '{
        "product_id": "prod_new",
        "quantity": 3,
        "proration_billing_mode": "prorated_immediately"
      }'
    ```
  </Tab>
</Tabs>

```json Success theme={null}
{
  "status": "processing",
  "subscription_id": "sub_123",
  "invoice_id": "inv_789",
  "payment_id": "pay_456",
  "proration_billing_mode": "prorated_immediately"
}
```

<Note>
  Fields like <code>invoice\_id</code> and <code>payment\_id</code> are returned only when an immediate charge and/or invoice is created during the plan change. Always rely on webhook events (e.g., <code>payment.succeeded</code>, <code>subscription.plan\_changed</code>) to confirm outcomes.
</Note>

<Warning>
  If the immediate charge fails, the subscription may move to `subscription.on_hold` until payment succeeds.
</Warning>

## Managing Addons

When changing subscription plans, you can also modify addons:

```javascript theme={null}
// Add addons to the new plan
await client.subscriptions.changePlan('sub_123', {
  product_id: 'prod_new',
  quantity: 1,
  proration_billing_mode: 'difference_immediately',
  addons: [
    { addon_id: 'addon_123', quantity: 2 }
  ]
});

// Remove all existing addons
await client.subscriptions.changePlan('sub_123', {
  product_id: 'prod_new',
  quantity: 1,
  proration_billing_mode: 'difference_immediately',
  addons: [] // Empty array removes all existing addons
});
```

<Info>
  Addons are included in the proration calculation and will be charged according to the selected proration mode.
</Info>

## Proration modes

Choose how to bill the customer when changing plans:

#### `prorated_immediately`

* Charges for the partial difference in the current cycle
* If in trial, charges immediately and switches to the new plan now
* Downgrade: may generate a prorated credit applied to future renewals

#### `full_immediately`

* Charges the full amount of the new plan immediately
* Ignores remaining time from the old plan

<Info>
  Credits created by downgrades using <code>difference\_immediately</code> are subscription-scoped and distinct from <a href="/features/customer-credit">Customer Credits</a>. They automatically apply to future renewals of the same subscription and are not transferable between subscriptions.
</Info>

#### `difference_immediately`

* Upgrade: immediately charge the price difference between old and new plans
* Downgrade: add remaining value as internal credit to the subscription and auto-apply on renewals

### Example scenarios

<AccordionGroup>
  <Accordion title="Upgrade: Basic ($30) → Pro ($80) with difference_immediately">
    ```javascript theme={null}
    await client.subscriptions.changePlan('sub_123', {
      product_id: 'prod_pro',
      quantity: 1,
      proration_billing_mode: 'difference_immediately'
    })
    // Immediate charge: $50
    ```
  </Accordion>

  <Accordion title="Downgrade: Plus ($50) → Starter ($20) with difference_immediately">
    ```javascript theme={null}
    await client.subscriptions.changePlan('sub_123', {
      product_id: 'prod_starter',
      quantity: 1,
      proration_billing_mode: 'difference_immediately'
    })
    // Credit added: $30 (auto-applied to future renewals for this subscription)
    ```
  </Accordion>

  <Accordion title="Upgrade mid-cycle with prorated_immediately">
    ```javascript theme={null}
    await client.subscriptions.changePlan('sub_123', {
      product_id: 'prod_new',
      quantity: 1,
      proration_billing_mode: 'prorated_immediately'
    })
    // Immediate prorated charge based on remaining days in cycle
    ```
  </Accordion>

  <Accordion title="Reset billing with full_immediately">
    ```javascript theme={null}
    await client.subscriptions.changePlan('sub_123', {
      product_id: 'prod_new',
      quantity: 1,
      proration_billing_mode: 'full_immediately'
    })
    // Immediate full charge for new plan; no credits calculated
    ```
  </Accordion>
</AccordionGroup>

<Tip>
  Pick `prorated_immediately` for fair-time accounting; choose `full_immediately` to restart billing; use `difference_immediately` for simple upgrades and automatic credit on downgrades.
</Tip>

## Handling webhooks

Track subscription state through webhooks to confirm plan changes and payments.

### Event types to handle

* `subscription.active`: subscription activated
* `subscription.plan_changed`: subscription plan changed (upgrade/downgrade/addon changes)
* `subscription.on_hold`: charge failed, subscription paused
* `subscription.renewed`: renewal succeeded
* `payment.succeeded`: payment for plan change or renewal succeeded
* `payment.failed`: payment failed

<Info>
  We recommend driving business logic from subscription events and using payment events for confirmation and reconciliation.
</Info>

### Verify signatures and handle intents

<Tabs>
  <Tab title="Next.js Route Handler">
    ```javascript theme={null}
    import { NextRequest, NextResponse } from 'next/server';

    export async function POST(req) {
      const webhookId = req.headers.get('webhook-id');
      const webhookSignature = req.headers.get('webhook-signature');
      const webhookTimestamp = req.headers.get('webhook-timestamp');
      const secret = process.env.DODO_WEBHOOK_SECRET;

      const payload = await req.text();
      // verifySignature is a placeholder – in production, use a Standard Webhooks library
      const { valid, event } = await verifySignature(
        payload,
        { id: webhookId, signature: webhookSignature, timestamp: webhookTimestamp },
        secret
      );
      if (!valid) return NextResponse.json({ error: 'Invalid signature' }, { status: 400 });

      switch (event.type) {
        case 'subscription.active':
          // mark subscription active in your DB
          break;
        case 'subscription.plan_changed':
          // refresh entitlements and reflect the new plan in your UI
          break;
        case 'subscription.on_hold':
          // notify user to update payment method
          break;
        case 'subscription.renewed':
          // extend access window
          break;
        case 'payment.succeeded':
          // reconcile payment for plan change
          break;
        case 'payment.failed':
          // log and alert
          break;
        default:
          // ignore unknown events
          break;
      }

      return NextResponse.json({ received: true });
    }
    ```
  </Tab>

  <Tab title="Express.js">
    ```javascript theme={null}
    import express from 'express';

    const app = express();
    app.post('/webhooks/dodo', express.raw({ type: 'application/json' }), async (req, res) => {
      const webhookId = req.header('webhook-id');
      const webhookSignature = req.header('webhook-signature');
      const webhookTimestamp = req.header('webhook-timestamp');
      const secret = process.env.DODO_WEBHOOK_SECRET;
      const payload = req.body.toString('utf8');

      const { valid, event } = await verifySignature(
        payload,
        { id: webhookId, signature: webhookSignature, timestamp: webhookTimestamp },
        secret
      );
      if (!valid) return res.status(400).send('Invalid signature');

      // handle events like above
      res.json({ received: true });
    });

    app.listen(3000);
    ```
  </Tab>
</Tabs>

<Note>
  For detailed payload schemas, see the <a href="/developer-resources/webhooks/intents/subscription">Subscription webhook payloads</a> and <a href="/developer-resources/webhooks/intents/payment">Payment webhook payloads</a>.
</Note>

## Best Practices

Follow these recommendations for reliable subscription plan changes:

### Plan Change Strategy

* **Test thoroughly**: Always test plan changes in test mode before production
* **Choose proration carefully**: Select the proration mode that aligns with your business model
* **Handle failures gracefully**: Implement proper error handling and retry logic
* **Monitor success rates**: Track plan change success/failure rates and investigate issues

### Webhook Implementation

* **Verify signatures**: Always validate webhook signatures to ensure authenticity
* **Implement idempotency**: Handle duplicate webhook events gracefully
* **Process asynchronously**: Don't block webhook responses with heavy operations
* **Log everything**: Maintain detailed logs for debugging and audit purposes

### User Experience

* **Communicate clearly**: Inform customers about billing changes and timing
* **Provide confirmations**: Send email confirmations for successful plan changes
* **Handle edge cases**: Consider trial periods, prorations, and failed payments
* **Update UI immediately**: Reflect plan changes in your application interface

## Common Issues and Solutions

Resolve typical problems encountered during subscription plan changes:

<AccordionGroup>
  <Accordion title="Charge created but subscription not updated">
    **Symptoms**: API call succeeds but subscription remains on old plan

    **Common causes**:

    * Webhook processing failed or was delayed
    * Application state not updated after receiving webhooks
    * Database transaction issues during state update

    **Solutions**:

    * Implement robust webhook handling with retry logic
    * Use idempotent operations for state updates
    * Add monitoring to detect and alert on missed webhook events
    * Verify webhook endpoint is accessible and responding correctly
  </Accordion>

  <Accordion title="Credits not applied after downgrade">
    **Symptoms**: Customer downgrades but doesn't see credit balance

    **Common causes**:

    * Proration mode expectations: downgrades credit the full plan price difference with `difference_immediately`, while `prorated_immediately` creates a prorated credit based on remaining time in the cycle
    * Credits are subscription-specific and don't transfer between subscriptions
    * Credit balance not visible in customer dashboard

    **Solutions**:

    * Use `difference_immediately` for downgrades when you want automatic credits
    * Explain to customers that credits apply to future renewals of the same subscription
    * Implement customer portal to show credit balances
    * Check next invoice preview to see applied credits
  </Accordion>

  <Accordion title="Webhook signature verification fails">
    **Symptoms**: Webhook events rejected due to invalid signature

    **Common causes**:

    * Incorrect webhook secret key
    * Raw request body modified before signature verification
    * Wrong signature verification algorithm

    **Solutions**:

    * Verify you're using the correct `DODO_WEBHOOK_SECRET` from dashboard
    * Read raw request body before any JSON parsing middleware
    * Use the standard webhook verification library for your platform
    * Test webhook signature verification in development environment
  </Accordion>

  <Accordion title="Plan change fails with 422 error">
    **Symptoms**: API returns 422 Unprocessable Entity error

    **Common causes**:

    * Invalid subscription ID or product ID
    * Subscription not in active state
    * Missing required parameters
    * Product not available for plan changes

    **Solutions**:

    * Verify subscription exists and is active
    * Check product ID is valid and available
    * Ensure all required parameters are provided
    * Review API documentation for parameter requirements
  </Accordion>

  <Accordion title="Immediate charge fails during plan change">
    **Symptoms**: Plan change initiated but immediate charge fails

    **Common causes**:

    * Insufficient funds on customer's payment method
    * Payment method expired or invalid
    * Bank declined the transaction
    * Fraud detection blocked the charge

    **Solutions**:

    * Handle `payment.failed` webhook events appropriately
    * Notify customer to update payment method
    * Implement retry logic for temporary failures
    * Consider allowing plan changes with failed immediate charges
  </Accordion>

  <Accordion title="Subscription on hold after plan change">
    **Symptoms**: Plan change charge fails and subscription moves to `on_hold` state

    **What happens**:
    When a plan change charge fails, the subscription is automatically placed in `on_hold` state. The subscription will not renew automatically until the payment method is updated.

    **Solution**: Update the payment method to reactivate the subscription

    To reactivate a subscription from `on_hold` state after a failed plan change:

    1. **Update the payment method** using the Update Payment Method API
    2. **Automatic charge creation**: The API automatically creates a charge for remaining dues
    3. **Invoice generation**: An invoice is generated for the charge
    4. **Payment processing**: The payment is processed using the new payment method
    5. **Reactivation**: Upon successful payment, the subscription is reactivated to `active` state

    <CodeGroup>
      ```javascript Node.js theme={null}
      // Reactivate subscription from on_hold after failed plan change
      async function reactivateAfterFailedPlanChange(subscriptionId) {
        // Update payment method - automatically creates charge for remaining dues
        const response = await client.subscriptions.updatePaymentMethod(subscriptionId, {
          type: 'new',
          return_url: 'https://example.com/return'
        });
        
        if (response.payment_id) {
          console.log('Charge created for remaining dues:', response.payment_id);
          console.log('Payment link:', response.payment_link);
          
          // Redirect customer to payment_link to complete payment
          // Monitor webhooks for:
          // 1. payment.succeeded - charge succeeded
          // 2. subscription.active - subscription reactivated
        }
        
        return response;
      }

      // Or use existing payment method if available
      async function reactivateWithExistingPaymentMethod(subscriptionId, paymentMethodId) {
        const response = await client.subscriptions.updatePaymentMethod(subscriptionId, {
          type: 'existing',
          payment_method_id: paymentMethodId
        });
        
        // Monitor webhooks for payment.succeeded and subscription.active
        return response;
      }
      ```

      ```python Python theme={null}
      # Reactivate subscription from on_hold after failed plan change
      def reactivate_after_failed_plan_change(subscription_id):
          # Update payment method - automatically creates charge for remaining dues
          response = client.subscriptions.update_payment_method(
              subscription_id=subscription_id,
              type="new",
              return_url="https://example.com/return"
          )
          
          if response.payment_id:
              print("Charge created for remaining dues:", response.payment_id)
              print("Payment link:", response.payment_link)
              
              # Redirect customer to payment_link to complete payment
              # Monitor webhooks for:
              # 1. payment.succeeded - charge succeeded
              # 2. subscription.active - subscription reactivated
          
          return response

      # Or use existing payment method if available
      def reactivate_with_existing_payment_method(subscription_id, payment_method_id):
          response = client.subscriptions.update_payment_method(
              subscription_id=subscription_id,
              type="existing",
              payment_method_id=payment_method_id
          )
          
          # Monitor webhooks for payment.succeeded and subscription.active
          return response
      ```
    </CodeGroup>

    **Webhook events to monitor**:

    * `subscription.on_hold`: Subscription placed on hold (received when plan change charge fails)
    * `payment.succeeded`: Payment for remaining dues succeeded (after updating payment method)
    * `subscription.active`: Subscription reactivated after successful payment

    **Best practices**:

    * Notify customers immediately when a plan change charge fails
    * Provide clear instructions on how to update their payment method
    * Monitor webhook events to track reactivation status
    * Consider implementing automatic retry logic for temporary payment failures

    <Card title="Update Payment Method API Reference" icon="code" href="/api-reference/subscriptions/update-payment-method">
      View the complete API documentation for updating payment methods and reactivating subscriptions.
    </Card>
  </Accordion>
</AccordionGroup>

## Testing Your Implementation

Follow these steps to thoroughly test your subscription plan change implementation:

<Steps>
  <Step title="Set up test environment">
    * Use test API keys and test products
    * Create test subscriptions with different plan types
    * Configure test webhook endpoint
    * Set up monitoring and logging
  </Step>

  <Step title="Test different proration modes">
    * Test `prorated_immediately` with various billing cycle positions
    * Test `difference_immediately` for upgrades and downgrades
    * Test `full_immediately` to reset billing cycles
    * Verify credit calculations are correct
  </Step>

  <Step title="Test webhook handling">
    * Verify all relevant webhook events are received
    * Test webhook signature verification
    * Handle duplicate webhook events gracefully
    * Test webhook processing failure scenarios
  </Step>

  <Step title="Test error scenarios">
    * Test with invalid subscription IDs
    * Test with expired payment methods
    * Test network failures and timeouts
    * Test with insufficient funds
  </Step>

  <Step title="Monitor in production">
    * Set up alerts for failed plan changes
    * Monitor webhook processing times
    * Track plan change success rates
    * Review customer support tickets for plan change issues
  </Step>
</Steps>

## Error Handling

Handle common API errors gracefully in your implementation:

### HTTP Status Codes

<AccordionGroup>
  <Accordion title="200 OK">
    Plan change request processed successfully. The subscription is being updated and payment processing has begun.
  </Accordion>

  <Accordion title="400 Bad Request">
    Invalid request parameters. Check that all required fields are provided and properly formatted.
  </Accordion>

  <Accordion title="401 Unauthorized">
    Invalid or missing API key. Verify your `DODO_PAYMENTS_API_KEY` is correct and has proper permissions.
  </Accordion>

  <Accordion title="404 Not Found">
    Subscription ID not found or doesn't belong to your account.
  </Accordion>

  <Accordion title="422 Unprocessable Entity">
    The subscription cannot be changed (e.g., already cancelled, product not available, etc.).
  </Accordion>

  <Accordion title="500 Internal Server Error">
    Server error occurred. Retry the request after a brief delay.
  </Accordion>
</AccordionGroup>

### Error Response Format

```json theme={null}
{
  "error": {
    "code": "subscription_not_found",
    "message": "The subscription with ID 'sub_123' was not found",
    "details": {
      "subscription_id": "sub_123"
    }
  }
}
```

## Next steps

* Review the <a href="/api-reference/subscriptions/change-plan">Change Plan API</a>
* Explore <a href="/features/customer-credit">Customer Credits</a>
* Implement alerts for `subscription.on_hold`
* Check out our <a href="/developer-resources/webhooks">Webhook Integration Guide</a>


# Build an AI Image Generator with Usage-Based Billing
Source: https://docs.dodopayments.com/developer-resources/usage-based-billing-build-ai-image-generator

Follow along as we build PixelGen AI - an AI image generation service with pay-per-use billing

In this tutorial, you'll build **PixelGen AI** - a sample AI image generation service that demonstrates usage-based billing. We'll create everything from scratch: the billing meter, product configuration, and sample application code that generates images and tracks usage in real-time.

<Note>
  This tutorial provides sample implementation code for a terminal-based application. You can modify this code for your specific framework (React, Vue, Angular, etc.) and customize the user input method according to your application's needs.
</Note>

By the end of this tutorial, you'll have a working sample service that:

* Generates images using OpenAI's DALL-E API
* Tracks every image generation for billing
* Charges customers automatically based on usage
* Handles different quality tiers (standard vs HD)

## What We're Building

Let's start by understanding our PixelGen AI service:

* **Service**: AI image generation using OpenAI's DALL-E API
* **Pricing Model**: Pay-per-image (\$0.05 per image)
* **Free Tier**: 10 free images per customer per month
* **Quality Options**: Standard and HD images (same price for simplicity)

<Info>
  Before we start, make sure you have:

  * A Dodo Payments account
  * Access to OpenAI's API
  * Basic familiarity with TypeScript/Node.js
</Info>

## Step 1: Create Your Usage Meter

We'll start by creating a meter in your Dodo Payments dashboard that will track every image our service generates. Think of this as the "counter" that tracks billable events.

<Frame>
  <img alt="" />
</Frame>

<Tip>
  **What we're building**: A meter named "Image Generation Meter" that counts every time someone generates an image using our service.
</Tip>

<Steps>
  <Step title="Open the Meters section">
    1. Log into your Dodo Payments dashboard
    2. Click on **Meters** in the left sidebar
    3. Click the **Create Meter** button

    You should see a form where we'll configure our image generation tracking.
  </Step>

  <Step title="Fill in the basic meter information">
    Now we'll enter the specific details for our PixelGen AI service:

    **Meter Name**: Copy and paste this exactly → `Image Generation Meter`

    **Description**: Copy this → `Tracks each AI image generation request made by customers using our DALL-E powered service`

    **Event Name**: This is crucial - copy exactly → `image.generated`

    <Warning>
      The event name `image.generated` must match exactly what we'll send from our application code later. Event names are case-sensitive!
    </Warning>
  </Step>

  <Step title="Configure how we count images">
    Set up the aggregation (how the meter counts our events):

    **Aggregation Type**: Select **Count** from the dropdown

    **Measurement Unit**: Type → `images`

    <Info>
      We're using "Count" because we want to bill per image generated, not by size or generation time. Each successful image = 1 billable unit.
    </Info>
  </Step>

  <Step title="Add quality filtering">
    <Frame>
      <img alt="" />
    </Frame>

    We want to make sure we only count legitimate images (not test runs or failures):

    1. **Enable Event Filtering**: Toggle this **ON**
    2. **Filter Logic**: Select **OR** (this means "count if ANY of these conditions are true")
    3. **Add the first condition**:
       * Property Key: `quality`
       * Comparator: `equals`
       * Value: `standard`
    4. **Click "Add Condition"** for the second one:
       * Property Key: `quality`
       * Comparator: `equals`
       * Value: `hd`

    <Tip>
      This setup means we'll only count events where the quality is either "standard" OR "hd" - filtering out any test events or malformed requests.
    </Tip>
  </Step>

  <Step title="Create your meter">
    1. Double-check all your settings match the values above
    2. Click **Create Meter**

    <Check>
      **Meter created!** Your "Image Generation Meter" is now ready to start counting image generations. Next, we'll connect it to a billing product.
    </Check>
  </Step>
</Steps>

## Step 2: Create Your Billing Product

Now we need to create a product that defines our pricing (\$0.05 per image with 10 free images). This connects our meter to actual billing.

<Tip>
  **What we're building**: A product called "PixelGen AI - Image Generation" that charges \$0.05 per image after the first 10 free images each month.
</Tip>

<Steps>
  <Step title="Navigate to Products">
    1. In your Dodo Payments dashboard, click **Products** in the left sidebar
    2. Click **Create Product**
    3. Select **Usage-Based** as the product type

    This tells Dodo Payments that billing will be based on meter usage, not a fixed subscription.
  </Step>

  <Step title="Enter product details">
    Fill in these exact values for our PixelGen AI service:

    **Product Name**: Copy this → `PixelGen AI - Image Generation`

    **Description**: Copy this → `AI-powered image generation service with pay-per-use billing`

    **Product Image**: Upload a clear, relevant image.

    <Info>
      These will appear on customer invoices, so make them clear and professional.
    </Info>
  </Step>

  <Step title="Connect your meter">
    <Frame>
      <img alt="" />
    </Frame>

    Before connecting your meter, make sure you have selected **Usage Based Billing** as the price type for your product.

    Additionally, set the **Fixed Price** to `0` to ensure customers are only charged based on their usage, with no base fee.

    Now, link the meter you just created:

    1. Scroll down to the **Associated Meter** section
    2. Click **Add Meters**
    3. From the dropdown, select **"Image Generation Meter"** (the one you created earlier)
    4. Confirm that it appears in your product configuration

    <Check>
      Your meter is now successfully connected to this product.
    </Check>
  </Step>

  <Step title="Set your pricing">
    Here's where we define our business model:

    <Frame>
      <img alt="" />
    </Frame>

    **Price Per Unit**: Enter → `0.05` (this is \$0.05 per image)

    **Free Threshold**: Enter → `10` (customers get 10 free images per month)

    <Tip>
      **How billing works**: If a customer generates 25 images in a month, they'll be charged for 15 images (25 - 10 free) = 15 × $0.05 = $0.75
    </Tip>
  </Step>

  <Step title="Save your product">
    1. Review all your settings:
       * Name: PixelGen AI - Image Generation
       * Meter: Image Generation Meter
       * Price: \$0.05 per image
       * Free tier: 10 images
    2. Click **Save Changes**

    <Check>
      **Product created!** Your billing is now configured. Customers will automatically be charged based on their image generation usage.
    </Check>
  </Step>
</Steps>

## Step 3: Make a Test Purchase

Before we start ingesting usage events, we need to make a test purchase.

<Steps>
  <Step title="Get your payment link">
    1. In your Dodo Payments dashboard, go to **Products**
    2. Find your "PixelGen AI - Image Generation" product
    3. Click the **Share** button next to your product
    4. Copy the payment link that appears

    The payment link will look something like: `https://test.checkout.dodopayments.com/buy/pdt_IgPWlRsfpbPd5jQKezzW1?quantity=1`
  </Step>

  <Step title="Complete a test purchase">
    1. Open the payment link in a new browser tab
    2. Enter test payment details and complete purchase.

    <Check>
      After successful payment, you'll have a customer ID that we'll use in our application code.
    </Check>
  </Step>

  <Step title="Find your customer ID">
    1. Go back to your Dodo Payments dashboard
    2. Navigate to **Customers** in the left sidebar
    3. Find the customer you just created (with the test email)
    4. Copy the customer ID - it will look like `cus_abc123def456`

    <Note>
      Save this customer ID - we'll hardcode it in our sample application code to ensure events are properly tracked.
    </Note>
  </Step>
</Steps>

## Step 4: Build the Sample Application

Now we have our billing setup complete and a test customer created. Let's build the sample PixelGen AI application that generates images and automatically tracks usage for billing.

<Steps>
  <Step title="Set up your project">
    Create a new directory and initialize the project:

    ```bash theme={null}
    mkdir pixelgen-ai
    cd pixelgen-ai
    npm init -y
    ```
  </Step>

  <Step title="Install dependencies">
    Install the packages we need:

    ```bash theme={null}
    npm install openai dotenv
    npm install -D typescript @types/node ts-node
    ```
  </Step>

  <Step title="Create the main application">
    Create a file called `index.ts` and copy this complete application code:
  </Step>
</Steps>

Here's the complete PixelGen AI application with integrated billing:

<CodeGroup>
  ```typescript index.ts expandable theme={null}
  import 'dotenv/config';
  import OpenAI from 'openai';
  import * as readline from 'readline';
  import { randomUUID } from 'crypto';

  // Initialize OpenAI client
  const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
  });

  // Dodo Payments configuration
  const DODO_PAYMENTS_CONFIG = {
    apiKey: process.env.DODO_PAYMENTS_API_KEY,
    baseUrl: 'https://test.dodopayments.com',
    customerId: 'cus_FX5FAB43aShGyiHJGIqjB', // Replace with your actual customer ID from Step 3
  };

  // DALL-E 3 pricing (as of 2024-2025)
  const PRICING = {
    'standard': 0.040, // $0.040 per image (1024×1024)
    'hd': 0.080,       // $0.080 per image (1024×1024, HD quality)
  };

  interface ImageGenerationOptions {
    prompt: string;
    model?: 'dall-e-3' | 'dall-e-2';
    quality?: 'standard' | 'hd';
    size?: '1024x1024' | '1792x1024' | '1024x1792';
    style?: 'vivid' | 'natural';
  }

  interface UsageEvent {
    event_id: string;
    customer_id: string;
    event_name: string;
    timestamp: string;
    metadata: {
      quality: string;
    };
  }

  /**
   * Send usage event to Dodo Payments for billing tracking
   */
  async function sendUsageEvent(event: UsageEvent): Promise<void> {
    try {
      console.log('Sending usage event to Dodo Payments...');
      console.log(`URL: ${DODO_PAYMENTS_CONFIG.baseUrl}/events/ingest`);
      console.log(`API Key present: ${!!DODO_PAYMENTS_CONFIG.apiKey}`);
      console.log(`API Key length: ${DODO_PAYMENTS_CONFIG.apiKey?.length || 0}`);
      console.log(`Customer ID: ${DODO_PAYMENTS_CONFIG.customerId}`);
      
      const requestBody = {
        events: [event]
      };
      console.log('Request body:', JSON.stringify(requestBody, null, 2));
      
      const headers = {
        'Authorization': `Bearer ${DODO_PAYMENTS_CONFIG.apiKey}`,
        'Content-Type': 'application/json',
      }
      console.log('Headers:', headers);
      const response = await fetch(`${DODO_PAYMENTS_CONFIG.baseUrl}/events/ingest`, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(requestBody),
      });

      console.log(`Response status: ${response.status}`);
      console.log(`Response headers:`, Object.fromEntries(response.headers.entries()));

      if (!response.ok) {
        const errorData = await response.text();
        console.log(`Error response body: ${errorData}`);
        throw new Error(`HTTP ${response.status}: ${errorData}`);
      }

      const result = await response.json();
      console.log('Usage event sent successfully');
      console.log(`   • Event ID: ${event.event_id}`);
      console.log(`   • Customer: ${event.customer_id}`);
      console.log(`   • Quality: ${event.metadata.quality}`);
      
    } catch (error) {
      console.error('Failed to send usage event:', error);
      // In production, you might want to queue failed events for retry
      throw error;
    }
  }

  async function generateImage(options: ImageGenerationOptions) {
    const startTime = Date.now();
    const eventId = randomUUID();
    
    try {
      console.log('Generating image...');
      console.log(`Prompt: "${options.prompt}"`);
      console.log(`Quality: ${options.quality || 'standard'}`);
      console.log(`Size: ${options.size || '1024x1024'}`);
      
      const response = await openai.images.generate({
        model: options.model || 'dall-e-3',
        prompt: options.prompt,
        n: 1,
        size: options.size || '1024x1024',
        quality: options.quality || 'standard',
        style: options.style || 'vivid',
      });

      const endTime = Date.now();
      const duration = (endTime - startTime) / 1000;
      const cost = PRICING[options.quality || 'standard'];
      
      // Create usage event for Dodo Payments
      const usageEvent: UsageEvent = {
        event_id: eventId,
        customer_id: DODO_PAYMENTS_CONFIG.customerId!,
        event_name: 'image.generated',
        timestamp: new Date().toISOString(),
        metadata: {
          quality: options.quality || 'standard',
        }
      };

      // Send usage event to Dodo Payments for billing
      await sendUsageEvent(usageEvent);
      
      console.log('\nImage generated successfully!');
      console.log(`Generation Stats:`);
      console.log(`   • Duration: ${duration.toFixed(2)} seconds`);
      console.log(`   • Quality: ${options.quality || 'standard'}`);
      console.log(`   • Cost: $${cost.toFixed(3)}`);
      console.log(`   • Image URL: ${response.data?.[0]?.url}`);
      
      if (response.data?.[0]?.revised_prompt) {
        console.log(`   • Revised prompt: "${response.data[0].revised_prompt}"`);
      }

      return {
        imageUrl: response.data?.[0].url,
        revisedPrompt: response.data?.[0].revised_prompt,
        cost: cost,
        duration: duration,
        eventId: eventId,
      };

    } catch (error) {
      console.error('Error generating image:', error);
      
      // Send failure event for monitoring (optional)
      try {
        const failureEvent: UsageEvent = {
          event_id: eventId,
          customer_id: DODO_PAYMENTS_CONFIG.customerId!,
          event_name: 'image.generation.failed',
          timestamp: new Date().toISOString(),
          metadata: {
            quality: options.quality || 'standard',
          }
        };
        
        // Note: You might want to create a separate meter for failed attempts
        // await sendUsageEvent(failureEvent);
      } catch (eventError) {
        console.error('Failed to send failure event:', eventError);
      }
      
      throw error;
    }
  }

  async function getUserInput(): Promise<string> {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    return new Promise((resolve) => {
      rl.question('Enter your image prompt: ', (answer) => {
        rl.close();
        resolve(answer);
      });
    });
  }

  async function main() {
    console.log('PixelGen AI - Image Generator with Usage Billing\n');
    
    // Validate environment variables
    const requiredEnvVars = [
      'OPENAI_API_KEY',
      'DODO_PAYMENTS_API_KEY'
    ];
    
    for (const envVar of requiredEnvVars) {
      if (!process.env[envVar]) {
        console.error(`Error: ${envVar} environment variable is not set.`);
        console.log('Please set all required environment variables:');
        console.log('export OPENAI_API_KEY="your-openai-key"');
        console.log('export DODO_PAYMENTS_API_KEY="your-dodo-api-key"');
        console.log('Note: Customer ID is hardcoded in the application');
        process.exit(1);
      }
    }

    try {
      const prompt = await getUserInput();
      
      if (!prompt.trim()) {
        console.log('No prompt provided. Exiting...');
        return;
      }

      const result = await generateImage({
        prompt: prompt.trim(),
        quality: 'standard', // Change to 'hd' for higher quality (costs more)
        size: '1024x1024',
        style: 'vivid'
      });

      console.log('\nProcess completed successfully!');
      console.log(`Billing Information:`);
      console.log(`   • Total cost: $${result.cost.toFixed(3)}`);
      console.log(`   • Event ID: ${result.eventId}`);
      console.log(`   • Billing will be processed automatically via Dodo Payments`);
      
    } catch (error) {
      console.error('Application error:', error);
      process.exit(1);
    }
  }

  // Run the application
  if (require.main === module) {
    main().catch(console.error);
  }
  ```

  ```bash .env theme={null}
  # Create .env file with your API keys
  OPENAI_API_KEY=your_openai_api_key_here
  DODO_PAYMENTS_API_KEY=your_DODO_PAYMENTS_payments_api_key_here
  # Note: Customer ID is hardcoded in the application code
  ```

  ```typescript package.json theme={null}
  {
    "name": "pixelgen-ai",
    "version": "1.0.0",
    "description": "AI Image Generation with Usage-Based Billing",
    "main": "index.js",
    "scripts": {
      "start": "ts-node index.ts",
      "build": "tsc",
      "dev": "ts-node --watch index.ts"
    },
    "dependencies": {
      "openai": "^4.0.0",
      "dotenv": "^16.0.0"
    },
    "devDependencies": {
      "@types/node": "^20.0.0",
      "typescript": "^5.0.0",
      "ts-node": "^10.0.0"
    }
  }
  ```
</CodeGroup>

## Step 5: Test Your Sample Application

Time to test our sample PixelGen AI service and see the billing in action! Let's make sure everything works end-to-end.

<Tip>
  **What we're testing**: We'll generate some images, verify the events reach Dodo Payments, and confirm billing calculations are correct.
</Tip>

<Steps>
  <Step title="Set up your environment">
    First, make sure you have everything configured:

    1. Create a `.env` file in your `pixelgen-ai` directory
    2. Add your actual API keys:

    ```bash theme={null}
    OPENAI_API_KEY=sk-your-actual-openai-key
    DODO_PAYMENTS_API_KEY=your-actual-dodo-api-key
    # Customer ID is hardcoded in the application
    ```

    3. Install dependencies and run the app:

    ```bash theme={null}
    npm install
    npm start
    ```

    <Warning>
      Make sure to use real API keys and update the hardcoded customer ID in the code with your actual customer ID from Step 3!
    </Warning>
  </Step>

  <Step title="Generate your first test image">
    When the app starts, you'll see:

    ```
    PixelGen AI - Image Generator with Usage Billing

    Enter your image prompt:
    ```

    Try this prompt: **"A cute robot painting a landscape"**

    You should see output like this:

    ```
    Generating image...
    Prompt: "A cute robot painting a landscape"
    Quality: standard
    Size: 1024x1024

    Sending usage event to Dodo Payments...
    Usage event sent successfully
       • Event ID: 550e8400-e29b-41d4-a716-446655440000
       • Customer: cus_atXa1lklCRRzMicTqfiw2
       • Quality: standard

    Image generated successfully!
    Generation Stats:
       • Duration: 8.45 seconds
       • Quality: standard
       • Cost: $0.040
       • Image URL: https://oaidalleapi...
    ```

    <Check>
      If you see "Usage event sent successfully", your billing integration is working!
    </Check>
  </Step>

  <Step title="Generate a few more images">
    Let's generate 2-3 more images to test multiple events. Try these prompts:

    1. **"A sunset over mountains with purple clouds"**
    2. **"A steampunk coffee machine in a Victorian kitchen"**
    3. **"A friendly dragon reading a book in a library"**

    Each time, watch for the "Usage event sent successfully" message.
  </Step>

  <Step title="Check your Dodo Payments dashboard">
    Now let's verify the events are being received:

    1. Open your Dodo Payments dashboard
    2. Go to *Usage Billing* → \***Meters** → **Image Generation Meter**
    3. Click on the **Events**  tab
    4. You should see your image generation events listed

    **What to look for**:

    * Event names: `image.generated`
    * Customer ID: Your test customer ID

    <Check>
      You should see one event for each image you generated!
    </Check>
  </Step>

  <Step title="Verify billing calculations">
    Let's check if the usage counting is working:

    <Frame>
      <img alt="" />
    </Frame>

    1. In your meter, go to the **Customers** tab
    2. Find your test customer
    3. Check the "Consumed Units" column
  </Step>

  <Step title="Test the billing threshold">
    Let's exceed the free tier to see billing in action:

    1. Generate 8 more images (to reach 12 total)
    2. Check your meter dashboard again
    3. You should now see:
       * Consumed units: 12
       * Billable units: 2 (12 - 10 free)
       * Billing amount: \$0.10

    <Check>
      **Success!** Your usage-based billing is working perfectly. Customers will be automatically charged based on their actual image generation usage.
    </Check>
  </Step>
</Steps>

## Troubleshooting

Common issues and their solutions:

<AccordionGroup>
  <Accordion title="Events not appearing in dashboard">
    **Possible causes:**

    * Event name doesn't match meter configuration exactly
    * Customer ID doesn't exist in your account
    * API key is invalid or expired
    * Network connectivity issues

    **Solutions:**

    1. Verify event name matches meter configuration exactly (case-sensitive)
    2. Check that customer ID exists in Dodo Payments
    3. Test API key with a simple API call
    4. Check network connectivity and firewall settings
  </Accordion>
</AccordionGroup>

## Congratulations! You Built PixelGen AI

You've successfully created a snippet for AI image generation with usage-based billing! Here's what you accomplished:

<CardGroup>
  <Card title="Usage Meter" icon="sliders">
    Created "Image Generation Meter" that tracks every image generation event
  </Card>

  <Card title="Billing Product" icon="credit-card">
    Configured pricing at \$0.05 per image with 10 free images per month
  </Card>

  <Card title="AI Application" icon="robot">
    Built a working TypeScript app that generates images using OpenAI's DALL-E
  </Card>

  <Card title="Automated Billing" icon="bolt">
    Integrated real-time event tracking that automatically bills customers
  </Card>
</CardGroup>


# Usage-Based Billing Integration guide
Source: https://docs.dodopayments.com/developer-resources/usage-based-billing-guide

Learn how to set up meters and send usage events to enable accurate usage-based billing with Dodo Payments.

<CardGroup>
  <Card title="API Reference - Events Ingestion" icon="code" href="/api-reference/usage-events/ingest-events">
    Access the complete API documentation for ingesting usage events and test event ingestion requests and responses interactively.
  </Card>

  <Card title="API Reference - Meters Creation" icon="code" href="/api-reference/meters/create-meter">
    Explore the full API documentation for creating meters and interactively test meter creation requests and responses.
  </Card>
</CardGroup>

## Creating a Meter

Meters define how your usage events are aggregated and measured for billing purposes.

Before creating a meter, plan your usage tracking strategy:

* Identify what usage events you want to track
* Determine how events should be aggregated (count, sum, etc.)
* Define any filtering requirements for specific use cases

### Step-by-Step Meter Creation

Follow this comprehensive guide to set up your usage meter:

<Steps>
  <Step title="Configure Basic Information">
    Set up the fundamental details for your meter.

    <ParamField type="string">
      Choose a clear, descriptive name that identifies what this meter tracks.

      Examples: "Tokens", "API Calls", "Storage Usage", "Compute Hours"
    </ParamField>

    <ParamField type="string">
      Provide a detailed explanation of what this meter measures.

      Example: "Counts each POST /v1/orders request made by the customer"
    </ParamField>

    <ParamField type="string">
      Specify the event identifier that will trigger this meter.

      Examples: "token", "api.call", "storage.usage", "compute.session"
    </ParamField>

    <Info>
      The event name must match exactly what you send in your usage events. Event names are case-sensitive.
    </Info>
  </Step>

  <Step title="Configure Aggregation Settings">
    Define how the meter calculates usage from your events.

    <ParamField type="string">
      Select how events should be aggregated:

      <Tabs>
        <Tab title="Count">
          Simply counts the number of events received.

          Use case: API calls, page views, file uploads

          Calculation: Total number of events
        </Tab>

        <Tab title="Sum">
          Adds up values from a specific property in your events.

          Use case: Data transfer, storage consumption, processing time

          Calculation: Sum of all property values
        </Tab>

        <Tab title="Max">
          Records the highest value of a specific property during the billing period.

          Use case: Peak concurrent users, maximum storage used, highest bandwidth

          Calculation: Maximum property value observed
        </Tab>

        <Tab title="Last">
          Uses the most recent value of a specific property.

          Use case: Current plan tier, latest configuration setting

          Calculation: Last recorded property value
        </Tab>
      </Tabs>
    </ParamField>

    <ParamField type="string">
      The property name from event metadata to aggregate over.

      <Warning>
        This field is required when using Sum, Max, or Last aggregation types.
      </Warning>
    </ParamField>

    <ParamField type="string">
      Define the unit label for display purposes in reports and billing.

      Examples: "calls", "GB", "hours", "tokens"
    </ParamField>
  </Step>

  <Step title="Configure Event Filtering (Optional)">
    Set up criteria to control which events are included in the meter.

    <Info>
      Event filtering allows you to create sophisticated rules that determine which events contribute to your usage calculations. This is useful for excluding test events, filtering by user tiers, or focusing on specific actions.
    </Info>

    **Enable Event Filtering**

    Toggle **Enable Event Filtering** to activate conditional event processing.

    **Choose Filter Logic**

    Select how multiple conditions are evaluated:

    <Tabs>
      <Tab title="AND Logic">
        All conditions must be true for an event to be counted. Use this when you need events to meet multiple strict criteria simultaneously.

        **Example:** Count API calls where `user_tier = "premium"` AND `endpoint = "/api/v2/users"`
      </Tab>

      <Tab title="OR Logic">
        At least one condition must be true for an event to be counted. Use this when you want to include events that meet any of several criteria.

        **Example:** Count events where `method = "POST"` OR `method = "PUT"` OR `method = "DELETE"`
      </Tab>
    </Tabs>

    **Setting Up Filter Conditions**

    <Steps>
      <Step title="Add Condition">
        Click **Add condition** to create a new filter rule.
      </Step>

      <Step title="Configure Property Key">
        Specify the property name from your event metadata.
      </Step>

      <Step title="Select Comparator">
        Choose from available operators:

        * `equals` - Exact match
        * `not equals` - Exclusion filter
        * `greater than` - Numeric comparison
        * `greater than or equals` - Numeric comparison (inclusive)
        * `less than` - Numeric comparison
        * `less than or equals` - Numeric comparison (inclusive)
        * `contains` - String contains substring
        * `does not contain` - String exclusion filter
      </Step>

      <Step title="Set Comparison Value">
        Set the target value for comparison.
      </Step>

      <Step title="Add Groups">
        Use **Add Group** to create additional condition groups for complex logic.
      </Step>
    </Steps>

    <Warning>
      Filtered properties must be included in your event metadata for the conditions to work properly. Events missing required properties will be excluded from counting.
    </Warning>
  </Step>

  <Step title="Create Meter">
    Review your meter configuration and click on **Create Meter**.

    <Check>
      Your meter is now ready to receive and aggregate usage events.
    </Check>
  </Step>
</Steps>

## Linking Meter in a Product

Once you have created your meter, you need to link it to a product to enable usage-based billing. This process connects your meter's usage data to pricing rules for customer billing.

Linking meters to products establishes the connection between usage tracking and billing:

* Products define pricing rules and billing behavior
* Meters provide usage data for billing calculations
* Multiple meters can be linked to a single product for complex billing scenarios

### Product Configuration Process

Transform your usage data into billable charges by properly configuring your product settings:

<Steps>
  <Step title="Choose Usage-Based Billing Product Type">
    Navigate to your product creation or editing page and select **Usage-Based** as the product type.
  </Step>

  <Step title="Select Associated Meter">
    Click on **Associated Meter** to open the meter selection panel from the side.

    This panel allows you to configure which meters will track usage for this product.
  </Step>

  <Step title="Add Your Meter">
    In the meter selection panel:

    1. Click **Add Meters** to view available meters
    2. Select the meter you created from the dropdown list
    3. The selected meter will appear in your product configuration
  </Step>

  <Step title="Configure Price Per Unit">
    Set the pricing for each unit of usage tracked by your meter.

    <ParamField type="number">
      Define how much to charge for each unit measured by your meter.

      **Example**: Setting `$0.50` per unit means:

      * 1,000 units consumed = 1,000 × \$0.50 = 500.00 charged
      * 500 units consumed = 500 × \$0.50 = 250.00 charged
      * 100 units consumed = 100 × \$0.50 = 50.00 charged
    </ParamField>
  </Step>

  <Step title="Set Free Threshold (Optional)">
    Configure a free usage allowance before billing begins.

    <ParamField type="number">
      Number of units customers can consume at no charge before paid usage calculation starts.

      **How it works**:

      * Free threshold: 100 units
      * Price per unit: \$0.50
      * Customer usage: 250 units
      * **Calculation**: (250 - 100) × $0.50 = **$75.00\*\* charged
    </ParamField>

    <Info>
      Free thresholds are ideal for freemium models, trial periods, or providing customers with a base allowance included in their plan.
    </Info>

    <Check>
      The free threshold applies to each billing cycle, giving customers fresh allowances monthly or according to your billing schedule.
    </Check>
  </Step>

  <Step title="Save Configuration">
    Review your meter and pricing configuration, then click **Save Changes** to finalize the setup.

    <Check>
      Your product is now configured for usage-based billing and will automatically charge customers based on their measured consumption.
    </Check>

    **What happens next**:

    * Usage events sent to your meter will be tracked and aggregated
    * Billing calculations will apply your pricing rules automatically
    * Customers will be charged based on actual consumption during each billing cycle
  </Step>
</Steps>

<Note>
  Remember that you can add up to 10 meters per product, enabling sophisticated usage tracking across multiple dimensions like API calls, storage, compute time, and custom metrics.
</Note>

## Sending Usage Events

Once your meter is configured, you can start sending usage events from your application to track customer usage.

### Event Structure

Each usage event must include these required fields:

<ParamField type="string">
  Unique identifier for this specific event. Must be unique across all events.
</ParamField>

<ParamField type="string">
  The Dodo Payments customer ID this usage should be attributed to.
</ParamField>

<ParamField type="string">
  The event name that matches your meter configuration. Event names trigger the appropriate meter.
</ParamField>

<ParamField type="string">
  ISO 8601 timestamp when the event occurred. Defaults to current time if not provided.
</ParamField>

<ParamField type="object">
  Additional properties for filtering and aggregation. Include any values referenced in your meter's "Over Property" or filtering conditions.
</ParamField>

### Usage Events API Examples

Send usage events to your configured meters using the Events API:

<CodeGroup>
  ```javascript Node.js theme={null}
  const response = await fetch('https://test.dodopayments.com/events/ingest', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.DODO_API_KEY}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      events: [
        {
          event_id: "api_call_1234",
          customer_id: "cus_atXa1lklCRRzMicTqfiw2", 
          event_name: "api.call",
          timestamp: new Date().toISOString(),
          metadata: {
            endpoint: "/v1/orders",
            method: "POST",
            response_size: 1024
          }
        }
      ]
    })
  });
  ```

  ```python Python theme={null}
  import requests
  from datetime import datetime

  response = requests.post(
      'https://test.dodopayments.com/events/ingest',
      headers={
          'Authorization': f'Bearer {api_key}',
          'Content-Type': 'application/json'
      },
      json={
          'events': [
              {
                  'event_id': 'api_call_1234',
                  'customer_id': 'cus_atXa1lklCRRzMicTqfiw2',
                  'event_name': 'api.call',
                  'timestamp': datetime.now().isoformat(),
                  'metadata': {
                      'endpoint': '/v1/orders',
                      'method': 'POST',
                      'response_size': 1024
                  }
              }
          ]
      }
  )
  ```

  ```curl cURL theme={null}
  curl -X POST 'https://test.dodopayments.com/events/ingest' \
    -H 'Authorization: Bearer YOUR_API_KEY' \
    -H 'Content-Type: application/json' \
    -d '{
      "events": [
        {
          "event_id": "api_call_1234",
          "customer_id": "cus_atXa1lklCRRzMicTqfiw2",
          "event_name": "api.call", 
          "timestamp": "2024-01-15T10:30:00Z",
          "metadata": {
            "endpoint": "/v1/orders",
            "method": "POST",
            "response_size": 1024
          }
        }
      ]
    }'
  ```
</CodeGroup>

## Usage-Based Billing Analytics

Monitor and analyze your usage-based billing data with comprehensive analytics dashboard. Track customer consumption patterns, meter performance, and billing trends to optimize your pricing strategy and understand usage behaviors.

### Overview Analytics

The Overview tab provides a comprehensive view of your usage-based billing performance:

#### Activity Metrics

Track key usage statistics across different time periods:

<ParamField type="metric">
  Shows usage activity for the current billing period, helping you understand monthly consumption patterns.
</ParamField>

<ParamField type="metric">
  Displays cumulative usage statistics since you started tracking, providing long-term growth insights.
</ParamField>

<Tip>
  Use the time period selector to compare usage across different months and identify seasonal trends or growth patterns.
</Tip>

#### Meter Quantities Chart

<Frame>
  <img alt="Meter quantities chart showing usage trends over time with purple gradient visualization" />
</Frame>

The meter quantities chart visualizes usage trends over time with the following features:

* **Time-series visualization**: Track usage patterns across days, weeks, or months
* **Multiple meter support**: View data from different meters simultaneously
* **Trend analysis**: Identify usage spikes, patterns, and growth trajectories

<Info>
  The chart automatically scales based on your usage volume and selected time range, providing clear visibility into both small fluctuations and major usage changes.
</Info>

### Events Analytics

<Frame>
  <img alt="Events table showing event names, IDs, and pagination controls for detailed event analysis" />
</Frame>

The Events tab provides granular visibility into individual usage events:

#### Event Information Display

The events table provides a clear view of individual usage events with the following columns:

* **Event Name**: The specific action or trigger that generated the usage event
* **Event ID**: Unique identifier for each event instance
* **Customer ID**: The customer associated with the event
* **Timestamp**: When the event occurred

<Info>
  This view allows you to track and monitor individual usage events across your customer base, providing transparency into billing calculations and usage patterns.
</Info>

### Customer Analytics

The Customers tab provides a detailed table view of customer usage data with the following information:

#### Available Data Columns

<ParamField type="string">
  Email address of the customer for identification.
</ParamField>

<ParamField type="string">
  Unique identifier for the customer's subscription.
</ParamField>

<ParamField type="number">
  Number of free units included in the customer's plan before charges apply.
</ParamField>

<ParamField type="currency">
  The cost per unit for usage beyond the free threshold.
</ParamField>

<ParamField type="timestamp">
  Timestamp of the customer's most recent usage event.
</ParamField>

<ParamField type="currency">
  Total amount charged to the customer for usage-based billing.
</ParamField>

<ParamField type="number">
  Total number of units the customer has consumed.
</ParamField>

<ParamField type="number">
  Number of units that exceed the free threshold and are being charged.
</ParamField>

#### Table Features

* **Column Filtering**: Use the "Edit Columns" feature to show/hide specific data columns
* **Real-time Updates**: Usage data reflects the most current consumption metrics

## Aggregation Examples

Here are practical examples of how different aggregation types work:

### Understanding Aggregation Types

Different aggregation types serve different billing scenarios. Choose the right type based on how you want to measure and charge for usage.

### Practical Implementation Examples

These examples demonstrate real-world applications of each aggregation type with sample events and expected results.

<AccordionGroup>
  <Accordion title="Count Aggregation - API Calls">
    Scenario: Track the total number of API requests

    Meter Configuration:

    * Event Name: `api.call`
    * Aggregation Type: Count
    * Measurement Unit: `calls`

    **Sample Events**:

    ```json theme={null}
    {
      "events": [
        {"event_id": "call_1", "customer_id": "cus_123", "event_name": "api.call"},
        {"event_id": "call_2", "customer_id": "cus_123", "event_name": "api.call"},
        {"event_id": "call_3", "customer_id": "cus_123", "event_name": "api.call"}
      ]
    }
    ```

    Result: 3 calls billed to customer
  </Accordion>

  <Accordion title="Sum Aggregation - Data Transfer">
    Scenario: Bill based on total bytes transferred

    Meter Configuration:

    * Event Name: `data.transfer`
    * Aggregation Type: Sum
    * Over Property: `bytes`
    * Measurement Unit: `GB`

    **Sample Events**:

    ```json theme={null}
    {
      "events": [
        {
          "event_id": "transfer_1",
          "customer_id": "cus_123", 
          "event_name": "data.transfer",
          "metadata": {"bytes": 1073741824}
        },
        {
          "event_id": "transfer_2",
          "customer_id": "cus_123",
          "event_name": "data.transfer", 
          "metadata": {"bytes": 536870912}
        }
      ]
    }
    ```

    Result: 1.5 GB total transfer billed to customer
  </Accordion>

  <Accordion title="Max Aggregation - Peak Concurrent Users">
    Scenario: Bill based on highest concurrent user count

    Meter Configuration:

    * Event Name: `concurrent.users`
    * Aggregation Type: Max
    * Over Property: `count`
    * Measurement Unit: `users`

    **Sample Events**:

    ```json theme={null}
    {
      "events": [
        {
          "event_id": "peak_1",
          "customer_id": "cus_123",
          "event_name": "concurrent.users", 
          "metadata": {"count": 15}
        },
        {
          "event_id": "peak_2",
          "customer_id": "cus_123",
          "event_name": "concurrent.users",
          "metadata": {"count": 23}
        },
        {
          "event_id": "peak_3",
          "customer_id": "cus_123",
          "event_name": "concurrent.users",
          "metadata": {"count": 18}
        }
      ]
    }
    ```

    Result: 23 peak concurrent users billed to customer
  </Accordion>
</AccordionGroup>

### Event Filtering Examples

<Tabs>
  <Tab title="Filter by API Endpoint">
    Only count API calls to specific endpoints:

    Filter Configuration:

    * Property: `endpoint`
    * Comparator: `equals`
    * Value: `/v1/orders`

    Sample Event:

    ```json theme={null}
    {
      "event_id": "call_1",
      "customer_id": "cus_123",
      "event_name": "api.call",
      "metadata": {
        "endpoint": "/v1/orders",
        "method": "POST"
      }
    }
    ```

    Result: Events matching the filter criteria would be counted. Events with different endpoints would be ignored.
  </Tab>

  <Tab title="Filter by Value Range">
    Only count large file uploads:

    Filter Configuration:

    * Property: `file_size`
    * Comparator: `greater_than`
    * Value: `1048576` (1MB in bytes)

    Sample Event:

    ```json theme={null}
    {
      "event_id": "upload_1",
      "customer_id": "cus_123", 
      "event_name": "file.upload",
      "metadata": {
        "file_size": 5242880,
        "file_type": "image"
      }
    }
    ```

    Result: Files larger than 1MB would be counted. Smaller files would be ignored.
  </Tab>

  <Tab title="Complex Multi-Condition Filters">
    Count premium API calls during business hours:

    Filter Configuration (using AND logic):

    * Property: `plan_type`, Comparator: `equals`, Value: `premium`
    * Property: `hour`, Comparator: `greater_than_or_equal`, Value: `9`
    * Property: `hour`, Comparator: `less_than`, Value: `17`

    Sample Event:

    ```json theme={null}
    {
      "event_id": "call_1",
      "customer_id": "cus_123",
      "event_name": "api.call",
      "metadata": {
        "plan_type": "premium",
        "hour": 14,
        "endpoint": "/v1/analytics"
      }
    }
    ```

    Result: Premium API calls during business hours (9 AM - 5 PM) would be counted.
  </Tab>
</Tabs>

## Troubleshooting

Resolve common issues with usage-based billing implementation and ensure accurate tracking and billing.

### Common Issues

Most usage-based billing problems fall into these categories:

* Event delivery and processing issues
* Meter configuration problems
* Data type and formatting errors
* Customer ID and authentication issues

### Debugging Steps

When troubleshooting usage-based billing:

1. Verify event delivery in the Events analytics tab
2. Check meter configuration matches your event structure
3. Validate customer IDs and API authentication
4. Review filtering conditions and aggregation settings

### Solutions and Fixes

<AccordionGroup>
  <Accordion title="Events not showing in meter">
    Common causes:

    * Event name doesn't exactly match meter configuration
    * Event filtering conditions are excluding your events
    * Customer ID doesn't exist in your Dodo Payments account
    * Event timestamp is outside the current billing period

    Solutions:

    * Verify event name spelling and case sensitivity
    * Review and test your filtering conditions
    * Confirm customer ID is valid and active
    * Check event timestamps are recent and properly formatted
  </Accordion>

  <Accordion title="Aggregation not working as expected">
    Common causes:

    * Over Property name doesn't match event metadata keys
    * Metadata values are wrong data type (string vs number)
    * Missing required metadata properties

    Solutions:

    * Ensure metadata keys exactly match your Over Property setting
    * Convert string numbers to actual numbers in your events
    * Include all required properties in every event
  </Accordion>

  <Accordion title="Filtering not working">
    Common causes:

    * Filter property names don't match event metadata
    * Wrong comparator for data type (string vs number)
    * Case sensitivity in string comparisons

    Solutions:

    * Double-check property names match exactly
    * Use appropriate comparators for your data types
    * Consider case sensitivity when filtering strings
  </Accordion>
</AccordionGroup>


# Bypassing App Store & Play Store Fees using Dodo Payments
Source: https://docs.dodopayments.com/features/bypassing-app-store-fees

Learn how to legally bypass Apple and Google's 30% app store fees using Merchant of Record solutions and compliant payment strategies

## The Platform Tollbooth Problem

For over a decade, Apple and Google have operated their app stores not just as marketplaces, but as powerful toll booths. Any developer or startup offering digital goods within an app was forced to route payments through their respective billing systems: Apple's In-App Purchase (IAP) and Google's Play Billing-while forfeiting up to 30% of revenue.

If that sounds like a steep cut, it's because it absolutely is.

This "store tax" drew widespread criticism, particularly from developers from large apps like Spotify, Epic Games, and Netflix, who found the commissions not only excessive but anti-competitive. Apps couldn't even inform users about cheaper options outside the app. These policies-especially Apple's "anti-steering" rules-made app stores de facto monopolies for digital distribution.

<Warning>
  The 30% app store commission represents a significant revenue drain for digital businesses, especially for subscription-based services and SaaS applications.
</Warning>

## The Epic Games Catalyst

Epic Games' CEO, Tim Sweeney, initiated Project Liberty as a strategic legal campaign to challenge the monopolistic practices of Apple and Google's app stores, particularly their 30% commission fees on in-app purchases. The project aimed to disrupt these platforms' control over app distribution and payments, advocating for a more open environment for developers.

Tim Sweeney knew Apple would contest this and laid a bait. Epic updated Fortnite with a hidden direct-pay option, bypassing Apple's IAP. Apple fell for the bait, swiftly banned Fortnite, and Epic sued.

The Epic Games v. Apple legal battle cracked open the conversation globally.

## The Epic v. Apple Verdict

In 2021, the U.S. District Judge ruled in a landmark decision:

* **Apple did not violate antitrust laws outright**, meaning it could continue to control app distribution on iOS
* **However, Apple's anti-steering policies were deemed anti-competitive**. The court issued a permanent injunction-Apple must allow developers to direct users to external payment methods

After delays and appeals, Apple finally updated its App Store guidelines in May 2025 to allow external purchase links in U.S. apps.

<Check>
  This U.S. ruling spurred similar regulatory pressure and legal action across South Korea, Japan, the EU, and other regions. Combined with the EU's Digital Markets Act (DMA)-the tide turned decisively in favor of developers.
</Check>

## Global Overview: Where Developers Can Legally Bypass Fees

| Region          | Apple Policy (2025)                   | Google Policy (2025)            |
| --------------- | ------------------------------------- | ------------------------------- |
| **USA**         | External links allowed (no Apple fee) | UCB allowed (reduced fee)       |
| **EU (EEA)**    | Alt payments/links allowed (10–17%)   | UCB allowed for non-games       |
| **South Korea** | Apple-approved PSPs (26% fee)         | UCB mandated (26% fee)          |
| **Netherlands** | Dating apps only                      | UCB allowed                     |
| **Japan**       | Reader apps can link out              | UCB allowed                     |
| **India**       | No change                             | UCB allowed (4% fee reduction)  |
| **Other**       | No change                             | UCB allowed in select countries |
| **China**       | No external billing allowed           | Google Play not relevant        |

<Info>
  UCB stands for User Choice Billing, Google's alternative billing system that allows developers to use third-party payment processors.
</Info>

## Pre-2025 Loopholes: How Apps Circumvented App Store Rules

Before regulations loosened their grip, some apps found "creative" ways to get around the 30% cut. These hacks were rarely compliant but undeniably clever.

### Reader App Loophole

One common tactic was the "reader app loophole," where apps like Kindle or Netflix claimed they were merely displaying previously purchased content. Apple couldn't fault apps for letting users access pre-purchased content. So as long as the app didn't explicitly link to external payment or prompt an in-app purchase, it was allowed to operate.

### Hidden Payment Redirections

Others experimented with code obfuscation, embedding hidden payment redirections. A few even used email notifications post-download to nudge users to pay outside the app.

<Note>
  Spotify was one such company that implemented this strategy. If you're in India and use Spotify, you've probably noticed that you can't buy the Premium plan inside the app. You have to pay on the web. This is why.
</Note>

All of this was risky, brittle, and usually led to takedowns once discovered. But it underscored one thing: developers were desperate to reclaim control over their margins and user data.

## The Payment Gateway Trap: What Developers Often Miss

At first glance, payment gateways (PGs) like Stripe or Razorpay seem like the obvious solution. But for in-app purchases, it's not that simple.

<Warning>
  If you're on iOS outside of allowed regions (like India or China), plugging in a PG directly into the app violates Apple's policies, risking an app takedown.
</Warning>

Even where it is legal, PGs come with limitations: they don't solve for tax compliance across geographies, invoicing, refund management, or regulatory filings.

That's where Merchant-of-Record (MoR) platforms like Dodo Payments come in. We handle the full stack: payments, taxes, documentation, customer support, and legal accountability.

It's not just about collecting money. It's about doing it cleanly, globally, and without risking your App Store listing.

## Two Legal Workarounds for Developers

### 1. App-to-Web Redirect (Link Out Flow)

**What it is:** The app links users to a web-based checkout (hosted by Dodo Payments or the developer). Payment is completed outside the app, then access is granted in-app.

**Legal Status:**

* **iOS:** Legal in US, EU, South Korea, Netherlands (only dating apps), Japan (only reader apps)
* **Android:** Legal in all UCB-supported markets

**Advantages:**

* Simple to implement
* Fully compliant
* No app-side PCI burden

**Drawbacks:**

* Slight friction - user leaves app to pay

### 2. In-App SDK Integration (Third-Party SDK)

**What it is:** Embed a payment UI - such as <a href="/developer-resources/react-native-integration">Dodo's React Native SDK</a> - directly in your app to enable seamless checkout without requiring users to leave the app.

**Legal Status:**

* **iOS:** Legal only in EU (under DMA terms); elsewhere it's still a violation
* **Android:** Legal in UCB markets, if proper UX and reporting are followed

**Advantages:**

* Smooth UX
* User stays in app
* Can match IAP experience

**Drawbacks:**

* Integration complexity
* Compliance risk outside allowed regions

## Developer Strategy: Combine Legal Compliance with Revenue Efficiency

An effective global rollout strategy could look like this:

<Steps>
  <Step title="U.S. Users">
    Use App-to-Web (no Apple cut)
  </Step>

  <Step title="EU Users">
    Use In-App SDK or App-to-Web (10–17% Apple cut)
  </Step>

  <Step title="Android Users in UCB Markets">
    Use In-App SDK with Google-compliant UX
  </Step>

  <Step title="Other iOS Markets">
    Use Apple IAP (or omit in-app purchases)
  </Step>

  <Step title="Other Android Markets">
    Use Google Play billing or distribute via alt app stores
  </Step>
</Steps>

## The Biggest Opportunity

Among all the regulatory changes, the U.S. App Store presents the single largest opportunity for developers. With the 2025 guideline update following the Epic v. Apple ruling, developers can now legally include external links in their iOS apps that direct users to a web-based checkout.

This means: **no mandatory Apple IAP, no 30% fee, and full control over customer relationships and revenue.**

Given that the U.S. is the largest app revenue market globally, this change alone can significantly improve margins for any digital product business from subscriptions and SaaS tools to media and learning apps. For many, it's a 30% revenue unlock in their most lucrative geography.

<Tip>
  The U.S. market represents the largest opportunity for revenue recovery, with developers able to bypass the full 30% Apple commission through compliant external payment links.
</Tip>

## How Dodo Payments Enables This

Dodo Payments acts as a Merchant of Record, handling:

* **Global tax compliance** (VAT/GST)
* **Payment processing** (cards, UPI, wallets)
* **Invoicing, refunds, fraud prevention**
* **SDK & hosted checkout integration**

This simplifies compliance and operational load while offering fee-saving alternatives that are 100% legal in supported regions.

<CardGroup>
  <Card title="Get Started" icon="rocket" href="/quickstart">
    Begin your integration with Dodo Payments
  </Card>

  <Card title="Mobile Integration" icon="mobile" href="/developer-resources/mobile-integration">
    Learn how to integrate payments in your mobile app
  </Card>
</CardGroup>

## Conclusion: A Developer-Friendly Future Is Here

For years, the 30% store tax was a take-it-or-leave-it ultimatum. Thanks to landmark cases like Epic v. Apple, regulatory pushback, and public pressure, that model is no longer universally enforceable.

In 2025, developers finally have choices.

By combining compliant workarounds like App-to-Web flows or SDK integrations with services like Merchant-of-Record platforms like Dodo Payments, it's now practically and legally feasible to retain more revenue and control.

The app stores haven't opened the gates willingly but the gates are opening. And for developers, it's time to walk through.

<Check>
  The future of app monetization is here-one where developers can legally bypass excessive platform fees while maintaining compliance and user experience.
</Check>


# Feature Request and Roadmap
Source: https://docs.dodopayments.com/features/feature-request

We value feedback from our merchants and aim to continuously improve Dodo Payments to meet your business needs. Submit feature requests, vote on existing ideas, and track our public roadmap through Featurebase.

We use [Featurebase](https://dodopayments.featurebase.app/) to manage feature requests and maintain our public roadmap. This platform allows you to submit ideas, vote on features you'd like to see, and track the development status of upcoming improvements.

<Card title="Visit Our Public Roadmap" icon="external-link" href="https://dodopayments.featurebase.app/">
  View all feature requests, vote on ideas, and track our product roadmap on Featurebase.
</Card>

## **Request a New Feature**

If you have an idea for a feature that would enhance your experience with Dodo Payments, you can submit a feature request directly on Featurebase.

<img alt="Feature Request" />

* **How to Request a Feature**:
  1. Visit our [Featurebase portal](https://dodopayments.featurebase.app/).
  2. Click on **"Post an idea"** or **"Submit a feature request"**.
  3. Provide the following details:
     * **Feature Name**: A concise title for your feature idea.
     * **Feature Description**: A brief explanation of the feature, including why it's important and how it will help your business.
  4. Submit the request.
* **Tips for Effective Requests**:
  * Be clear and concise.
  * Highlight the business impact of the feature.
  * Provide examples, if applicable.
  * Include use cases that demonstrate the value.

## **Vote for Existing Feature Requests**

We prioritize features that benefit the most merchants. You can browse existing feature requests on Featurebase and vote for those you find valuable.

* **How to Vote**:
  1. Visit our [Featurebase portal](https://dodopayments.featurebase.app/).
  2. Browse through the list of submitted requests.
  3. Click the **upvote** button (👍) next to the feature(s) you support.
* **Benefits of Voting**:
  * Influence the development priority for features you care about.
  * Help our team identify features that have widespread demand.
  * Get notified when features you've voted for are released.

## **View the Product Roadmap**

Stay informed about the status of feature development through our public roadmap on Featurebase.

* **Roadmap Features**:
  * **Planned**: Features that have been approved and are scheduled for development.
  * **In Progress**: Features currently being worked on by our team.
  * **Completed**: Features that have been successfully implemented and are live.
* **How to Access**:
  * Visit our [Featurebase portal](https://dodopayments.featurebase.app/).
  * Navigate to the **Roadmap** section to view features by status.
  * Browse the feature categories and their current statuses.
  * Filter by status, category, or search for specific features.

<Tip>
  Bookmark our [Featurebase portal](https://dodopayments.featurebase.app/) to stay updated on new features and vote on ideas that matter to you.
</Tip>


# Android & iOS Mobile App
Source: https://docs.dodopayments.com/features/mobile-app

Manage your Dodo Payments business on the go with our mobile app, available on Google Play and Apple App Store. Monitor transactions, receive real-time notifications, and access your dashboard anywhere.

## Introduction

<Frame>
  <iframe title="Mobile App | Dodo Payments" />
</Frame>

Manage your payments, subscriptions, and business activity — anytime, anywhere. The **Dodo Payments Mobile App** brings the power of the Dodo Dashboard to your fingertips, allowing you to stay connected to your revenue, customers, and activity in real time.

Whether you're commuting, traveling, or just away from your desk, you'll never miss an important update again.

## Key Features

<CardGroup>
  <Card title="Real-time Notifications" icon="bell">
    Get instant alerts for new transactions, payouts, subscription renewals, and verification status updates
  </Card>

  <Card title="Dashboard on the Go" icon="chart-line">
    View your revenue, transaction history, customer statistics, and visual performance graphs
  </Card>

  <Card title="Subscription Management" icon="repeat">
    Monitor all active subscriptions and check individual customer details
  </Card>

  <Card title="Product Management" icon="box">
    Create and manage products directly from your mobile device
  </Card>
</CardGroup>

## Parity with Desktop Dashboard

All the features of the desktop version are fully available in the mobile app, including:

* Test Mode and Live Mode switching
* Verification progress and submission
* Developer settings and API key visibility
* Pricing and Discount configuration

## Download Now

<CardGroup>
  <Card title="Android" icon="google-play" href="https://play.google.com/store/apps/details?id=com.dodopayments.app">
    Download from Google Play Store
  </Card>

  <Card title="iOS" icon="apple" href="https://apps.apple.com/in/app/dodo-payments/id6743651329">
    Download from Apple App Store
  </Card>
</CardGroup>


# Introduction
Source: https://docs.dodopayments.com/features/mor-introduction

Dodo Payments acts as your Merchant of Record, handling global payments, tax compliance, fraud protection, and regulatory liability so you can focus on building your product.

Dodo Payments operates as a **Merchant of Record (MoR)** — we become the legal seller of your digital products, taking on the responsibility for payments, taxes, fraud, and compliance so you can focus entirely on building your product.

<CardGroup>
  <Card title="220+ Regions" icon="globe">
    Tax compliance handled automatically
  </Card>

  <Card title="30+ Payment Methods" icon="credit-card">
    Cards, wallets, and local methods
  </Card>

  <Card title="Zero Tax Filing" icon="file-invoice">
    We handle all remittance
  </Card>
</CardGroup>

## What Is a Merchant of Record?

A **Merchant of Record** is the legal entity that appears on your customer's credit card statement and assumes responsibility for the transaction. When you use Dodo Payments as your MoR:

* **We are the legal seller** — Dodo appears on bank statements and receipts
* **You are the product creator** — You build, price, and deliver your product
* **We handle the back office** — Taxes, disputes, compliance, and billing support
* **You receive net payouts** — Revenue deposited directly to your account

```mermaid theme={null}
flowchart LR
    A[👤 Customer] -->|💳 Pays| B[🏦 Dodo]
    B -->|📋 Tax| C[🏛️ Tax Authority]
    B -->|💰 Payout| D[💼 You]
```

<Note>
  Think of a Merchant of Record as hiring a global finance team that handles invoicing, taxes, and billing in every country — without you lifting a finger.
</Note>

## Why Use a Merchant of Record?

Selling digital products globally means navigating VAT in Europe, GST in Australia, Sales Tax in the US, and countless other requirements. Each jurisdiction has different rules, rates, thresholds, and filing deadlines.

| Your Responsibility     |    Without MoR   | With Dodo as MoR |
| ----------------------- | :--------------: | :--------------: |
| VAT/GST Registration    |       ❌ You      |      ✅ Dodo      |
| Tax Calculation         |       ❌ You      |      ✅ Dodo      |
| Tax Filing & Remittance |       ❌ You      |      ✅ Dodo      |
| Chargeback Liability    |       ❌ You      |      ✅ Dodo      |
| PCI Compliance          |       ❌ You      |      ✅ Dodo      |
| Multi-Currency Support  |     ❌ Complex    |    ✅ Built-in    |
| Local Payment Methods   | ❌ Integrate Each |  ✅ 30+ Included  |

<Tip>
  **Example**: Selling a €50/month subscription to a French customer?

  **Without MoR**: Register for French VAT, charge €60 (20% VAT), file quarterly French returns, handle audits—in French.

  **With Dodo**: We collect €60, remit €10 VAT to France, and pay you €50 minus fees. You write code.
</Tip>

## PSP vs. MoR: Key Differences

Understanding the difference between a **Payment Service Provider** (like Stripe) and a **Merchant of Record** is essential.

### Payment Service Provider (PSP)

A PSP processes transactions but leaves you as the legal seller:

```mermaid theme={null}
flowchart LR
    A[👤 Customer] --> B[🌐 Your Site]
    B --> C[💳 PSP]
    C --> D[🏦 Your Bank]
    
    D -.->|⚠️ You Handle| E[📋 Taxes]
    D -.->|⚠️ You Handle| F[⚖️ Disputes]
    D -.->|⚠️ You Handle| G[📜 Compliance]
```

<Warning>
  With a PSP, **you** are responsible for tax registration, collection, filing, and remittance in every jurisdiction where you have customers.
</Warning>

### Merchant of Record (Dodo)

An MoR becomes the legal seller, handling compliance end-to-end:

```mermaid theme={null}
flowchart LR
    A[👤 Customer] --> B[🛒 Dodo Checkout]
    B --> C[🏦 Dodo Payments]
    C --> D[💰 Your Wallet]
    
    C -.->|✅ Handled| E[📋 Taxes]
    C -.->|✅ Handled| F[⚖️ Disputes]
    C -.->|✅ Handled| G[📜 Compliance]
```

<Check>
  With Dodo as MoR, we handle taxes, disputes, and compliance. You receive net payouts with zero paperwork.
</Check>

### Side-by-Side Comparison

| Aspect                | PSP (Stripe, etc.) | MoR (Dodo) |
| --------------------- | :----------------: | :--------: |
| Legal Seller          |    Your Company    |    Dodo    |
| On Customer Statement |      Your Name     |    Dodo    |
| Tax Registration      |        ❌ You       |   ✅ Dodo   |
| Tax Calculation       |        ❌ You       |   ✅ Dodo   |
| Tax Remittance        |        ❌ You       |   ✅ Dodo   |
| Chargeback Risk       |        ❌ You       |   ✅ Dodo   |
| PCI Compliance        |        ❌ You       |   ✅ Dodo   |
| Setup for Global      |       Complex      |   Simple   |

<Info>
  **Important**: Both PSPs and MoRs handle payment processing. The key difference is **who is legally responsible** for tax compliance and transaction liability.
</Info>

## How Tax Compliance Works

Dodo handles the entire tax lifecycle automatically:

<Steps>
  <Step title="Customer Location">
    We detect the customer's country and determine which tax rules apply — VAT, GST, Sales Tax, or other local requirements.
  </Step>

  <Step title="Rate Calculation">
    The correct tax rate is calculated based on product type, customer location, and B2B/B2C status. EU business customers with valid VAT numbers get reverse charge applied.
  </Step>

  <Step title="Collection at Checkout">
    Tax is clearly displayed and collected at checkout. Customers see exactly what they're paying.
  </Step>

  <Step title="Filing & Remittance">
    We file returns and pay collected taxes to the relevant authorities on schedule. You never see a tax form.
  </Step>
</Steps>

## Revenue Flow

Here's how money moves from customer to your account:

```mermaid theme={null}
flowchart LR
    A[👤 Customer<br/>Pays $200] -->|incl. $30 tax| B[🏦 Dodo Payments]
    B -->|$30| C[🏛️ Tax Authority]
    B -->|$162.40| D[💼 You]
```

### Example Payout Breakdown

| Line Item              |       Amount |
| ---------------------- | -----------: |
| Customer Payment       |     \$200.00 |
| Sales Tax (15% VAT)    |     −\$30.00 |
| Dodo Platform Fee (4%) |      −\$8.00 |
| Payment Processing     |      −\$0.60 |
| **Your Payout**        | **\$162.40** |

## When to Choose MoR vs. PSP

<Tabs>
  <Tab title="Choose Dodo (MoR)">
    **Dodo Payments is ideal if you:**

    * Sell digital products, SaaS, or subscriptions
    * Have customers across multiple countries
    * Want to avoid tax registration headaches
    * Prefer predictable, outsourced compliance
    * Value speed to market over maximum control
    * Don't want to manage disputes and fraud
  </Tab>

  <Tab title="Consider a PSP">
    **A PSP might suit you if you:**

    * Operate primarily in one country
    * Have in-house finance and compliance teams
    * Need absolute control over checkout UX
    * Work with extremely thin margins
    * Sell physical goods (MoRs focus on digital)
  </Tab>
</Tabs>

<Note>
  Many businesses start with a PSP and switch to an MoR as they scale internationally. Dodo offers migration support to make this transition seamless.
</Note>

## Frequently Asked Questions

<AccordionGroup>
  <Accordion title="What appears on my customer's credit card statement?">
    Dodo Payments appears as the merchant. We include your product/brand reference where character limits allow, and customers receive detailed receipts showing your product information.
  </Accordion>

  <Accordion title="Do I still own the customer relationship?">
    Yes. You control pricing, branding, product delivery, and direct communication. Dodo handles billing mechanics, but customers know they're buying from you. Your brand appears prominently in checkout, emails, and invoices.
  </Accordion>

  <Accordion title="How does B2B VAT reverse charge work?">
    For B2B sales in the EU, customers can enter their VAT number at checkout. We validate it and apply reverse charge automatically — the tax shifts to the buyer's VAT return instead of being collected.
  </Accordion>

  <Accordion title="Can I use my own payment processor?">
    Dodo operates as a complete solution using our payment infrastructure. This integration is what allows us to assume tax and fraud liability. We are working on providing an integration with other payment processors in the future.
  </Accordion>

  <Accordion title="How do refunds work?">
    Initiate refunds from your dashboard. We process the refund in the customer's original payment method and currency. Tax amounts are automatically adjusted and reconciled.
  </Accordion>

  <Accordion title="What about my income tax?">
    Dodo handles **sales taxes** (VAT, GST, Sales Tax) on customer transactions. You remain responsible for your business's income tax, corporate tax, and tax obligations on the payouts you receive.
  </Accordion>

  <Accordion title="Which countries can I sell to?">
    We accept payments from 220+ countries and regions with continuous expansion. See the full list:

    <Card title="Supported Regions" icon="globe" href="/miscellaneous/list-of-countries-we-accept-payments-from">
      View all 220+ countries and regions where we accept payments.
    </Card>
  </Accordion>
</AccordionGroup>

## Get Started

<CardGroup>
  <Card title="Create Account" icon="rocket" href="https://app.dodopayments.com/signup">
    Sign up free and accept global payments in minutes.
  </Card>

  <Card title="MoR vs PG Deep Dive" icon="scale-balanced" href="/features/mor-vs-pg">
    Detailed comparison with examples and use cases.
  </Card>

  <Card title="Acceptance Policy" icon="building-shield" href="/miscellaneous/merchant-acceptance">
    Learn what businesses we support.
  </Card>

  <Card title="Talk to Us" icon="envelope" href="mailto:founders@dodopayments.com">
    Get personalized guidance from our team.
  </Card>
</CardGroup>


# MoR vs PG
Source: https://docs.dodopayments.com/features/mor-vs-pg

When it comes to processing payments globally, digital businesses and SaaS companies are often torn between two models: Merchant of Record (MoR) and Payment Gateway (PG). At Dodo Payments, we believe in simplifying global payments while taking care of compliance, taxes, and local laws - and that's why we operate as a Merchant of Record.

## Introduction

This guide compares the MoR model with the traditional Payment Gateway approach, helping you understand the advantages Dodo Payments brings to your business.

## The Core Difference

| Feature                        | MoR (Dodo Payments)                      | Payment Gateway (Traditional PG)              |
| ------------------------------ | ---------------------------------------- | --------------------------------------------- |
| Legal Seller                   | Dodo Payments (MoR)                      | Your Company                                  |
| Tax Collection & Remittance    | Handled by Dodo                          | You are responsible                           |
| Compliance & Regulatory Burden | Dodo assumes liability                   | You handle local laws and chargebacks         |
| Settlement Currency            | USD, EUR, INR, and 25+ others supported  | Depends on your merchant account              |
| Risk Management                | Built-in fraud and chargeback protection | You set up your own tools (e.g. Stripe Radar) |
| Payouts                        | Aggregated and simplified global payouts | Direct from PG to you, with bank setup        |

## What It Means For You

With **Dodo as MoR**, we become the legal seller to your customers, allowing you to:

* Skip setting up local entities
* Avoid handling VAT, GST, or sales tax
* Offer more payment methods globally
* Reduce legal risk
* Launch faster in new markets

<Note>
  Imagine selling a digital subscription to a user in France. With Dodo Payments, we collect the payment, file VAT with French authorities, and send you the net revenue. No tax headaches. No lawyers. Just growth.
</Note>

Additionally, the MoR model simplifies your entire back office. As your MoR, Dodo handles PCI compliance, fraud detection, currency conversion, and even customer billing support, freeing your team to focus on product and growth.

## Visual Comparison

**Revenue Flow: Payment Gateway**

```mermaid theme={null}
flowchart LR
    A[Customer] --> B[Your Website]
    B --> C["Payment Gateway (e.g. Stripe)"]
    C --> D[Your Bank]
    D -.-> E["You handle: tax, support, refunds, fraud"]
```

**Revenue Flow: Merchant of Record (Dodo)**

```mermaid theme={null}
flowchart LR
    A[Customer] --> B[Dodo Checkout]
    B --> C[Dodo Payments]
    C --> D[Your Wallet]
    C -.-> E["Dodo handles: Tax, Compliance, FX, Fraud, Invoicing"]
```

## Why It Matters for SaaS & Digital Businesses

As your business scales, managing taxes, compliance, and global payment preferences can become overwhelming. With a payment gateway, you're responsible for:

* VAT/GST registration and filing in multiple jurisdictions
* Managing currency conversion and chargebacks
* Providing localized checkout and payment methods

With Dodo Payments as your MoR:

* You expand globally without setting up local entities
* Taxes are calculated, collected, and remitted on your behalf
* You gain access to a library of payment methods tailored to your customers
* We act as your legal buffer and operational partner

<Tip>
  "Think of a payment gateway as a tunnel. Now imagine the Merchant of Record as a tunnel, train, driver, and ticketing staff all-in-one."
</Tip>

## Who Should Use MoR?

Dodo Payments is perfect for:

* SaaS & digital product companies
* Indie creators and solopreneurs
* Global businesses with customers across 100+ countries
* Companies who don't want to manage taxes & compliance in-house

If you're expanding internationally, selling subscriptions, or just want to reduce operational headaches, MoR is the smarter choice.

## When to Use a Payment Gateway Instead

There are cases where using just a payment gateway might make sense:

* Your business operates only in one country
* You already have internal finance and compliance resources
* You require complete control over customer billing experience
* You are highly cost-sensitive with thin margins at scale

<Note>
  For many startups, using a gateway may suffice initially - but as complexity grows, switching to an MoR can save time, reduce risk, and accelerate international growth.
</Note>

## Why Choose Dodo Payments

Dodo Payments offers:

* All-in-one payments, tax, and compliance stack
* Real-time FX and multi-currency support
* Access to 30+ payment methods
* Seat-based billing, subscriptions, and one-time payments
* Automated tax handling in 150+ countries
* Built-in fraud prevention and PCI compliance

Whether you're a solo founder or a scaling SaaS team, Dodo simplifies the complexities of selling globally.

## Learn More

<CardGroup>
  <Card title="Adaptive Currency Support" icon="money-bill-wave" href="/features/adaptive-currency">
    Learn how Dodo automatically presents prices in your customers' local currencies
  </Card>

  <Card title="Supported Payment Methods" icon="credit-card" href="/features/payment-methods">
    Discover the 30+ payment methods available through Dodo Payments
  </Card>
</CardGroup>

## Ready to Switch?

Join 3,000+ digital businesses using Dodo Payments to sell globally, without borders or bottlenecks.

<CardGroup>
  <Card title="Sign Up Free" icon="user-plus" href="https://app.dodopayments.com/signup">
    Create your Dodo Payments account and start selling globally today
  </Card>

  <Card title="Talk to Sales" icon="envelope" href="mailto:founders@dodopayments.com">
    Get personalized guidance from our team
  </Card>
</CardGroup>

<Tip>
  Let Dodo handle the hard stuff - so you can focus on building a great product.
</Tip>


# FAQs
Source: https://docs.dodopayments.com/miscellaneous/faq

Comprehensive answers to common questions about Dodo Payments, covering onboarding, payments, subscriptions, compliance, and technical integration to help you navigate and make the most of our platform.

## Getting Started & Account Setup

<Accordion title="Q1: How do I login to Dodo Payments Dashboard?">
  A: Visit our dashboard and enter the Login email and password shared with you in your welcome email. In case you face any issues please reach out to our support team.
</Accordion>

<Accordion title="Q2: What documents do I need to complete the verification process?">
  A: The documents required for verification include a valid government-issued ID (for identity verification) and business registration documents (for business verification). For details check the [verification process page](/miscellaneous/verification-process).
</Accordion>

<Accordion title="Q3: What happens if my verification is rejected?">
  A: If your verification is rejected, you will receive an email with the reason for rejection. You can contact our support team to resolve any issues, correct documentation, and reapply. The resubmit option will be enabled by our verification team if necessary.
</Accordion>

<Accordion title="Q4: How long does the verification process take?">
  A: The verification process typically takes **24-72 working hours**. However, if additional documents are required, the process may take longer.
</Accordion>

<Accordion title="Q5: I currently do not have a website for my business. Can I submit my company's linkedin page instead?">
  A: We need your website to understand the kind of products you are selling and verify your business for live access. If you do not have a website or are in the process of building one please reach out to us at [support@dodopayments.com](mailto:support@dodopayments.com)
</Accordion>

<Accordion title="Q6: I am an individual and I do not have a registered business. Can I still use dodo payments?">
  A: Yes, we support unregistered businesses as well. You do not need a registered business to use Dodo Payments. You can onboard as an individual and start receiving international payments without any hassle. You will still need to submit Identity Verification forms and Business Verification forms as an unregistered business for us to onboard you.
</Accordion>

<Accordion title="Q7: I want to integrate my other business with Dodo payments. Should I create a new account?">
  A: No, you can manage multiple businesses through a single account. To add a new business, click the + icon in the bottom left corner of the dashboard and select the Add Business option.
  You can refer to /miscellaneous/accounts#managing-multiple-businesses for more details
</Accordion>

<Accordion title="Q8: Should I wait for verification to complete before integrating dodo payments in my system?">
  A: No, there is no need for you to wait. You can start integrating using the Test mode and once your verification is successful you can start making Live payments in production. Learn more about Test and Live modes here,
  /miscellaneous/test-mode-vs-live-mode
</Accordion>

<Accordion title="Q9: How do I get live mode access?">
  A: Once your account is created, you will automatically get access to live mode.
</Accordion>

<Accordion title="Q10: Does Dodo Payments have an affiliate program?">
  A: Yes, we do offer an affiliate program!

  <Card title="Learn more about our affiliate program" icon="users" href="/features/affiliates">
    Discover how to join our affiliate program, commission rates, and how to start earning.
  </Card>
</Accordion>

<Accordion title="Q11: How can I delete the products/customers that I have created?">
  A: Currently, you cannot delete products or customers, as they must be retained for future compliance. However, you can now archive products, which removes them from the active products list while keeping the records for compliance purposes.
</Accordion>

<Accordion title="Q12: How can I have a custom UI for the payments page?">
  A: You can add your business logo and your business name to the payment page. To upload them, visit the business profile page on your dashboard.
</Accordion>

<Accordion title="Q13: Can I update the branding on the checkout page?">
  A: Yes. You can:

  * Go to Dashboard → Settings → Business Setting
  * Update your logo, brand name, and support email.
  * Changes will reflect on both static and dynamic links
</Accordion>

<Accordion title="Q14: Can I embed Dodo Checkout in an iframe?">
  A: No. The hosted checkout flow does not support embedding in an iframe.

  Instead:

  * Redirect users to the Dodo checkout URL
  * Or use our Overlay Checkout Feature. [Overlay Checkout Docs](/developer-resources/overlay-checkout)
</Accordion>

<Accordion title="Q15: Can I create a one-time hosted checkout payment without adding products to Dodo Payments?">
  A: No. Products are mandatory in the Dodo Payments system.
</Accordion>

<Accordion title="Q16: Do you support e-commerce websites?">
  A: No, we do not support e-commerce websites.
</Accordion>

<Accordion title="Q17: Can I switch between brands in Dodo Payments?">
  A: Yes, you can switch between brands for products. You can select the desired brand when creating or editing products in your dashboard.
</Accordion>

<Accordion title="Q18: Can I delete a brand or update the Brand URL in Dodo Payments?">
  A: No, Dodo Payments currently does not support:

  * **Deleting a brand**: If a brand is not in use, you can simply ignore it — it won't affect your account or operations
  * **Changing or updating the Brand URL**: Once created, the Brand URL cannot be modified. Even if the URL is incorrect, it does not impact your setup or functionality
</Accordion>

<Accordion title="Q19: Can I integrate Dodo Payments with Shopify to sell physical products?">
  A: No, Dodo Payments currently does not support physical goods and does not offer a Shopify plugin.
</Accordion>

<Accordion title="Q20: My INR subscription product is showing USD on checkout. How do I fix that?">
  A: Our subscription products are managed in USD by default. To display prices in the customer's local currency and enable the corresponding payment methods, you need to enable Adaptive Pricing.
</Accordion>

## Verification, Tax & Compliance

<Accordion title="Q21: Why is my verification taking so long?">
  A: Dodo Payments typically takes 24–72 working hours to process verifications. However, delays can occur due to:

  * High volume of applications
  * Weekends and public holidays
  * Incomplete or incorrect submissions
  * Manual reviews for risk or compliance

  <Note>
    If it's been more than 72 hours, please check your email or Dodo Payments dashboard for any required action. You can also DM your registered email to the team on Discord for a follow-up.
  </Note>
</Accordion>

<Accordion title="Q22: I submitted my W-8BEN form, but the signature section doesn't work properly. What do I do?">
  A: Use a proper PDF editor like:

  * Adobe Acrobat
  * Mac Preview (works for most)
  * Smallpdf or PDFescape (online editors)

  If there's a cross mark on the signature, make sure:

  * You're saving the file after applying the signature.
  * The tool is flattening the signature layer (some editors don't).

  <Tip>
    Avoid signing in browser previewers—they don't always embed digital signatures properly.
  </Tip>
</Accordion>

<Accordion title="Q23: I chose the wrong registration type (business vs individual). How can I fix it?">
  A: If you selected the wrong entity type (e.g., chose “Organization” but you’re an individual or a Sole Prop with GST), your verification might be On-hold, requiring you to change or update the documentation.

  Steps to fix:
  Step 1: Inform support via Intercom or Discord who will help you enable resubmission for the Payout Compliance form.
  Step 2: Choose the right registration type, and resubmit the required documents.
</Accordion>

<Accordion title="Q24: My verification was declined due to entity mismatch. What should I do?">
  A: If your verification was declined due to an entity mismatch (e.g., you selected "Organization" but you're an individual or a Sole Prop with GST), you'll need to correct the registration type and resubmit your documents.

  Steps to fix:
  Step 1: Check your dashboard or email for the specific reason for decline.
  Step 2: Contact support via Intercom or support email ([support@dodopayments.com](mailto:support@dodopayments.com)) to request resubmission access for the Payout Compliance form.
  Step 3: Select the correct registration type (Individual vs Organization) and resubmit all required documents.
  Step 4: Wait for the compliance team to review your resubmission.

  <Note>
    The resubmission option will be enabled by our verification team after you contact support. Make sure to select the correct entity type this time to avoid further delays.
  </Note>
</Accordion>

<Accordion title="Q25: Can I use a different name (like my parent's) to sign up and get verified?">
  A: No. The person signing up must match the legal owner of the business and all submitted documents.

  If your parent is the actual business owner:

  * They should sign up using their email and mobile number.
  * All documents should be in their name.

  <Note>
    Using someone else's name for verification while you manage the business may lead to compliance rejection.
  </Note>
</Accordion>

<Accordion title="Q26: How do I check the reason for verification rejection?">
  A: You can find the reason in:

  * The Dodo Payments dashboard, under the verification section.
  * Email notifications (if enabled)

  <Tip>
    If it's not visible, contact [compliance@dodopayments.com](mailto:compliance@dodopayments.com) or DM your registered email ID to a team member.
  </Tip>
</Accordion>

<Accordion title="Q27: Can I create a new business account if my previous one was declined?">
  A: Yes — but only if:

  * You've fixed the issues that led to rejection.
  * You're not attempting to bypass risk decisions (e.g., deboarding for fraud concerns).

  <Note>
    Creating multiple accounts without resolving the underlying issue will likely result in the new account being rejected as well.
  </Note>
</Accordion>

<Accordion title="Q28: I've been told my account was previously deboarded. What does this mean?">
  A: If you see a message stating your account was previously deboarded by the risk team:

  * It means Dodo Payments found significant compliance or risk issues with your activity or business.
  * Attempting to create new accounts using the same identity or business details will likely be rejected again.

  <Note>
    If you believe this is a mistake, email [compliance@dodopayments.com](mailto:compliance@dodopayments.com) and request a review — include clear evidence to support your case.
  </Note>
</Accordion>

<Accordion title="Q29: How do I get my payout verification cleared faster?">
  A: To avoid delays:

  * Submit clear, properly formatted documents
  * Avoid repeated messages/tags in Discord — this slows the queue
  * Mention if you've crossed the payout threshold or have urgent timelines
  * DM your registered email ID if asked

  <Tip>
    Most payout reviews are completed within 72 working hours, unless there's an issue with your submission.
  </Tip>
</Accordion>

<Accordion title="Q30: What if I chose the wrong form (W-8BEN vs W-8BEN-E)?">
  A: These forms are tied to your entity type:

  * W-8BEN is for Individuals
  * W-8BEN-E is for Organizations

  If you submitted the wrong one:

  * Contact support to reset your form.
  * Fill and upload the correct form type.
  * Ensure the PAN is in the correct field (Line 6a for individuals).

  <Tip>
    Refer to IRS official form guides if confused.
  </Tip>
</Accordion>

<Accordion title="Q31: I have a GST with a trade name. Is that considered an organization?">
  A: No. If you're registered with a GST as an individual (sole proprietor), you're still considered an Individual.

  ✅ Use W-8BEN
  ✅ Select "Individual" in the registration
  ❌ Do not fill W-8BEN-E or select "Organization" unless you're a registered legal entity
</Accordion>

<Accordion title="Q32: My account was deboarded. Can I just create a new one?">
  A: Creating a new account to bypass a previous deboarding is not allowed. If you attempt this:

  * The new account may also be flagged or rejected
  * Risk decisions carry over across signups if the underlying business or person is the same

  <Tip>
    If you believe you were wrongly deboarded, email [compliance@dodopayments.com](mailto:compliance@dodopayments.com) with your case.
  </Tip>
</Accordion>

<Accordion title="Q33: How does Dodo Payments handle GST for Indian SaaS merchants?">
  A: Dodo Payments automatically calculates and applies **GST** for Indian merchants based on your customer's location.
</Accordion>

<Accordion title="Q34: Does Dodo Payments handle international sales?">
  A: Yes, Dodo Payments supports international sales and manages all associated compliances.
</Accordion>

<Accordion title="Q35: Are address data such as city, state, zipcode fields mandatory? Can I exclude requesting those values from my customer?">
  A: Yes, they are mandatory. As we are the Merchant of Record and generate invoices, file taxes, and ensure all purchases are compliant, we require the customer's billing address. You can implement our API-based checkout flow where you can pre-fill the customer's details if you have already collected them to ensure a smoother experience for your customers, but we will need these details for every purchase.
</Accordion>

<Accordion title="Q36: Do I need to file taxes in the US if I sell there?">
  A: Not directly. Dodo Payments acts as the Merchant of Record, handles customer-side tax, and remits where applicable. You still need to:

  * File income tax in your home country (e.g., India)
  * Submit W-8BEN(-E) to avoid default 30% US withholding
</Accordion>

<Accordion title="Q37: I don't know whether to fill W-8BEN or W-8BEN-E — help?">
  A: Use the following logic to determine which form you need:

  | You are...                              | Form to Submit | Merchant Type |
  | --------------------------------------- | -------------- | ------------- |
  | Sole Proprietor, Freelancer, Individual | W-8BEN         | Individual    |
  | Pvt Ltd, LLP, Registered Organization   | W-8BEN-E       | Organization  |

  Still unsure? Consider these indicators:

  * **If your bank account is under your personal name**, you're likely an Individual → Use W-8BEN
  * **If your bank account is under a company name**, you're an Organization → Use W-8BEN-E
  * **If you have a GST but operate with a personal bank account**, you're still considered an Individual → Use W-8BEN

  <Tip>
    If you're a sole proprietor with GST, you're still an Individual. Only registered legal entities (Pvt Ltd, LLP, etc.) should use W-8BEN-E.
  </Tip>
</Accordion>

<Accordion title="Q38: Do I need a PAN or GST to receive payments?">
  A: For Individuals, PAN is a mandatory requirement (for KYC and tax purposes). For registered businesses, either Business PAN or GSTIN can be submitted. GST is optional unless you exceed the registration threshold or want input credit
</Accordion>

<Accordion title="Q39: I have a Udyam/MSME certificate. Should I submit W-8BEN or W-8BEN-E?">
  A: Having a Udyam/MSME certificate does not automatically make you an Organization. The form you submit depends on your bank account type:

  * **If you operate with a personal bank account** (even with Udyam/MSME certificate): You're considered an **Individual** → Submit **W-8BEN**
  * **If you operate with a company bank account** (registered entity): You're an **Organization** → Submit **W-8BEN-E**

  <Note>
    The key factor is whether your bank account is in your personal name or your company's name, not whether you have business registration certificates.
  </Note>
</Accordion>

<Accordion title="Q40: If Dodo handles taxes, why do I need to file W-8BEN(-E)?">
  A: Dodo handles sales tax for your customers. W-8BEN(-E) is needed for withholding tax on payouts to you.

  <Note>
    Filing W-8BEN correctly can help you avoid double taxation under India–US tax treaties.
  </Note>
</Accordion>

## Payments & Transactions

<Accordion title="Q41: What types of payments can I accept with Dodo Payments?">
  A: Dodo Payments supports a variety of payment methods, including **credit cards**, **debit cards**, and **digital wallets**. We also support one-time payments and recurring subscription payments for digital products.
</Accordion>

<Accordion title="Q42: Why was the first payment marked successful with an amount of $0 for subscription?">
  A: If a product has a trial period, the first payment automatically becomes a mandate payment of \$0. This is expected behavior and confirms that the mandate has been created successfully.
</Accordion>

<Accordion title="Q43: After the trial period ends, does the customer need to pay (product price(e.g $25)) again manually?">
  A: No. Once the trial ends, the system automatically generates the product price(e.g \$25) for the customer. They do not need to pay it manually.
</Accordion>

<Accordion title="Q44: What if the trial period shows differently on my app vs. the Dodo Payments dashboard?">
  A: This usually indicates a setup or implementation issue on your end. Test the trial + subscription flow in test mode first, confirm it's working, and then switch to live mode.
</Accordion>

<Accordion title="Q45: Do I need to test the trial feature before going live?">
  A: Yes. It's recommended to fully implement and test the feature in test mode to ensure everything works correctly before switching to live mode.
</Accordion>

<Accordion title="Q46: How can I track payment statuses?">
  A: You can track the status of payments from the **Payments** section of your dashboard. Each transaction is listed with a status indicator: **In Progress**, **Failed**, or **Successful**.
</Accordion>

<Accordion title="Q47: What should I do if a payment fails?">
  A: If a payment fails, check the **Payment Details Page** for more information. Common reasons include incorrect payment details, insufficient funds, or network issues. You can resend the payment link to your customer to retry the payment.
</Accordion>

<Accordion title="Q48: Do merchants get notified when a user’s payment fails?">
  A: Yes. Dodo Payments notifies the merchant when a user's payment fails through multiple channels in live mode:

  * Email notifications
  * Webhook events
  * Mobile notifications
  * Dashboard notifications
    This ensures merchants stay informed about failed transactions.
</Accordion>

<Accordion title="Q49: What happens to a subscription if a payment fails?">
  A: The subscription is not cancelled immediately. Instead, it is moved to on-hold status until a successful payment is made.

  If you have an issue with the card, you can update the payment method by:

  * Clicking on the on-hold subscription in your dashboard and using the **Update Payment Method** button
  * Or using the API endpoint: [https://docs.dodopayments.com/api-reference/subscriptions/update-payment-method](https://docs.dodopayments.com/api-reference/subscriptions/update-payment-method)
</Accordion>

<Accordion title="Q50: If I retry payments myself, do I need the failed payment ID?">
  A: No. You only need the subscription ID to initiate a new payment attempt.
</Accordion>

<Accordion title="Q51: How can a subscription payment fail with INCORRECT_NUMBER if previous cycles were successful?">
  A: A subscription payment can fail with INCORRECT\_NUMBER if the customer's card was cancelled, replaced, deactivated, or flagged by their bank or payment provider after the previous billing cycle. Dodo Payments simply displays the error message returned by the payment provider.
</Accordion>

<Accordion title="Q52: Does the chargeback apply for business even if my business has a no refund policy?">
  A: Yes. Even if you state "No refunds" in your terms or website, chargebacks are largely governed by the cardholder's bank and card network rules (e.g., Visa, Mastercard). A "No refund" policy does not override the card network's dispute resolution process. If a customer files a dispute, your business is still subject to a chargeback investigation. This means you must respond with evidence (proof of delivery, usage logs, terms acceptance, etc.) to fight or manage the dispute. If the customer's bank decides in favor of the cardholder, the chargeback fee and transaction reversal will apply regardless of your stated policy. We recommend having clear communications, tracking customer usage, and providing compelling evidence when chargebacks arise.
</Accordion>

<Accordion title="Q53: Why is payment.status sometimes null?">
  A: payment.status can be null for a short time:

  * Right after creation but before processing completes
  * During subscription billing failures or retries

  Eventually, it becomes one of: succeeded, failed, or cancelled.

  <Note>
    Use webhook events like payment.succeeded or payment.failed for more reliable status tracking.
  </Note>
</Accordion>

<Accordion title="Q54: Why is product_cart null even though it's a checkout in webhook payload?">
  A:

  * For subscription payments, product\_cart is empty because there's no one-time item being bought
  * product\_cart is only populated for one-time payments
</Accordion>

<Accordion title="Q55: Why was my real card blocked during testing?">
  A: You likely tested in Live Mode instead of Test Mode.

  Live payments:

  * Use real money
  * Go through real banks
  * May be flagged as suspicious if volume is low or inconsistent

  ✅ Always test using:

  * Test Mode in the dashboard
  * Test card numbers provided in the documentation
</Accordion>

<Accordion title="Q56: My customer completed payment but I didn't receive webhook?">
  A: Checklist:

  * Confirm webhook is configured in Dashboard > Developers -> Webhooks
  * Check if webhook is failing silently due to non-2xx response
  * Check logs: was a 429 or timeout returned?
</Accordion>

<Accordion title="Q57: Why is my dashboard showing success, but my app didn't update?">
  A: It's likely you're relying solely on redirect\_url query params and not handling:

  * Webhooks
  * API confirmation call

  ✅ Fix:

  * Always listen for payment.succeeded webhook
  * Or query the API to confirm transaction after redirect
</Accordion>

<Accordion title="Q58: I'm not seeing UPI as a payment option — why?">
  A: UPI may not appear as a payment option for several reasons:

  * The billing country is not set to India (IN).
  * Adaptive Currency is disabled.

  Note: If you are a non-Indian merchant and Adaptive Currency is not enabled, UPI will not be available for your customers.
</Accordion>

<Accordion title="Q59: Does Dodo support UPI for subscriptions?">
  A: Yes, UPI subscriptions are supported with RBI-compliant mandates. UPI subscriptions operate under RBI (Reserve Bank of India) regulations with specific requirements:

  * **Mandate Limits**:
    * Charges below Rs 15,000: An on-demand mandate for Rs 15,000 INR is created
    * Charges Rs 15,000 or above: A subscription mandate for the exact subscription amount is created
  * **48-Hour Processing Delay**: Charges are initiated on the scheduled date, but the actual deduction occurs 48 hours after initiation (may extend up to 2-3 additional hours)
  * **Mandate Cancellation**: Customers can cancel mandates via their banking apps during the 48-hour window

  <Note>
    UPI subscriptions have the same RBI-compliant mandate requirements as Indian card subscriptions. For detailed information, see the [Payment Methods documentation](/features/payment-methods#upi-and-rupay-india).
  </Note>
</Accordion>

<Accordion title="Q60: How do I enable Google Pay / Apple Pay on static payment links?">
  A: Google Pay and Apple Pay automatically appear on static payment links in live mode. You do not need to take any additional steps to enable them.
</Accordion>

<Accordion title="Q61: How can I enable 3DS in Dodo Payments?">
  A: You can enable 3DS directly from your Business Settings in the Dodo Payments dashboard. Simply go to Business Settings → Payment Settings and turn on the 3DS option.
</Accordion>

<Accordion title="Q62: How do I collect billing details without passing them in API?">
  A: If you want users to enter billing info themselves:

  * Use static links, which automatically collect billing
  * For dynamic flows, you must collect info manually and pass it in the API

  There's no built-in UI yet for collecting billing during dynamic link creation.
</Accordion>

<Accordion title="Q63: What's the difference between static and dynamic payment links?">
  A: **Static payment links** are no-code options meant for quick use. They:

  * Are configured from the dashboard
  * Automatically collect billing info
  * Cannot be customized per customer/session

  **Dynamic payment links** are created via API. They:

  * Require you to pass billing info explicitly
  * Can be customized in real-time (price, user ID, redirect URL, etc.)

  <Tip>
    If you don't want to write code, go with static links. If you need flexibility or want to build custom workflows, use dynamic links.
  </Tip>
</Accordion>

<Accordion title="Q64: Will I get two webhook events when someone starts a subscription?">
  A: On the first successful subscription payment, you will typically receive these three webhooks if no trial period is involved:

  * `subscription.created` webhook
  * `payment.succeeded` webhook
  * `subscription.renewal` webhook
</Accordion>

<Accordion title="Q65: What does subscription.cancelled_at mean? Is it a scheduled cancellation?">
  A: Dodo supports both immediate and scheduled cancellations.

  When a cancellation request is made:

  * **Immediate cancellation**: The subscription.cancelled\_at timestamp is set immediately and the subscription ends at that moment
  * **Scheduled cancellation**: Use the `cancel_at_next_billing_date` parameter in the subscription patch API to cancel at the end of the current billing period
</Accordion>

<Accordion title="Q66: When does a subscription get charged?">
  A: Dodo Payments charges the customer immediately upon subscription creation if the product does not have a trial period.

  <Note>
    For Indian cards and UPI subscriptions, see the <a href="/features/payment-methods/india">India Payment Methods</a> page for detailed information about RBI regulations and processing delays.
  </Note>
</Accordion>

<Accordion title="Q67: Why does the Change Plan API return an empty response?">
  A: The Change Plan API returns only a 200 status code with no response body, so the response will appear empty even though the plan change is successful.
</Accordion>

<Accordion title="Q68: Why wasn't a new payment prompted when switching from a monthly to an annual plan?">
  A: When changing plans, Dodo Payments automatically charges the saved card. If the charge fails, the subscription is moved to "on hold." So no manual payment flow is triggered.
</Accordion>

<Accordion title="Q69: Why does my product price (Rs 100) show a higher amount (Rs 104) during checkout?">
  A: This happens when Adaptive Currency is enabled. The feature adds an additional 4% charge automatically.
</Accordion>

<Accordion title="Q70: Why does checkout ignore existing active subscriptions and create a new one?">
  A: Checkout always creates a new subscription. It does not check whether the customer already has an active subscription. Your application must block existing subscribers from starting a checkout session to avoid duplicate charges.
</Accordion>

<Accordion title="Q71: Why am I seeing a TRANSACTION_NOT_ALLOWED error during a subscription upgrade/downgrade?">
  A: This error comes from the card issuer, not Dodo Payments. The bank is blocking the transaction due to restrictions on that card.

  Common reasons:

  * Card not allowed for online, international, or recurring payments
  * Merchant category (MCC) is blocked
  * Bank's fraud rules prevented the charge
  * Prepaid or restricted cards may not support these payments
</Accordion>

<Accordion title="Q72: Is there a way to test in live mode without making real payments?">
  A: Yes. You can test live-mode checkout flows by creating a 100% discount code. This allows you to complete the full payment and redirect flow without being charged.
</Accordion>

<Accordion title="Q73: What is the $0 payment method?">
  A: A \$0 payment occurs when the total payable amount becomes zero (e.g., by applying a 100% discount). In such cases, no actual payment is processed, but the checkout and subscription flow still work normally.
</Accordion>

<Accordion title="Q74: It seems my account appears to be suspended, but compliance says everything is fine. What should I do?">
  A: In most cases, this happens because you've accidentally switched to an old or inactive business account. Simply switch back to your active business account in the Dodo Payments dashboard. If the issue continues after switching, contact Dodo Payments Support for assistance.
</Accordion>

## Payouts & Bank Integration

<Accordion title="Q75: How do payouts work with Dodo Payments?">
  A: Payouts are the transfer of your collected sales revenue to your linked bank account. Dodo Payments supports multiple payout cycles:

  * **Bi-Monthly (Default)**:
    * Billing Period 1: 1st to 15th → Payout on 18th of same month
    * Billing Period 2: 16th to end of month → Payout on 4th of following month
  * **Weekly**: Available for businesses with higher transaction volumes (contact support to request)
  * **Monthly**:
    * Billing Period: 1st to end of month → Payout on 11th of following month

  Payouts are only initiated if all verifications are successful and the payout threshold is met. It typically takes 1-2 business days for funds to appear in your bank account after the payout is initiated.

  <Note>
    Delays may occur if payout processing dates fall on weekends or bank holidays. The default payout cycle for all businesses is bi-monthly.
  </Note>
</Accordion>

<Accordion title="Q76: What is the minimum threshold amount after fees & taxes to process payouts?">
  A: The minimum payout threshold is **$50 USD** (or Rs 1,000 INR) after platform fees and taxes deduction. You can customize your USD wallet threshold to any amount **≥ $50** directly from your dashboard. If your balance doesn't meet the threshold, it will carry forward to the next payout cycle.

  You can see the exact wallet amount and manage your payout threshold in the [payouts section](https://app.dodopayments.com/business/payouts) of your dashboard.

  <Note>
    The flexible threshold feature is currently available for USD/EUR/GBP wallets. INR wallet threshold remains fixed at Rs 1,000.
  </Note>
</Accordion>

<Accordion title="Q77: How do I link my bank account to receive payouts?">
  A: To link your bank account, navigate to the **Payout Settings** section of your dashboard and click **Add Bank Account**. You'll need to enter your bank details and verify the account.
</Accordion>

<Accordion title="Q78: Can I track the status of my payouts?">
  A: Yes, you can track your payout status from the **Payouts** section of the dashboard.
</Accordion>

<Accordion title="Q79: What are payout fees and how much are they?">
  A: Payout fees refer to the transaction costs for transferring the money we've collected from your customers to your bank account. We constantly make improvements to reduce the payout fee by partnering with local partners in your country. Please refer to the [pricing](https://dodopayments.com/pricing) for detailed information.
</Accordion>

<Accordion title="Q80: I received a &#x22;payout processed&#x22; email — when will the funds arrive?">
  A: Payouts usually take 1–2 business days to reflect in your bank account.

  <Note>
    Transfers don't settle on weekends or bank holidays. If your payout was processed on Friday, expect it by Monday or Tuesday.
  </Note>
</Accordion>

<Accordion title="Q81: How do I add Payoneer as a payout account?">
  A: Just enter your Payoneer bank details in the Bank Info Form under your dashboard. There's no separate Payoneer integration yet.
</Accordion>

<Accordion title="Q82: Can I receive payouts to a Payoneer account?">
  A: Yes. You can receive payouts via Payoneer by:

  * Entering your Payoneer account details in the Bank Info Form on the Dodo dashboard
  * Ensure your account is approved and supports USD or the currency you're withdrawing

  There is no dedicated Payoneer integration — it is treated as a regular bank account.
</Accordion>

<Accordion title="Q83: My bank info and compliance form are still in review — what should I do?">
  A: Just wait. Our compliance team typically reviews forms within 1–2 working days. If it's urgent:

  * Email [support@dodopayments.com](mailto:support@dodopayments.com)
</Accordion>

<Accordion title="Q84: What happens if my payout day falls on a Friday or weekend?">
  A: If your payout day is on a Friday, it is usually processed on the same day. However:

  * If there's a bank holiday or weekend, it may be delayed to the next working day (usually Monday).
  * The exact timing may depend on your bank's processing rules.

  <Note>
    If in doubt, check your dashboard or ask support with your registered email.
  </Note>
</Accordion>

<Accordion title="Q85: How can I expedite payout compliance if I have an urgent launch or ad campaign planned?">
  A: If you've submitted everything and are awaiting payout compliance:

  * Mention your urgency clearly in support chats (e.g., live launch, paid campaigns).
  * Include your business ID and email.
  * Avoid spamming or tagging multiple team members — this may slow down the queue.
</Accordion>

<Accordion title="Q86: I submitted the wrong bank account details. How do I update them?">
  A: If you've entered incorrect bank details:

  * Contact support via Intercom or Discord or Mail.
  * DM your email ID and request a manual reset of the bank verification section if you reach through Discord.
  * Wait for the compliance team to reopen the section for you to re-submit.

  <Note>
    Editing bank details directly in the dashboard may not be allowed post-submission.
  </Note>
</Accordion>

<Accordion title="Q87: Can I use my personal bank account if I have a registered company?">
  A: No. If you're registered as a company or legal entity, you must use the entity's bank account.
</Accordion>

<Accordion title="Q88: My country doesn't use SWIFT codes. How will that affect my verification?">
  A: If your country does not issue SWIFT codes, this will not block your verification, but it will require manual review by our compliance team.

  What to do:

  * Contact support and explain that your country doesn't issue SWIFT codes
  * Submit official bank documents that confirm:
    * Your account number
    * Account holder name
    * That no SWIFT code is issued in your country
  * In some cases, a generic placeholder SWIFT may be used based on your country

  <Note>
    This case will go through manual compliance review. For faster processing, write to [compliance@dodopayments.com](mailto:compliance@dodopayments.com) for escalation.
  </Note>
</Accordion>

<Accordion title="Q89: What alternative documentation can I provide if my country doesn't use SWIFT codes?">
  A: If your country doesn't use SWIFT codes, provide the following alternative documentation:

  * Official bank statement or certificate showing your account details
  * Bank letter confirming your account number, holder name, and that SWIFT codes are not issued
  * Any government-issued document that confirms your bank's routing information format

  <Tip>
    Contact [support@dodopayments.com](mailto:support@dodopayments.com) before submitting to ensure you provide the correct documentation format for your country.
  </Tip>
</Accordion>

<Accordion title="Q90: Can I set a payout threshold lower than $50?">
  A: No, the minimum payout threshold cannot be set below $50. 
      You can increase the payout threshold above $50, but setting it to less than \$50 is not supported.
</Accordion>

## Invoicing & Reports

<Accordion title="Q91: Does Dodo Payments generate invoices automatically?">
  A: Yes, Dodo Payments automatically generates **invoices** for every successful transaction. These invoices include all necessary details such as tax breakdowns, customer information, and product details.
</Accordion>

<Accordion title="Q92: Can I customize the invoices?">
  A: Yes, you can customize the look of your invoices by adding your **company logo and brand name.** You can manage these settings in the Business Profile section of your dashboard.
</Accordion>

<Accordion title="Q93: How do I access or download an invoice?">
  A: You can view or download invoices from the **Invoices** section of the dashboard. Each payment will have an associated invoice that can be downloaded as a **PDF**.
</Accordion>

<Accordion title="Q94: How do I view reports on my transactions and payouts?">
  A: You can generate detailed reports from the **Reports** section of your dashboard. These reports include data on transactions, refunds, and payouts, which you can filter by date and export in CSV format.
</Accordion>

## Refunds & Disputes

<Accordion title="Q95: How do I issue a refund?">
  A: To issue a refund, go to the **Payment Details Page** of the transaction you want to refund and click the **Initiate Refund** button. You can issue a **full** or **partial** refund, provided the payment meets the refund eligibility rules.
</Accordion>

<Accordion title="Q96: How long does it take for a customer to receive their refund?">
  A: Once a refund is initiated, the customer will typically receive the refunded amount within **3-5 business days**, depending on the payment method and their bank.
</Accordion>

<Accordion title="Q97: I'm facing a dispute or chargeback. What can I do?">
  A: If a chargeback is filed against you:

  * You may lose both the transaction amount and a dispute fee
  * You can submit evidence of product delivery, usage logs, or customer communication
  * However, the final decision lies with the customer's issuing bank

  <Note>
    Email [support@dodopayments.com](mailto:support@dodopayments.com) with:

    * Dispute ID
    * Payment ID
    * Relevant proof
  </Note>
</Accordion>

<Accordion title="Q98: The customer disputed the charge after using the service. Can I appeal this?">
  A: Yes — you can:

  * Share documentation (chat logs, usage records, delivery confirmation)
  * Explain that the service was fulfilled
  * Request a waiver of the dispute fee if it's a first-time issue or if fraud is provable

  <Tip>
    There's no guarantee the fee will be waived, but our team reviews each case on merit.
  </Tip>
</Accordion>

## Webhooks & Integration

<Accordion title="Q99: How is proration calculated — on the product price or the total amount?">
  A: Proration is calculated on the **total amount paid**, not just the base product price.
  This means if a discount is applied, the proration is calculated on the **final amount after the discount**.
</Accordion>

<Accordion title="Q100: Why do we use the `subscription.renewed` webhook for the first subscription?">
  A: After the first payment succeeds, the subscription enters its first billing period and the next billing date is set.
  The `subscription.renewed` webhook is sent to indicate that a billing period is now active and the next billing cycle has been scheduled.
  This webhook is used for every billing period—including the first one—so billing logic can be handled consistently each time.
</Accordion>

<Accordion title="Q101: Can I manually verify Dodo Payments webhooks in Python?">
  A: Yes. Manual verification is possible, but it must strictly follow the correct signing steps. For an easier and more reliable approach, Dodo Payments recommends using the standardwebhooks package:

  ```python theme={null}
  from standardwebhooks.webhooks import Webhook

  wh = Webhook(webhook_secret_key)
  payload = request.get_data(as_text=True)
  headers = request.headers

  if not wh.verify(payload, headers):
      return jsonify({'error': 'Invalid webhook signature'}), 401

  Then parse the payload as needed.
  ```
</Accordion>

<Accordion title="Q102: Where can I find official docs on manual webhook verification?">
  A: You can refer to the official Dodo Payments documentation here: [https://docs.dodopayments.com/developer-resources/webhooks#manual-verification-alternative](https://docs.dodopayments.com/developer-resources/webhooks#manual-verification-alternative)
</Accordion>

<Accordion title="Q103: My webhook isn't receiving a POST request, only a GET. Why?">
  A: You're likely confusing the redirect URL with the webhook URL. A redirect URL is where the user is sent after a payment, and it may contain `?subscription_id=...&status=active` in a GET request. This is not your webhook.

  To receive structured POST payloads from Dodo Payments:

  * Set up a webhook under Dashboard → Developers → Webhooks
  * Ensure the URL accepts POST requests and verifies the signature

  <Note>
    You can have both a webhook and a redirect URL — they serve different purposes.
  </Note>
</Accordion>

<Accordion title="Q104: I get a 401 Unauthorized error using the Python SDK. Why?">
  A: You likely forgot to pass the correct environment when initializing the DodoPayments client.

  <Check>
    **Fix:**

    ```python theme={null}
    client = DodoPayments(
    bearer_token="your_api_key",
          environment="live_mode"  # or "test_mode"
    )
    ```
  </Check>
</Accordion>

<Accordion title="Q105: Is there a way to manually trigger a webhook event for testing?">
  A: You can do it through the webhook dashboard. Go to Dashboard -> Developers -> Webhooks
</Accordion>

<Accordion title="Q106: What's the difference between webhook and redirect URL?">
  A:

  * **Webhook URL**: Configured in dashboard. Receives POST payloads about events.
  * **Redirect URL**: Sent in the payment API request. Sends user back to your app with query params (`?status=success`).

  <Tip>
    Use webhooks to automate things like DB updates, and redirects to show thank-you screens.
  </Tip>
</Accordion>

<Accordion title="Q107: Why didn't I receive the product id in the payment.succeeded webhook for a subscription product?">
  A: The payment.succeeded webhook event for subscription products does not include a product\_id. Instead, it provides the `subscription_id` associated with the subscription, along with other relevant details.
</Accordion>

<Accordion title="Q108: How do I verify the webhooks I receive are actually from dodo payments and not from any malicious actors?">
  A: To verify that the webhooks you receive are genuinely from Dodo Payments and not from malicious actors, follow these steps:

  1. **Check the Signature**: Each webhook sent by Dodo Payments includes a unique signature in the **`webhook-signature`** header. This signature is generated using your webhook's secret key and the payload of the event.
  2. **Retrieve the Secret Key**: Ensure you have the secret key for your webhook, which can be found in your Dodo Payments dashboard under the Webhooks settings.
  3. **Recompute the Signature**: Use the same signing algorithm (HMAC-SHA256) as Dodo Payments to compute the signature on your server. Use the payload of the webhook and your webhook secret key.
  4. **Compare Signatures**: Compare the recomputed signature with the one provided in the **`webhook-signature`** header. If they match, the webhook is authentic; if not, it should be rejected.
  5. **Use HTTPS**: Ensure your webhook endpoint uses HTTPS to secure communication and prevent tampering during data transmission.
     By implementing these steps, you can confidently verify the authenticity of webhooks sent by Dodo Payments.

  <Tip>We recommend using packages provided by StandardWebhooks to verify signature and not construct it by yourself.</Tip>
</Accordion>

<Accordion title="Q109: Why am I receiving a subscription.renew webhook even for the first month payment?">
  A: For subscriptions, `subscription.renew` will be triggered whenever the subscription amount is deducted. So yes, this is expected behavior.
</Accordion>

<Accordion title="Q110: How can I test webhooks locally?">
  A: To test webhooks locally, you can follow these steps:

  1. **Use a Tunneling Tool**: Tools like [ngrok](https://ngrok.com/), [LocalTunnel](https://localtunnel.github.io/www/), or [Cloudflare Tunnel](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/) can expose your local server to the internet. This provides a public URL that Dodo Payments can use to send webhook events to your local environment.
  2. **Set Up the Webhook Endpoint**: Create a webhook endpoint in your local application to handle incoming webhook events. Ensure it listens for HTTP POST requests.
  3. **Configure the Webhook in Dodo Payments**: Go to your Dodo Payments dashboard, navigate to the Webhooks settings, and update the webhook URL to the public URL generated by the tunneling tool.
</Accordion>

<Accordion title="Q111: Why is my webhook not being called after payment?">
  A: Check the following:

  * You did not confuse the webhook URL with redirect URL
  * The webhook is configured under Developers > Webhooks
  * Your URL accepts POST requests and responds with 2xx
  * Signature validation (if enabled) is implemented correctly

  If you only see GETs with ?status=success, you are debugging the redirect URL, not the webhook.
</Accordion>

<Accordion title="Q112: Is it safe to rely on status=success in URL query params?">
  A: No. While it's a quick win, URL query params can be tampered with.

  If you're using redirect\_url?status=success:

  * Double-validate the transaction with an API call
  * Or wait for payment.succeeded webhook

  <Tip>
    Treat redirects as user-facing confirmations, not proof of payment.
  </Tip>
</Accordion>

<Accordion title="Q113: Can I integrate Dodo Payments with my existing website or platform?">
  A: Yes, Dodo Payments offers **API integration** and **SDKs support** for seamless integration with your website or platform. You can find API documentation, SDK guides, and integration resources in the **Developer Section** of your dashboard.
</Accordion>

## Testing & Local Development

<Accordion title="Q114: Can I test subscriptions in Test Mode?">
  A: Yes — subscriptions can be tested fully in Test Mode.

  Just don't use real card numbers.
</Accordion>

<Accordion title="Q115: How do I switch between Test and Live Mode?">
  A:

  * On your Dodo dashboard, look for a Test Mode toggle.
  * Switch it ON to use test API keys and simulate payments.

  You'll see "Test Mode" labels on all screens. Make sure to use the corresponding API key or environment when switching.
</Accordion>

<Accordion title="Q116: Can I use real customer data in Test Mode?">
  A: Yes, but keep in mind:

  * No real money will be transferred
  * You can simulate webhooks and flows
  * Card details should still be test cards

  This helps debug flows end-to-end without any financial impact.
</Accordion>

<Accordion title="Q117: I'm getting: &#x22;You must provide a mandate for off-session card payments&#x22;">
  A: It means:

  * An Indian Card is used to make the payment but the billing country is not set as IN.
  * You likely passed an incorrect billing country.
</Accordion>

## Support & Communication

<Accordion title="Q118: How do I contact support?">
  A: You can contact our support team by sending an email to [**support@dodopayments.com**](mailto:support@dodopayments.com). We are here to assist you with any issues or questions you may have.
</Accordion>

<Accordion title="Q119: My support messages are getting no response. What should I do?">
  A: If you've messaged in:

  * Intercom with no response
  * Discord without acknowledgement

  Then:

  * Escalate via [compliance@dodopayments.com](mailto:compliance@dodopayments.com) or [support@dodopayments.com](mailto:support@dodopayments.com) with subject line Urgent: No Response – \[Your Email]
</Accordion>

## Security & Fraud Prevention

<Accordion title="Q120: How does Dodo Payments protect my business from fraud?">
  A: Dodo Payments uses **real-time fraud detection** to monitor suspicious transactions. We also comply with **PCI-DSS standards** to ensure that all payment information is encrypted and secure.
</Accordion>

<Accordion title="Q121: Is my customer data secure with Dodo Payments?">
  A: Yes, Dodo Payments uses **data encryption** and **tokenization** to protect sensitive information. We ensure that customer payment data is never stored directly and remains secure during transactions.
</Accordion>

<Accordion title="Q122: I found a security vulnerability in Dodo Payments. How should I report it?">
  A: Please report any discovered vulnerabilities directly to our security team at [pt-team@dodopayments.com](mailto:pt-team@dodopayments.com)
</Accordion>

<Accordion title="Q123: Does Dodo Payments offer bug bounties?">
  A: We currently do not offer monetary bounties, but we do provide Dodo Payments merchandise as a token of appreciation.
</Accordion>

## Payments Failures

<Accordion title="Q124: Why is my payment status showing 'Not Initiated'?">
  A: This means the payment link was created, but the user never opened the payment page or attempted the payment.
</Accordion>

<Accordion title="Q125: Why is my payment status showing 'Requires Payment Method'?">
  A: This means the user opened the payment page and entered customer details but exited before adding card or payment details.
</Accordion>

<Accordion title="Q126: Why am I getting an 'Invalid authorization details' error?">
  A: This usually happens when the 3D Secure (3DS) authentication fails or is not completed by the user.
</Accordion>

<Accordion title="Q127: Why am I getting an 'Authentication failure' error for payments?">
  A: The payment failed due to an authentication error. Please check with your bank regarding this issue. Unfortunately, there is nothing further we can do from our side. We recommend trying a different card or a different payment method.
</Accordion>


# Feature Prioritization Tools
Source: https://docs.dodopayments.com/miscellaneous/gtm-tools/feature-prioritization-tool

The **Feature Prioritization Tool** helps SaaS product teams prioritize feature development using the **RICE (Reach, Impact, Confidence, Effort) framework**. By assigning a RICE score to each feature, this tool ensures that high-impact, low-effort features are prioritized, maximizing development efficiency and business value.

## **Start Prioritizing Features for Maximum Impact**

Use the **Feature Prioritization Tool** to optimize product development and ensure your SaaS team focuses on features that drive engagement, user satisfaction, and revenue growth.

Link: [https://dodopayments.com/tools/product-prioritization-tool](https://dodopayments.com/tools/product-prioritization-tool)

## **Why Feature Prioritization is Essential for SaaS Businesses**

Prioritizing product features ensures that development teams focus on features with the highest user impact while efficiently managing resources. A structured prioritization process helps:

1. Improve customer satisfaction by delivering high-value features first
2. Maximize ROI on development efforts
3. Reduce time-to-market for essential features
4. Align product development with business objectives

By leveraging data-driven prioritization, SaaS companies can build products that drive engagement, retention, and revenue growth.

## **Key Input Metrics**

### **1. Reach Score (1-10)**

Represents the estimated number of users who will benefit from the feature within a specific period. High-reach features impact a large portion of the user base.

### **2. Impact Score (1-10)**

Measures the feature’s value to affected users. Higher impact scores indicate features that significantly enhance the user experience or solve a critical problem.

### **3. Confidence Level (%)**

Reflects the certainty of reach and impact estimates. A higher confidence percentage ensures that decisions are based on reliable data and user insights.

### **4. Effort Score (1-10)**

Represents the estimated resources required to implement the feature, including development time, personnel, and budget. Features requiring lower effort with high impact should be prioritized.

## **How the Feature Prioritization Tool Works**

Using the **RICE framework**, the tool ranks product features based on their potential value vs. effort. It provides:

1. A structured scoring system to evaluate feature importance
2. Automated ranking to ensure optimal resource allocation
3. Data-driven prioritization for faster decision-making

The tool generates a prioritized feature list, ensuring that the highest-impact features with the lowest resource investment are developed first.

## **Key Output Metrics**

### **1. Prioritized Feature List**

A feature ranking list is generated based on the RICE score, displayed in descending order. This list helps SaaS product teams focus on the most impactful features first, ensuring efficient roadmap planning.

## **Frequently Asked Questions (FAQs)**

### **FAQs:**

1. **What is the RICE framework?**
   * The RICE framework is a prioritization method used to rank product features based on four factors: Reach (how many users it will affect), Impact (how much value it provides), Confidence (how sure you are of the estimates), and Effort (how much work it requires).
2. **How do I calculate Reach for a feature?**
   * Reach is the estimated number of users who will benefit from the feature. For example, if a feature impacts 1,000 users per month, your reach score would reflect this number.
3. **Why is Confidence important in the RICE framework?**
   * Confidence helps ensure that you’re making decisions based on reliable estimates. If you’re unsure about the impact or reach of a feature, a lower confidence score will prevent you from over-prioritizing a feature that may not deliver the expected value.
4. **How do I decide which features to prioritize?**
   * Features with the highest RICE scores should be prioritized first because they offer the most value relative to the effort required. This ensures your team focuses on tasks that deliver maximum results quickly.
5. **What should I do if two features have the same RICE score?**
   * If two features have the same RICE score, consider qualitative factors such as strategic importance, user feedback, or alignment with long-term business goals. You can also reassess confidence levels or adjust the impact estimate to break the tie.


# Freemium Model
Source: https://docs.dodopayments.com/miscellaneous/gtm-tools/freemium-model

The Freemium Model ROI Analysis Tool helps SaaS businesses evaluate the effectiveness and financial viability of a freemium strategy. It provides insights into the costs associated with supporting free users and the revenue generated from conversions to paid plans. This tool enables businesses to assess whether their freemium model is sustainable and profitable.

## **Start Optimizing Your Freemium Strategy Today**

Evaluate your freemium model’s profitability with the Freemium Model ROI Calculator.

Link: [https://dodopayments.com/tools/freemium-model-calculator](https://dodopayments.com/tools/freemium-model-calculator)

Make data-driven decisions to maximize conversions and revenue!

## Importance of ROI Analysis for Freemium Models

Freemium models attract a large user base by offering free access to basic features, with the expectation that a percentage of users will convert to paid plans. However, if conversion rates are too low or operational costs are too high, the free tier can become unsustainable. Understanding the ROI of a freemium strategy is critical for:

* Evaluating the financial impact of supporting free users.
* Optimizing conversion strategies to increase paid users.
* Identifying cost inefficiencies and areas for improvement.
* Enhancing pricing models to maximize revenue potential.

## **Key Metrics Analyzed**

This tool provides insights into the following key factors affecting freemium profitability:

### **1. Free User Base**

Understanding the size of the free user base is essential, as these users form the primary pool for potential paid conversions.

### **2. Operational Costs**

The costs associated with supporting free users, including server infrastructure, customer support, and product maintenance, directly impact the financial sustainability of a freemium model.

### **3. Free-to-Paid Conversion Rate**

The percentage of free users upgrading to paid plans is a critical indicator of monetization success. A low conversion rate may suggest issues with feature differentiation, pricing, or user engagement.

### **4. Paid User Revenue & Costs**

Revenue generated from paid subscribers must offset both acquisition costs and the cost of maintaining free users. Understanding the balance between these factors ensures long-term profitability.

## **How This Tool Helps SaaS Businesses**

By analyzing these metrics, the Freemium Model ROI Analysis Tool enables businesses to:

1. Assess the financial impact of free users and determine if the model is sustainable.
2. Optimize the free-to-paid conversion funnel to improve monetization.
3. Identify opportunities to reduce costs while maintaining product quality.
4. Fine-tune pricing and feature differentiation to increase revenue.

## **Strategic Considerations**

* **ROI (Return on Investment)**: The tool provides an ROI percentage, showing the profitability of your freemium model. A positive ROI indicates that your free users are converting into paying customers at a rate that covers your costs and generates profit.

If the analysis indicates a negative ROI, businesses may need to:

* Refine pricing models by adjusting free and premium feature allocations.
* Enhance product value to improve user retention and encourage upgrades.
* Reduce operational costs associated with maintaining free users.
* Optimize conversion tactics, such as targeted promotions and in-app nudges.

### **FAQs:**

1. **What is a good conversion rate for freemium models?**
   * A typical conversion rate for freemium models is between 2% and 5%, but it can vary depending on your product and market. Higher conversion rates indicate that your free users are finding enough value to upgrade to a paid plan.
2. **How do I reduce the costs of supporting free users?**
   * You can reduce costs by optimizing server resources, automating customer support for free users, and limiting the features available in the free tier to reduce usage costs.
3. **What are the risks of a freemium model?**
   * The biggest risk is that too many users stay on the free plan without converting to paid plans. This can lead to high costs without generating sufficient revenue. Balancing the value of the free tier and making the upgrade path attractive is key.
4. **How can I improve my freemium conversion rate?**
   * You can improve conversion by offering clear value in the paid tiers, such as premium features, better support, or advanced analytics. Offering timely nudges to ask the user to upgrade may push the conversion
5. **What should I do if my freemium ROI is negative?**
   * If your freemium ROI is negative, it’s important to reevaluate the value you’re offering in the free tier. Consider reducing the free features or increasing the incentives to upgrade to a paid plan to make your strategy more profitable.


# SaaS KPI Measurement
Source: https://docs.dodopayments.com/miscellaneous/gtm-tools/saas-kpi-measurement

The SaaS KPI Measurement Tool enables SaaS businesses to monitor their key performance indicators (KPIs) such as Annual Recurring Revenue (ARR), Churn Rate, and Customer Lifetime Value (CLTV). By consolidating critical financial metrics in a single dashboard, businesses can gain insights into growth trends, customer retention, and long-term profitability.

## **Start Tracking Your SaaS KPIs Today**

Gain valuable business insights with the **SaaS KPI Measurement Tool**.

Link: [https://dodopayments.com/tools/saas-kpi-measurement](https://dodopayments.com/tools/saas-kpi-measurement)

**Optimize revenue, monitor churn, and scale with confidence!**

## **Why KPI Measurement is Essential for SaaS Businesses**

Accurate KPI tracking helps SaaS companies:

1. Understand monthly and annual revenue trends
2. Identify customer retention challenges and reduce churn
3. Forecast long-term financial performance
4. Optimize pricing and revenue models
5. Improve customer lifetime value (CLTV) and ROI

Tracking these KPIs consistently ensures better decision-making and business sustainability.

## **Key Input Metrics**

To generate accurate SaaS KPIs, the tool requires the following inputs:

### 1. Monthly Recurring Revenue (MRR)

The total recurring revenue generated per month from customer subscriptions. This metric is the foundation for calculating ARR and CLTV.

### 2. New Customers Added This Month

The number of new customers acquired during the current month. This input is essential for tracking growth and understanding customer acquisition effectiveness.

### 3. Customers Last Month

The total customer base at the start of the month. This metric is used to assess churn rate and retention trends.

### 4. Current Customer Base This Month

The number of active customers at the end of the month. This figure helps determine if the company is retaining or losing customers.

### 5. Average Customer Retention Period

The average length of time a customer remains subscribed (in months or years). This is crucial for calculating CLTV and evaluating long-term revenue potential.

## **How the SaaS KPI Measurement Tool Works**

The tool performs real-time calculations based on the provided inputs and generates key SaaS metrics:

1. **ARR Calculation** – Estimates Annual Recurring Revenue using MRR.
2. **Churn Rate Calculation** – Determines customer retention trends over time.
3. **CLTV Calculation** – Evaluates customer lifetime value to measure revenue potential per customer.

By consolidating these KPIs, the tool provides a comprehensive performance overview, allowing businesses to identify opportunities for growth and improvement.

## **Frequently Asked Questions (FAQs)**

1. **What is a good churn rate for a SaaS business?**
   * A good churn rate for SaaS businesses varies depending on the industry but it typically falls below 10%. Lower churn means better customer retention, which directly impacts revenue stability. If your churn rate is higher, it may indicate issues with product fit or customer satisfaction.
2. **Why is tracking MRR important for SaaS companies?**
   * MRR provides a clear, predictable revenue stream that you can count on month over month. It helps with financial forecasting, budgeting, and measuring the success of marketing and sales strategies.
3. **How can I increase my CLTV?**
   * You can increase CLTV by improving customer retention, upselling customers to higher pricing tiers, and providing exceptional customer service. Happy customers are likely to stick around longer and spend more.
4. **What’s the difference between MRR and ARR?**
   * MRR represents your monthly recurring revenue, while ARR is the annualized version of MRR. ARR provides a longer-term perspective on your recurring revenue, making it easier to assess yearly performance.
5. **Why should I monitor churn rate closely?**
   * Churn rate directly affects your bottom line. High churn means that you’re losing customers faster than you’re acquiring new ones, which can lead to negative revenue growth. Monitoring churn helps you identify areas for improvement, like product enhancements or better customer support.


# SaaS Pricing calculator
Source: https://docs.dodopayments.com/miscellaneous/gtm-tools/saas-pricing-calculator

The SaaS Pricing Calculator is designed to help SaaS businesses determine the ideal pricing strategy for their software products. Setting the right price is critical for remaining competitive, covering operational costs, and maximizing profitability. This tool enables businesses to explore different pricing models, including competitor-based, cost-based, and value-based pricing, to develop a pricing structure that aligns with market trends and customer expectations.

## **Optimize Your SaaS Pricing Strategy Today**

Use the **SaaS Pricing Calculator** to develop a pricing model that maximises profitability, competitiveness, and customer acquisition.

Link: [https://dodopayments.com/tools/saas-pricing-calculator](https://dodopayments.com/tools/saas-pricing-calculator)

**Find the perfect balance between cost, value, and market positioning!**

## **Why Pricing Strategy is Crucial for SaaS Businesses**

Pricing directly impacts customer acquisition, revenue growth, and profitability. A well-defined pricing strategy ensures:

1. **Competitive positioning** – Aligns your product pricing with market expectations
2. **Sustainable profitability** – Covers costs while maintaining profit margins
3. **Value-based pricing** – Ensures customers pay according to the benefits they receive

Choosing the right pricing strategy allows SaaS businesses to balance affordability, perceived value, and business growth.

## **Key Input Metrics**

### **1. Competitor Pricing**

Understanding the price points of similar SaaS solutions in the market helps in positioning your product effectively. Competitor pricing acts as a reference, enabling businesses to decide whether to price above, below, or at market rates.

### **2. Product Value Addition (%)**

Represents the relative value your product provides compared to competitors. If your software offers 30% more features or efficiency, pricing can be adjusted accordingly.

### **3. Cost per User**

Includes operational costs such as cloud hosting, development, maintenance, and support services. This metric helps in setting a profitable baseline price to ensure sustainability.

### **4. Estimated User Base**

Defines the projected number of users subscribing to the SaaS product over a set period. This estimation helps determine revenue potential and optimal pricing.

### **5. Target Revenue**

Businesses must set annual or monthly revenue goals to ensure pricing strategies align with profitability objectives. This metric helps determine minimum pricing thresholds.

### **6. Estimated Value for the Customer**

Assesses the financial impact or time savings the product delivers to users. For example, if the software saves businesses \$10,000 annually, pricing should reflect this value-based approach.

## **How the SaaS Pricing Calculator Works**

This tool enables businesses to compare multiple pricing models and identify the most suitable one based on financial goals, competitive landscape, and customer expectations. It supports:

1. **Competitor-Based Pricing** – Align pricing with industry benchmarks
2. **Cost-Based Pricing** – Ensure pricing covers operational costs and profit margins
3. **Value-Based Pricing** – Charge based on customer-perceived value

By leveraging data-driven pricing strategies, SaaS companies can optimize revenue, enhance customer acquisition, and drive business growth.

## **Key Output Metrics**

### **1. Recommended Price Range**

The tool provides a flexible pricing range, allowing businesses to adjust prices based on market trends and customer feedback. Pricing recommendations typically range between 0.8x and 1.2x the suggested price, ensuring adaptability.

### **2. Tiered Pricing Structure**

A well-defined tiered pricing model maximizes revenue potential by catering to different customer segments. The tool recommends three tiers:

**Basic Tier** – Lower-priced plan for budget-conscious users with essential features.

**Pro Tier** – Standard pricing plan offering a balanced set of features.

**Enterprise Tier** – Premium pricing model with advanced functionalities and personalized support.

## **Frequently Asked Questions (FAQs)**

1. **What is the best pricing strategy for SaaS companies?**
   * There is no one-size-fits-all pricing strategy for SaaS companies. The best approach depends on your product, market, and business goals. Competitor-based pricing helps you align with market rates, cost-based pricing ensures you cover your expenses, and value-based pricing lets you charge based on the perceived value your product delivers to customers.
2. **How do I decide whether to use competitor-based, cost-based, or value-based pricing?**
   * If your market is saturated with similar products, competitor-based pricing can keep you competitive. If you want to ensure profitability, cost-based pricing guarantees your costs are covered. If your product offers significant value to users, value-based pricing allows you to charge based on the results your product delivers, which can lead to higher pricing.
3. **How can I make my SaaS pricing more competitive?**
   * To stay competitive, evaluate your competitors regularly, ensure your pricing reflects the value you provide, and consider offering tiered pricing or freemium models. Adjust your pricing based on user feedback and market trends to ensure you remain competitive.
4. **Why should I offer tiered pricing for my SaaS product?**
   * Tiered pricing allows you to cater to different customer segments, offering basic features at lower prices and premium features at higher prices. This flexibility maximizes your revenue by appealing to both budget-conscious users and those willing to pay for advanced features.
5. **How often should I reevaluate my SaaS pricing?**
   * It’s a good practice to review your pricing strategy at least once a year, or when significant changes occur in your product offerings, market conditions, or customer needs. This ensures your pricing remains competitive and aligned with your business goals.


# SaaS Revenue & Profit Growth
Source: https://docs.dodopayments.com/miscellaneous/gtm-tools/saas-revenue-and-profit-growth

The **SaaS Revenue & Profit Growth Tool** is designed to help SaaS businesses accurately forecast their **financial performance** by analyzing revenue, costs, and growth rates. This tool enables businesses to make data-driven decisions about scaling, hiring, and long-term sustainability. By predicting future revenue and profit trends, SaaS companies can optimize growth strategies and maximize profitability.

Start Forecasting Your Business Growth with **SaaS Revenue and Profit Growth Tool**

**Link:** [https://dodopayments.com/tools/saas-revenue-profit-growth-tool](https://dodopayments.com/tools/saas-revenue-profit-growth-tool)

**Optimize revenue, increase profitability, and scale smarter!**

## **Why Revenue & Profit Growth Projections Matter for SaaS Businesses**

Accurate revenue and profit projections are crucial for SaaS companies to:

1. Plan long-term growth strategies

2. Set realistic revenue and expansion goals

3. Make informed decisions about scaling, hiring, and product development

4. Identify potential financial risks and opportunities

5. Ensure sustainable profitability in an evolving market

By leveraging financial forecasting, SaaS businesses can gain a competitive advantage and minimize unexpected financial hurdles.

## **Key Input Metrics**

To generate precise revenue and profit projections, the tool requires the following key metrics:

### **1. Estimated Annual Revenue**

This is the total revenue generated annually from customer subscriptions. Entering an accurate figure allows the tool to forecast revenue growth trends over multiple years.

### **2. Estimated Annual Costs**

All operational expenses, including software development, hosting, salaries, marketing, and customer support, should be included. Tracking these costs ensures an accurate profitability forecast.

### **3. Revenue Growth Rate**

This is the annual percentage increase in revenue based on customer acquisition, expansion, and pricing adjustments. For example, if you expect a 10% revenue increase yearly, enter this value to project long-term growth.

### **4. Cost Growth Rate**

Expenses grow as the business scales. The cost growth rate estimates how annual costs increase over time, accounting for infrastructure, hiring, and marketing investments.

### **5. Forecast Duration (Number of Years)**

Select the time frame for your financial projections (e.g., 3, 5, or 10 years). Longer projections provide a bigger picture of financial health but should be regularly reviewed for accuracy.

## **How the SaaS Revenue & Profit Growth Calculator Works**

This tool uses real-time calculations based on your revenue, costs, and growth rates to generate financial projections. It provides:

1. **Revenue Growth Forecasts** – Year-over-year revenue increase based on your expected growth rate.
2. **Profitability Analysis** – Calculates net profit by subtracting projected costs from revenue.
3. **Break-even Insights** – Identifies when your business becomes sustainably profitable.
4. **Data-driven Decision Support** – Helps refine pricing, reduce churn, and optimize cost management.

## **Key Output Metrics**

After entering your data, the tool provides detailed insights into your SaaS business’s financial future:

### **1. Revenue Projection**

A year-over-year revenue forecast, estimating how your business will grow based on your revenue growth rate. This projection helps track expansion progress and scalability.

### **2. Profit Projection**

A detailed profit analysis displaying how much revenue remains after accounting for growing operational costs. Monitoring profit growth ensures long-term business sustainability.

## **Frequently Asked Questions (FAQs)**

### **1. Why are revenue and profit projections important for SaaS businesses?**

Revenue and profit forecasts allow SaaS businesses to make informed financial decisions, set realistic goals, and plan growth strategies. Predicting financial trends helps **optimize operations, scale efficiently, and mitigate risks**.

### **2. How accurate are long-term SaaS revenue projections?**

Projections are based on current data and estimated growth rates, but factors like customer churn, market shifts, and operational costs can impact actual outcomes. Regularly updating forecasts ensures greater accuracy.

### **3. What is the difference between revenue growth and profit growth?**

* **Revenue Growth**: Measures total income increase from SaaS subscriptions and customer expansion.
* **Profit Growth**: Accounts for both revenue and costs, reflecting the actual net earnings after expenses. A company may experience revenue growth but lower profits if costs rise significantly.

### **4. How can I increase my SaaS revenue growth rate?**

Boost revenue by:

1. Enhancing customer acquisition strategies
2. Reducing churn with better retention efforts
3. Optimizing pricing models and offering upsells
4. Expanding into new markets or launching new features

### **5. How does cost growth affect SaaS profitability?**

As businesses scale, operational costs (e.g., support, hosting, infrastructure, and marketing) also increase. If costs outpace revenue growth, profitability declines. Monitoring expenses ensures financial stability.


# Help and Support
Source: https://docs.dodopayments.com/miscellaneous/help-support

We understand that navigating a new platform or resolving issues can sometimes require additional support. To ensure a seamless experience, we offer multiple support channels to address all your concerns.

## **Dodo Payments Centralized Support System**

The Dodo Payments Centralized Support System provides a unified support experience, offering multiple channels to assist merchants.

Merchants can access the support system through the "Get Support" icon on the Dodo Payments Dashboard, leading to a dedicated support landing page with four key options:

## 1. AI-Powered Chat Assistance

The Chat with AI feature provides instant, automated support using an AI-powered chatbot. It is designed to assist users by:

* Answering technical and business queries
* Providing guidance on API integration and setup
* Offering navigation support for product documentation

This feature ensures quick resolution of common queries, reducing the need for direct human support.

📌 Best for: Instant self-serve assistance and general troubleshooting.

## 2. Community Support via Discord

The Dodo Payments Discord Community enables merchants to engage with other users and the Dodo Payments team. Through this platform, users can:

* Discuss best practices and share experiences
* Seek peer-to-peer assistance from other merchants
* Engage with the Dodo Payments support team in an interactive environment

This feature fosters a collaborative community-driven support experience.

📌 Best for: Peer support, longer queries and networking with other merchants.

## 3. Dedicated Chat Support

The Chat Support feature provides a direct line to the Dodo Payments support team for more complex or account-specific inquiries. Key aspects include:

* Support is managed via Intercom, where merchants can submit detailed queries.
* Response time is within 24-48 business hours.
* Unresolved tickets will automatically close if there is no user response for 72 hours.

This feature ensures that merchants receive personalized assistance for critical issues requiring human intervention.

📌 Best for: Account-related concerns, technical escalations, and personalized troubleshooting.

## **4. Self-Service Documentation**

The Dodo Payments Documentation Portal serves as a comprehensive resource for merchants looking for detailed product and integration information. The portal includes:

* Detailed feature explanations
* Step-by-step implementation guides
* API documentation and integration manuals
* Frequently Asked Questions (FAQs)

This feature provides structured, self-paced learning for merchants to independently navigate the platform.

📌 Best for: In-depth learning, implementation guidance, and technical documentation.

## **Support Options Overview**

| **Support Channel**   | **Purpose**                                 | **Response Time** |
| --------------------- | ------------------------------------------- | ----------------- |
| **AI-Powered Chat**   | Automated responses, documentation guidance | Instant           |
| **Discord Community** | Peer support, community discussions         | Community-driven  |
| **Chat Support**      | Personalized assistance for complex issues  | 24-48 hours       |
| **Self-Service Docs** | Product guides, API reference, tutorials    | Self-paced        |

Merchants can choose the most suitable support channel based on the complexity of their query and the required response time. For further assistance, visit the Dodo Payments Support Center via the dashboard.


# Countries Eligible for Payment Acceptance
Source: https://docs.dodopayments.com/miscellaneous/list-of-countries-we-accept-payments-from

The list below includes the countries from which we accept payments for our SaaS and digital products.

| #   | ISO Code | Country Name                                 |
| --- | -------- | -------------------------------------------- |
| 1   | AD       | Andorra                                      |
| 2   | AE       | United Arab Emirates                         |
| 3   | AG       | Antigua and Barbuda                          |
| 4   | AI       | Anguilla                                     |
| 5   | AL       | Albania                                      |
| 6   | AM       | Armenia                                      |
| 7   | AO       | Angola                                       |
| 8   | AR       | Argentina                                    |
| 9   | AS       | American Samoa                               |
| 10  | AT       | Austria                                      |
| 11  | AU       | Australia                                    |
| 12  | AW       | Aruba                                        |
| 13  | AX       | Åland Islands                                |
| 14  | AZ       | Azerbaijan                                   |
| 15  | BA       | Bosnia and Herzegovina                       |
| 16  | BB       | Barbados                                     |
| 17  | BD       | Bangladesh                                   |
| 18  | BE       | Belgium                                      |
| 19  | BF       | Burkina Faso                                 |
| 20  | BG       | Bulgaria                                     |
| 21  | BH       | Bahrain                                      |
| 22  | BI       | Burundi                                      |
| 23  | BJ       | Benin                                        |
| 24  | BL       | Saint Barthélemy                             |
| 25  | BM       | Bermuda                                      |
| 26  | BN       | Brunei Darussalam                            |
| 27  | BO       | Bolivia                                      |
| 28  | BQ       | Caribbean Netherlands                        |
| 29  | BR       | Brazil                                       |
| 30  | BS       | Bahamas                                      |
| 31  | BT       | Bhutan                                       |
| 32  | BV       | Bouvet Island                                |
| 33  | BW       | Botswana                                     |
| 34  | BZ       | Belize                                       |
| 35  | CA       | Canada                                       |
| 36  | CC       | Cocos (Keeling) Islands                      |
| 37  | CG       | Republic of the Congo                        |
| 38  | CH       | Switzerland                                  |
| 39  | CI       | Côte d'Ivoire                                |
| 40  | CK       | Cook Islands                                 |
| 41  | CL       | Chile                                        |
| 42  | CM       | Cameroon                                     |
| 43  | CN       | China                                        |
| 44  | CO       | Colombia                                     |
| 45  | CR       | Costa Rica                                   |
| 46  | CV       | Cape Verde                                   |
| 47  | CW       | Curaçao                                      |
| 48  | CX       | Christmas Island                             |
| 49  | CY       | Cyprus                                       |
| 50  | CZ       | Czech Republic                               |
| 51  | DE       | Germany                                      |
| 52  | DJ       | Djibouti                                     |
| 53  | DK       | Denmark                                      |
| 54  | DM       | Dominica                                     |
| 55  | DO       | Dominican Republic                           |
| 56  | DZ       | Algeria                                      |
| 57  | EC       | Ecuador                                      |
| 58  | EE       | Estonia                                      |
| 59  | EG       | Egypt                                        |
| 60  | EH       | Western Sahara                               |
| 61  | ER       | Eritrea                                      |
| 62  | ES       | Spain                                        |
| 63  | ET       | Ethiopia                                     |
| 64  | FI       | Finland                                      |
| 65  | FJ       | Fiji                                         |
| 66  | FK       | Falkland Islands                             |
| 67  | FM       | Micronesia                                   |
| 68  | FO       | Faroe Islands                                |
| 69  | FR       | France                                       |
| 70  | GA       | Gabon                                        |
| 71  | GB       | United Kingdom                               |
| 72  | GD       | Grenada                                      |
| 73  | GE       | Georgia                                      |
| 74  | GF       | French Guiana                                |
| 75  | GG       | Guernsey                                     |
| 76  | GH       | Ghana                                        |
| 77  | GI       | Gibraltar                                    |
| 78  | GL       | Greenland                                    |
| 79  | GM       | Gambia                                       |
| 80  | GN       | Guinea                                       |
| 81  | GP       | Guadeloupe                                   |
| 82  | GQ       | Equatorial Guinea                            |
| 83  | GR       | Greece                                       |
| 84  | GS       | South Georgia and the South Sandwich Islands |
| 85  | GT       | Guatemala                                    |
| 86  | GU       | Guam                                         |
| 87  | GW       | Guinea-Bissau                                |
| 88  | GY       | Guyana                                       |
| 89  | HK       | Hong Kong                                    |
| 90  | HM       | Heard Island and McDonald Islands            |
| 91  | HN       | Honduras                                     |
| 92  | HR       | Croatia                                      |
| 93  | HU       | Hungary                                      |
| 94  | ID       | Indonesia                                    |
| 95  | IE       | Ireland                                      |
| 96  | IL       | Israel                                       |
| 97  | IM       | Isle of Man                                  |
| 98  | IN       | India                                        |
| 99  | IO       | British Indian Ocean Territory               |
| 100 | IQ       | Iraq                                         |
| 101 | IS       | Iceland                                      |
| 102 | IT       | Italy                                        |
| 103 | JE       | Jersey                                       |
| 104 | JM       | Jamaica                                      |
| 105 | JO       | Jordan                                       |
| 106 | JP       | Japan                                        |
| 107 | KE       | Kenya                                        |
| 108 | KG       | Kyrgyzstan                                   |
| 109 | KH       | Cambodia                                     |
| 110 | KI       | Kiribati                                     |
| 111 | KM       | Comoros                                      |
| 112 | KN       | Saint Kitts and Nevis                        |
| 113 | KR       | South Korea                                  |
| 114 | KW       | Kuwait                                       |
| 115 | KY       | Cayman Islands                               |
| 116 | KZ       | Kazakhstan                                   |
| 117 | LA       | Laos                                         |
| 118 | LB       | Lebanon                                      |
| 119 | LC       | Saint Lucia                                  |
| 120 | LI       | Liechtenstein                                |
| 121 | LK       | Sri Lanka                                    |
| 122 | LR       | Liberia                                      |
| 123 | LS       | Lesotho                                      |
| 124 | LT       | Lithuania                                    |
| 125 | LU       | Luxembourg                                   |
| 126 | LV       | Latvia                                       |
| 127 | MA       | Morocco                                      |
| 128 | MC       | Monaco                                       |
| 129 | ME       | Montenegro                                   |
| 130 | MF       | Saint Martin                                 |
| 131 | MG       | Madagascar                                   |
| 132 | MH       | Marshall Islands                             |
| 133 | MK       | North Macedonia                              |
| 134 | MP       | Northern Mariana Islands                     |
| 135 | MQ       | Martinique                                   |
| 136 | MR       | Mauritania                                   |
| 137 | MS       | Montserrat                                   |
| 138 | MT       | Malta                                        |
| 139 | MU       | Mauritius                                    |
| 140 | MV       | Maldives                                     |
| 141 | MW       | Malawi                                       |
| 142 | MX       | Mexico                                       |
| 143 | MY       | Malaysia                                     |
| 144 | MZ       | Mozambique                                   |
| 145 | MN       | Mongolia                                     |
| 146 | MO       | Macau                                        |
| 147 | NA       | Namibia                                      |
| 148 | NC       | New Caledonia                                |
| 149 | NE       | Niger                                        |
| 150 | NF       | Norfolk Island                               |
| 151 | NG       | Nigeria                                      |
| 152 | NI       | Nicaragua                                    |
| 153 | NL       | Netherlands                                  |
| 154 | NO       | Norway                                       |
| 155 | NP       | Nepal                                        |
| 156 | NR       | Nauru                                        |
| 157 | NU       | Niue                                         |
| 158 | NZ       | New Zealand                                  |
| 159 | OM       | Oman                                         |
| 160 | PA       | Panama                                       |
| 161 | PE       | Peru                                         |
| 162 | PF       | French Polynesia                             |
| 163 | PG       | Papua New Guinea                             |
| 164 | PH       | Philippines                                  |
| 165 | PK       | Pakistan                                     |
| 166 | PL       | Poland                                       |
| 167 | PM       | Saint Pierre and Miquelon                    |
| 168 | PN       | Pitcairn Islands                             |
| 169 | PR       | Puerto Rico                                  |
| 170 | PT       | Portugal                                     |
| 171 | PW       | Palau                                        |
| 172 | PY       | Paraguay                                     |
| 173 | QA       | Qatar                                        |
| 174 | RE       | Réunion                                      |
| 175 | RO       | Romania                                      |
| 176 | RS       | Serbia                                       |
| 177 | RW       | Rwanda                                       |
| 178 | SA       | Saudi Arabia                                 |
| 179 | SB       | Solomon Islands                              |
| 180 | SC       | Seychelles                                   |
| 181 | SE       | Sweden                                       |
| 182 | SG       | Singapore                                    |
| 183 | SH       | Saint Helena                                 |
| 184 | SI       | Slovenia                                     |
| 185 | SJ       | Svalbard and Jan Mayen                       |
| 186 | SK       | Slovakia                                     |
| 187 | SL       | Sierra Leone                                 |
| 188 | SM       | San Marino                                   |
| 189 | SN       | Senegal                                      |
| 190 | SR       | Suriname                                     |
| 191 | ST       | São Tomé and Príncipe                        |
| 192 | SV       | El Salvador                                  |
| 193 | SX       | Sint Maarten                                 |
| 194 | SZ       | Eswatini                                     |
| 195 | TC       | Turks and Caicos Islands                     |
| 196 | TD       | Chad                                         |
| 197 | TF       | French Southern Territories                  |
| 198 | TG       | Togo                                         |
| 199 | TH       | Thailand                                     |
| 200 | TJ       | Tajikistan                                   |
| 201 | TK       | Tokelau                                      |
| 202 | TL       | Timor-Leste                                  |
| 203 | TM       | Turkmenistan                                 |
| 204 | TN       | Tunisia                                      |
| 205 | TO       | Tonga                                        |
| 206 | TR       | Turkey                                       |
| 207 | TT       | Trinidad and Tobago                          |
| 208 | TV       | Tuvalu                                       |
| 209 | TW       | Taiwan                                       |
| 210 | TZ       | Tanzania                                     |
| 211 | UG       | Uganda                                       |
| 212 | UM       | United States Minor Outlying Islands         |
| 213 | US       | United States                                |
| 214 | UY       | Uruguay                                      |
| 215 | UZ       | Uzbekistan                                   |
| 216 | VA       | Vatican City                                 |
| 217 | VC       | Saint Vincent and the Grenadines             |
| 218 | VG       | British Virgin Islands                       |
| 219 | VI       | U.S. Virgin Islands                          |
| 220 | VN       | Vietnam                                      |
| 221 | VU       | Vanuatu                                      |
| 222 | WF       | Wallis and Futuna                            |
| 223 | WS       | Samoa                                        |
| 224 | YT       | Mayotte                                      |
| 225 | ZA       | South Africa                                 |
| 226 | ZM       | Zambia                                       |

<Tip>
  You can only accept payments from the 226 countries listed above. We regularly update this list as we expand support to more countries.
</Tip>


# Merchant Acceptance Policy
Source: https://docs.dodopayments.com/miscellaneous/merchant-acceptance

This policy will help you understand the types of businesses we support, the types we restrict or prohibit, and how we enforce our standards.

## Introduction

Dodo Payments operates as a Merchant of Record (MoR), providing an all-in-one platform for digital businesses for merchants by acting as their official reseller. As MoR, Dodo Payments assumes responsibility for payment processing, tax compliance, and chargeback handling. To protect the integrity of our platform and our global partnerships, we maintain strict standards for the products we resell on our platform.

This policy outlines the kinds of businesses we support, the types we restrict or prohibit, and how we enforce our standards. It is intended to help builders understand how to align with our platform requirements from the start.

## Businesses We Love!

We're excited to support legit builders creating digital-first products that are valuable, trustworthy, and easy to deliver. In general, we welcome:

1. SaaS & AI products
2. Digital goods
3. Templates, Plugins & Apps

<Note>
  We assess "value" based on what a customer actually gets and experiences after they buy the product. In general, we're excited about products that do what they promise, are genuinely useful, and feel worth the price to a reasonable customer. Clear functionality, honest descriptions, and a solid end-user experience go a long way.

  On the flip side, products that rely mostly on hype, vague claims, artificial urgency, or heavily repackaged free content create poor customer experiences. If something feels designed to extract payment rather than solve a real problem, we may take a closer look or decide not to support it.

  Our goal here isn't to police creativity, but to ensure our customers walk away feeling safe and satisfied, not misled. We want to back builders who care about what they're putting into the world. If you're ever unsure whether your product fits, please feel free to reach out! We're always happy to talk it through.
</Note>

## What We Look For

If your product is digital, delivered easily, and meets these qualities, we'd love to work with you:

* **Legally Compliant:** Your product complies with relevant laws (like consumer protection and data privacy) in the regions you operate.
* **Honest and Helpful:** We appreciate products that provide real value to users - things that are helpful, not deceptive or exploitative.
* **Community-friendly:** Products should adhere to our policies and ensure a smooth experience for everyone.

## Businesses We Can't Support

<Warning>
  This is not an exhaustive list. Dodo Payments reserves the right to update or enforce this policy at any time. We may place your account under review or suspend it immediately if we determine your business model is deceptive, harmful, high-risk, generates excessive refunds or chargebacks, or has been flagged by our payment partners.
</Warning>

As your MoR, we're legally and reputationally responsible for what's being sold through our platform. That means we must stay clear of anything that's:

1. **NSFW, Intimacy & Adult content or services** – This includes explicit or suggestive content whether real or AI-generated (e.g., OnlyFans-style platforms, NSFW chatbots, webcam streams, erotic games, sex toys, escort-style services).
2. **Manual Digital Services** – Selling non-automated services via digital platforms. So, selling custom design, development, coaching, freelancing or consulting services via digital platforms isn't allowed. In essence, if the majority of the value sits in the human labour rather than digital systems, it will not be accepted.
3. **Digital products with limited or unclear value** – For example, AI-generated PDFs with little value, thin templates marked up heavily, or clearly unfinished websites sold at premium prices which may lead to customer dissatisfaction. This also includes placeholder or pre-launch offerings such as holding pages, teaser sites, waitlists, or "coming soon" products that do not provide immediate, usable value after purchase.
4. **Physical goods** – We only support digital delivery. Physical goods include merchandise packaged with digital bundles. No T-shirts, mugs, books, supplements, or computer hardware. In-person services: Any service that is delivered in person, even if booking or payment happens online. So no personal training, coaching delivered physically, beauty treatments, repair or maintenance work performed at the customer's location, etc.
5. **Illegal or age-restricted** – Including but not limited to drugs, alcohol, tobacco, vapes, prescription medicines, or content that violates local laws in any region you're targeting.
6. **Restricted by payment and compliance partners** – Some business types may be subject to restrictions under the policies of our payment and compliance partners. If our financial and regulatory partners restrict certain categories, we cannot provide our support.
7. **Financial products, services & advice** – We can't support unlicensed financial tools, investment strategies, wealth-building courses, tax calculators, banking services, escrow services or anything involving stored value, lending, or managing funds.
8. **Official registration or incorporation services** – Services that process or facilitate company registration, government filings, licences, permits, or any other statutory/legal registrations.
9. **Tax Evasion, Shell Entities, or Regulatory Arbitrage** – We can't support products, services, or setups designed to evade taxes, mask ownership, or bypass financial or legal regulations—this includes using fake business entities, misleading jurisdictions, or "gray market" setups.
10. **Legal, accounting, medical, and professional services** – This includes any services that require licensing, certification or regulatory compliance. Examples include advisory work, diagnosis or treatment, document preparation, representation, financial or tax planning, or any expertise-based service that carries regulatory or liability risk.
11. **Travel, Immigration & Visa services** – This includes bookings for commercial airlines, cruises, charter or private flights, and timeshare offerings. Services that offer handling or facilitating Visa or citizenships.
12. **Health & wellness products** – Including diagnostics, weight-loss programs, supplements, or biohacking kits. This entire class of products is incompatible with our MoR obligations even if well-intentioned, or honestly marketed.
13. **Miracle, Misleading, or Unverifiable Claims** – No products making exaggerated or unverifiable claims – e.g., "cures cancer," "reverses aging," "burns fat while you sleep," "make money while you sleep."
14. **Social matching and interaction services** – This includes platforms for real-time person-to-person interactions, similar to random video- or chat-matching services, matchmaking services, dating platforms, AI-generated relationship companions.
15. **Religious or spiritual product or services** – This includes offerings of spiritual guidance, paid prayers, rituals, faith-based counselling, or similar services where users are paying for religious or spiritual interaction or access to a religious or spiritual authority.
16. **Gambling & games of chance** – Including casinos, lotteries, betting, sweepstakes, fantasy sports for cash prizes, or chance-based reward mechanics (such as loot boxes or spins).
17. **Gaming and virtual-goods environments** – This includes games of skill, online games, video games, in-game currencies, digital item sales, game boosters, or private servers - whether official or unofficial.
18. **Virtual asset services** – Crypto-related offerings, Digital wallets, NFTs, DeFi, crypto exchanges, or token launches aren't permitted.
19. **Piracy or IP violations** – Selling things you didn't create or license (e.g., pirated books, software licenses, copy-paste code packs, unauthorized media downloads).
20. **IPTV and streaming access services** – This includes IPTV subscriptions, reseller panels, or tools that provide access to third-party streaming content.
21. **Software resale or license flipping** – Including selling software licenses at a discount, or reselling AI APIs, datasets, or tools without clear rights or authorisation.
22. **Privacy Violations & Surveillance Tech** – We don't allow products that violate user privacy or enable unauthorized surveillance – this includes stalkerware, keyloggers, location tracking without consent, facial recognition tech, face-swap features or tools that scrape or collect personal data without a clear legal basis.
23. **Hosting, servers, and infrastructure services** – This includes VPN, VPS or dedicated servers, hosting plans, cloud compute credits, bandwidth reselling, or any product that provides users with persistent infrastructure or server-level access.
24. **Telecommunication services** – This includes services that offer call SPI, telecom routing, global calling to PSTN, SIM cards, e-SIMs, VoIP services, call/SMS termination, or related telecom operations (licensed or unlicensed).
25. **Spam, mass outreach or scraping tools** – Data privacy violations, including lead scraping, mass outreach or spam tools, and sensitive private information databases.
26. **Proxy, cloaking, or anti-terms tools** – Anything that helps users bypass API rate limits, captcha or authentication limits, platform terms, or geolocation restrictions.
27. **Cheating & manipulation tools** – That means hacks, mods, bots, engagement manipulation, fake reviews, or tools for bypassing platform restrictions, gameplay or API limits.
28. **Donations** – If you're collecting money without delivering something in return, for general support of your platform, we likely can't process it.
29. **Fundraising** – We don't support charity or NGO drives, political or religious donations, personal fundraisers, crowdfunding campaigns, and any contribution-based model without a defined product or service.
30. **Marketplaces, resale model** – If you're selling on behalf of others, operating a multi-vendor platform, or taking funds and forwarding them elsewhere, selling gift or other benefit cards, that's not supported under our MoR structure.
31. **Ticketing & bookings services** – Services that facilitate the sale, resale, or booking of tickets, reservations, or access to events, travel, accommodations.
32. **Weapons, Self-Defense & Violence-Oriented Content** – We don't allow content promoting weapons, combat training, DIY explosives, self-defense tools, or any content that glorifies violence or incites harm.

<Tip>
  Even if your business isn't listed above, we may still decline to work with you if we believe it poses legal, financial, or reputational risk. This includes high refunds / chargebacks, low-effort, or exploitative offerings. We assess you holistically and reserve the right to refuse or revoke access at our discretion.
</Tip>

## When in Doubt…

If your product is pushing boundaries or you're unsure whether it qualifies, we strongly recommend reaching out to us. We'd love to explore ways to help you stay compliant without compromising on your vision.

And remember: just because something is technically digital doesn't mean it's automatically okay. If it feels shady, scammy, exploitative, or like something you wouldn't explain confidently to your mother, we probably can't support it.

Some business types may fall into a restricted zone - not outright prohibited, but not immediately approved either. These cases will require enhanced due diligence, and we'll take a closer look before making a final decision. This is done on a case to case basis.

## Businesses We Might Support

To meet our compliance obligations, some business types require additional review. If your business falls into one of the categories below, we may ask for extra details such as licenses or information about how you operate.

While we aim to support a wide range of businesses, approval isn't guaranteed. If approved, access may be limited or adjusted over time in line with the Terms & Conditions, and this policy. Some types of businesses are not outright prohibited but do raise higher compliance or reputational risks. If you operate in one of these spaces, we may ask for extra details (like disclaimers, demo access, or policy links) before approving your account.

### Categories That Often Require Review

1. **AI Content Generation tools (text, image, video, voice)** – No impersonation, scraping, or deepfakes
2. **Marketing & outreach tools** – No spam, scraping, or fake engagement
3. **Resume, hiring, or exam tools** – No impersonation or cheating functionality
4. **Spiritual & Astrology services** – Entertainment only; no claims or predictions
5. **Audio / music / chatbot generators** – No voice cloning, NSFW, IP Infringements or fake claims
6. **E-books and written digital publications** – Including guides, playbooks, reports, or downloadable written content.
7. **Productised services** – A fixed, pre-defined digital product that is delivered the same way for every buyer. This may include limited, repeatable human operational work, as long as it is not customized or consultative.

**Unsure if your business qualifies?**

If your product operates near the edge of these categories, we encourage you to reach out before applying. We may still be able to support you, especially if you're transparent about your model, actively mitigate risks, and are willing to work within platform guidelines. You can reach out to [compliance@dodopayments.com](mailto:compliance@dodopayments.com) to check if you qualify.

## Accepted Territories or Regions

<AccordionGroup>
  <Accordion title="Accepted territories">
    1. Albania
    2. Algeria
    3. Andorra
    4. Anguilla
    5. Antigua and Barbuda
    6. Argentina
    7. Armenia
    8. Aruba
    9. Australia
    10. Austria
    11. Azerbaijan
    12. Bahamas
    13. Bahrain
    14. Bangladesh
    15. Barbados
    16. Belgium
    17. Belize
    18. Benin
    19. Bolivia
    20. Bosnia and Herzegovina
    21. Botswana
    22. Brazil
    23. British Virgin Islands
    24. Brunei
    25. Bulgaria
    26. Burkina Faso
    27. Cambodia
    28. Cameroon
    29. Canada
    30. Cayman Islands
    31. Central African Republic
    32. Chad
    33. Chile
    34. China
    35. Colombia
    36. Cook Islands
    37. Costa Rica
    38. Croatia
    39. Curaçao
    40. Cyprus
    41. Czech Republic
    42. Denmark
    43. Djibouti
    44. Dominica
    45. Dominican Republic
    46. Ecuador
    47. Egypt
    48. El Salvador
    49. Equatorial Guinea
    50. Estonia
    51. Eswatini
    52. Ethiopia
    53. Fiji
    54. Finland
    55. France
    56. Gabon
    57. Gambia
    58. Georgia
    59. Germany
    60. Ghana
    61. Greece
    62. Grenada
    63. Guatemala
    64. Guinea
    65. Guinea-Bissau
    66. Guyana
    67. Holy See (Vatican City)
    68. Honduras
    69. Hong Kong SAR
    70. Hungary
    71. Iceland
    72. India
    73. Indonesia
    74. Ireland
    75. Israel
    76. Italy
    77. Jamaica
    78. Japan
    79. Jordan
    80. Kazakhstan
    81. Kenya
    82. Kiribati
    83. Kosovo
    84. Kuwait
    85. Kyrgyzstan
    86. Latvia
    87. Lebanon
    88. Lesotho
    89. Liberia
    90. Liechtenstein
    91. Lithuania
    92. Luxembourg
    93. Madagascar
    94. Malawi
    95. Malaysia
    96. Maldives
    97. Malta
    98. Marshall Islands
    99. Martinique
    100. Mauritania
    101. Mauritius
    102. Mexico
    103. Micronesia
    104. Moldova
    105. Monaco
    106. Mongolia
    107. Montenegro
    108. Montserrat
    109. Morocco
    110. Myanmar
    111. Namibia
    112. Nepal
    113. Netherlands
    114. New Zealand
    115. Nicaragua
    116. Niger
    117. Nigeria
    118. Norway
    119. Oman
    120. Palau
    121. Panama
    122. Papua New Guinea
    123. Paraguay
    124. Peru
    125. Philippines
    126. Poland
    127. Portugal
    128. Qatar
    129. Republic of the Congo
    130. Romania
    131. Rwanda
    132. Saint Barthélemy
    133. Saint Kitts and Nevis
    134. Saint Lucia
    135. Saint Martin
    136. Saint Pierre and Miquelon
    137. Saint Vincent and the Grenadines
    138. Samoa
    139. San Marino
    140. São Tomé and Príncipe
    141. Saudi Arabia
    142. Senegal
    143. Serbia
    144. Seychelles
    145. Sierra Leone
    146. Singapore
    147. Slovakia
    148. Slovenia
    149. Solomon Islands
    150. South Africa
    151. South Korea
    152. Spain
    153. Sri Lanka
    154. Suriname
    155. Sweden
    156. Switzerland
    157. Taiwan
    158. Tajikistan
    159. Tanzania
    160. Thailand
    161. Timor-Leste
    162. Togo
    163. Tonga
    164. Trinidad and Tobago
    165. Tunisia
    166. Turkey
    167. Turks and Caicos Islands
    168. Tuvalu
    169. Uganda
    170. United Arab Emirates
    171. United Kingdom
    172. United States
    173. Uruguay
    174. Uzbekistan
    175. Vanuatu
    176. Vietnam
    177. Zambia
    178. Zimbabwe
  </Accordion>
</AccordionGroup>

<Note>
  This list is regularly updated to reflect FATF, OFAC, UN, and EU AML/CFT directives. All merchants are responsible for ensuring ongoing compliance.

  Payouts are supported only in the countries and regions listed above. If your country is not included, payouts are not currently available from that location.

  This list may change over time in line with regulatory and compliance requirements, and we're unable to offer payouts outside of the supported regions.

  Merchant accounts are supported only where KYC documentation is issued in the countries listed above.
</Note>

## Enforcement

We take violations of our merchant policy seriously. If we determine that a merchant has onboarded in breach of this policy or our terms — including by misrepresenting their business, attempting to bypass restrictions, or engaging in prohibited activities — Dodo Payments may take appropriate action.

### Enforcement Actions May Include:

* Permanent account suspension
* Immediate halt of transactions and platform access
* Withholding of payouts or reversal of settled funds
* Refunding all transactions processed
* Fines or penalties in proportion to losses, reputational harm, or downstream risk (up to USD 425,000)
* Reporting to card networks, financial partners, or regulators where required

These measures may be taken without prior notice in cases of material breach or imminent platform risk.

### Examples of Policy Breach

The following may trigger investigation or enforcement:

1. Misclassifying your business or products to bypass category restrictions.
2. Using proxy merchants, sub-accounts, or account takeovers to avoid enforcement.
3. Selling or promoting products that are deceptive, harmful, or violate our prohibited content rules.
4. Failing to disclose essential onboarding information (e.g., website mismatch, incorrect entity type).
5. Suspicious or unusual volume of transactions.
6. High volume of refunds, disputes, or customer complaints.
7. Actions or transactions that have been flagged by our payment, financial, or regulatory platforms.
8. Requests by legal authorities upon receipt of relevant legal order.
9. Reports of fraudulent activities flagged by our regulatory and compliance partners, and customer reports.
10. Any other material breaches of our platform policies or violations of law as applicable

### Appeals & Resolution

If you believe enforcement was applied in error, you may submit a request for review. Please note that reviews are considered on a one-time basis only. The appeal review decision will be final.

In some cases, we may allow corrective action or resubmission for review. Voluntary disclosure of potential issues may be considered favorably. You can reach out to **[compliance@dodopayments.com](mailto:compliance@dodopayments.com)** to initiate the review process.


# Review & Monitoring Policy
Source: https://docs.dodopayments.com/miscellaneous/review-monitoring-policy

How Dodo Payments monitors merchant activity to protect customers, partners, and the payment ecosystem.

## Introduction

At Dodo Payments, we act as a Merchant of Record (MoR), managing payment processing, invoicing, taxes, refunds, and disputes on behalf of the businesses that use our platform. To safeguard customers, businesses, and partners, we operate a structured monitoring program. This program ensures that accounts on our platform remain compliant with card network rules, applicable laws, and our \[Merchant Acceptance Policy].

## Purpose

Our monitoring framework is designed to protect both businesses and customers. By identifying and addressing potential risks early, we help ensure a trusted and reliable payment environment.

## Monitoring Approach

We combine automated checks with human review to maintain oversight of business activity. Reviews focus on:

1. Compliance with our [Merchant Acceptance Policy](/miscellaneous/merchant-acceptance)
2. Consistency between what is disclosed at onboarding and what is offered live
3. Compliance with card network rules, sanctions, and applicable laws
4. Customer experience signals such as refunds and disputes
5. Use of approved brands, domains, and product lines

## When Reviews Occur

Reviews take place at key points in the lifecycle:

1. **Activation & First Transaction** – to confirm that products and checkout experiences match what was disclosed.
2. **Before First Payout** – to complete compliance checks and validate fulfillment.
3. **Ongoing Triggers** – when significant changes occur, such as new domains, product shifts, unusual transaction patterns, or rising disputes / refunds.
4. **Periodic Reviews** – regular monitoring to help ensure continued compliance.

## Outcomes of Reviews

Following a review, possible outcomes include:

1. **Continued support** – your account remains active on the platform.
2. **Remediation** – we may ask you to correct issues or provide clarifications.
3. **Deboarding** – in cases of prohibited activity, policy violations, or non-response, the account may be closed and payouts withheld in line with our enforcement process.

## Customer Protection

We take customer complaints, fraud alerts, and refund requests seriously. In such cases, we may contact both the customer and your business. If we don’t receive a response within reasonable timelines, refunds may be processed automatically and your account may be restricted or closed.

## Transparency & Communication

If clarifications are required, we contact you at your registered email address. You’ll have the opportunity to respond and provide context. Where no response is received, accounts may be closed and funds held in line with card network and regulatory requirements.

## Enforcement

Violations of our policies, card network rules, or applicable laws may result in:

1. Suspension of payments
2. Account closure
3. Notifications to card networks, partners, or regulators as required

## Commitment to Fairness

Our monitoring standards are applied consistently across all businesses. We aim to work collaboratively to resolve issues where possible, while maintaining strong protections for customers and the payment ecosystem.


# Security Reporting Policy
Source: https://docs.dodopayments.com/miscellaneous/security-policy

Guidelines for responsible disclosure of security vulnerabilities at Dodo Payments.

## Introduction

At Dodo Payments, we take security seriously and appreciate responsible disclosure of vulnerabilities that help us improve our platform. If you discover a security vulnerability, we encourage you to report it to us following the guidelines below.

## Reporting Security Vulnerabilities

If you identify a security vulnerability in our platform, please contact us at **[pt-team@dodopayments.com](mailto:pt-team@dodopayments.com)** with the following details:

* **Description**: A clear and concise explanation of the vulnerability.
* **Steps to Reproduce**: Detailed steps to replicate the issue.
* **Impact**: The potential risk or harm that could arise from the vulnerability.
* **Suggested Mitigations**: (If available) Any recommendations on how to fix the issue.

## How We Handle Reports

1. **Acknowledgment**: Our team will confirm receipt of your report within a reasonable timeframe.
2. **Assessment**: We will review the report and prioritize it based on severity and impact.
3. **Resolution Timeline**: If the issue is already known and logged internally, we will provide an update on its expected resolution.
4. **Follow-up**: We may reach out for additional information or clarification as needed.

## No Monetary Rewards (Bug Bounty Program)

Currently, **Dodo Payments does not have an official bug bounty program**. While we deeply appreciate security researchers' efforts, we **do not offer monetary rewards** for vulnerability disclosures. This ensures fairness for all individuals who have reported similar issues in the past.

## Recognition & Appreciation

We highly value the contributions of ethical security researchers. While we do not offer financial compensation, we would be happy to send **Dodo Payments goodies/merch** as a token of appreciation for valid security reports. If you are interested, please let us know after your report has been reviewed.

## Responsible Disclosure

To ensure a responsible and ethical reporting process, please adhere to the following:

* **Do not publicly disclose** vulnerabilities until our team has had a reasonable time to address them.
* **Do not exploit** the vulnerability beyond what is necessary to demonstrate the issue.
* **Do not access, modify, or delete** data that does not belong to you.
* **Do not perform** any activity that could disrupt our services.

## Contact Us

If you have any security concerns or need further assistance, please reach out to us at **[pt-team@dodopayments.com](mailto:pt-team@dodopayments.com)**.


# Subscription Migration to Dodo Payments
Source: https://docs.dodopayments.com/miscellaneous/subscription-migration

Learn how to migrate your existing subscribers and payment methods from your current payment processor to Dodo Payments.

## What is a subscription migration?

A subscription migration transfers your existing subscribers from your legacy payment processor to Dodo Payments, giving you a single source of truth for all your customer data. Without a migration, customers you've acquired to date remain in your legacy system, and only new customers would be visible in Dodo Payments.

The migration process ensures a seamless billing experience for your customers—they won't need to re-enter their payment details or experience any interruption to their subscriptions.

<Warning>
  Currently, we only support migration for **card tokens**. Apple Pay, Google Pay, and other wallet payment methods cannot be transferred between payment processors due to tokenization restrictions imposed by these providers.
</Warning>

## Migration process overview

The subscription migration process consists of three key parts:

1. **Payment method transfer** — Secure transfer of sensitive card data from your current processor
2. **Subscriber data transfer** — Export of customer details, subscription plans, and billing schedules
3. **Import and validation** — Unifying payment methods and subscriber data in Dodo Payments

<Note>
  To begin a subscription migration, contact our [support team](mailto:support@dodopayments.com). They will connect you with a dedicated Solutions Engineer who will guide you through the entire process.
</Note>

## Requirements

Before initiating a migration, ensure you meet the following requirements:

<AccordionGroup>
  <Accordion title="PCI DSS compliance verification">
    Dodo Payments is PCI DSS Level 1 compliant. To meet compliance obligations, we can only receive card data from another PCI DSS Level 1-compliant payment processor.

    Your current processor must provide:

    * Their current PCI Attestation of Compliance (AOC), or their listing on Visa's Global Registry of Service Providers
    * Confirmation that they support secure card data exports

    View our [Attestation of Compliance (AOC)](https://pub-2a89184e4c954b599464449d23f506bb.r2.dev/dodo-payments-pci-dss-aoc.pdf) to share with your current processor.
  </Accordion>

  <Accordion title="Dodo Payments integration">
    Complete your Dodo Payments integration and ensure all new customers are being directed to Dodo Payments checkout before starting the migration. This prevents data inconsistencies during the transition period.
  </Accordion>

  <Accordion title="Data access authorization">
    Ensure you have the necessary authorization to request a data export from your current processor. This typically requires:

    * Account owner verification
    * Written authorization for sensitive data access
    * Completion of your processor's security verification steps
  </Accordion>
</AccordionGroup>

## Step-by-step migration guide

<Steps>
  <Step title="Request payment method export from your current processor">
    Contact your current payment processor's support team and submit a formal request for a complete export of your customer card tokens.

    You will need to:

    * Provide verification of your identity and authorization
    * Request they encrypt the export using Dodo Payments' PGP public key (provided below)
    * Ask them to transfer the encrypted file directly to our secure SFTP server

    <Info>
      Secure transfers are made directly from server to server via SFTP. Your Solutions Engineer will provide the SFTP credentials to share with your current processor.
    </Info>

    On average, this process takes around **2 weeks**, although timing varies depending on your current processor's policies and response times.
  </Step>

  <Step title="Prepare subscriber data export">
    While the payment method transfer is in progress, export your subscriber data from your legacy system. Your Solutions Engineer will provide a CSV template and guide you through the required fields.

    ### Required subscriber data

    | Field               | Description                                   |
    | ------------------- | --------------------------------------------- |
    | `customer_id`       | Your internal customer identifier             |
    | `email`             | Customer's email address                      |
    | `name`              | Customer's full name                          |
    | `country`           | Two-letter country code (ISO 3166-1 alpha-2)  |
    | `currency`          | Three-letter currency code (ISO 4217)         |
    | `payment_amount`    | Subscription amount in smallest currency unit |
    | `payment_interval`  | Billing frequency (monthly, yearly, etc.)     |
    | `next_billing_date` | Next scheduled billing date (ISO 8601)        |
    | `card_token`        | Unique token from your current processor      |

    <Warning>
      The `card_token` field is critical—it's used to match subscriber records with their payment methods during import. Ensure this matches exactly with the token in the payment method export.
    </Warning>

    ### Sample data format

    ```json theme={null}
    {
      "customers": [
        {
          "customer_id": "cus_abc123",
          "email": "jane.doe@example.com",
          "name": "Jane Doe",
          "country": "US",
          "currency": "USD",
          "payment_amount": 2999,
          "payment_interval": "monthly",
          "next_billing_date": "2025-01-15T00:00:00Z",
          "card_token": "tok_xyz789",
          "metadata": {
            "plan": "pro",
            "signup_source": "website"
          }
        }
      ]
    }
    ```
  </Step>

  <Step title="Validation and testing">
    Before the import date, our team will:

    * Verify file integrity and encryption of the payment method data
    * Validate your subscriber CSV for correct formatting
    * Run a test import in our sandbox environment
    * Identify and resolve any data mapping issues

    <Check>
      You'll receive a validation report confirming everything is ready for the production import.
    </Check>
  </Step>

  <Step title="Production import">
    On the agreed import date, our engineering team will:

    1. Import the payment method data into our PCI-compliant Card Vault
    2. Import your subscriber data
    3. Match subscribers to their payment methods using the card tokens
    4. Activate all migrated subscriptions

    <Info>
      Typical processing time is **2-3 business days** for standard migrations, depending on the volume of subscribers.
    </Info>
  </Step>

  <Step title="Post-migration verification">
    After the import completes, you'll receive:

    * A comprehensive migration report
    * A CSV mapping your old subscription IDs to new Dodo Payments IDs
    * Access to all migrated customers in your Dodo Payments dashboard

    We recommend:

    * Verifying a sample of migrated subscriptions in your dashboard
    * Testing a few subscription renewals in sandbox mode
    * Updating your internal database references with the new IDs
    * Running parallel monitoring for the first billing cycle
  </Step>
</Steps>

## Migratable data

The following data can be transferred during a subscription migration:

| Data type                 | Supported | Notes                              |
| ------------------------- | --------- | ---------------------------------- |
| Credit/debit card numbers | ✅         | Encrypted via PGP                  |
| Card expiration dates     | ✅         |                                    |
| Cardholder names          | ✅         |                                    |
| Billing addresses         | ✅         |                                    |
| Customer email addresses  | ✅         |                                    |
| Customer metadata         | ✅         | Custom key-value pairs             |
| Subscription details      | ✅         | Plan, amount, interval             |
| Apple Pay tokens          | ❌         | Cannot be transferred              |
| Google Pay tokens         | ❌         | Cannot be transferred              |
| Other wallet tokens       | ❌         | Cannot be transferred              |
| Payment history           | ❌         | Export from your current processor |

<Note>
  Payment history and transaction records cannot be migrated. We recommend exporting this data from your current processor for your records before completing the transition.
</Note>

## PGP encryption

For maximum security when transferring sensitive card data, all files **must** be encrypted using our PGP public key. This provides an additional layer of protection beyond transport-level encryption.

Share this key with your current payment processor for encrypting the card data export:

<Accordion title="Dodo Payments PGP Public Key">
  ```
  -----BEGIN PGP PUBLIC KEY BLOCK-----

  mQINBGflFWEBEADA8IaeXNc9ekoyWGH6TBi3PvazDTXH9MeAIcq8tcXPjr+aDTA7
  QE0oJbnH+Zi6nP6Mh20c4bftzC890/QJmk6shdgpQuCd/80yC1TT5tyqKDV517WQ
  B7A8CmbonuZ//jS+jWrekpbLFMzoro1ZkeCRDNbhF3KSrMv1UOugBHPAchtkTur8
  2k+HtIFKVW8xQ3/nrnKGeNWdHMp3y6yATjXm0E2y9Oq83CQ1TkwwB+MI0Y/uZaXv
  3016pOos3lQFXqVAvShDRzMXxvPHc902QS47v0gSj5wsVWv3g5QP/TlAE6Pvua18
  78xoROo9RLwovMmX372JeZdqKgIV+BmxlOrGCDcNOY4Flz+NRJuKbVk0UmD8f1tW
  NL5x/r36ZNnBbzohqcwp5dktiRn0MDHUsvv8StOkbFqQ+HyYSzoO1dRYGkz5bkfI
  urv4hd26I4rdu8GTpEaBcd0rx1NcNT2lbqrcTE7rux3c3Vf1QD6lSj+VbJBxxyxO
  +fgeoVNpAi4Zfyls+VYCRolVHxxdjh/Zu6iAUrpubpgBxoxwzF3vMVWDPvZahUxY
  gt340eRr6KQUpI2TK4iNhTzc4CpYP/eKyC8TavHzpuGap0f7ojNaD1yjPxKJ9HFF
  eFde7jtoglvGrdW/GnoTVBFdN4wdcrJ6+Xthlqk5n0CZLKxZzCsnJ+Y00wARAQAB
  tFlEb2RvIFBheW1lbnRzIEltcG9ydCBLZXkgKEltcG9ydCBrZXkgZm9yIGNhcmQg
  dG9rZW4gbWlncmF0aW9uKSA8cHQtdGVhbUBkb2RvcGF5bWVudHMuY29tPokCVwQT
  AQgAQRYhBAfnpp8sSFvzQCZA9mOB38/zSlnMBQJn5RVhAhsDBQkJZgGABQsJCAcC
  AiICBhUKCQgLAgQWAgMBAh4HAheAAAoJEGOB38/zSlnMLm4QAK1sQxraYnV4OC9l
  G0LNUDRKsayJ3+5uW6gbD72NhQ1Q7GpD6J1kmoXO95ZMSV4Ev+PAdBHVnhbl+LTk
  JBZTrVszeZfmAr2D0HTdBsqlB8uUISXaffL/a0POWTLRdVzHJbTPtC23SHjW8XFu
  0ixomJxnIXu1iBccEPJTWpjYQbecfK6xMbHYvLQYBCLBWbDfr7hJ3ubnF8izo4W+
  cxYmFS5A4lKs6PHC+MlikFHtKKhDaKT+Zc5c5utcGpPEFUw1vxvQkgabOie6/ufc
  EAfzHaFklDvyovfKJ3eOrTRlOG8T0TmoccxjTtx4vboaTcnKoANO0p1G5esjkAWU
  2Bpa/hTaW3YvKBlHEPovm+E4c7OieHIvw3+BS7uyWOmNHgzJcAEVkbJAvRl9X1lQ
  LzcOqBIVMyLF5zswRBHtCWHuYsolIO8zMKHmYKV52jR7OkGcZ5ekaqIKVsOmpDCk
  Rn7RWubhglOC6e+CNK+2LEQALpDLx05F4uUSmbo0KvQtgnXJHsVsesaO/CVxvdOw
  nWv3MyZbhN+EGCKbO3eoTkaM7EHRPEsHa04a+T+TPFel1B7VlTdBikoyNQxyh4a2
  V/ERoKi1qI9DS158lkPkZt90PLhPMVyOFTmTt8ZbZhp1TndmIterWGlYFz8yXb7A
  BDeo0Xmu2rmuoG7kEihSwt0UmfMSuQINBGflFWEBEACyXdG9SjXd7dRoJ5bcs64A
  Cxea1NZ90x4NWdx0lTy8ruHBSzl2SYDGhDbAAOhVTxZHr1UeDfPBp/urYiENsFeA
  Fx2V4Pt2Jj0oBJ6IIHnf1X0U+T6JzVYraaQBHUjXsq4GVoD0bWydQwE6+PSOOZ8R
  d7GlsdDl0lM38krkN84BRI/OEfLJaUKFAN9COBnna3bpUwhrvk2o05ItYK/CPoEp
  lQAI5mvO7x+kPSsWUCW905TrQuvYuJQvhCZN/2NMn7X5NzhVLLnPW+hyBfkjkWWm
  8GQoH54AADQOKAczkXuSUuLwji+TA2ImAw9FI/S5cIjxG3z4PaAg7zVeZEpjjTWN
  7QQXEMvzDLLXRSjXHsmtWmg//pgvkTxyuzPbNKK7KY9Q+Xyqb0bP5UQKrZ9nRn4l
  MMZjC7Kj7eeMv3g/V6wH60Sle0/XW1zSX0djay/Hf99eXcfntlSW0DB2pn9fa8+W
  vdmASrLwcYyGjIROxzHIW9uUs4kdJqWatzfT/0uWWwaLayEkd/lCzITn61UAYwVt
  YIhY5u9lH0ZuQsxOm267TZrrgDbN9h+z5OVLxW9ylhvXZhMa0w87z8ZTp9wCycki
  CNCM1dP0N+lxIPnDu3MztK8u/yelcKpruY5L+gMmVcyDPSYUHDO7g764IdUmSPh4
  VfIeXAsj2r5usa4/+OcxuQARAQABiQI8BBgBCAAmFiEEB+emnyxIW/NAJkD2Y4Hf
  z/NKWcwFAmflFWECGwwFCQlmAYAACgkQY4Hfz/NKWcxoIA//edJGWP4Pu70M5IlQ
  rLRhi0+hKe0l5VrR1XYcr0EA4qiRQIouab4QvHoxNpn5RGQ+C2agwraiIwIP/nqR
  Wz1arWpea8BuSeAJCI0uVQURGexB9ZIJ4oiz8itAiHyjW6x+B4zC9RKe3xGO8KIt
  FhtGMYGP+8bZyOUnIU9ZqO+mxHc/wnwCeICzE5TpITrEERbXh0XZJJCLotpss8o8
  4F0Lb/9VwObCEdxpC6IkKW9GF5WJjmycfdcojaEr26qNSj1KsKRww7ukoVthD4aT
  KRM0j3X0UFNz522hBCV/+0+cGMSc5lIRzE+gsXM8vpCW3rmWZj9pMyL5r/RH1FFL
  9N3nFvfjoiuEqQ/DRy3jdwCHXEijjo5ym1KU9AGuo42deI0nrpvzXYSSahKMOb0/
  PbF4YlrtSbXwhIsBfCUX6njvNomu2u4wDs7gv7gyimyetMZ8EwJ3aGvXlD4kHh15
  tIo5NVXXLfslGtoL+27iW4nmoAxV1lOU2c2Wei+lXEc7t6JgeI0NTdqBnYTNHsOZ
  f+dti4KGC2Y+6QKhCgvTFHdHpBJj9DzG49C+4E5ZZL3bNdsU5eXaIuJf/KW+eVQB
  EZgHVgBRCqwrDD6SpkOT2lzNxfKI5rBV+WCT+hbu83hk2Pd1K7N3JQs1fVFffF37
  1OSDhXaPYtJnVApUzaCrC5PJCXU=
  =nHcw
  -----END PGP PUBLIC KEY BLOCK-----

  ```
</Accordion>

## Timeline expectations

| Phase                       | Duration            |
| --------------------------- | ------------------- |
| Initial setup and planning  | 1-2 days            |
| Payment method transfer     | \~2 weeks           |
| Subscriber data preparation | 3-5 days (parallel) |
| Validation and testing      | 2-3 days            |
| Production import           | 2-3 business days   |
| Post-migration verification | 1-2 days            |

<Tip>
  The total migration typically takes **3-4 weeks** from start to finish. Starting your subscriber data preparation while the payment method transfer is in progress helps minimize the overall timeline.
</Tip>

## Get started

Ready to migrate your subscriptions to Dodo Payments? Contact our team to begin the process:

<CardGroup>
  <Card title="Contact Support" icon="envelope" href="mailto:support@dodopayments.com">
    Reach out to start your migration and get connected with a Solutions Engineer.
  </Card>

  <Card title="API Documentation" icon="code" href="/api-reference">
    Explore our API to understand how subscriptions work in Dodo Payments.
  </Card>
</CardGroup>


# Create Brand
Source: https://docs.dodopayments.com/api-reference/brands/create-brand

post /brands
Create a new brand.



# Get Brand
Source: https://docs.dodopayments.com/api-reference/brands/get-brand

get /brands/{id}
Retrieve a specific brand by ID.



# List Brands
Source: https://docs.dodopayments.com/api-reference/brands/list-brands

get /brands
List all brands.



# Update Brand
Source: https://docs.dodopayments.com/api-reference/brands/update-brand

patch /brands/{id}
Update an existing brand's details.



# Update Brand Images
Source: https://docs.dodopayments.com/api-reference/brands/update-brand-images

put /brands/{id}/images
Update the images associated with a brand.



# List Disputes
Source: https://docs.dodopayments.com/api-reference/disputes/get-disputes

get /disputes
Get a list of all disputes associated with your account.



# Get Dispute Detail
Source: https://docs.dodopayments.com/api-reference/disputes/get-disputes-1

get /disputes/{dispute_id}
Get detailed information about a specific dispute.



# Charge Subscription
Source: https://docs.dodopayments.com/api-reference/misc/charge-subscriptions

post /subscriptions/{subscription_id}/charge
Charge a customer for an on-demand subscription.



# Supported Countries
Source: https://docs.dodopayments.com/api-reference/misc/supported-countries

get /checkout/supported_countries
Retrieve a list of countries that are supported by the Dodo Payments for your customers.

<Tip> You will receive a list of [ISO Alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) country codes representing the countries we **currently support for payments**. You can view the full list of supported countries [here](/miscellaneous/list-of-countries-we-accept-payments-from). This list is updated regularly as we expand our coverage. </Tip>

<Tip> Note: The available options include ISO Alpha-2 codes for **all countries**, not just the ones we currently support. Please refer to the supported countries list to confirm availability. </Tip>


# List Payouts
Source: https://docs.dodopayments.com/api-reference/payouts/get-payouts

get /payouts
Get a list of all payouts associated with your account.



# Get Refund Receipt
Source: https://docs.dodopayments.com/api-reference/refunds/get-refund-receipt

get /invoices/refunds/{refund_id}
Get a refund receipt for a refund.



# List Refunds
Source: https://docs.dodopayments.com/api-reference/refunds/get-refunds

get /refunds
Get a list of all refunds associated with your account.



# Get Refund Detail
Source: https://docs.dodopayments.com/api-reference/refunds/get-refunds-1

get /refunds/{refund_id}
Get detailed information about a specific refund.



# Create Refund
Source: https://docs.dodopayments.com/api-reference/refunds/post-refunds

post /refunds
Create a refund for a payment.



# Get Event
Source: https://docs.dodopayments.com/api-reference/usage-events/get-event

get /events/{event_id}
Get an event by its ID.



# List Events
Source: https://docs.dodopayments.com/api-reference/usage-events/list-events

get /events
Get a list of all events.



# Create Webhook
Source: https://docs.dodopayments.com/api-reference/webhooks/create-webhook

post /webhooks
Create a new webhook for a business.



# Delete Webhook
Source: https://docs.dodopayments.com/api-reference/webhooks/delete-webhook

delete /webhooks/{webhook_id}
Delete a specific webhook.



# Get Webhook Details
Source: https://docs.dodopayments.com/api-reference/webhooks/get-details

get /webhooks/{webhook_id}
Get detailed information about a specific webhook.



# Get Webhook Headers
Source: https://docs.dodopayments.com/api-reference/webhooks/get-webhook-headers

get /webhooks/{webhook_id}/headers
Get the headers for a specific webhook.



# Get Webhook Signing Key
Source: https://docs.dodopayments.com/api-reference/webhooks/get-webhook-signing-key

get /webhooks/{webhook_id}/secret
Get the signing key for a specific webhook.



# List Webhooks
Source: https://docs.dodopayments.com/api-reference/webhooks/list-webhooks

get /webhooks
List all webhooks for a business.



# Update Webhook
Source: https://docs.dodopayments.com/api-reference/webhooks/update-webhook

patch /webhooks/{webhook_id}
Update a specific webhook.



# Update Webhook Headers
Source: https://docs.dodopayments.com/api-reference/webhooks/update-webhook-headers

patch /webhooks/{webhook_id}/headers
Update the headers for a specific webhook.



# Changelog
Source: https://docs.dodopayments.com/changelog/introduction

Track all Dodo Payments releases, new features, improvements, and platform updates. Complete version history with detailed changelogs for each release.

## Version Logs

| Version                       | Release Date       | Highlights                                                                                                                                                                                                                                                |
| ----------------------------- | ------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [v1.78.0](/changelog/v1.78.0) | February 2, 2026   | Communication preferences with push notifications, custom fields for checkout sessions, and expanded checkout language support"                                                                                                                           |
| [v1.75.0](/changelog/v1.75.0) | January 23, 2026   | Product collections, RevolutPay & Billie for GBP one-time payments, checkout session preview, metadata in change plan requests, invoice\_url in API responses, discount validation endpoint, and enhanced dashboard filtering                             |
| [v1.70.0](/changelog/v1.70.0) | December 24, 2025  | Inline checkout support, use existing payment methods for instant checkouts, manage subscription plans from dashboard, generate short payment links, skip success pages with redirect\_immediately, and enable on-demand subscriptions for all businesses |
| [v1.67.0](/changelog/v1.67.0) | December 17, 2025  | Mixed cart checkout for one-time and subscription products, Unified Customer Portal, invoice\_id in Payment Response                                                                                                                                      |
| [v1.66.0](/changelog/v1.66.0) | December 8, 2025   | Subscription.updated webhook, minimal address checkout, read-only API keys, UPI AutoPay & RuPay subscriptions for all businesses                                                                                                                          |
| [v1.61.5](/changelog/v1.61.5) | November 17, 2025  | EUR & GBP pricing full rollout, payment method management, metadata in customers and refunds, checkout session feature flags, license key/file indicators, GitHub OAuth, and Featurebase integration                                                      |
| [v1.56.0](/changelog/v1.56.0) | October 27, 2025   | Streamlined onboarding, C# SDK launch, webhook verification, Two-Factor Authentication, overlay checkout sessions, and usage-based subscription plan changes                                                                                              |
| [v1.53.2](/changelog/v1.53.2) | September 13, 2025 | Customer credits, enhanced refund details, higher meter limits, license activation context, and \$0 downgrades                                                                                                                                            |
| [v1.52.4](/changelog/v1.52.4) | September 3, 2025  | Usage-Based Billing, public Refund Receipt API, 100% subscription discounts, and checkout session ID in payments                                                                                                                                          |
| [v1.51.0](/changelog/v1.51.0) | August 23, 2025    | Powerful Checkout Sessions API, Metadata in Payments Export, and Subscription Next Billing Date Update                                                                                                                                                    |
| [v1.47.0](/changelog/v1.47.0) | August 11, 2025    | Dashboard UI overhaul, discount codes for subscriptions, expanded Adaptive Currency, webhook management API, and product metadata support                                                                                                                 |
| [v1.44.0](/changelog/v1.44.0) | August 3, 2025     | Adaptive Currency, Turkish Language Support, and New Proration Mode                                                                                                                                                                                       |
| [v1.43.0](/changelog/v1.43.0) | July 24, 2025      | Comprehensive Webhooks Upgrade: endpoint management, security, delivery logs, debugging, and monitoring—now fully self-serve in the dashboard                                                                                                             |
| [v1.38.0](/changelog/v1.38.0) | July 9, 2025       | Analytics Chart Sharing, Multiple Partial Refunds, Cumulative Revenue Analytics, Context7 Integration, Next.js Adapter                                                                                                                                    |
| [v1.37.0](/changelog/v1.37.0) | July 2, 2025       | Enhanced Analytics Dashboard with comprehensive revenue and retention insights, Reports 2.0 with detailed business reporting capabilities                                                                                                                 |
| [v1.34.4](/changelog/v1.34.4) | June 26, 2025      | Enhanced Dashboard Analytics with comprehensive new metrics across Revenue Analytics, Customer Analytics, and Payment Success Rate Analytics                                                                                                              |
| [v1.34.0](/changelog/v1.34.0) | June 18, 2025      | Digital Product Delivery, React Native SDK beta release, new proration modes, adaptive currency for subscriptions, and enhanced verification form management                                                                                              |
| [v1.32.0](/changelog/v1.32.0) | June 9, 2025       | Affiliates with Affonso, multiple webhook support, enhanced fraud prevention, subscription schedule cancellation, and static payment links                                                                                                                |
| [v1.30.0](/changelog/v1.30.0) | June 2, 2025       | Support for \$0 payments and 100% discount codes for one-time products, enabled payout threshold for USD wallet, and standardized API error codes                                                                                                         |
| [v1.27.0](/changelog/v1.27.0) | May 26, 2025       | Partial Refunds and Multi-Brand Support, enabling merchants to manage multiple brands and websites under a single verified business account                                                                                                               |
| [v1.25.0](/changelog/v1.25.0) | May 20, 2025       | Overlay Checkout Beta, a modern TypeScript library for embedded payments, and subscription.plan\_changed webhook event                                                                                                                                    |
| [v1.22.0](/changelog/v1.22.0) | May 9, 2025        | Unified search to the dashboard, support for upgrading and downgrading subscriptions with addons, and comprehensive card information in payment responses                                                                                                 |
| [v1.21.0](/changelog/v1.21.0) | May 3, 2025        | Support for addons to subscriptions, enhanced dispute handling, and customer billing details in payment responses                                                                                                                                         |
| [v1.18.3](/changelog/v1.18.3) | April 26, 2025     | Subscription Plan Change API, enhanced onboarding guidance, notification preferences center, and improved adaptive currency information                                                                                                                   |
| [v1.16.1](/changelog/v1.16.1) | April 18, 2025     | Modern verification forms, new Java and Kotlin SDKs, Afterpay/Clearpay integration, and Google Sign-In                                                                                                                                                    |
| [v1.14.0](/changelog/v1.14.0) | April 12, 2025     | New European payment methods, subscription billing address updates, and various improvements                                                                                                                                                              |
| [v1.13.0](/changelog/v1.13.0) | April 9, 2025      | Adaptive Currency Support, MCP Server for AI integration, mobile apps, Custom GPT, and Dodo Dash game                                                                                                                                                     |
| [v1.11.0](/changelog/v1.11.0) | March 28, 2025     | Address autofill for checkout page, notifications center, payment link query builder, saved payment methods, and billing currency control                                                                                                                 |
| [v1.10.1](/changelog/v1.10.1) | March 21, 2025     | Checkout 2.0, configurable payment methods, dynamic tax calculation, and on-demand subscriptions                                                                                                                                                          |
| [v1.7.0](/changelog/v1.7.0)   | March 14, 2025     | Dedicated subscriptions page, enhanced customer details, detailed payout information, official Ruby SDK, and enhanced API filters                                                                                                                         |
| [v1.5.0](/changelog/v1.5.0)   | March 7, 2025      | Custom date filter for analytics, new tax category, and various improvements                                                                                                                                                                              |
| [v1.4.0](/changelog/v1.4.0)   | March 6, 2025      | Storefront Feature and Amazon Pay Integration                                                                                                                                                                                                             |
| [v1.3.2](/changelog/v1.3.2)   | February 28, 2025  | Teams Feature, enhanced success/failure screens, and minor improvements                                                                                                                                                                                   |
| [v1.0.0](/changelog/v1.0.0)   | February 23, 2025  | Public release of Dodo Payments with Customer Portal and Customer Portal Session API                                                                                                                                                                      |
| [v0.24.0](/changelog/v0.24.0) | February 15, 2025  | Discount coupons, support for over 25 local payment methods, customizable statement descriptors, and complete UI makeover of the login page                                                                                                               |
| [v0.22.0](/changelog/v0.22.0) | February 6, 2025   | Subscription's first payment, UPI QR payment method, tax ID on checkout, dashboard restructure, self-serve onboarding guides, multi-language support                                                                                                      |
| [v0.20.1](/changelog/v0.20.1) | January 31, 2025   | Pay What You Want (PWYW) pricing and expanded global payment coverage                                                                                                                                                                                     |
| [v0.19.0](/changelog/v0.19.0) | January 24, 2025   | Support for UPI and Indian Rupay cards, PHP SDK release, and product archiving                                                                                                                                                                            |
| [v0.18.0](/changelog/v0.18.0) | January 20, 2025   | AI chat support, enhanced APIs, inclusive tax pricing, automated country selection, and more                                                                                                                                                              |
| [v0.16.1](/changelog/v0.16.1) | January 11, 2025   | Account Summary feature, enhanced API documentation, and improved postal code validation                                                                                                                                                                  |
| [v0.15.1](/changelog/v0.15.1) | January 3, 2025    | Invoice API, subscription webhooks, comprehensive guides, Dodo Wall of Love, and social sharing features                                                                                                                                                  |
| [v0.14.0](/changelog/v0.14.0) | December 26, 2024  | License Key Management feature, enhancing security and control for merchants distributing digital products and services                                                                                                                                   |
| [v0.13.2](/changelog/v0.13.2) | December 21, 2024  | Updated Atlas codebase, SDK updates, and minor improvements                                                                                                                                                                                               |
| [v0.12.0](/changelog/v0.12.0) | December 17, 2024  | Official SDKs, metadata field, and expanded customer APIs with minor improvements and bug fixes                                                                                                                                                           |
| [v0.11.0](/changelog/v0.11.0) | December 13, 2024  | Automated emails, webhook event logs, license key generation guide, and various minor improvements and bug fixes                                                                                                                                          |
| [v0.10.0](/changelog/v0.10.0) | December 8, 2024   | Open-sourced Atlas demo, feature-request section, webhook request logs API, subscription list API, and various improvements                                                                                                                               |
| [v0.1.0](/changelog/v0.1.0)   | November 25, 2024  | Initial release of the Dodo Payments documentation, marking the Beta launch of our product                                                                                                                                                                |


# v0.1.0 (25 Nov 2024)
Source: https://docs.dodopayments.com/changelog/v0.1.0

This is the initial release of the Dodo Payments documentation, marking the Beta launch of our product. Explore the features and improvements designed to enhance your payment processing experience.

## Smooth Onboarding

* Comprehensive onboarding tracker to monitor merchant progress.
* Support for document resubmission and live-mode activation upon verification.

## Product Catalogue Management

* Easy creation, editing, and deletion of one-time and subscription products.

## Payment Link

* Generate payment links for one-time and subscription products.
* Includes configurable quantities and redirection options for post-payment customer journeys.

## Customizable Checkout Page

* Branded checkout experiences with localized payment options available.
* Real-time tax and total amount calculation displayed on checkout.

## Automated Invoice Generation

* Automatic invoice generation for payments, refunds, and payouts.

## Refund Management

* Seamless partial and full refund management from the dashboard.
* Introduced dispute tracking for effective resolutions.

## Transparent Payouts

* Flexible payout mechanisms with transparent policies and fees.

## Analytics and Reporting

* Advanced analytics dashboard to showcase total revenue, transaction breakdown, customer insights, and top-performing product types.

## API and Webhook Generation

* Easy-to-generate API keys to integrate Dodo Payments into your website or application.
* Webhook setup for real-time notifications about transactions, refunds, and disputes.


# v0.10.0 (8 Dec 2024)
Source: https://docs.dodopayments.com/changelog/v0.10.0

Open-sourced Atlas demo, feature-request section, webhook request logs API, subscription list API, and various improvements and bug fixes.

## New Features

* **Open Sourced Atlas**: A demo application written in Next.js to showcase the integration of Dodo Payments. Explore the [GitHub Repository](https://github.com/dodopayments/dodo-checkout-demo) and documentation [here](/developer-resources/integration-guide).
* **Feature-Request Section**: Introduced a feature-request section on the Dodo Payments dashboard to prioritize the product roadmap based on user feedback.
* **Webhook Request Logs API**: Added APIs for listing and detailing webhook request logs.
* **Static Payment Links**: Added more query parameters to the static payment links to provide more flexibility in the checkout process. For more details, click [here](/developer-resources/integration-guide#1-static-payment-links).
* **Subscription List API**: Added an API to fetch all subscriptions. Refer to the [API Reference](/api-reference/subscriptions/get-subscriptions-1) for details.

## Minor Improvements and Bug Fixes

* Enhanced the Product and Subscription API responses with additional parameters.
* Implemented rate limiting for API requests, currently set to 20 requests per second.
* Improved the documentation to be more user-friendly and easier to navigate.
* Various minor bug fixes and improvements.


# v0.11.0 (13 Dec 2024)
Source: https://docs.dodopayments.com/changelog/v0.11.0

Introduced automated emails, webhook event logs, a license key generation guide, and various minor improvements and bug fixes.

## New Features

* **Automated Emails**: Added automated emails for payments, subscriptions, refunds, and disputes to keep merchants and customers informed.
* **Webhook Event Log**: Added webhook event log on Dodo Payments Dashboard to track webhook events and troubleshoot issues. Navigate to `Settings > Webhooks > Webhook Logs` to access the logs.
* **License Key Generation Guide**: Added a new guide to implement license key generation for digital products. Refer to the [guide](/features/license-keys) for more information.

## Minor Improvements and Bug Fixes

* Various minor fixes and improvements.


# v0.12.0 (17 Dec 2024)
Source: https://docs.dodopayments.com/changelog/v0.12.0

Added official SDKs, metadata field, and expanded customer APIs with minor improvements and bug fixes.

## New Features

* **Official SDKs**: Introduced official Dodo Payments SDKs for **Node.js**, **Python**, and **Go**. Refer to the [SDKs](/developer-resources/dodo-payments-sdks) page for more information.
* **Metadata Field**: Added a `Metadata` field for payments and subscriptions to store additional information. Refer to the [Metadata](/api-reference/metadata) page for more details.
* **Customer APIs**: Expanded customer APIs to include the following endpoints. You can now pass `customer_id` in payments and subscriptions to prevent customer duplication:
  * **Create Customer**: [/api-reference/customers/create-customer](/api-reference/customers/create-customer)
  * **Patch Customer**: [/api-reference/customers/patch-customer](/api-reference/customers/patch-customer)

## Minor Improvements and Bug Fixes

* Various minor fixes and improvements.


# v0.13.2 (21 Dec 2024)
Source: https://docs.dodopayments.com/changelog/v0.13.2

Updated Atlas codebase, SDK updates, and minor improvements.

## New Features

* **Atlas**: The [GitHub Repository](https://github.com/dodopayments/dodo-checkout-demo) codebase has been updated to use the [Dodo Payments Node SDK](https://github.com/dodopayments/dodopayments-node).
* **SDK Update**: Bumped our SDK versions to `0.13.2` with fixes and updates.

## Minor Improvements and Bug Fixes

* **Dashboard Toggle**: Improved the Test Mode and Live Mode toggle on the dashboard to enhance UX.
* Various minor fixes and improvements.


# v0.14.0 (26 Dec 2024)
Source: https://docs.dodopayments.com/changelog/v0.14.0

Introduced the License Key Management feature, enhancing security and control for merchants distributing digital products and services.

### New Feature: License Key Management

We are excited to introduce the **License Key Management** feature, designed to help merchants secure their digital products and services by generating, managing, and tracking unique license keys. This feature ensures only authorized users access your products and provides merchants with full control over their license key usage and distribution. Ideal for SaaS businesses and digital product vendors, the tool also includes advanced tracking and revocation capabilities for enhanced security.

For more details, please visit the [License Keys Documentation](/features/license-keys).


# v0.15.1 (4 Jan 2025)
Source: https://docs.dodopayments.com/changelog/v0.15.1

Introducing Invoice API, subscription webhooks, comprehensive guides, Dodo Wall of Love, and social sharing features. Plus, enhanced subscription trial periods and customer identification.

## New Features 🚀

### API Enhancements

* Launched Invoice API, enabling merchants and customers to download invoices using `payment_id`. Visit the [Invoice API](/api-reference/payments/get-invoice) documentation for more details.
* Implemented new `subscription.renewed` webhook event for subscription renewal notifications.

### Platform Updates

* Introduced Dodo Payments [Wall of Love](https://dodopayments.com/wall-of-love), showcasing customer testimonials.
* Added social sharing functionality for successful transactions.
  <img alt="Share Transaction Feature" />
* Released Policy Generator tool for automatic generation of privacy policy, terms of service, and refund policy documents. [Try Policy Generator](https://dodopayments.com/tools/policy-generator).

### Documentation Improvements

* Published comprehensive guides:
  * [Subscription Integration Guide](/developer-resources/subscription-integration-guide)
  * [Webhook Events Guide](/developer-resources/webhooks/intents/webhook-events-guide)

## Improvements and Bug Fixes 🔧

### API Updates

* Added `trial_period_days` parameter to [Create Subscription API](/api-reference/subscriptions/post-subscriptions) to override product-level trial periods.
* Enhanced customer identification logic: now using consistent `customer_id` across payments and subscriptions for the same email.
* Implemented various performance optimizations and fixed minor bugs.


# v0.16.1 (11 Jan 2025)
Source: https://docs.dodopayments.com/changelog/v0.16.1

Added Account Summary feature, enhanced API documentation, and improved postal code validation.

## New Features 🚀

* **Account Summary Feature**: Provides detailed visibility into transaction and payout ledgers.
  <img alt="Account Summary" />
* **Enhanced API Documentation**: Includes comprehensive parameter descriptions and usage examples.

## Improvements and Bug Fixes 🔧

* **Postal Code Validation**: Updated `Zipcode` field validation to support alphanumeric postal codes.
* **System Optimizations**: Implemented various bug fixes and optimizations to improve overall performance.


# v0.18.0 (20 Jan 2025)
Source: https://docs.dodopayments.com/changelog/v0.18.0

Added AI chat support, enhanced APIs, inclusive tax pricing, automated country selection, and more.

## New Features 🚀

* **AI Chat Support**: Now you can chat with our AI assistant to get help with your technical queries or check the documentation more effectively.
  <img alt="Dodo Payments AI Chat Support" />

* **Enhanced APIs**: Added APIs to filter payments, refunds, subscriptions, and disputes based on `customer_id`, time period, and status, providing more flexibility in data retrieval.

* **Inclusive Tax Pricing**: Added support to make the product price inclusive of tax while creating/updating the product. The tax amount will be calculated automatically based on the tax rate.

* **Automated Country Selection**: Implemented IP-based country auto-selection in static payment links. The country will be auto-selected based on the user's IP address when they open the static payment links.

* **Query Parameter Removal**: Query parameters are now removed as soon as the static payment link loads, preventing end customers from changing URL parameters and tampering with the static payment link.

## Improvements and Bug Fixes 🔧

* **Minor Enhancements and Fixes**: Various minor enhancements and fixes to improve overall performance and user experience.


# v0.19.0 (24 Jan 2025)
Source: https://docs.dodopayments.com/changelog/v0.19.0

Added support for UPI and Indian Rupay cards, released PHP SDK, and introduced product archiving.

## New Features 🚀

* **UPI and Indian Rupay Card Support**: Added support for UPI and Indian Rupay cards for processing payments in India, currently limited to one-time purchases only. You can now accept payments from customers using UPI and Rupay cards. Additionally, enabled the creation of products with INR pricing on the Dodo Payments Dashboard.

  <Frame>
    <iframe title="UPI Announcement | Dodo Payments" />
  </Frame>

* **PHP SDK Release**: Launched a new PHP SDK for Dodo Payments, simplifying the integration of Dodo Payments into PHP applications.
  <Card title="View PHP SDK on GitHub →" icon="github" href="https://github.com/dodopayments/dodopayments-php"> Explore the PHP SDK for Dodo Payments on GitHub. </Card>

* **Product Archiving**: Introduced the ability to archive and unarchive products on the Dodo Payments Dashboard, helping manage clutter and maintain a clean interface.

## Improvements and Bug Fixes 🔧

* **Minor Enhancements and Fixes**: Various minor enhancements and fixes to improve overall performance and user experience.


# v0.20.1 (31 Jan 2025)
Source: https://docs.dodopayments.com/changelog/v0.20.1

Introduced Pay What You Want (PWYW) pricing and expands global payment coverage.

## New Features 🚀

* **Pay What You Want (PWYW) Pricing**: Introduced support for PWYW pricing, allowing users to choose any amount they wish to pay. This feature can be found while creating the product. For more details, please refer to the [documentation](/features/pricing#pay-what-you-want-pricing).

* **Expanded Global Coverage**: Dodo Payments now supports seamless payments from over 150 countries, enhancing global accessibility and convenience for users.
  <Frame>
    <iframe title="Global Coverage Announcement | Dodo Payments" />
  </Frame>

## Improvements and Bug Fixes 🔧

* **Minor Enhancements and Fixes**: Various minor enhancements and fixes to improve overall performance and user experience.


# v0.22.0 (6 Feb 2025)
Source: https://docs.dodopayments.com/changelog/v0.22.0

Introduced subscription's first payment, UPI QR payment method, tax ID on checkout, dashboard restructure, self-serve onboarding guides, multi-language support, invoice PDF makeover, and a centralized help widget.

## New Features 🚀

* **Subscription's First Payment**: The most requested feature is here! Now, there will be a single transaction for the first payment, combining the mandate and the actual subscription amount.

* **UPI QR Payment Method**: Added UPI QR as a payment method for the Indian market, allowing customers to pay using UPI QR codes.

  <img alt="UPI QR Feature" />

* **Tax ID on Checkout**: Customers can now add their Tax ID on the checkout page for invoicing and tax purposes.

* **Dashboard Restructure**: The entire Dodo Payments Dashboard has been restructured to be more intuitive and user-friendly.

* **Self-Serve Onboarding Guides**: New users can now get started with Dodo Payments using self-serve onboarding guides.

* **Multi-Language Support**: Added support for 14+ languages on the checkout page, allowing customers to pay in their preferred language. Supported languages include:
  * English (en)
  * العربية (ar) // Arabic
  * Català (ca) // Catalan
  * 中文 (cn) // Chinese
  * Deutsch (de) // German
  * Español (es) // Spanish
  * Français (fr) // French
  * עברית (he) // Hebrew
  * Italiano (it) // Italian
  * 日本語 (ja) // Japanese
  * Nederlands (nl) // Dutch
  * Polski (pl) // Polish
  * Português (pt) // Portuguese
  * Svenska (sv) // Swedish
  <Frame>
    <iframe title="Language Announcement | Dodo Payments" />
  </Frame>

* **Invoice PDF Makeover**: The invoice PDFs have been given a new, clearer, and more effective design.

* **Centralized Help Widget**: Added a centralized Help widget to streamline and improve support.

  <img alt="Help Widget" />

## Improvements and Bug Fixes 🔧

* **Rate Limiting**: Added rate limiting in the invoice API to prevent abuse and ensure system stability.

* **Metadata in Static Payment Links**: Added support for metadata in static payment links. For more details, refer to the [documentation](/developer-resources/integration-guide#1-static-payment-links).

* **Minor Enhancements and Fixes**: Various minor enhancements and fixes to improve overall performance and user experience.


# v0.24.0 (15 Feb 2025)
Source: https://docs.dodopayments.com/changelog/v0.24.0

Introduced discount coupons, support for over 25 local payment methods, customizable statement descriptors, and a complete UI makeover of the login page.

## New Features 🚀

* Introduced the functionality to create and add Discount Coupons to your products and services. You can create coupons with percentage discounts, set expiry dates, and more. Go to `Dashboard > Sales > Discounts` to create and manage discount coupons.

* Dodo Payments now supports over 25 local payment methods, including Apple Pay, Google Pay, Klarna, Affirm, Cash App, UPI, and all major credit/debit cards. This helps boost conversions and reduce checkout drop-offs.

  <Frame>
    <iframe title="Local Payment Methods Announcement | Dodo Payments" />
  </Frame>

* Added functionality to customize the statement descriptor that appears on your customers' bank statements when they make a payment. You can find the option to customize the statement descriptor under `Dashboard > Business > Business Profile`.

* Complete UI makeover of the Dodo Payments login page.

## Improvements and Bug Fixes 🔧

* Security enhancements, performance improvements, and minor fixes.


# v1.0.0 (23 Feb 2025)
Source: https://docs.dodopayments.com/changelog/v1.0.0

Public release of Dodo Payments with Customer Portal and Customer Portal Session API.

This marks the first changelog since Dodo Payments exited Beta and is now publicly available. 🎉

<Frame>
  <iframe title="Public Announcement | Dodo Payments" />
</Frame>

## New Features 🚀

* **Customer Portal**: Introduced the `Customer Portal` feature, allowing customers to manage their subscriptions, invoices, and payment methods. You can create static or dynamic Customer Portal links for your customers via the Dodo Payments Dashboard or through APIs. On the dashboard, navigate to `Sales > Customers > Share Invite`.

* **Customer Portal Session API**: Added the `Customer Portal Session` API to create a session of the Customer Portal for a specific customer. Note that the session is valid for only 24 hours. Check the [API Reference](/api-reference/customers/create-customer-portal-session) for more details.

* **Others**: Minor improvements and bug fixes.


# v1.10.1 (21 March 2025)
Source: https://docs.dodopayments.com/changelog/v1.10.1

Introduced Checkout 2.0, configurable payment methods, dynamic tax calculation, and on-demand subscriptions.

## New Features 🚀

* **Checkout 2.0**: Introducing a completely redesigned checkout experience featuring:
  * Streamlined, modern interface for improved user experience
  * New Query Collector System that stores parameters in session storage with unique IDs (e.g., `sess_1a2b3c4d`)
  * Persistent data availability throughout the entire checkout flow
  * More enhancements planned for future releases!
  <Frame>
    <img alt="Checkout 2.0" />
  </Frame>

* **Configurable Payment Methods**: New `allowed_payment_methods` configuration enables merchants to customize available payment options during checkout. See the [Allowed Payment Methods](/features/payment-methods#configuring-payment-methods) documentation for implementation details.

* **Dynamic Tax Calculation**: Real-time calculation of tax rates based on customer billing addresses for more accurate pricing on the static payment links.

* **On-Demand Subscriptions**: New API endpoints for flexible subscription billing (available for select merchants).  Learn more in the [On-Demand Subscriptions](/features/subscription#enabling-on-demand-subscriptions) guide.

* **Additional Updates**:
  * Performance optimizations
  * Bug fixes
  * General system improvements


# v1.11.0 (28 March 2025)
Source: https://docs.dodopayments.com/changelog/v1.11.0

Introduced address autofill for checkout page, notifications center, payment link query builder, saved payment methods, and billing currency control.

## New Features 🚀

* **Address Autofill**: Streamlined checkout process with smart address field auto-completion based on user input.

  <Frame>
    <img alt="Address Autofill" />
  </Frame>

* **Notifications Center**: Stay informed with a new dedicated notifications tab for important system events and updates.

  <Frame>
    <img alt="Notifications" />
  </Frame>

* **Payment Link Query Builder**: Create and customize payment links more efficiently with our new visual query builder.

  <Frame>
    <img alt="Query Builder" />
  </Frame>

* **Saved Payment Methods**: Enable display of previously used payment methods during checkout by setting `show_saved_payment_methods: true` in payment link configuration.

* **Billing Currency Control**: Enforce specific billing currencies for payment links by setting the `billing_currency` parameter.

* **Improvements**: Various improvements and bug fixes.


# v1.13.0 (9th April 2025)
Source: https://docs.dodopayments.com/changelog/v1.13.0

New features including Adaptive Currency Support, MCP Server for AI integration, mobile apps, Custom GPT, and Dodo Dash game

## New Features 🚀

* **[Adaptive Currency Support](/features/adaptive-currency)** 💱
  * Automatically display prices in customers' local currencies based on their location.
  * Merchants receive payments in their preferred currency, while customers pay in their local currency.
  * Transparent conversion fee structure ranging from 2% to 4%, depending on the order value.
  * Support for over 25 new currencies has been added:
    * **Middle East**: AED (UAE Dirham), SAR (Saudi Riyal)
    * **Asia Pacific**: AUD (Australian Dollar), CNY (Chinese Yuan), HKD (Hong Kong Dollar), IDR (Indonesian Rupiah), KRW (South Korean Won), SGD (Singapore Dollar), TWD (New Taiwan Dollar)
    * **Europe**: ALL (Albanian Lek), CHF (Swiss Franc), CZK (Czech Koruna), DKK (Danish Krone), EUR (Euro), GBP (British Pound), HUF (Hungarian Forint), NOK (Norwegian Krone), PLN (Polish Zloty), RON (Romanian Leu), RSD (Serbian Dinar), SEK (Swedish Krona), TRY (Turkish Lira)
    * **Americas**: BRL (Brazilian Real), CAD (Canadian Dollar), MXN (Mexican Peso)
    <Frame>
      <img alt="Adaptive Currency" />
    </Frame>

* **[Dodo Payments MCP Server](/developer-resources/mcp-server)** 🤖
  * Introducing the new Model Context Protocol (MCP) Server for seamless AI model integration.
  * Provides a standardized interface for interacting with the DodoPayments API.
  * Simple installation via `npx` or through MCP client integration.
  * Offers a comprehensive tool suite for managing payments, subscriptions, and more.
  * Includes advanced features such as tool filtering and enhanced security controls.

* [Mobile App](/features/mobile-app): Now available for iOS and Android, bringing the complete dashboard experience to your mobile device. Key features include:
  * Real-time notifications for transactions, payouts, and subscription renewals
  * Full dashboard access with revenue tracking and performance graphs
  * Complete subscription and product management capabilities
  * Business operations including test/live mode switching and verification management
  * Developer tools with API key management and webhook monitoring
    Download now on the [App Store](https://apps.apple.com/in/app/dodo-payments/id6743651329) or [Google Play](https://play.google.com/store/apps/details?id=com.dodopayments.app).

* **Custom GPT for Dodo Payments**: Available on the ChatGPT Marketplace, trained on our documentation to assist with technical questions or issues. Access it here, [https://dodo.pe/custom-gpt](https://dodo.pe/custom-gpt)

* **Dodo Dash**: Experience the thrill of our endless runner game, Dodo Dash! Guide a daring dodo bird as it sprints, jumps, and dodges obstacles to survive. Give it a try here, [https://dash.dodopayments.com](https://dash.dodopayments.com).

* Various other bug fixes and improvements have been implemented.


# v1.14.0 (12th April 2025)
Source: https://docs.dodopayments.com/changelog/v1.14.0

Introduced new European payment methods, subscription billing address updates, and various improvements.

## New Features 🚀

* **New European Payment Methods**: We've expanded our payment options with four new European payment methods:

  * **iDEAL** - Netherlands
  * **Bancontact** - Belgium
  * **Przelewy24 (P24)** - Poland
  * **EPS** - Austria

  <Frame>
    <img alt="Supported European Payment Methods" />
  </Frame>

  <Note>
    These payment methods are currently limited to:

    * Euro (EUR) currency only
    * One-time payments only (not available for subscriptions)

    For detailed information about these payment methods, visit our [Payment Methods](/features/payment-methods) documentation.
  </Note>

* **Subscription Billing Address Updates**: Added the ability to update billing addresses for subscriptions through:
  * Customer portal interface
  * Patch subscription API endpoint


# v1.16.1 (18th April 2025)
Source: https://docs.dodopayments.com/changelog/v1.16.1

Introduced modern verification forms, new Java and Kotlin SDKs, Afterpay/Clearpay integration, and Google Sign-In.

## New Features 🚀

* **Modern Verification Forms**: Redesigned the verification forms with a modern, user-friendly interface featuring clearer instructions, improved visual hierarchy, and intuitive form fields for a smoother verification process.

  <Frame>
    <img alt="Verification Forms" />
  </Frame>

* **New Java and Kotlin SDKs**: Released native SDKs for Java and Kotlin to support Android development and enterprise Java applications. The SDKs include comprehensive documentation, sample code, and full support for Dodo Payments features including payments, subscriptions, and refunds. Available on GitHub: [Java SDK](https://github.com/dodopayments/dodopayments-java) and [Kotlin SDK](https://github.com/dodopayments/dodopayments-kotlin).

* **Afterpay/Clearpay Integration**: Added support for Afterpay/Clearpay as a Buy Now, Pay Later (BNPL) payment method, enabling customers to split payments into 4 interest-free installments.

* **Google Sign-In**: Implemented Google Sign-In as a new authentication option, allowing users to log in using their Google accounts. This OAuth 2.0-compliant integration supports both personal and workspace Google accounts for enhanced security and convenience.


# v1.18.3 (26th April 2025)
Source: https://docs.dodopayments.com/changelog/v1.18.3

Introduced Subscription Plan Change API, enhanced onboarding guidance, notification preferences center, and improved adaptive currency information.

## New Features 🚀

* **Subscription Plan Change API**: Launched a new API that enables seamless upgrades or downgrades of subscriptions between different product plans. For implementation details, see the [API reference](/api-reference/subscriptions/change-plan).

* **Enhanced Onboarding Guidance**: Improved sidebar nudges to provide clearer direction on next steps in your Dodo Payments onboarding journey.

  <Frame>
    <img alt="Sidebar Nudges" />
  </Frame>

* **Notification Preferences Center**: Added a dedicated section for managing your notification settings. Access it by clicking the bell icon in the top right corner and then selecting the settings icon.

  <Frame>
    <img alt="Notification Preferences" />
  </Frame>

* **Enhanced Adaptive Currency Information**: Added new fields to the payment response including `settlement_amount`, `settlement_currency`, and `settlement_tax` to provide greater transparency on settlement details.

* **General Improvements**: Various minor enhancements and bug fixes to improve overall platform performance.


# v1.21.0 (3rd May 2025)
Source: https://docs.dodopayments.com/changelog/v1.21.0

Added support for addons to subscriptions, made dispute handling more robust, and added customer billing details to payment responses.

## New Features 🚀

* **Subscription Addons**: Introduced support for addons to subscription products. In the Products section, you'll find a new Addons tab where you can create addons such as "Seats". Once created, you can edit your subscription products to include these addons. This feature is available both on the dashboard and via API.

  * [Create Addon](/api-reference/addons/create-addon)
  * [List Addons](/api-reference/addons/list-addons)
  * [Get Addon](/api-reference/addons/get-addon)
  * [Update Addon](/api-reference/addons/update-addon)
  * [Update Addon Images](/api-reference/addons/update-addon-images)

  With addons, you unlock new billing options such as seat-based billing or variable billing per customer. Get creative with addons to design flexible billing models for your business.

  <Frame>
    <img alt="Addons" />
  </Frame>

* **Enhanced Dispute Management**: Improved dispute handling to be more robust and easier to manage through your Dodo Payments dashboard.

* **Expanded Response Data**: Added customer billing details to payment responses, subscription responses, and webhooks.

* **General Improvements**: Various minor enhancements and bug fixes to improve overall platform performance.


# v1.22.0 (9th May 2025)
Source: https://docs.dodopayments.com/changelog/v1.22.0

Added unified search to the dashboard, added support for upgrading and downgrading subscriptions with addons, and added comprehensive card information to payment responses.

## New Features 🚀

* **Unified Dashboard Search**: We've implemented a powerful search functionality across the entire dashboard. You can now quickly find:

  * **Identifiers**: Payment, Refund, Dispute, Customer, Discount, Product, and Addon IDs
  * **Names**: Products, Addons, and Customers
  * **Contact Information**: Customer Email addresses
  * **Metadata**: Payment and Subscription metadata
  * **Navigation**: All pages within the Dodo Payments dashboard

  <Frame>
    <img alt="Unified Dashboard Search" />
  </Frame>

* **Addons Plan Changes**: Added support for upgrading and downgrading subscriptions that include addons.

* **Expanded Payment Card Details**: Payment responses now include comprehensive card information:
  * `card_issuing_country`: Country where the card was issued
  * `card_last_four`: Last 4 digits of the card number
  * `card_brand`: Card brand (Visa, Mastercard, etc.)
  * `card_type`: Card type (credit, debit, prepaid)

* **Platform Enhancements**: Various performance optimizations, bug fixes, and minor improvements across the platform.


# v1.25.0 (20th May 2025)
Source: https://docs.dodopayments.com/changelog/v1.25.0

Introduced Overlay Checkout Beta, a modern TypeScript library for embedded payments, and a new subscription.plan_changed webhook event for better subscription lifecycle management.

## New Features 🚀

* **Overlay Checkout Beta**: We're excited to announce the beta release of our new overlay checkout experience. This modern TypeScript library provides a seamless way to integrate our payment overlay into your web application with real-time event handling and customizable themes. Key features include:

  * **Real-time Event Handling**: Listen to checkout events like payment creation, success, and failure
  * **TypeScript Support**: Fully typed APIs for better developer experience
  * **Customizable Themes**: Support for light and dark themes
  * **Browser Compatibility**: Works across all modern browsers including Chrome, Firefox, Safari, Edge, and IE11+
  * **PCI Compliance**: Maintains security standards while providing an embedded experience

  <Frame>
    <img alt="Overlay Checkout Cover Image" />
  </Frame>

  Try it out:

  * Live Demo: [https://atlas.dodopayments.com](https://atlas.dodopayments.com#overlay-checkout)
  * Example Code: [https://github.com/dodopayments/dodo-checkout-demo](https://github.com/dodopayments/dodo-checkout-demo)
  * Integration Guide: [Overlay Checkout Guide](/developer-resources/overlay-checkout)

* **New Subscription Event**: Added support for the `subscription.plan_changed` webhook event that fires whenever a subscription is upgraded, downgraded, or modified. This event provides:

  * Complete subscription details after the change
  * Previous and new plan information
  * Prorated billing adjustments
  * Updated next billing date

  This event complements our existing subscription events (`subscription.active`, `subscription.on_hold`, etc.) to provide comprehensive visibility into the subscription lifecycle.

* **Platform Enhancements**: Various performance optimizations, bug fixes, and minor improvements across the platform.


# v1.27.0 (26th May 2025)
Source: https://docs.dodopayments.com/changelog/v1.27.0

Introduced Partial Refunds and Multi-Brand Support, enabling merchants to manage multiple brands and websites under a single verified business account.

## New Features 🚀

* **Partial Refunds**: We're excited to introduce our new Partial Refunds feature, now available through both our API and Dashboard. This powerful capability allows merchants to process precise refunds for specific components of a payment, whether it's a seat add-on or a portion of a subscription. The feature includes built-in validation to prevent errors and automatically generates refund receipts for your records.
  <Frame>
    <img alt="Partial Refunds Cover Image" />
  </Frame>

* **Multi-Brand Support**: We're launching Multi-Brand Support, enabling you to manage multiple brands and websites under a single verified business account. This feature is ideal for launching new product lines, creating regional microsites, or separating different offerings while maintaining a streamlined operation.

  Key features include:

  * **Rapid Verification**: Most brands are approved within 24 working hours through our streamlined website review process
  * **Branded Checkout Experience**: Customers see the specific brand's logo, name, and descriptor during checkout
  * **Seamless Brand Creation**: Create additional brands through Business Settings ▸ Brands ▸ Add Brand
  * **Detailed Transaction Analytics**: Each transaction clearly indicates its associated brand for better business insights
  * **Simplified Payouts**: All revenue consolidates into your existing account without additional verification requirements

  <Frame>
    <img alt="Multi-Brand Cover Image" />
  </Frame>

  To create additional brands, navigate to Business `Settings ▸ Brands ▸ Add Brand` and complete the required details.

* **Platform Enhancements**: Various performance optimizations, bug fixes, and minor improvements across the platform.


# v1.3.2 (28 Feb 2025)
Source: https://docs.dodopayments.com/changelog/v1.3.2

Introduced the Teams Feature, enhanced success/failure screens, and minor improvements.

## New Features 🚀

* **Teams Feature**: We have introduced the highly requested Teams Feature. Now, you can invite `Editors` and `Viewers` to your Business and collaborate with them seamlessly. To try it out, navigate to the `Business > Teams` section in the Dashboard.

  <Frame>
    <img alt="Teams Feature" />
  </Frame>

* **Enhanced Success/Failure Screens**: The default success and failure screens have been updated for cases where no `redirect_url` is provided. These screens now offer greater visibility to your customers and include an option to download the invoice.

  <Frame>
    <img alt="Success Screens" />
  </Frame>

* **Others**: Minor improvements and bug fixes.


# v1.30.0 (2nd June 2025)
Source: https://docs.dodopayments.com/changelog/v1.30.0

Added support for $0 payments and 100% discount codes for one-time products, enabling free product offerings, payout threshold for USD wallet, and standardized API error codes and messages.

## New Features 🚀

* **Zero-Dollar Payments**: Added support for \$0 payments and 100% discount codes for one-time products, enabling free product offerings and promotional campaigns.

* **Custom Payout Threshold**: Added the ability to set minimum payout amounts for USD wallets, helping merchants optimize payout processing and reduce fees for small transactions. Access this feature at `Payouts ▸ USD Wallet ▸ Edit Payout Threshold`.

  <Frame>
    <img alt="Payout Threshold Cover Image" />
  </Frame>

* **API Standardization**: Implemented standardized API error codes and messages as part of our ongoing API improvement initiative. This enhancement makes the API more consistent and developer-friendly. For detailed information, visit our [Error Codes Documentation](/api-reference/error-codes).

* **Transaction Decline Standardization**: Introduced unified transaction decline codes and messages, providing clearer insights into failure reasons and distinguishing between user errors and system issues. Learn more in our [Transaction Failures Documentation](/api-reference/transaction-failures).


# v1.32.0 (9th June 2025)
Source: https://docs.dodopayments.com/changelog/v1.32.0

Added support for Affiliates with Affonso, multiple webhook support, enhanced fraud prevention, subscription schedule cancellation, and static payment links.

## New Features 🚀

* **Affiliate Program Integration**: Launched integration with Affonso, enabling you to create and manage affiliate programs directly through Dodo Payments. Track referrals, handle commissions, and grow your revenue with trusted affiliate partnerships. Learn more in our [Affiliates](/features/affiliates) documentation.
  <Frame>
    <img alt="Affiliates Cover Image" />
  </Frame>

* **Multiple Webhook Support**: Enhanced webhook capabilities to support multiple endpoints, allowing you to send event notifications to different systems simultaneously.

* **Enhanced Fraud Prevention**: Added a new business setting to force 3D Secure authentication for all transactions, helping reduce fraud and chargebacks.

* **Subscription Schedule Cancellation**: Introduced the ability to schedule subscription cancellations to take effect at the end of the billing period, available through our API.

* **Static Payment Links**: Added two more query params for static payment links:
  * `paymentCurrency`: Specifies the payment currency. Default is set as per the billing country.
  * `showCurrencySelector`: Shows the currency selector. Default is true.


# v1.34.0 (18th June 2025)
Source: https://docs.dodopayments.com/changelog/v1.34.0

Added Digital Product Delivery, React Native SDK beta release, new proration modes, adaptive currency for subscriptions, and enhanced verification form management.

## New Features 🚀

* **Digital Product Delivery**: Streamlined digital product delivery system with automated fulfillment, ensuring customers receive their digital goods immediately after successful payment. Learn more in our [Digital Product Delivery](/features/digital-product-delivery) documentation.

  <Frame>
    <img alt="Digital product delivery configuration interface showing file upload and external link options" />
  </Frame>

* **React Native SDK (Beta)**: Released our React Native SDK in beta, enabling secure payment processing in native Android and iOS apps with customizable UI components and screens. Learn more in our [React Native SDK](/developer-resources/react-native-integration) documentation.

  <Frame>
    <iframe title="React Native SDK Demo | Dodo Payments" />
  </Frame>

* **New Proration Mode**: Introduced `full_immediately` proration mode, allowing immediate full charges when subscription changes occur, providing more flexible billing options for your business needs.

* **Adaptive Currency for Subscriptions**: Enhanced subscription management with adaptive currency support, automatically adjusting pricing based on customer location and local currency preferences.

* **Instantaneous On-Demand Processing**: Improved processing speed for on-demand charges making it almost instant, reducing transaction times and providing faster payment confirmations.

* **Verification Form Management**: Added comprehensive verification form data viewing capabilities in the Dodo Payments Dashboard verification section, allowing you to review and manage all submitted verification documents in one centralized location.

* **Subscription Cancellation Enhancement**: Implemented subscription cancellation at the end of billing period functionality, now available in both the dashboard and customer portal for improved user experience and billing transparency.

* **General Improvements**: Various minor fixes and performance improvements to enhance overall platform stability and user experience.


# v1.34.4 (26th June 2025)
Source: https://docs.dodopayments.com/changelog/v1.34.4

Enhanced Dashboard Analytics with comprehensive new metrics across three key dashboard sections: Revenue Analytics, Customer Analytics, and Payment Success Rate Analytics.

## New Features 🚀

* **Enhanced Dashboard Analytics**: Completely redesigned the home page analytics with comprehensive new metrics across three key dashboard sections:

  * **Revenue Analytics**

    * Total Revenue overview
    * Daily Revenue tracking
    * Payment count metrics
    * Refund count tracking
    * Payout Received status
    * Top 5 revenue-generating countries
    * Revenue growth rate analysis

    <Frame>
      <img alt="Revenue Analytics dashboard showing comprehensive revenue metrics and country breakdown" />
    </Frame>

  * **Customer Analytics**

    * Average Revenue Per User (ARPU)
    * Active Customers count
    * Customer segmentation (new vs existing)
    * Top 6 customers for current month

    <Frame>
      <img alt="Customer Analytics dashboard displaying ARPU, customer counts, and top customer rankings" />
    </Frame>

  * **Payment Success Rate Analytics**

    * Payment Success Rate metrics
    * Refund Success Rate tracking
    * Failure Reasons breakdown
    * Payments status distribution
    * Monthly Success Rate trends

    <Frame>
      <img alt="Payment Success Rate Analytics showing success rates, failure reasons, and monthly trends" />
    </Frame>


# v1.37.0 (2nd July 2025)
Source: https://docs.dodopayments.com/changelog/v1.37.0

Enhanced Analytics Dashboard with comprehensive revenue and retention insights, Reports 2.0 with detailed business reporting capabilities, and improved subscription management features for better business intelligence and operational efficiency.

## New Features 🚀

### Enhanced Analytics Dashboard

We've expanded the analytics dashboard with comprehensive revenue and retention insights to help you better understand your business performance.

#### Revenue Breakdown Analytics

Track your recurring revenue metrics with detailed breakdowns:

* **Projected ARR**: Annual Recurring Revenue projections with trend analysis
* **MRR Breakdown and Growth Rate**: Monthly Recurring Revenue analysis with month-over-month growth metrics
* **New MRR Chart**: Visual representation of new customer revenue acquisition
* **Expansion MRR Chart**: Tracking revenue growth from existing customer upgrades and expansions
* **Churn MRR Chart**: Monitoring revenue lost from customer cancellations and downgrades
* **Net New MRR Chart**: Net revenue impact combining new, expansion, and churn MRR

<Frame>
  <img alt="Revenue Breakdown dashboard showing projected ARR, MRR breakdown, and growth rates" />
</Frame>

#### Retention Analytics

Monitor customer retention and churn patterns:

* **Customer Churn Rate**: Percentage of customers who cancel their subscriptions
* **Revenue Churn Rate**: Percentage of revenue lost from cancellations and downgrades
* **Churn Rate Trends**: Historical tracking of both customer and revenue churn patterns over time
* **User Retention Matrix**: Cohort analysis showing customer retention rates across different time periods

<Frame>
  <img alt="Retention Analytics dashboard showing customer churn rate, revenue churn rate, and churn rate trends" />
</Frame>

### Reports 2.0

We've completely revamped the reports section with more comprehensive and detailed reporting capabilities. Navigate to **Business > Reports** to access the new reporting suite.

Available reports include:

* **Payment Report**: Detailed record of all processed payments with transaction status tracking
* **Refund Report**: Comprehensive log of all refund activities with detailed refund information
* **Payout Report**: Summary of payouts made to your account
* **Product-wise Sales Report**: Sales performance insights with revenue and business growth metrics
* **Payment Failure Report**: Summary of failed payment attempts with failure reasons
* **Customer Report**: Payment summary organized by customer
* **Disputes Report**: Payment disputes summary with resolution status
* **Account Summary Report**: Complete account overview and summary

<Frame>
  <img alt="Reports 2.0 dashboard showing various report types" />
</Frame>

### Enhanced Payout Reporting

We've added detailed payout reports that provide clear visibility into fees and transaction details for each payout you receive from Dodo Payments. Access these enhanced reports in **Business > Payouts**.

<Frame>
  <img alt="Payout Report dashboard showing detailed payout information" />
</Frame>

### Dodo Payments Remote MCP Server

You can now use the hosted Remote MCP Server at [https://mcp.dodopayments.com](https://mcp.dodopayments.com) for instant MCP integration—no local setup required.

<Frame>
  <iframe title="Using Dodo Payment's Remote MCP Server" />
</Frame>

<Note>
  This is the fastest way to get started with Dodo Payments' MCP integration. No server installation or maintenance needed.
</Note>

<Steps>
  <Step title="Open the Remote MCP Server">
    Visit <a href="https://mcp.dodopayments.com">[https://mcp.dodopayments.com](https://mcp.dodopayments.com)</a> in your browser.
  </Step>

  <Step title="Copy the MCP JSON configuration">
    On the site, copy the MCP JSON configuration provided for your client.
  </Step>

  <Step title="Configure your AI application">
    Paste the configuration into your application's MCP settings (for example, Cursor or Claude).

    <Tip>
      For Cursor, your configuration should look like this:
    </Tip>

    ```json theme={null}
    {
      "mcpServers": {
        "dodopayments_api": {
          "command": "npx",
          "args": ["-y", "mcp-remote@latest", "https://mcp.dodopayments.com/sse"]
        }
      }
    }
    ```
  </Step>

  <Step title="Complete authentication and environment setup">
    After adding the JSON configuration, a pop-up will prompt you to:

    * Enter your Dodo Payments API key
    * Select the environment (test or live)
    * Select your MCP Client under Configuration Options
  </Step>

  <Step title="Login and Approve">
    * Click the Login and Approve button
  </Step>

  <Step title="Verify successful connection">
    Once setup is complete, you'll see a success screen.

    <Check>
      You're now ready to use the Dodo Payments MCP server!
    </Check>
  </Step>
</Steps>

### Additional Improvements

* Various minor improvements and bug fixes for enhanced stability and performance


# v1.38.0 (9th July 2025)
Source: https://docs.dodopayments.com/changelog/v1.38.0

Analytics Chart Sharing, Multiple Partial Refunds, Cumulative Revenue Analytics, Context7 Integration, Next.js Adapter

## New Features 🚀

### Analytics Chart Sharing

Share your analytics charts as images with customizable branding options. Click the share button on any chart to generate an image with multiple color variants that match your brand identity.

<Frame>
  <img alt="Analytics chart sharing interface showing share button and color variant options" />
</Frame>

### Multiple Partial Refunds

Process multiple partial refunds for a single payment through both the API and Dodo Payments Dashboard, providing greater flexibility in handling customer refund requests.

### Cumulative Revenue Analytics

Track your business growth with new cumulative revenue charts in the analytics dashboard, offering comprehensive insights into your revenue trends over time.

<Frame>
  <img alt="Cumulative revenue charts displaying revenue growth trends" />
</Frame>

### Next.js Adapter

Easily integrate Dodo Payments into your Next.js application with our official adapter. Set up payment processing in just a few lines of code. You can also use our ready-made LLM prompt with AI coding agents (such as Cursor, Windsurf, Lovable, and others) to automate the integration process.

[View the @dodopayments/nextjs package on npm](https://www.npmjs.com/package/@dodopayments/nextjs)

### Context7 Integration

Access Dodo Payments documentation through Context7 MCP, enabling AI coding agents to leverage comprehensive payment processing context. For detailed information, visit the [Context7 documentation](https://context7.com/llmstxt/dodopayments-llms-full.txt).


# v1.4.0 (6 Mar 2025)
Source: https://docs.dodopayments.com/changelog/v1.4.0

Introduced the Storefront Feature and Amazon Pay Integration.

## New Features 🚀

* **Storefront Feature**: Create a simple, branded, and mobile-friendly online store to showcase both One-Time Payment products and Subscription products. This feature eliminates the complexity of building an entire website, enabling you to quickly offer your products or services online without additional web development efforts.

  <Frame>
    <img />
  </Frame>

* **Amazon Pay Integration**: Added Amazon Pay as a payment method for One-Time Payments.

* **Improvements and Fixes**: Minor improvements and bug fixes.


# v1.43.0 (24th July 2025)
Source: https://docs.dodopayments.com/changelog/v1.43.0

Comprehensive Webhooks Upgrade: endpoint management, security, delivery logs, debugging, and monitoring—now fully self-serve in the dashboard.

## New Features 🚀

### Major Webhooks Upgrade

Gain complete control, visibility, and security with our fully reimagined webhooks system. Explore the new capabilities below.

<Steps>
  <Step title="Endpoint & Subscription Management">
    * Create, edit, pause/resume, and delete webhook endpoints (URLs)
    * Select event types for each endpoint
    * Configure custom headers per endpoint
    * Set rate limits for each endpoint
  </Step>

  <Step title="Secrets & Security">
    * View and rotate signing secrets (HMAC keys) per endpoint
    * Regenerate secrets and view last rotation timestamps
    * Copy code snippets or documentation for signature verification
  </Step>

  <Step title="Delivery History & Debugging">
    * View message logs for each endpoint (status, timestamps)
    * Inspect individual message attempts with request/response bodies and headers
    * Replay (re-send) failed or past messages
    * Filter logs by event type, status code, or time range
  </Step>

  <Step title="Testing & Troubleshooting">
    * Send test events from the portal using mock payloads
    * Inspect payload schemas and view expected fields
  </Step>

  <Step title="Monitoring & Metrics">
    * Track delivery stats: success/failure counts, latency, and recent error trends
    * Monitor endpoint health status (e.g., failing, healthy)
  </Step>
</Steps>

<Check>
  You can now manage, debug, and secure your webhooks with greater flexibility—all from the dashboard.
</Check>


# v1.44.0 (3rd August 2025)
Source: https://docs.dodopayments.com/changelog/v1.44.0

Adaptive Currency, Turkish Language Support, and New Proration Mode

## New Features 🚀

* The Adaptive Currency feature now supports additional currencies, further enhancing localized payment experiences across more regions. Newly supported currencies include:
  * MVR (Maldivian Rufiyaa)
  * MUR (Mauritian Rupee)
  * ZAR (South African Rand)
  * PHP (Philippine Peso)
  * FJD (Fijian Dollar)
  * QAR (Qatari Riyal)
  * MYR (Malaysian Ringgit)

For comprehensive details on Adaptive Currency functionality and its benefits, please visit the [Adaptive Currency documentation](/features/adaptive-currency).

* Turkish language support has been added to the Dodo Payments Checkout Page.

* A new proration mode, `difference_immediately`, has been introduced. This mode charges the difference immediately, irrespective of the remaining time in the billing cycle when changing plans via the API. [Documentation](/developer-resources/subscription-integration-guide).


# v1.47.0 (11th August 2025)
Source: https://docs.dodopayments.com/changelog/v1.47.0

Dashboard UI overhaul, discount codes for subscriptions, expanded Adaptive Currency, webhook management API, and product metadata support.

## New Features 🚀

* **Major Dashboard Enhancements**

  * **Sidebar Navigation:** Now collapsible, allowing you to minimize distractions and focus on your workflow.
  * **Dashboard Search:** Completely redesigned for faster, more relevant results with full keyboard navigation support.
  * **Tables:** Gain more control with the ability to hide or rearrange columns, pin columns left or right, and adjust rows per page for a personalized view.
  * **Transaction Details Page:** Improved layout displays more payment information, including a detailed payment breakdown for full transparency.
  * **UI & Style Updates:** Refined colors, typography, and spacing deliver a cleaner, more consistent user experience.

  <Frame>
    <img alt="Dashboard enhancements including new sidebar, search, and table controls" />
  </Frame>

* **Discount Codes for Subscriptions**\
  You can now apply discount codes to subscriptions, specifying the number of billing cycles the discount should apply. This gives you greater flexibility and control over your pricing strategies.

  <Frame>
    <img alt="Applying discount codes to subscriptions in the dashboard" />
  </Frame>

* **Adaptive Currency Expansion**\
  The Adaptive Currency feature now supports 50+ additional currencies, enabling even more localized payment experiences. See the [Adaptive Currency documentation](/features/adaptive-currency) for the complete list of supported currencies.

* **Webhook Management API**\
  Introduced webhook CRUD APIs, allowing you to programmatically create, update, and manage your webhooks.

* **Product Metadata Support**\
  You can now add metadata to your products, making it easy to store and retrieve additional information for each product.


# v1.5.0 (7 March 2025)
Source: https://docs.dodopayments.com/changelog/v1.5.0

Introduced a custom date filter for analytics, a new tax category, and various improvements.

## Minor Features 🚀

* Added a custom date filter on the home page analytics to view data for a specific date range.

* Introduced `EdTech` as a tax category for products.

* Various minor improvements and bug fixes.


# v1.51.0 (23rd August 2025)
Source: https://docs.dodopayments.com/changelog/v1.51.0

Powerful Checkout Sessions API, Metadata in Payments Export, and Subscription Next Billing Date Update

## New Features 🚀

### Checkout Sessions API

Introducing our new **Checkout Sessions API** - a powerful, hosted checkout solution that provides a complete payment flow for both one-time purchases and subscriptions. This new API replaces the previous Dynamic Links approach with enhanced flexibility and improved user experience.

**Key Benefits:**

* **Simplified Integration**: No need to provide complete billing addresses upfront - we handle missing details automatically
* **Enhanced Customization**: Full control over payment methods, currencies, themes, and feature flags
* **Better UX**: Pre-fill customer information to reduce checkout friction and improve conversion rates
* **Flexible Configuration**: Support for multi-product carts, subscription trials, discount codes, and more

**What's Changed:**

* **Before**: Required complete billing address information when creating payment links
* **Now**: Pass whatever customer information you have available - we'll collect the rest during checkout
* **Migration**: Simple API endpoint change with no additional handling required

<CardGroup>
  <Card title="Get Started with Checkout Sessions" icon="rocket" href="/developer-resources/checkout-session">
    Complete guide with code examples in Node.js, Python, and REST API
  </Card>

  <Card title="API Reference" icon="code" href="/api-reference/checkout-sessions/create">
    Full API documentation with live testing
  </Card>
</CardGroup>

### Minor Improvements

* Payments export reports now include metadata for enhanced data analysis.
* You can now update the next billing date for subscriptions directly via the API.


# v1.52.4 (3rd September 2025)
Source: https://docs.dodopayments.com/changelog/v1.52.4

Usage-Based Billing, public Refund Receipt API, 100% subscription discounts, and checkout session ID in payments

## New Features 🚀

### Usage-Based Billing

Bill customers precisely based on actual consumption. Define meters, ingest events, and convert usage into charges automatically.

* **Flexible aggregation**: count, sum (over property), unique, max, last
* **Event filtering**: AND/OR logic with rich comparators to include only relevant events
* **Product linkage**: attach meters to products with price-per-unit and optional free thresholds
* **Analytics**: track trends, event streams, and per-customer consumption

<CardGroup>
  <Card title="Feature Overview" icon="rocket" href="/features/usage-based-billing">
    Learn the concepts, components, and the end-to-end data flow.
  </Card>

  <Card title="Integration Guide" icon="code" href="/developer-resources/usage-based-billing-guide">
    Step-by-step setup for meters, products, and event ingestion.
  </Card>
</CardGroup>

<Warning>
  Usage-Based Billing is currently in beta.
</Warning>

### 100% Discounts for Subscriptions

Apply a 100% discount for any number of billing cycles to support complimentary periods, sponsorships, or promotional campaigns. Invoices reflect the full discount and proration follows your plan settings.

### Minor Improvements

* Refund Receipt API is now publicly accessible. See the docs: [/api-reference/refunds/get-refund-receipt](/api-reference/refunds/get-refund-receipt).
* Added `checkout session ID` to the Get Payment API response and payment webhooks to help correlate payments with their originating checkout session.


# v1.53.2 (13th September 2025)
Source: https://docs.dodopayments.com/changelog/v1.53.2

Customer credits, enhanced refund details, higher meter limits, license activation context, and $0 downgrades

## New Features 🚀

### Customer Credits

Credits are now **automatically applied to recurring subscription invoices**, making it easy to:

* Reward loyal customers
* Issue service credits
* Handle manual adjustments without disrupting billing cycles

<Tip>
  Use customer credits for:

  * Promotional incentives
  * Compensation for service interruptions
  * Pre-paid account balances
</Tip>

You can **add or remove credits from a customer's wallet using the API**, enabling automated workflows for customer support, retention, or loyalty programs.

**Example use cases:**

* Credit a customer's wallet after a successful referral
* Debit credits as part of a custom upgrade path

Explore the new and updated customer wallet APIs:

* [Get Customer Wallets](/api-reference/customers/get-customer-wallets)
* [List Customer Wallet Ledger Entries](/api-reference/customers/get-customer-wallets-ledger-entries)
* [Create Customer Wallet Ledger Entry for Adding and Removing Credits](/api-reference/customers/post-customer-wallets-ledger-entries)

<Info>
  Credit application during Checkout will be available in the next release, allowing customers to redeem their wallet balance directly at the point of purchase.
</Info>

## Improvements & Updates ✨

* **Customer details in Get Refund API**\
  The refund retrieval endpoint now returns associated customer information, streamlining reconciliation and support workflows.\
  Learn more: [Get Refund API](/api-reference/refunds/get-refunds-1)

* **Increased meter limit to 50**\
  You can now create up to 50 meters per account, enabling more granular usage tracking across your products and features.\
  Learn more: [Get Meters API](/api-reference/meters/get-meters)

* **Product and customer context in Activate License Key API**\
  License activation responses now include detailed product and customer context, improving entitlement checks and downstream integrations.\
  Learn more: [Activate License Key API](/api-reference/licenses/activate-license)

* **Subscriptions can be downgraded to \$0**\
  You can now downgrade subscriptions to free or \$0 plans, making it easier to support trials, community tiers, and sponsorships.\
  Manage subscriptions: [Update Subscription API](/api-reference/subscriptions/patch-subscriptions)


# v1.56.0 (27 October 2025)
Source: https://docs.dodopayments.com/changelog/v1.56.0

Streamlined onboarding, C# SDK launch, webhook verification, Two-Factor Authentication, overlay checkout sessions, and usage-based subscription plan changes

## New Features 🚀

1. **New Onboarding Experience**\
   Onboarding is now streamlined so you can get started faster and begin accepting payments without unnecessary delays.
   * Faster account activation
   * Simplified verification process

2. **Two-Factor Authentication (2FA)**\
   Enhanced account security with two-factor authentication support. Protect your merchant account and team members with an additional layer of security beyond passwords.
   * Secure your account against unauthorized access
   * Support for authenticator apps
   * Required for sensitive operations

3. **Session Links in Overlay Checkout**\
   Checkout sessions now integrate seamlessly with overlay checkout, providing a smoother embedded payment experience. Create checkout sessions and display them in an overlay without redirecting customers away from your application.

4. **C# SDK**\
   The official Dodo Payments C# SDK is now available, bringing native .NET support for integrating payment functionality into your C# and .NET applications.

   * Full type safety with C# interfaces
   * Async/await support for all API operations
   * Available on NuGet for easy installation

   Learn more: [Dodo Payments SDKs](/developer-resources/dodo-payments-sdks)

5. **Webhook Verification in All SDKs**\
   All SDKs now include built-in webhook verification functions to securely validate incoming webhook events. Powered by the industry-standard [webhooks library](https://github.com/standard-webhooks), these functions make it simple to verify and process webhook payloads.

   Two methods are available:

   * `unwrap()`: Verifies webhook signatures using your webhook secret key for production use
   * `unsafe_unwrap()`: Parses webhook payloads without verification for local testing and development

   To use webhook verification, provide your `DODO_PAYMENTS_WEBHOOK_KEY` when initializing the Dodo Payments client. Both functions automatically parse the webhook payload and extract the event type, making webhook handling more secure and convenient.

***

## Improvements & Updates ✨

* **Update customer name in subscription billing details**\
  Customer names can now be modified directly in subscription billing details, making it easier to correct information or update records.

* **Get Checkout Session API**\
  Retrieve checkout session details programmatically to check status, validate sessions, or integrate with your analytics workflows.

* **Changing plan support for usage-based subscriptions**\
  Subscription plan changes are now fully supported for usage-based billing models, enabling seamless upgrades and downgrades while preserving usage tracking.

* **Tax ID in subscription responses**\
  Tax identification numbers are now included in subscription API responses, improving compliance reporting and invoice generation.

* **Force 3DS flags in APIs**\
  Enhanced 3D Secure control with force 3DS flags now available in checkout session, payment, and subscription APIs for stronger authentication requirements.

* **Filter balance ledger by currency**\
  Dashboard now supports filtering balance ledger entries by currency, simplifying reconciliation for multi-currency operations.

* **Reduced payout threshold to \$50**\
  Merchants can now set payout thresholds as low as \$50, providing more flexibility for smaller businesses and faster access to funds.

* **Minor improvements and bug fixes**\
  General enhancements and stability improvements across the platform.


# v1.61.5 (November 17, 2025)
Source: https://docs.dodopayments.com/changelog/v1.61.5

EUR & GBP pricing full rollout, payment method management, metadata in customers and refunds, checkout session feature flags, license key/file indicators, GitHub OAuth, and Featurebase integration

## New Features 🚀

1. **EUR & GBP Pricing - Full Rollout**\
   Native support for € EUR and £ GBP is now fully rolled out to all businesses worldwide, enabling seamless pricing and payment collection in these major currencies.

   You can now:

   * Price products in € and £
   * Collect payments natively in these currencies
   * Settle directly in € and £ with no forex charges

   <Check>
     Result: Higher success rates and better acceptance across the UK and Europe.
   </Check>

2. **Payment Method Management**\
   Enhanced payment method management capabilities for subscriptions and customers. You can now update payment methods for existing subscriptions and retrieve all payment methods associated with a customer, making it easier to handle expired cards, failed payments, and customer preference changes.

   **Update Payment Methods for Subscriptions:**

   * Update payment methods for active subscriptions without disruption
   * Automatically reactivate `on_hold` subscriptions by updating payment methods
   * Use existing saved payment methods or add new ones
   * Automatic charge creation for remaining dues when reactivating subscriptions

   **Fetch Customer Payment Methods:**

   * List all saved payment methods for a customer
   * Use payment method IDs when updating subscriptions
   * Improve customer experience by showing available payment options

   Learn more: [Update Payment Method API](/api-reference/subscriptions/update-payment-method) | [List Payment Methods API](/api-reference/customers/get-customer-payment-methods)

3. **Metadata Support in Customer and Refund Objects**\
   Metadata is now available on customer and refund objects, expanding your ability to store custom information and integrate with external systems.
   * Attach metadata to customers for CRM integration and custom categorization
   * Store additional context on refunds for better tracking and reporting
   * Maintain consistency with other Dodo Payments objects that support metadata
     Learn more: [Metadata Guide](/api-reference/metadata)

4. **Checkout Session Feature Flags for Customer Editing**\
   New feature flags in checkout sessions give you granular control over what customers can edit during checkout, improving flexibility and user experience.
   * `allow_customer_editing_name`: Enable customers to edit their name
   * `allow_customer_editing_email`: Allow email address modifications
   * `allow_customer_editing_street`: Permit street address editing
   * `allow_customer_editing_city`: Enable city field editing
   * `allow_customer_editing_state`: Allow state/province editing
   * `allow_customer_editing_zipcode`: Enable postal code editing
   * `allow_customer_editing_country`: Permit country selection changes
     These flags provide fine-grained control over the checkout experience, allowing you to customize which fields customers can modify based on your business requirements.

5. **Checkout License Key and File Indicators**\
   The checkout page now displays clear indicators when license keys or digital files are being purchased, improving transparency and customer confidence.
   * Visual indicators for license key purchases
   * Clear file download indicators
   * Enhanced product type visibility during checkout

6. **GitHub OAuth for Login Page**\
   Enhanced authentication options with GitHub OAuth integration, providing developers and technical users with a familiar and secure login method.
   * Sign in with GitHub account
   * Streamlined authentication for developer accounts
   * Additional security layer for team access

7. **Featurebase Integration for Feature Requests and Roadmap**\
   We've integrated Featurebase to provide a better experience for submitting feature requests and tracking our public roadmap.

   * Submit and vote on feature requests
   * View public product roadmap
   * Track feature development status
   * Community-driven prioritization

   Visit our public roadmap: [https://dodopayments.featurebase.app/](https://dodopayments.featurebase.app/)

   Learn more: [Feature Request and Roadmap](/features/feature-request)

8. **Minor improvements and bug fixes**\
   General enhancements and stability improvements across the platform.


# v1.66.0 (December 8, 2025)
Source: https://docs.dodopayments.com/changelog/v1.66.0

Subscription.updated webhook, minimal address checkout, read-only API keys, UPI AutoPay & RuPay subscriptions for all businesses

## New Features 🚀

1. **`subscription.updated` Webhook**\
   A new webhook event that fires on every subscription object update, giving you real-time notifications about any changes to your subscriptions.

   Use this webhook to:

   * Get instant notifications when subscription details change
   * Keep your application state synchronized with Dodo Payments
   * React to subscription updates without polling the API

   <Tip>
     Subscribe to `subscription.updated` to eliminate the need for polling and keep your system in sync with real-time subscription changes.
   </Tip>

   Learn more: [Subscription Webhooks](/developer-resources/webhooks/intents/subscription)

2. **Minimal Address Support in Checkout**

   <Frame>
     <img alt="Minimal Address Support in Checkout" />
   </Frame>

   Reduce checkout friction with the new minimal address collection mode. Instead of collecting full address details, minimal address mode only collects:

   * **Country**: Always required for tax determination
   * **ZIP/Postal code**: Only collected in regions where it's necessary for sales tax, VAT, or GST calculation

   <Check>
     Result: Significantly faster checkout completion with fewer form fields for customers.
   </Check>

   **Enable minimal address:**

   <Tabs>
     <Tab title="Checkout Sessions">
       ```javascript theme={null}
       const session = await client.checkoutSessions.create({
         product_cart: [{ product_id: 'prod_123', quantity: 1 }],
         minimal_address: true
       });
       ```
     </Tab>

     <Tab title="Static Payment Links">
       Append `minimalAddress=true` to your payment link URL:

       ```
       https://checkout.dodopayments.com/buy/prod_123?minimalAddress=true
       ```
     </Tab>
   </Tabs>

   <Info>
     By default, checkout continues to collect complete addresses. We'll gradually transition all checkout links to minimal address mode. Enable the feature flag now to start benefiting from reduced checkout friction.
   </Info>

3. **Read-Only API Keys**\
   Create API keys with read-only permissions for safer integrations. When creating a new API key, uncheck **Enable write access** to create a read-only key.

   Read-only keys can:

   * Fetch payment, subscription, and customer data
   * List products and retrieve details
   * Access reports and analytics

   Read-only keys **cannot**:

   * Create or modify payments
   * Update subscriptions
   * Change product configurations

   <Tip>
     Uncheck "Enable write access" for dashboard integrations, analytics tools, and any system that only needs to view data without making changes.
   </Tip>

4. **UPI AutoPay & RuPay Card Subscriptions - Full Rollout**\
   UPI AutoPay and RuPay card subscriptions are now available for all businesses. This enables recurring payments for Indian customers with:

   * **UPI AutoPay**: Automated recurring charges via UPI mandate
   * **RuPay Cards**: Subscription support for India's domestic card network

   <Check>
     Result: Expanded subscription payment options for the Indian market with RBI-compliant mandate handling.
   </Check>

   Learn more: [Subscriptions with RBI-Compliant Mandates](/features/subscription#subscriptions-with-rbi-compliant-mandates)

5. **Plan Change Preview API**\
   A new API endpoint to preview subscription plan changes before committing to them. Get the exact charge amount and see how the subscription will look after the change - without making any actual modifications.

   ```javascript theme={null}
   const preview = await client.subscriptions.previewChangePlan('sub_123', {
     product_id: 'prod_pro_plan',
     proration_billing_mode: 'prorated_immediately',
     quantity: 1
   });

   console.log('Charge amount:', preview.immediate_charge.summary);
   console.log('New plan details:', preview.new_plan);
   ```

   Use this to:

   * Show customers exactly what they'll pay before confirming upgrades/downgrades
   * Build pricing calculators and plan comparison tools
   * Reduce support tickets by improving pricing transparency

   Learn more: [Preview Plan Change API](/api-reference/subscriptions/preview-change-plan)

6. **General Bug Fixes and Enhancements**\
   This release includes UI polish, performance improvements, and resolves minor bugs for a more reliable, streamlined experience.


# v1.67.0 (December 17, 2025)
Source: https://docs.dodopayments.com/changelog/v1.67.0

Mixed cart checkout for one-time and subscription products, Unified Customer Portal, invoice_id in Payment Response

## New Features 🚀

1. **Mixed Cart Checkout: One-Time and Subscription Products in a Single Cart**\
   Checkout now supports combining both one-time payment products and subscription products in a single cart, unlocking powerful new billing use cases.

   <Frame>
     <img alt="Mixed checkout with one-time and subscription products" />
   </Frame>

   ### What This Enables

   * **Setup fees + subscriptions**: Charge a one-time setup fee alongside a recurring subscription in a single checkout
   * **Bundles with recurring components**: Sell a product (one-time) bundled with ongoing service access (subscription)
   * **Course + membership combos**: Offer a course purchase with an optional community membership subscription
   * **Lifetime + add-on subscriptions**: Combine lifetime product access with optional recurring premium features

   ### How It Works

   Simply add both one-time and subscription products to your checkout session:

   ```javascript theme={null}
   const session = await client.checkoutSessions.create({
     product_cart: [
       // One-time setup fee
       { product_id: 'prod_setup_fee', quantity: 1 },
       // Monthly subscription
       { product_id: 'prod_monthly_plan', quantity: 1 }
     ],
     customer: {
       email: 'customer@example.com',
       name: 'Jane Doe'
     },
     return_url: 'https://yourapp.com/success'
   });
   ```

   <Check>
     Result: A single checkout flow that processes the one-time payment and initiates the subscription — reducing friction and increasing conversion rates.
   </Check>

   <Info>
     When mixing product types, the one-time payment is charged immediately while the subscription follows its configured billing cycle (including any trial period you've set).
   </Info>

   Learn more: [Checkout Sessions](/developer-resources/checkout-session)

2. **Unified Customer Portal**

   A new centralized customer portal at [customer.dodopayments.com](https://customer.dodopayments.com) where customers can view and manage all their purchases and subscriptions across different businesses on Dodo Payments.

   <Frame>
     <img alt="Unified Customer Portal" />
   </Frame>

   ### Portal Features

   * **Cross-business visibility**: View all purchases and subscriptions from any business using Dodo Payments in one place
   * **Centralized subscription management**: Manage subscriptions across different merchants from a single dashboard
   * **Unified billing history**: Access invoices and payment history from all your purchases
   * **Single sign-on experience**: Log in once with your email to access purchases from all Dodo Payments merchants

   ### How It Works

   Customers simply visit [customer.dodopayments.com](https://customer.dodopayments.com) and enter their email address. They'll receive a secure login link that grants access to all their purchases across the Dodo Payments ecosystem.

   <Tip>
     The Unified Customer Portal complements business-specific customer portals. Customers can still access individual merchant portals for a branded experience, or use the unified portal for a consolidated view.
   </Tip>

   <Note>
     The unified portal uses the same email-based authentication as business-specific portals, ensuring a consistent and secure experience.
   </Note>

3. **Invoice ID in Payment Response**\
   The Payment response now includes an `invoice_id` field, making it easier to reconcile payments with invoices and integrate with accounting systems.

   ```json theme={null}
   {
     "payment_id": "pay_2IjeQm4hqU6RA4Z4kwDee",
     "status": "succeeded",
     "invoice_id": "inv_2IsUnWGtRKFLxk7xAQeyt",
     "amount": 9900,
     "currency": "USD",
     // ... other fields
   }
   ```

   ### Use Cases

   * **Accounting integration**: Directly link payments to invoices in your accounting software
   * **Customer support**: Quickly find the invoice associated with a payment when handling support requests
   * **Reconciliation**: Simplify financial reconciliation by matching payments to invoices programmatically
   * **Compliance**: Maintain accurate records linking payments to their corresponding tax invoices

   <Info>
     The `invoice_id` field uses India-specific invoice IDs when available, ensuring compliance with local invoicing requirements.
   </Info>

   Learn more: [Get Payment Detail API](/api-reference/payments/get-payments-1)

4. **General Bug Fixes and Enhancements**\
   This release includes performance improvements, UI polish, and resolves minor bugs for a more reliable, streamlined experience.


# v1.7.0 (14 March 2025)
Source: https://docs.dodopayments.com/changelog/v1.7.0

Introduced a dedicated subscriptions page, enhanced customer details, detailed payout information, an official Ruby SDK, enhanced API filters, and various minor improvements.

## New Features 🚀

* **Dedicated Subscriptions Page**: Manage customer subscriptions easily with the new dedicated page. Navigate to `Sales > Subscriptions` on the dashboard.

  <Frame>
    <img alt="Subscriptions Page" />
  </Frame>

* **Enhanced Customer Details**: View subscriptions, payments, and refunds for each customer in one place. Go to `Sales > Customers > arrow icon` on the dashboard.

  <Frame>
    <img alt="Customer Details" />
  </Frame>

* **Detailed Payout Information**: Get more insights on payout amounts, cycles, and dates. Visit `Business > Payouts` on the dashboard.

  <Frame>
    <img alt="Payout Information" />
  </Frame>

* **Official Ruby SDK**: Integrate Dodo Payments into your Ruby applications effortlessly. Check out the [Ruby SDK](https://github.com/dodopayments/dodopayments-ruby) for more details.

* **Enhanced API Filters**: Added filters like `customer_id`, `status`, etc., to relevant list APIs. Refer to the API documentation for more information.

* **Minor Improvements and Bug Fixes**: Various other minor improvements and bug fixes have been implemented.


# v1.70.0 (December 24, 2025)
Source: https://docs.dodopayments.com/changelog/v1.70.0

Inline checkout support, use existing payment methods for instant checkouts, manage subscription plans from dashboard, generate short payment links, skip success pages with redirect_immediately, and enable on-demand subscriptions for all businesses

## New Features 🚀

1. **Inline Checkout - Fully Embedded Checkout Experiences (BETA)**

   Embed Dodo Payments checkout directly into your website for a seamless, branded payment experience. Unlike overlay checkout which opens as a modal, inline checkout embeds the payment form directly into your page layout.

   <Frame>
     <img alt="Inline Checkout Cover Image" />
   </Frame>

   ### Benefits

   * **Fully integrated**: Create checkout experiences that blend seamlessly with your website
   * **Custom order summaries**: Build custom UI that syncs with checkout in real-time
   * **Maximum control**: Full control over checkout layout and design
   * **PCI compliant**: Dodo Payments securely handles all sensitive payment information
   * **Real-time sync**: Use SDK events to keep your UI in sync with checkout state

   ### How It Works

   Initialize the SDK with `displayType: 'inline'` and embed checkout in a container element:

   ```typescript theme={null}
   import { DodoPayments } from "dodopayments-checkout";

   // Initialize the SDK for inline mode
   DodoPayments.Initialize({
     mode: "test",
     displayType: "inline",
     onEvent: (event) => {
       if (event.event_type === "checkout.breakdown") {
         // Update your UI with real-time tax and total calculations
         const breakdown = event.data?.message;
       }
     },
   });

   // Open checkout in a specific container
   DodoPayments.Checkout.open({
     checkoutUrl: "https://test.dodopayments.com/session/cks_123",
     elementId: "dodo-inline-checkout" // ID of the container element
   });
   ```

   ### Key Features

   * **Real-time breakdown events**: Receive `checkout.breakdown` events as customers enter their details
   * **Custom order summaries**: Build your own pricing display that updates in real-time
   * **Seamless integration**: Checkout frame handles payment collection while you control the layout
   * **SDK methods**: Use `open()`, `close()`, and `isOpen()` to control checkout programmatically

   <Check>
     Result: Fully integrated checkout experiences that match your brand and provide maximum control over the payment flow.
   </Check>

   <Tip>
     Use inline checkout when you want maximum control over checkout design. Use [overlay checkout](/developer-resources/overlay-checkout) for faster integration with minimal changes to existing pages.
   </Tip>

   Learn more: [Inline Checkout Guide](/developer-resources/inline-checkout)

2. **Create Payments, Subscriptions, and Checkouts Using Existing Payment Methods**\
   Streamline checkout flows by using saved payment methods from existing customers. The new `payment_method_id` parameter allows you to create payments, subscriptions, or checkout sessions using a customer's previously saved payment method.

   ### Benefits

   * **Faster checkout**: Skip payment method collection for returning customers
   * **One-click purchases**: Enable instant purchases with saved payment methods
   * **Subscription management**: Easily create subscriptions using existing payment methods
   * **Improved conversion**: Reduce checkout friction for repeat customers

   ### How It Works

   Use `payment_method_id` when creating checkout sessions, payments, or subscriptions:

   <Tabs>
     <Tab title="Checkout Sessions">
       ```javascript theme={null}
       const session = await client.checkoutSessions.create({
         product_cart: [{ product_id: 'prod_123', quantity: 1 }],
         customer: {
           customer_id: 'cus_123'
         },
         payment_method_id: 'pm_abc123',
         confirm: true
       });
       ```
     </Tab>

     <Tab title="One-Time Payments">
       ```javascript theme={null}
       const payment = await client.payments.create({
         product_cart: [{ product_id: 'prod_123', quantity: 1 }],
         customer_id: 'cus_123',
         payment_method_id: 'pm_abc123'
       });
       ```
     </Tab>

     <Tab title="Subscriptions">
       ```javascript theme={null}
       const subscription = await client.subscriptions.create({
         customer_id: 'cus_123',
         product_id: 'prod_subscription',
         payment_method_id: 'pm_abc123'
       });
       ```
     </Tab>
   </Tabs>

   <Warning>
     When using `payment_method_id` in checkout sessions, `confirm` must be set to `true`, and an existing `customer_id` must be provided. The payment method will be validated for eligibility with the payment's currency.
   </Warning>

   <Info>
     The payment method must belong to the customer and be compatible with the payment currency. If validation fails, the request will return an error.
   </Info>

3. **Subscription Plan Changes in Dashboard with Next Billing Date Updates**

   Manage subscription plans directly from the dashboard with enhanced control. You can now change subscription plans and update the next billing date in a single action, giving you complete flexibility over subscription management.

   <Frame>
     <img alt="Subscription plan changes in dashboard" />
   </Frame>

   ### Dashboard Features

   * **Plan changes**: Upgrade or downgrade subscriptions with a single click
   * **Billing date control**: Update the next billing date when changing plans
   * **Proration options**: Choose how to handle proration when changing plans
   * **Visual preview**: See exactly how plan changes affect billing before confirming

   ### Use Cases

   * **Customer support**: Quickly adjust subscription plans for customer requests
   * **Promotional upgrades**: Temporarily upgrade customers with specific billing dates
   * **Plan migrations**: Smoothly transition customers between subscription tiers
   * **Billing alignment**: Align billing dates across multiple subscriptions

   <Check>
     Result: Complete subscription management control from the dashboard, reducing the need for API calls for common subscription adjustments.
   </Check>

   <Tip>
     Use the dashboard for quick subscription plan changes, and the API for programmatic subscription management in your application.
   </Tip>

4. **Short Links for Payment URLs**\
   Generate cleaner, more shareable payment links with our new short link feature. Short links provide shortened checkout URLs with custom slugs, making them easier to share with customers or embed on your website.

   <Frame>
     <img alt="Short links feature for payment URLs" />
   </Frame>

   ### Benefits

   * **Cleaner URLs**: Replace long payment URLs with short, branded links
   * **Better trust**: Professional-looking links that build customer confidence
   * **Easier sharing**: Simplified URLs perfect for SMS, email, or social media
   * **Custom slugs**: Create memorable, branded short links for your products

   ### How It Works

   Enable short links when creating checkout sessions or payment links:

   <Tabs>
     <Tab title="Checkout Sessions">
       ```javascript theme={null}
       const session = await client.checkoutSessions.create({
         product_cart: [{ product_id: 'prod_123', quantity: 1 }],
         short_link: true,
         return_url: 'https://yourapp.com/success'
       });
       ```
     </Tab>

     <Tab title="Payment Links">
       ```javascript theme={null}
       const payment = await client.payments.create({
         product_cart: [{ product_id: 'prod_123', quantity: 1 }],
         short_link: true,
         return_url: 'https://yourapp.com/success'
       });
       ```
     </Tab>
   </Tabs>

   <Check>
     Result: A shortened payment link that's easier to share and more professional-looking, improving conversion rates and customer trust.
   </Check>

   <Info>
     Short links are managed in your dashboard and can be viewed via the [List Short Links API](/api-reference/products/get-products-short-links).
   </Info>

5. **`redirect_immediately` Flag - Skip Payment Success Page**\
   Control the checkout flow with the new `redirect_immediately` flag. When enabled, customers are redirected immediately after payment completion, bypassing the default success page for a faster, more streamlined experience.

   ### Use Cases

   * **Faster checkout flow**: Reduce friction by skipping intermediate pages
   * **Custom success pages**: Redirect directly to your branded success page
   * **Mobile optimization**: Improve mobile checkout experience with immediate redirects
   * **Embedded checkouts**: Seamlessly integrate with overlay or embedded checkout flows

   ### How It Works

   Enable immediate redirects in checkout sessions, payments, or subscriptions:

<Tabs>
  <Tab title="Checkout Sessions">
    ```javascript theme={null}
    const session = await client.checkoutSessions.create({
      product_cart: [{ product_id: 'prod_123', quantity: 1 }],
      feature_flags: {
        redirect_immediately: true
      },
      return_url: 'https://yourapp.com/success'
    });
    ```
  </Tab>

  <Tab title="One-Time Payments">
    ```javascript theme={null}
    const payment = await client.payments.create({
      product_cart: [{ product_id: 'prod_123', quantity: 1 }],
      redirect_immediately: true,
      return_url: 'https://yourapp.com/success'
    });
    ```
  </Tab>

  <Tab title="Subscriptions">
    ```javascript theme={null}
    const subscription = await client.subscriptions.create({
      customer_id: 'cus_123',
      product_id: 'prod_subscription',
      redirect_immediately: true,
      return_url: 'https://yourapp.com/success'
    });
    ```
  </Tab>
</Tabs>

<Tip>
  Use `redirect_immediately: true` when you have a custom success page that provides better user experience than the default payment success page.
</Tip>

<Note>
  When `redirect_immediately` is enabled, customers are redirected to your `return_url` immediately after payment completion, skipping the default success page entirely.
</Note>

6. **On-Demand Subscriptions - Available for All Businesses**\
   On-demand subscriptions are now enabled for all businesses, giving you flexible billing control for usage-based and metered services.

   ### What This Enables

   * **Usage-based billing**: Create subscriptions and charge customers based on actual usage
   * **Flexible billing cycles**: Charge customers on-demand rather than fixed intervals
   * **Metered services**: Perfect for API usage, storage, compute time, and other metered resources
   * **Manual charge control**: Create charges manually when needed, giving you full control over billing timing

   ### How It Works

   Create an on-demand subscription and charge customers as needed:

   ```javascript theme={null}
   // Create an on-demand subscription
   const subscription = await client.subscriptions.create({
     customer_id: 'cus_123',
     product_id: 'prod_api_access',
     on_demand: true
   });

   // Charge the customer when usage occurs
   await client.subscriptions.createCharge(subscription.id, {
     amount: 4900,
     currency: 'USD',
     description: 'API usage for September: 1,000 requests'
   });
   ```

   <Check>
     Result: Full control over when and how much to charge customers, perfect for usage-based business models.
   </Check>

   Learn more: [On-Demand Subscriptions](/developer-resources/ondemand-subscriptions)

7. **General Bug Fixes and Enhancements**\
   This release includes performance improvements, UI polish, and resolves minor bugs for a more reliable, streamlined experience.


# v1.75.0 (January 23, 2026)
Source: https://docs.dodopayments.com/changelog/v1.75.0

Product collections, RevolutPay & Billie payment methods for GBP one-time payments, checkout session preview, metadata in change plan requests, invoice_url field, discount validation endpoint, and enhanced dashboard filtering

## New Features

### 1. **Product Collections**

Group related products together for unified checkout experiences, plan selection, and seamless upgrade/downgrade paths within the Customer Portal.

<Frame>
  <img alt="Product Collection checkout page showing multiple plan options" />
</Frame>

**Key Benefits**

* **Collection-based checkout**: Display all products from a collection in one checkout view, letting customers compare and choose their preferred plan
* **Organized product management**: Group related products (e.g., Starter, Pro, Enterprise) under a single collection
* **Customer Portal integration**: Enable customers to upgrade or downgrade between products within the same collection
* **Merchant control**: Enable, disable, and reorder products within each collection

**How It Works**

Create a checkout session for a collection:

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_collection_id: 'pdc_abc123',
  product_cart: [], // Required: pass an empty array for collection checkout
  return_url: 'https://yoursite.com/return'
});

// Redirect customer to the checkout
window.location.href = session.url;
```

<Check>
  Result: A unified checkout experience where customers can view and select from all available products in your collection.
</Check>

<Info>
  Collection checkout is ideal for subscription businesses where you want customers to compare plans side-by-side before purchasing.
</Info>

Learn more: [Product Collections Guide](/features/product-collections)

### 2. **RevolutPay & Billie Payment Methods for GBP Currency**

Expanded payment options with RevolutPay and Billie now available globally for GBP one-time payment transactions, giving your customers more flexibility in how they pay.

**New Payment Methods**

| Payment Method | Supported Countries | Currency | Subscription Support |
| -------------- | ------------------- | -------- | -------------------- |
| **RevolutPay** | Global              | GBP      | No (one-time only)   |
| **Billie**     | Global              | GBP      | No (one-time only)   |

* **RevolutPay** – Fast and seamless payments for Revolut users globally
* **Billie** – B2B Buy Now Pay Later solution enabling businesses to offer flexible payment terms to their customers

<Info>
  These payment methods are automatically available for GBP transactions. No additional configuration is required.
</Info>

Learn more: [Payment Methods](/features/payment-methods)

### 3. **Checkout Session Preview**

Preview checkout sessions before creating them to calculate accurate pricing, taxes, discounts, and totals. Display real pricing to customers before they proceed to checkout.

**How It Works**

```typescript theme={null}
const preview = await client.checkoutSessions.preview({
  product_cart: [
    { product_id: 'prod_123', quantity: 1 }
  ],
  billing_address: {
    country: 'US',
    state: 'CA',
    zipcode: '94102'
  },
  discount_code: 'SAVE20'
});

console.log('Subtotal:', preview.subtotal);
console.log('Tax:', preview.tax);
console.log('Discount:', preview.discount);
console.log('Total:', preview.total);
```

**Use Cases**

* **Custom pricing displays**: Show accurate totals including tax before checkout
* **Discount validation**: Verify discount codes and show savings to customers
* **Multi-currency support**: Preview pricing in different currencies
* **Cart summaries**: Build custom cart UIs with real-time pricing

<Card title="Preview API Reference" icon="code" href="/api-reference/checkout-sessions/preview">
  View the complete preview endpoint documentation.
</Card>

### 4. **Metadata Support in Change Plan Requests**

Pass custom metadata when changing subscription plans, enabling better tracking and integration with your internal systems during plan transitions.

```javascript theme={null}
// Adding metadata when changing a subscription plan
await client.subscriptions.changePlan('sub_123', {
  product_id: 'prod_premium',
  proration_billing_mode: 'prorated_immediately',
  quantity: 1,
  metadata: {
    upgrade_reason: 'feature_request',
    previous_plan: 'basic',
    sales_rep: 'john@company.com'
  }
});
```

**Use Cases**

* **Track upgrade/downgrade reasons**: Store why customers changed plans
* **Link to CRM records**: Associate plan changes with sales activities
* **Internal categorization**: Tag plan changes for reporting and analytics
* **Audit trails**: Maintain records of who initiated plan changes

<Info>
  Metadata is included in webhook events, making it easy to process plan changes with your custom data.
</Info>

Learn more: [Metadata Guide](/api-reference/metadata) | [Change Plan API](/api-reference/subscriptions/change-plan)

### 5. **`invoice_url` Field in Payment Response and Payment Link Response**

The Payment Response and Payment Link Response now include an `invoice_url` field, providing direct access to the invoice associated with each payment.

```json theme={null}
{
  "payment_id": "pay_2IjeQm4hqU6RA4Z4kwDee",
  "status": "succeeded",
  "invoice_url": "https://dodopayments.com/invoices/inv_2IsUnWGtRKFLxk7xAQeyt",
  "amount": 9900,
  "currency": "USD",
  // ... other fields
}
```

**Use Cases**

* **Customer communication**: Send invoice links directly to customers
* **Accounting integration**: Link payments to invoices in your accounting software
* **Self-service portals**: Allow customers to access their invoices easily
* **Record keeping**: Maintain direct references to invoice documents

<Card title="Get Payment API" icon="code" href="/api-reference/payments/get-payments-1">
  View the Payment Response schema.
</Card>

### 6. **Validate Discount by Code Name Endpoint**

New API endpoint to validate and retrieve discount codes by their code name (e.g., "SAVE20") instead of using the internal discount ID. Verify discount eligibility before applying them at checkout.

```javascript theme={null}
// Validate a discount code before checkout
const discount = await client.discounts.getByCode('SAVE20');

console.log('Discount type:', discount.type);
console.log('Discount value:', discount.amount);
console.log('Valid until:', discount.expires_at);
```

**Benefits**

* **Pre-checkout validation**: Verify discount codes before creating checkout sessions
* **Real-time feedback**: Show customers if their code is valid
* **Error handling**: Catch invalid or expired codes early
* **Custom discount UIs**: Build discount code input fields with instant validation

<Card title="Get Discount by Code API" icon="code" href="/api-reference/discounts/get-discount-by-code">
  View the complete endpoint documentation.
</Card>

### 7. **Enhanced Filtering Capabilities for Customers, Discounts, and License Keys**

New API filters for listing Customers, Discounts, and License Keys, making it easier to find and manage your data programmatically.

**Customers API Filters**

| Filter           | Description                                               |
| ---------------- | --------------------------------------------------------- |
| `email`          | Filter by customer email                                  |
| `name`           | Filter by customer name (partial match, case-insensitive) |
| `created_at_gte` | Filter customers created on or after this timestamp       |
| `created_at_lte` | Filter customers created on or before this timestamp      |

```javascript theme={null}
// Find customers by name created in the last 30 days
const customers = await client.customers.list({
  name: 'John',
  created_at_gte: '2026-01-01T00:00:00Z'
});
```

**Discounts API Filters**

| Filter          | Description                                                               |
| --------------- | ------------------------------------------------------------------------- |
| `code`          | Filter by discount code (partial match, case-insensitive)                 |
| `discount_type` | Filter by discount type (percentage)                                      |
| `active`        | Filter by active status (true = not expired, false = expired)             |
| `product_id`    | Filter by product restriction (only discounts that apply to this product) |

```javascript theme={null}
// Find active percentage discounts for a specific product
const discounts = await client.discounts.list({
  active: true,
  discount_type: 'percentage',
  product_id: 'prod_123'
});
```

**License Keys API Filters**

| Filter           | Description                                                    |
| ---------------- | -------------------------------------------------------------- |
| `customer_id`    | Filter by customer ID                                          |
| `status`         | Filter by license key status (`active`, `expired`, `disabled`) |
| `product_id`     | Filter by product ID                                           |
| `created_at_gte` | Filter license keys created on or after this timestamp         |
| `created_at_lte` | Filter license keys created on or before this timestamp        |

```javascript theme={null}
// Find active license keys for a specific product
const licenseKeys = await client.licenseKeys.list({
  status: 'active',
  product_id: 'prod_123'
});
```

<CardGroup>
  <Card title="List Customers API" icon="users" href="/api-reference/customers/get-customers">
    View the complete Customers API documentation.
  </Card>

  <Card title="List Discounts API" icon="percent" href="/api-reference/discounts/list-discounts">
    View the complete Discounts API documentation.
  </Card>

  <Card title="List License Keys API" icon="key" href="/api-reference/licenses/list-license-keys">
    View the complete License Keys API documentation.
  </Card>
</CardGroup>

### 8. **UI/UX Improvements in Dashboard**

This release includes numerous UI/UX improvements across the dashboard for a more intuitive and polished experience.

**Highlights**

* Improved navigation and layout consistency
* Enhanced data table interactions
* Better loading states and feedback
* Refined visual design elements
* Improved mobile responsiveness


# v1.78.0 (February 2, 2026)
Source: https://docs.dodopayments.com/changelog/v1.78.0

Communication preferences with push notifications, custom fields for checkout sessions, and expanded checkout language support

## New Features

### 1. **Communication Preferences**

Take control of how you receive notifications with our revamped Communication Preferences. Configure email, push, and in-app notifications to match your workflow.

<Frame>
  <img alt="Communication Preferences overview showing notification settings" />
</Frame>

**Key Features**

* **Revamped email designs**: Fresh, modern email templates with clear calls-to-action and improved readability
* **Push notifications**: Get instant alerts on your mobile device for critical events like new sales, disputes, and payouts
* **Granular controls**: Choose exactly which events trigger notifications and through which channels
* **Multi-email support**: Add multiple email addresses to receive notifications
* **Customer email preferences**: Configure which emails your customers receive

**Notification Categories**

| Category              | Description                                              |
| --------------------- | -------------------------------------------------------- |
| **Sales & Payments**  | New sales, successful payments, failed payments          |
| **Payouts & Refunds** | Payout completions, refund requests, refund completions  |
| **Subscriptions**     | New subscriptions, renewals, cancellations, plan changes |
| **Disputes**          | Dispute opened, evidence required, dispute resolved      |

<Check>
  Result: Stay informed about your business with notifications delivered exactly how and when you want them.
</Check>

Learn more: [Communication Preferences Guide](/features/communication-preferences)

### 2. **Custom Fields in Checkout Sessions**

Collect additional information from customers during checkout with custom fields. Add text inputs, dropdowns, dates, and more to gather the data you need.

**Supported Field Types**

| Type       | Description                       | Use Case                            |
| ---------- | --------------------------------- | ----------------------------------- |
| `text`     | Single-line text input            | Company name, order notes           |
| `number`   | Numeric input                     | Quantity, age                       |
| `email`    | Email input with validation       | Billing contact email               |
| `url`      | URL input with validation         | Website, social profile             |
| `date`     | Date picker                       | Delivery date, event date           |
| `dropdown` | Selection from predefined options | Size, color, plan type              |
| `boolean`  | Checkbox for yes/no values        | Terms acceptance, newsletter opt-in |

**How It Works**

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  custom_fields: [
    {
      name: 'company_name',
      label: 'Company Name',
      type: 'text',
      required: true
    },
    {
      name: 'team_size',
      label: 'Team Size',
      type: 'dropdown',
      options: ['1-10', '11-50', '51-200', '200+'],
      required: true
    },
    {
      name: 'newsletter',
      label: 'Subscribe to our newsletter',
      type: 'boolean',
      required: false
    }
  ],
  return_url: 'https://yoursite.com/success'
});
```

**Benefits**

* **Flexible data collection**: Gather any information needed for fulfillment or personalization
* **Validation built-in**: Email and URL fields automatically validate input format
* **Required/optional control**: Mark fields as required or optional based on your needs
* **Webhook delivery**: Custom field values are included in payment webhook events

<Info>
  Custom field values are returned in the `custom_fields` object within payment and checkout session responses.
</Info>

Learn more: [Checkout Session Custom Fields](/developer-resources/checkout-session#custom-fields)

### 3. **Expanded Checkout Language Support**

The checkout page now supports **21 languages**, up from 16. Reach more customers in their native language for a better checkout experience.

**New Languages Added**

| Language | Code |
| -------- | ---- |
| Korean   | `ko` |
| Malay    | `ms` |
| Romanian | `ro` |
| Russian  | `ru` |
| Thai     | `th` |

**All Supported Languages**

Arabic, Chinese, Dutch, English, French, German, Hindi, Indonesian, Italian, Japanese, Korean, Malay, Portuguese, Romanian, Russian, Spanish, Swedish, Thai, Turkish, Ukrainian, Vietnamese.

**Force a Specific Language**

Use the `force_language` parameter to override automatic language detection:

```typescript theme={null}
const session = await client.checkoutSessions.create({
  product_cart: [{ product_id: 'prod_123', quantity: 1 }],
  force_language: 'ko', // Force Korean language
  return_url: 'https://yoursite.com/success'
});
```

<Tip>
  By default, the checkout page automatically detects the customer's preferred language from their browser settings. Use `force_language` when you want to ensure consistency with your website's language.
</Tip>

Learn more: [Checkout Language Support](/features/checkout#supported-languages)

### 4. **General Bug Fixes and Enhancements**

This release includes performance improvements, UI polish, and resolves minor bugs for a more reliable, streamlined experience.


# Community projects
Source: https://docs.dodopayments.com/community/overview

Discover community-built SDKs, plugins, and boilerplates for Dodo Payments.

<Info>
  This is a curated list of open-source projects created by the community. These projects are not affiliated with or endorsed by Dodo Payments unless explicitly stated.
</Info>

* **What you'll find**: SDKs, webhook handlers, plugins, and starters across languages
* **How to use**: Evaluate licensing, maintenance status, and security for your use case
* **How to contribute**: Submit your project via our template on the "Submit your project" page

<Warning>
  Use at your own risk. Review code, licenses, and security posture before production use.
</Warning>

<CardGroup>
  <Card title="Projects directory" icon="grid" href="/community/projects">
    Browse by type and language with links to code and docs.
  </Card>

  <Card title="Submit your project" icon="plus" href="/community/submit">
    Add your project with a short PR using our template.
  </Card>
</CardGroup>


# Projects directory
Source: https://docs.dodopayments.com/community/projects

Community-maintained libraries, plugins, and boilerplates for Dodo Payments.

Browse community projects by category. Each card links directly to the repository.

<Tabs>
  <Tab title="Libraries & SDKs">
    <CardGroup>
      <Card title="dodopayments-webhooks (TypeScript)" href="https://github.com/sancho1952007/dodopayments-webhooks" icon="node-js">
        Universal webhook verification and handlers for multiple frameworks.
        <br />Includes signature verification and typed event handling for Express, Hono, Elysia, and more.
        <br /><br />By <a href="https://github.com/sancho1952007">@sancho1952007</a> (Sancho Godinho)
        <br /><br />`TypeScript` `Webhooks` `Node`
      </Card>

      <Card title="dodpayments_rust_sdk (Rust)" href="https://github.com/Muhammad-Owais-Warsi/dodpayments_rust_sdk" icon="rust">
        Rust SDK for interacting with Dodo Payments APIs.
        <br />Provides typed models and helpers to call core endpoints from Rust services.
        <br /><br />By <a href="https://github.com/Muhammad-Owais-Warsi">@Muhammad-Owais-Warsi</a>
        <br /><br />`Rust` `SDK`
      </Card>

      <Card title="Dodo Payments Laravel SDK (PHP)" href="https://github.com/codeplugtech/dodo-payments" icon="php">
        Laravel SDK for Dodo Payments.
        <br />Easily integrate Dodo Payments APIs into your Laravel applications with ready-made service classes and helpers.
        <br /><br />By <a href="https://github.com/codeplugtech">@codeplugtech</a>
        <br /><br />`PHP` `Laravel` `SDK`
      </Card>

      <Card title="dodo-payments-rs (Rust)" href="https://github.com/PiyushXCoder/dodo-payments-rs" icon="rust">
        Easy-to-use SDK for interacting with Dodo Payments APIs.
        <br />It comes with predefined structures for requests and responses and uses a builder pattern to simplify constructing and sending payment-related API calls.
        <br /><br />By <a href="https://github.com/PiyushXCoder">@PiyushXCoder</a>
        <br /><br />`Rust` `SDK`
      </Card>

      <Card title="multi-app-dodo-payments (Python)" href="https://github.com/aniketkarne/multi-app-dodo-payments" icon="python">
        Handle Dodo Payments for multiple applications using single microservice application:
        <br />Production-ready payment microservice built with FastAPI that handles payments for multiple applications using Dodo Payments.
        <br />Features include <br /> `credit management`, `subscription support`, `webhook processing with idempotency`, `complete audit trails`, `MixPanel Analytics`, `Backend-to-backend architecture with API key authentication`.
        <br /><br />By <a href="https://github.com/aniketkarne">@aniketkarne</a> (Aniket Karne)
        <br /><br />`Python` `Fast-API` `Library`
      </Card>
    </CardGroup>
  </Tab>

  <Tab title="Plugins & Extensions">
    <CardGroup>
      <Card title="Dodo WHMCS (PHP)" href="https://github.com/Akash123a5/dodo-whmcs" icon="php">
        WHMCS payment gateway module integration.
        <br />Drop-in provider to accept payments in WHMCS using Dodo Payments.
        <br /><br />By <a href="https://github.com/Akash123a5">@Akash123a5</a>
        <br /><br />`PHP` `WHMCS` `Plugin`
      </Card>
    </CardGroup>
  </Tab>

  <Tab title="Boilerplates & Starters">
    <CardGroup>
      <Card title="DodoPayments Boilerplate" href="https://github.com/snehalsaurabh/DodoPayments-Boilerplate" icon="rocket">
        Starter boilerplate for integrating Dodo Payments quickly.
        <br />Includes example checkout flow, API wiring, and environment configuration.
        <br /><br />By <a href="https://github.com/snehalsaurabh">@snehalsaurabh</a>
        <br /><br />`Boilerplate`
      </Card>

      <Card title="Dodo Payments Boilerplate" href="https://github.com/vanshcodeworks/dodo_payments_boilerplate" icon="rocket">
        Lightweight starter for common flows.
        <br />Minimal setup to create and confirm payments with example pages.
        <br /><br />By <a href="https://github.com/vanshcodeworks">@vanshcodeworks</a>
        <br /><br />`Boilerplate`
      </Card>

      <Card title="PaymentService" href="https://github.com/rasadov/PaymentService" icon="rocket">
        Service template with payment flows.
        <br />Demonstrates clean architecture around payment intents and webhooks.
        <br /><br />By <a href="https://github.com/rasadov">@rasadov</a>
        <br /><br />`Template`
      </Card>

      <Card title="DodoStarter Boilerplate" href="https://github.com/AINotSoSmart/dodostarter" icon="rocket">
        Next.js SaaS starter with Supabase authentication and Dodo Payments integration.
        <br />You can go from an empty folder to a working app in an afternoon.
        <br /><br />By <a href="https://github.com/KissuChaudhary">@KissuChaudhary</a>
        <br /><br />`TypeScript` `Next.js` `Boilerplate`
      </Card>
    </CardGroup>
  </Tab>
</Tabs>

<Note>
  Want your project listed? See <a href="/community/submit">Submit your project</a>.
</Note>


# Submit your project
Source: https://docs.dodopayments.com/community/submit

How to add your open-source project to the Dodo Payments community directory.

<Steps>
  <Step title="Check eligibility">
    * The project is open-source with a permissive license.
    * It’s relevant to Dodo Payments (SDK, plugin, integration, template).
    * Has a README with install, usage, and maintenance status.
  </Step>

  <Step title="Add entry via PR">
    Edit `community/projects.mdx` and add a new `<Card>` under the most relevant tab.

    ```mdx theme={null}
    <Card title="PROJECT_NAME (LANG)" href="REPO_URL" icon="code">
      One-sentence description of your project.
      <br/>By <a href="GITHUB_PROFILE_URL">@github_username</a>
      <br/><br/>`LANGUAGE` `FRAMEWORK` `CATEGORY`
    </Card>
    ```
  </Step>

  <Step title="Open submission issue (optional)">
    If you prefer, open an issue using the "Community Project Submission" template with:

    * Repo URL, description, category (SDK/Plugin/Boilerplate)
    * Primary language/framework
    * Install/usage snippet link
    * Maintenance status and last update
  </Step>

  <Step title="Review & publish">
    We review for relevance, clarity, and safety. Approved entries are merged and published.
  </Step>
</Steps>

<Warning>
  We may remove entries that are unmaintained, insecure, misleading, or violate policy.
</Warning>


# AutoSend
Source: https://docs.dodopayments.com/integrations/autosend

Learn how to use AutoSend's email API to send automated transactional emails for your Dodo Payments transactions, refunds, and payment events.

## Introduction

The AutoSend and Dodo Payments integration enables you to automatically send real-time email notifications for all payment events, from successful transactions to failed attempts and refund confirmations.

Send transactional emails for payment events using AutoSend's powerful email API.

<Info>
  This integration requires your AutoSend API Key for authentication. You can find your API key in the AutoSend dashboard under Settings > API Keys.
</Info>

## Getting Started

Follow these steps to integrate AutoSend with Dodo Payments:

<Steps>
  <Step title="Open Webhook Section">
    Navigate to the Webhooks section in your Dodo Payments dashboard.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select AutoSend Integration">
    Choose AutoSend from the list of available integrations.
  </Step>

  <Step title="Enter API Key">
    Provide your AutoSend API key for authentication. You can find your API key in the AutoSend dashboard under Settings > API Keys.

    <Card title="Learn how to create and manage API keys" icon="key" href="https://docs.autosend.com/api-keys">
      Visit the AutoSend documentation for detailed instructions on creating and managing API keys.
    </Card>
  </Step>

  <Step title="Configure Transformation">
    Set up JavaScript transformation handlers to customize email content based on payment events.
  </Step>

  <Step title="Test & Create">
    Test your webhook configuration to ensure emails are sent correctly, then create the integration.
  </Step>

  <Step title="Activation Complete">
    🎉 Your AutoSend integration is now active and will automatically send emails for the configured payment events.
  </Step>
</Steps>

## Code Examples

### Payment Confirmation Email

Send a confirmation email when a payment is successfully processed:

```javascript payment_confirmation.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.url = "https://api.autosend.com/v1/mails/send";
    webhook.payload = {
      to: {
        email: p.customer.email,
        name: p.customer.name,
      },
      from: {
        email: "payments@mail.yourdomain.com",
        name: "Your Company",
      },
      subject: "Payment Successful - Thank you for your purchase!",
      templateId: "A-61522f2xxxxxxxxx",
      dynamicData: {
        customerName: p.customer.name,
        amount: p.amount,
        currency: p.currency,
        paymentId: p.payment_id,
        paymentDate: new Date(p.created_at).toLocaleDateString(),
      },
      replyTo: {
        email: "support@yourdomain.com",
        name: "Support Team",
      },
    };
  }
  return webhook;
}
```

### Subscription Welcome Email

Send a welcome email when a new subscription is created:

```javascript subscription_welcome.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "subscription.created") {
    const s = webhook.payload.data;
    webhook.url = "https://api.autosend.com/v1/mails/send";
    webhook.payload = {
      to: {
        email: s.customer.email,
        name: s.customer.name,
      },
      from: {
        email: "subscriptions@mail.yourdomain.com",
        name: "Your Company",
      },
      subject: "Welcome to your subscription!",
      templateId: "A-61522f2xxxxxxxxx",
      dynamicData: {
        customerName: s.customer.name,
        planName: s.plan.name,
        billingInterval: s.billing_interval,
        nextBillingDate: new Date(s.next_billing_at).toLocaleDateString(),
        subscriptionId: s.subscription_id,
      },
      replyTo: {
        email: "support@yourdomain.com",
        name: "Support Team",
      },
    };
  }
  return webhook;
}
```

### Payment Failure Notification

Send a notification email when a payment fails:

```javascript payment_failure.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.failed") {
    const p = webhook.payload.data;
    webhook.url = "https://api.autosend.com/v1/mails/send";
    webhook.payload = {
      to: {
        email: p.customer.email,
        name: p.customer.name,
      },
      from: {
        email: "billing@mail.yourdomain.com",
        name: "Your Company Billing",
      },
      subject: "Payment Failed - Action Required",
      templateId: "A-61522f2xxxxxxxxx",
      dynamicData: {
        customerName: p.customer.name,
        amount: p.amount,
        currency: p.currency,
        failureReason: p.failure_reason,
        paymentId: p.payment_id,
        retryUrl: `https://yourdomain.com/billing/retry/${p.payment_id}`,
      },
      replyTo: {
        email: "billing@yourdomain.com",
        name: "Billing Support",
      },
    };
  }
  return webhook;
}
```

## Best Practices

* **Verify your sender domain**: Ensure your sender email domain is verified in AutoSend to improve deliverability and avoid authentication issues. Verified domains help prevent emails from landing in spam folders.

* **Use dynamic data for personalization**: Use the `dynamicData` field to personalize emails with customer-specific information like names, payment amounts, and subscription details. Personalized emails have higher engagement rates.

* **Write clear subject lines**: Write descriptive subject lines that clearly indicate the email's purpose. Avoid spam-trigger words and keep subjects concise (under 50 characters).

* **Test before production**: Always test your emails before sending them in production. This ensures your email content renders correctly and all dynamic data is properly mapped.

## API Reference

For complete details on the AutoSend API, including all available parameters and error codes, visit the [AutoSend API Documentation](https://docs.autosend.com/api-reference/mails/send).

## Troubleshooting

<AccordionGroup>
  <Accordion title="Emails not being sent">
    * Verify API Key is correct and active
    * Check that sender domain is verified in AutoSend
    * Ensure recipient email addresses are valid
    * Review AutoSend sending limits and quotas
    * Verify the API endpoint URL is correct: `https://api.autosend.com/v1/mails/send`
    * Check that required parameters are present in the payload
  </Accordion>

  <Accordion title="Transformation errors">
    * Validate JSON structure matches AutoSend API format
    * Check that all required fields are present (`to`, `from`, `templateId` or `html`/`text`)
    * Ensure email addresses are properly formatted
    * Verify `templateId` is valid if using templates
    * Check that `dynamicData` keys match your template variables
  </Accordion>

  <Accordion title="Template issues">
    * Verify your template ID is correct and active in AutoSend
    * Ensure `dynamicData` keys match the variables used in your template
    * Check that all required template variables are provided
    * Test your template independently in the AutoSend dashboard
  </Accordion>
</AccordionGroup>


# Close CRM
Source: https://docs.dodopayments.com/integrations/close-crm

Sync Dodo Payments data with Close CRM to track leads and manage sales pipeline.

## Introduction

Connect your payment data directly to Close CRM for seamless lead management and sales tracking. Automatically create contacts and opportunities from successful payments, keeping your sales team informed of revenue-generating activities.

<Info>
  This integration requires a Close CRM API key with appropriate permissions.
</Info>

## Getting Started

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, navigate to <b>Webhooks → + Add Endpoint</b> and expand the integrations dropdown.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select Close CRM">
    Choose the <b>Close CRM</b> integration card.
  </Step>

  <Step title="Enter API Key">
    Provide your Close CRM API key in the configuration.
  </Step>

  <Step title="Configure Transformation">
    Edit the transformation code to map payment data to Close CRM objects.
  </Step>

  <Step title="Test & Create">
    Test with sample payloads and click <b>Create</b> to activate the sync.
  </Step>

  <Step title="Done!">
    🎉 Payment events will now automatically create/update records in Close CRM.
  </Step>
</Steps>

## Transformation Code Examples

### Create Contact from Payment

```javascript create_contact.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.url = "https://api.close.com/api/v1/contact/";
    webhook.payload = {
      name: p.customer.name,
      emails: [p.customer.email],
      phones: [p.customer.phone || ''],
      custom: {
        payment_amount: (p.total_amount / 100).toFixed(2),
        payment_method: p.payment_method || '',
        dodo_customer_id: p.customer.customer_id
      }
    };
  }
  return webhook;
}
```

### Create Opportunity from Subscription

```javascript create_opportunity.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "subscription.active") {
    const s = webhook.payload.data;
    webhook.url = "https://api.close.com/api/v1/opportunity/";
    webhook.payload = {
      lead_id: s.customer.customer_id,
      value: (s.recurring_pre_tax_amount / 100).toFixed(2),
      value_period: s.payment_frequency_interval,
      title: `Subscription - ${s.product_id}`,
      custom: {
        subscription_id: s.subscription_id,
        billing_frequency: s.payment_frequency_interval,
        next_billing: s.next_billing_date
      }
    };
  }
  return webhook;
}
```

## Tips

* Use Close CRM's API documentation to understand field mappings
* Include custom fields for payment-specific data
* Map subscription amounts to opportunity values
* Use customer IDs for proper lead associations

## Troubleshooting

<AccordionGroup>
  <Accordion title="Records not created in Close CRM">
    * Verify API key has write permissions
    * Check that required fields are included
    * Ensure email format is valid
    * Review Close CRM API rate limits
  </Accordion>

  <Accordion title="Transformation errors">
    * Validate JSON structure matches Close CRM API format
    * Check that all required fields are present
    * Ensure field names match Close CRM schema exactly
  </Accordion>
</AccordionGroup>


# Customer.io
Source: https://docs.dodopayments.com/integrations/customer-io

Send Dodo Payments events to Customer.io to trigger email automations and customer journeys.

## Introduction

Trigger personalized email campaigns and customer journeys based on payment events. Send welcome emails for new customers, subscription updates, and payment failure notifications automatically through Customer.io.

<Info>
  This integration requires your Customer.io Site ID and API Key.
</Info>

## Getting Started

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, navigate to <b>Webhooks → + Add Endpoint</b> and expand the integrations dropdown.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select Customer.io">
    Choose the <b>Customer.io</b> integration card.
  </Step>

  <Step title="Enter Credentials">
    Provide your Customer.io Site ID and API Key in the configuration.
  </Step>

  <Step title="Configure Transformation">
    Edit the transformation code to format events for Customer.io's Track API.
  </Step>

  <Step title="Test & Create">
    Test with sample payloads and click <b>Create</b> to activate the sync.
  </Step>

  <Step title="Done!">
    🎉 Payment events will now trigger Customer.io email automations.
  </Step>
</Steps>

## Transformation Code Examples

### Track Payment Events

```javascript track_payments.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.url = "https://track.customer.io/api/v2/entity";
    webhook.payload = {
      type: "person",
      identifiers: {
        id: p.customer.customer_id
      },
      action: "payment_completed",
      name: "Payment Completed",
      attributes: {
        email: p.customer.email,
        name: p.customer.name,
        payment_amount: (p.total_amount / 100).toFixed(2),
        payment_method: p.payment_method || "unknown",
        payment_id: p.payment_id,
        currency: p.currency || "USD"
      }
    };
  }
  return webhook;
}
```

### Track Subscription Lifecycle

```javascript track_subscriptions.js icon="js" expandable theme={null}
function handler(webhook) {
  const s = webhook.payload.data;
  switch (webhook.eventType) {
    case "subscription.active":
      webhook.url = "https://track.customer.io/api/v2/entity";
      webhook.payload = {
        type: "person",
        identifiers: {
          id: s.customer.customer_id
        },
        action: "subscription_started",
        name: "Subscription Started",
        attributes: {
          email: s.customer.email,
          subscription_id: s.subscription_id,
          product_id: s.product_id,
          amount: (s.recurring_pre_tax_amount / 100).toFixed(2),
          frequency: s.payment_frequency_interval,
          next_billing: s.next_billing_date
        }
      };
      break;
    case "subscription.cancelled":
      webhook.url = "https://track.customer.io/api/v2/entity";
      webhook.payload = {
        type: "person",
        identifiers: {
          id: s.customer.customer_id
        },
        action: "subscription_cancelled",
        name: "Subscription Cancelled",
        attributes: {
          email: s.customer.email,
          subscription_id: s.subscription_id,
          cancelled_at: s.cancelled_at,
          cancel_at_next_billing: s.cancel_at_next_billing_date
        }
      };
      break;
  }
  return webhook;
}
```

### Track Customer Attributes

```javascript track_attributes.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.url = "https://track.customer.io/api/v2/entity";
    webhook.payload = {
      type: "person",
      identifiers: {
        id: p.customer.customer_id
      },
      action: "identify",
      name: "Customer Identified",
      attributes: {
        email: p.customer.email,
        name: p.customer.name,
        total_spent: (p.total_amount / 100).toFixed(2),
        payment_method: p.payment_method || "unknown",
        last_payment_date: webhook.payload.timestamp,
        customer_since: webhook.payload.timestamp
      }
    };
  }
  return webhook;
}
```

## Tips

* Use consistent event names that match your Customer.io campaigns
* Include relevant attributes for personalization
* Set proper customer identifiers for accurate tracking
* Use meaningful event names for campaign triggers

## Troubleshooting

<AccordionGroup>
  <Accordion title="Events not triggering campaigns">
    * Verify Site ID and API Key are correct
    * Check that event names match your Customer.io campaigns
    * Ensure customer identifiers are properly set
    * Review Customer.io API rate limits
  </Accordion>

  <Accordion title="Transformation errors">
    * Validate JSON structure matches Customer.io API format
    * Check that all required fields are present
    * Ensure event names and attributes are properly formatted
  </Accordion>
</AccordionGroup>


# DataFast
Source: https://docs.dodopayments.com/integrations/datafast

Attribute revenue to marketing channels with DataFast analytics. Track which traffic sources drive paying customers and optimize your growth.

## Introduction

DataFast is a revenue-first analytics tool that helps you discover which marketing channels drive paying customers. By integrating Dodo Payments with DataFast, you can attribute revenue to your traffic sources, identify high-value customer segments, and make data-driven decisions to grow your business.

<Info>
  This integration requires your DataFast API Key, which you can obtain from your [DataFast dashboard](https://datafa.st/).
</Info>

## How It Works

DataFast tracks visitors through a unique visitor ID stored in a cookie. To attribute revenue to marketing channels, you need to:

1. **Capture DataFast's visitor ID** from the `datafast_visitor_id` cookie when creating checkout sessions
2. **Store the visitor ID** in your payment metadata
3. **Send payment data to DataFast** when payments succeed using their Payment API

This allows DataFast to match successful payments with the original traffic source, giving you complete revenue attribution.

## Getting Started

<Steps>
  <Step title="Install DataFast Script">
    First, install the DataFast tracking script on your website. This creates the `datafast_visitor_id` cookie that tracks your visitors.

    Visit the [DataFast documentation](https://datafa.st/docs) for installation instructions specific to your platform.
  </Step>

  <Step title="Get Your API Key">
    Log in to your [DataFast dashboard](https://datafa.st/) and navigate to your website settings to obtain your API key.

    <Warning>
      Keep your API key secure and never expose it in client-side code.
    </Warning>
  </Step>

  <Step title="Capture Visitor ID in Checkout">
    When creating a checkout session, capture the DataFast visitor ID from the cookie and add it to your payment metadata.
  </Step>

  <Step title="Send Payment Data via Webhook">
    Configure a webhook to send payment data to DataFast's Payment API when payments succeed.
  </Step>

  <Step title="Done!">
    🎉 Revenue data will now appear in your DataFast dashboard with full attribution to marketing channels.
  </Step>
</Steps>

## Implementation Guide

### Step 1: Add Visitor ID to Checkout Metadata

When creating a checkout session, capture the DataFast visitor ID from the cookie and include it in your payment metadata.

<CodeGroup>
  ```typescript Next.js theme={null}
  import { cookies } from 'next/headers';
  import { dodopayments } from '@/lib/dodopayments';

  export async function createCheckout(productId: string) {
    // Capture DataFast visitor ID from cookie
    const datafastVisitorId = cookies().get('datafast_visitor_id')?.value;

    const payment = await dodopayments.payments.create({
      product_id: productId,
      // ... other payment configuration
      metadata: {
        datafast_visitor_id: datafastVisitorId, // Store visitor ID in metadata
      },
    });

    return payment;
  }
  ```

  ```javascript Express.js theme={null}
  const express = require('express');
  const router = express.Router();

  router.post('/create-checkout', async (req, res) => {
    // Capture DataFast visitor ID from cookie
    const datafastVisitorId = req.cookies?.datafast_visitor_id;

    const payment = await dodopayments.payments.create({
      product_id: req.body.productId,
      // ... other payment configuration
      metadata: {
        datafast_visitor_id: datafastVisitorId, // Store visitor ID in metadata
      },
    });

    res.json({ payment });
  });
  ```

  ```javascript Other Frameworks theme={null}
  // Capture DataFast visitor ID from cookie
  const datafastVisitorId = getCookie('datafast_visitor_id'); // Use your framework's cookie method

  const payment = await dodopayments.payments.create({
    product_id: productId,
    // ... other payment configuration
    metadata: {
      datafast_visitor_id: datafastVisitorId, // Store visitor ID in metadata
    },
  });
  ```
</CodeGroup>

### Step 2: Send Payment Data to DataFast

Configure a webhook endpoint to send payment data to DataFast's Payment API when payments succeed.

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, navigate to <b>Webhooks → + Add Endpoint</b> and expand the integrations dropdown.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select DataFast">
    Choose the <b>DataFast</b> integration card.
  </Step>

  <Step title="Enter API Key">
    Provide your DataFast API Key in the configuration field.

    <Frame>
      <img alt="Add API Key" />
    </Frame>
  </Step>

  <Step title="Configure Transformation">
    Edit the transformation code to format payment data for DataFast's Payment API.
  </Step>

  <Step title="Test & Create">
    Test with sample payloads and click <b>Create</b> to activate the integration.
  </Step>
</Steps>

## Transformation Code Examples

### Basic Payment Attribution

```javascript basic_payment.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const payment = webhook.payload.data;
    
    // Only send to DataFast if visitor ID exists in metadata
    if (payment.metadata && payment.metadata.datafast_visitor_id) {
      webhook.payload = {
        amount: payment.total_amount / 100, // Convert from cents to dollars
        currency: payment.currency,
        transaction_id: payment.payment_id,
        datafast_visitor_id: payment.metadata.datafast_visitor_id,
      };
    } else {
      // Cancel dispatch if no visitor ID (prevents unnecessary API calls)
      webhook.cancel = true;
    }
  }
  return webhook;
}
```

### Handle Zero Decimal Currencies

Some currencies (like JPY) don't use decimal places. Adjust the amount calculation accordingly:

```javascript zero_decimal.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const payment = webhook.payload.data;
    
    if (payment.metadata && payment.metadata.datafast_visitor_id) {
      // Zero decimal currencies: JPY, KRW, CLP, etc.
      const zeroDecimalCurrencies = ['JPY', 'KRW', 'CLP', 'VND', 'UGX', 'MGA'];
      const isZeroDecimal = zeroDecimalCurrencies.includes(payment.currency);
      
      webhook.payload = {
        amount: isZeroDecimal 
          ? payment.total_amount // Use amount as-is for zero decimal currencies
          : payment.total_amount / 100, // Convert from cents for other currencies
        currency: payment.currency,
        transaction_id: payment.payment_id,
        datafast_visitor_id: payment.metadata.datafast_visitor_id,
      };
    } else {
      // Cancel dispatch if no visitor ID (prevents unnecessary API calls)
      webhook.cancel = true;
    }
  }
  return webhook;
}
```

### Subscription Payments

For recurring subscription payments, you can track each payment:

```javascript subscription_payment.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const payment = webhook.payload.data;
    
    // Check if this is a subscription payment
    const isSubscription = payment.subscription_id !== null;
    
    if (payment.metadata && payment.metadata.datafast_visitor_id) {
      webhook.payload = {
        amount: payment.total_amount / 100,
        currency: payment.currency,
        transaction_id: payment.payment_id,
        datafast_visitor_id: payment.metadata.datafast_visitor_id,
        // Optional: Add subscription context
        ...(isSubscription && {
          subscription_id: payment.subscription_id,
        }),
      };
    } else {
      // Cancel dispatch if no visitor ID (prevents unnecessary API calls)
      webhook.cancel = true;
    }
  }
  return webhook;
}
```

## Best Practices

<Tip>
  **Capture visitor ID early**: Store the DataFast visitor ID as soon as possible in your checkout flow to ensure accurate attribution, even if the user navigates away and returns later.
</Tip>

* **Always include visitor ID in metadata**: Without the visitor ID, DataFast cannot attribute revenue to marketing channels
* **Handle zero decimal currencies**: Some currencies (JPY, KRW, etc.) don't use decimal places—adjust your amount calculation accordingly
* **Test with sample payments**: Verify the integration works correctly before going live
* **Monitor your DataFast dashboard**: Check that payments are appearing correctly with proper attribution
* **Use webhook retries**: DataFast's Payment API is idempotent, so retries are safe if a webhook fails

## Troubleshooting

<AccordionGroup>
  <Accordion title="Payments not appearing in DataFast">
    * Verify your DataFast API key is correct and active
    * Check that the `datafast_visitor_id` is being captured and stored in payment metadata
    * Ensure the webhook transformation is correctly formatting the payload
    * Verify the webhook is triggering on `payment.succeeded` events
    * Check DataFast dashboard for any error messages or API logs
  </Accordion>

  <Accordion title="Revenue attribution not working">
    * Confirm the DataFast tracking script is installed and working on your website
    * Verify the `datafast_visitor_id` cookie is being set correctly
    * Check that visitor IDs match between checkout creation and payment completion
    * Ensure you're capturing the visitor ID before creating the checkout session
    * Review DataFast's [Payment API documentation](https://datafa.st/docs/payments-api) for additional guidance
  </Accordion>

  <Accordion title="Transformation errors">
    * Validate the JSON structure matches DataFast's Payment API format
    * Check that all required fields (`amount`, `currency`, `transaction_id`, `datafast_visitor_id`) are present
    * Ensure amount is correctly converted (divide by 100 for most currencies, except zero decimal currencies)
    * Verify the API endpoint URL is correct: `https://datafa.st/api/v1/payments`
    * Test the transformation with sample webhook payloads
  </Accordion>

  <Accordion title="Currency conversion issues">
    * For zero decimal currencies (JPY, KRW, CLP, VND, UGX, MGA), send the amount as-is without dividing by 100
    * For all other currencies, divide the amount by 100 to convert from cents to the base unit
    * Double-check the currency code matches ISO 4217 format (e.g., "USD", "EUR", "JPY")
  </Accordion>
</AccordionGroup>

## Additional Resources

<CardGroup>
  <Card title="DataFast Documentation" icon="book" href="https://datafa.st/docs/payments-api">
    Learn more about DataFast's Payment API and revenue attribution features.
  </Card>

  <Card title="DataFast Dashboard" icon="chart-bar" href="https://datafa.st/">
    Access your DataFast dashboard to view revenue analytics and attribution data.
  </Card>
</CardGroup>

<Info>
  Need help? Contact Dodo Payments support at [support@dodopayments.com](mailto:support@dodopayments.com) for assistance with the integration.
</Info>


# Discord
Source: https://docs.dodopayments.com/integrations/discord

Send real-time Dodo Payments notifications to your Discord channels.

## Introduction

Keep your team informed where they already collaborate. The Discord integration delivers payment, subscription, dispute, and other important events directly to any channel you choose—no polling or dashboards required.

<Info>
  This guide assumes you have access to the Integrations section of the Dodo Payments dashboard.
</Info>

## Getting Started

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, open <b>Webhooks → + Add Endpoint</b> and expand the dropdown to reveal integrations.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select Discord">
    Choose the <b>Discord</b> card then click <b>Connect your Discord workspace</b>.
  </Step>

  <Step title="Authorize the Bot">
    Grant the requested permissions so the bot can post messages in your selected channel.
  </Step>

  <Step title="Edit Transformation Code">
    Tailor the payload → embed mapping to your needs—or start with the templates below.
  </Step>

  <Step title="Test & Create">
    Use sample payloads to preview the embed, then hit <b>Create</b>.
  </Step>

  <Step title="Done!">
    🎉 Your Discord channel will now receive live Dodo Payments updates.
  </Step>
</Steps>

## Transformation Code Examples

### Minimal Payment Embed

```javascript payment_embed.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.payload = {
      embeds: [{
        title: "✅ Payment Successful",
        description: `**Amount:** $${(p.total_amount / 100).toFixed(2)}\n**Customer:** ${p.customer.email}`,
        color: 0x2ecc71 // green
      }]
    };
  }
  return webhook;
}
```

### Subscription Events

```javascript subscription_embed.js icon="js" expandable theme={null}
function handler(webhook) {
  const s = webhook.payload.data;
  switch (webhook.eventType) {
    case "subscription.active":
      webhook.payload = {
        embeds: [{
          title: "📄 Subscription Activated",
          fields: [
            { name: "Customer", value: s.customer.email, inline: true },
            { name: "Product", value: s.product_id, inline: true },
            { name: "Next Billing", value: new Date(s.next_billing_date).toLocaleDateString(), inline: true }
          ],
          color: 0x2ecc71
        }]
      };
      break;
    case "subscription.cancelled":
      webhook.payload = {
        embeds: [{
          title: "⚠️ Subscription Cancelled",
          fields: [
            { name: "Customer", value: s.customer.email, inline: true },
            { name: "Product", value: s.product_id, inline: true }
          ],
          color: 0xf1c40f
        }]
      };
      break;
  }
  return webhook;
}
```

### Dispute Alerts

```javascript dispute_embed.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType.startsWith("dispute.")) {
    const d = webhook.payload.data;
    webhook.payload = {
      embeds: [{
        title: d.dispute_status === "won" ? "🏆 Dispute Won" : d.dispute_status === "lost" ? "❌ Dispute Lost" : "🚨 Dispute Update",
        fields: [
          { name: "Payment ID", value: d.payment_id, inline: true },
          { name: "Amount", value: `$${(d.amount / 100).toFixed(2)}`, inline: true },
          { name: "Status", value: d.dispute_status, inline: true }
        ],
        color: d.dispute_status === "won" ? 0x2ecc71 : d.dispute_status === "lost" ? 0xe74c3c : 0xe67e22
      }]
    };
  }
  return webhook;
}
```

## Tips

* Prefer embeds for rich formatting and colors.
* Keep titles short; put details in fields.
* Use intuitive colors: green (success), red (failure), orange (warnings).

## Troubleshooting

<AccordionGroup>
  <Accordion title="No messages in Discord">
    * Confirm the bot has access to the channel.
    * Check that the transformation returns a JSON object with `embeds`.
  </Accordion>

  <Accordion title="Transformation errors">
    * Validate your code in the editor – syntax errors will block delivery.
    * Ensure field names match the webhook payload structure.
  </Accordion>
</AccordionGroup>


# Dub
Source: https://docs.dodopayments.com/integrations/dub

Track sale conversion events in Dub when customers complete purchases through Dodo Payments.

## Introduction

[Dub](https://dub.co) is a powerful link management platform that helps you create, share, and track short links. By integrating Dodo Payments with Dub, you can automatically track sale conversion events when customers complete purchases, enabling you to measure the ROI of your marketing campaigns and referral programs.

A "sale" event is recorded in Dub when a customer:

* Completes a one-time payment
* Subscribes to a paid plan
* Makes a recurring subscription payment

<Info>
  This integration requires a Dub account with conversion tracking enabled on your links.
</Info>

<Tip>
  **Affiliate Program Integration**: This integration also works seamlessly with **Dub Partners** for tracking affiliate referrals and commissions. Use Dub's conversion tracking to attribute sales to your affiliate links and measure partner performance. Learn more about setting up affiliate programs in our [Affiliates feature guide](/features/affiliates).
</Tip>

## How It Works

Dub tracks visitors through a unique click ID (`dub_id`) stored in a cookie when users click your Dub short links. To attribute sales to your links, you need to:

1. **Capture Dub's click ID** from the `dub_id` cookie when creating checkout sessions
2. **Store the click ID** in your payment metadata along with the customer's external ID
3. **Send sale data to Dub** when payments succeed using their Track API

This allows Dub to match successful sales with the original link click, giving you complete conversion attribution.

## Prerequisites

Before setting up this integration, ensure you have:

1. A [Dub account](https://dub.co) with a workspace
2. Conversion tracking enabled for your links
3. Your Dub API key (available in your Dub dashboard under Settings → API Keys)

## Getting Started

<Steps>
  <Step title="Enable Conversion Tracking in Dub">
    In your Dub dashboard, enable conversion tracking for the links you want to track sales for. This allows Dub to record sale events when customers complete purchases.

    <Info>
      Learn more about enabling conversion tracking in the [Dub documentation](https://dub.co/docs/conversions/quickstart).
    </Info>
  </Step>

  <Step title="Get Your Dub API Key">
    Navigate to your [Dub dashboard](https://app.dub.co) → Settings → API Keys and create a new API key with `conversions.write` scope.

    <Warning>
      Keep your API key secure and never expose it in client-side code.
    </Warning>
  </Step>

  <Step title="Capture Click ID in Checkout">
    When creating a checkout session, capture the Dub click ID from the cookie and add it to your payment metadata.
  </Step>

  <Step title="Send Sale Data via Webhook">
    Configure a webhook to send sale data to Dub's Track API when payments succeed.
  </Step>

  <Step title="Done!">
    Sale conversion events will now appear in your Dub analytics dashboard with full attribution to your links.
  </Step>
</Steps>

## Implementation Guide

### Step 1: Add Click ID and Customer ID to Checkout Metadata

When creating a checkout session, capture the Dub click ID from the cookie and include it in your payment metadata along with your customer's external ID.

<CodeGroup>
  ```typescript Next.js theme={null}
  import { cookies } from 'next/headers';
  import DodoPayments from 'dodopayments';

  const client = new DodoPayments();

  export async function createCheckout(productId: string, customerId: string) {
    // Capture Dub click ID from cookie
    const dubClickId = cookies().get('dub_id')?.value;

    const payment = await client.payments.create({
      billing: {
        city: 'New York',
        country: 'US',
        state: 'NY',
        street: '123 Main St',
        zipcode: '10001',
      },
      customer: {
        email: 'customer@example.com',
        name: 'John Doe',
      },
      product_id: productId,
      metadata: {
        dub_click_id: dubClickId,           // Store Dub click ID
        dub_external_id: customerId,        // Store your customer's unique ID
      },
    });

    return payment;
  }
  ```

  ```javascript Express.js theme={null}
  const express = require('express');
  const DodoPayments = require('dodopayments').default;
  const router = express.Router();

  const client = new DodoPayments();

  router.post('/create-checkout', async (req, res) => {
    // Capture Dub click ID from cookie
    const dubClickId = req.cookies?.dub_id;

    const payment = await client.payments.create({
      billing: {
        city: 'New York',
        country: 'US',
        state: 'NY',
        street: '123 Main St',
        zipcode: '10001',
      },
      customer: {
        email: req.body.email,
        name: req.body.name,
      },
      product_id: req.body.productId,
      metadata: {
        dub_click_id: dubClickId,           // Store Dub click ID
        dub_external_id: req.body.customerId, // Store your customer's unique ID
      },
    });

    res.json({ payment });
  });
  ```

  ```python Python (FastAPI) theme={null}
  from fastapi import FastAPI, Request
  from dodopayments import DodoPayments

  app = FastAPI()
  client = DodoPayments()

  @app.post("/create-checkout")
  async def create_checkout(request: Request):
      # Capture Dub click ID from cookie
      dub_click_id = request.cookies.get("dub_id")

      body = await request.json()

      payment = client.payments.create(
          billing={
              "city": "New York",
              "country": "US",
              "state": "NY",
              "street": "123 Main St",
              "zipcode": "10001",
          },
          customer={
              "email": body["email"],
              "name": body["name"],
          },
          product_id=body["product_id"],
          metadata={
              "dub_click_id": dub_click_id,          # Store Dub click ID
              "dub_external_id": body["customer_id"], # Store your customer's unique ID
          },
      )

      return {"payment": payment}
  ```

  ```go Go theme={null}
  package main

  import (
      "github.com/dodopayments/dodopayments-go"
  )

  func createCheckout(dubClickId, customerId, productId string) (*dodopayments.Payment, error) {
      client := dodopayments.NewClient()

      payment, err := client.Payments.Create(context.Background(), dodopayments.PaymentCreateParams{
          Billing: dodopayments.BillingParam{
              City:    "New York",
              Country: "US",
              State:   "NY",
              Street:  "123 Main St",
              Zipcode: "10001",
          },
          Customer: dodopayments.CustomerParam{
              Email: "customer@example.com",
              Name:  "John Doe",
          },
          ProductID: productId,
          Metadata: map[string]string{
              "dub_click_id":   dubClickId,  // Store Dub click ID
              "dub_external_id": customerId, // Store your customer's unique ID
          },
      })

      return payment, err
  }
  ```
</CodeGroup>

### Step 2: Send Sale Data to Dub

Configure a webhook endpoint to send sale data to Dub's Track API when payments succeed.

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, navigate to **Webhooks → + Add Endpoint** and expand the integrations dropdown.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select Dub">
    Choose the **Dub** integration card.
  </Step>

  <Step title="Enter API Key">
    Provide your Dub API Key in the configuration field.

    <Frame>
      <img alt="Add API Key" />
    </Frame>
  </Step>

  <Step title="Configure Transformation">
    Edit the transformation code to format payment data for Dub's Track Sale API.
  </Step>

  <Step title="Test & Create">
    Test with sample payloads and click **Create** to activate the integration.
  </Step>
</Steps>

## Transformation Code Examples

### Basic Sale Tracking

Track sales when payments succeed:

```javascript basic_sale.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const payment = webhook.payload.data;

    // Only send to Dub if click ID exists in metadata
    if (payment.metadata && payment.metadata.dub_click_id) {
      webhook.payload = {
        clickId: payment.metadata.dub_click_id,
        externalId: payment.metadata.dub_external_id || payment.customer.customer_id,
        amount: payment.total_amount, // Ensure the amount is in cents
        currency: payment.currency || "USD",
        paymentProcessor: "dodo",
        invoiceId: payment.payment_id,
        metadata: {
          customer_email: payment.customer.email,
          customer_name: payment.customer.name,
          product_id: payment.product_cart ? payment.product_cart.map(product => product.product_id).join(', ') : undefined,
        },
      };
    } else {
      // Cancel dispatch if no click ID (organic traffic)
      webhook.cancel = true;
    }
  }
  return webhook;
}
```

### Track Subscription Sales

Track both initial subscriptions and recurring payments:

```javascript subscription_sale.js icon="js" expandable theme={null}
function handler(webhook) {
  const data = webhook.payload.data;

  // Track initial subscription activation
  if (webhook.eventType === "subscription.active") {
    if (data.metadata && data.metadata.dub_click_id) {
      webhook.payload = {
        clickId: data.metadata.dub_click_id,
        externalId: data.metadata.dub_external_id || data.customer.customer_id,
        amount: data.recurring_pre_tax_amount, // Amount in cents
        currency: data.currency || "USD",
        paymentProcessor: "dodo",
        invoiceId: data.subscription_id,
        eventName: "Subscription Started",
        metadata: {
          subscription_id: data.subscription_id,
          product_id: data.product_id,
          billing_interval: data.payment_frequency_interval,
          customer_email: data.customer.email,
        },
      };
    } else {
      // Cancel dispatch if no click ID (organic traffic)
      webhook.cancel = true;
    }
  }

  // Track recurring subscription payments
  if (webhook.eventType === "subscription.renewed") {
    if (data.metadata && data.metadata.dub_click_id) {
      webhook.payload = {
        clickId: data.metadata.dub_click_id,
        externalId: data.metadata.dub_external_id || data.customer.customer_id,
        amount: data.recurring_pre_tax_amount,
        currency: data.currency || "USD",
        paymentProcessor: "dodo",
        invoiceId: `${data.subscription_id}_${Date.now()}`,
        eventName: "Subscription Renewed",
        metadata: {
          subscription_id: data.subscription_id,
          product_id: data.product_id,
          customer_email: data.customer.email,
        },
      };
    } else {
      // Cancel dispatch if no click ID (organic traffic)
      webhook.cancel = true;
    }
  }

  return webhook;
}
```

### Track Sales with Tax Exclusion

Send only the pre-tax amount to Dub for accurate revenue tracking:

```javascript sale_without_tax.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const payment = webhook.payload.data;

    if (payment.metadata && payment.metadata.dub_click_id) {
      // Calculate pre-tax amount (total minus tax)
      const preTaxAmount = payment.total_amount - (payment.tax || 0);

      webhook.payload = {
        clickId: payment.metadata.dub_click_id,
        externalId: payment.metadata.dub_external_id || payment.customer.customer_id,
        amount: preTaxAmount, // Pre-tax amount in cents
        currency: payment.currency || "USD",
        paymentProcessor: "dodo",
        invoiceId: payment.payment_id,
        metadata: {
          total_amount: payment.total_amount,
          tax_amount: payment.tax || 0,
          customer_email: payment.customer.email,
        },
      };
    } else {
      // Cancel dispatch if no click ID (organic traffic)
      webhook.cancel = true;
    }
  }
  return webhook;
}
```

### Track Sales with Custom Event Names

Use custom event names to categorize different types of sales:

```javascript custom_events.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const payment = webhook.payload.data;

    if (payment.metadata && payment.metadata.dub_click_id) {
      // Determine event name based on payment type
      let eventName = "Purchase";
      if (payment.subscription_id) {
        eventName = "Subscription Purchase";
      } else if (payment.metadata && payment.metadata.is_upgrade) {
        eventName = "Plan Upgrade";
      }

      webhook.payload = {
        clickId: payment.metadata.dub_click_id,
        externalId: payment.metadata.dub_external_id || payment.customer.customer_id,
        amount: payment.total_amount,
        currency: payment.currency || "USD",
        paymentProcessor: "dodo",
        invoiceId: payment.payment_id,
        eventName: eventName,
        metadata: {
          product_id: payment.product_cart ? payment.product_cart.map(product => product.product_id).join(', ') : undefined,
          customer_email: payment.customer.email,
        },
      };
    } else {
      // Cancel dispatch if no click ID (organic traffic)
      webhook.cancel = true;
    }
  }
  return webhook;
}
```

## Alternative: Client-Side Implementation

If you prefer to track sales from your server instead of using webhooks, you can call Dub's Track API directly after a successful payment:

<CodeGroup>
  ```typescript Next.js (Server Action) theme={null}
  'use server';

  import { Dub } from 'dub';

  const dub = new Dub();

  export async function trackSale(
    paymentId: string,
    clickId: string,
    customerId: string,
    amount: number,
    currency: string
  ) {
    await dub.track.sale({
      clickId: clickId,
      externalId: customerId,
      amount: amount,
      currency: currency,
      paymentProcessor: 'dodo',
      invoiceId: paymentId,
    });
  }
  ```

  ```javascript Node.js theme={null}
  const { Dub } = require('dub');

  const dub = new Dub();

  async function trackSale(payment) {
    if (payment.metadata?.dub_click_id) {
      await dub.track.sale({
        clickId: payment.metadata.dub_click_id,
        externalId: payment.metadata.dub_external_id,
        amount: payment.total_amount,
        currency: payment.currency,
        paymentProcessor: 'dodo',
        invoiceId: payment.payment_id,
      });
    }
  }
  ```
</CodeGroup>

## Best Practices

<Tip>
  **Capture the click ID early**: Store the Dub click ID as soon as possible in your checkout flow to ensure accurate attribution, even if the user navigates away and returns later.
</Tip>

* **Always include click ID in metadata**: Without the click ID, Dub cannot attribute revenue to your links
* **Use external IDs consistently**: Pass the same customer ID you use in your system for accurate customer-level analytics
* **Handle organic traffic gracefully**: Set `webhook.cancel = true` when there's no click ID to avoid unnecessary API calls
* **Test with sample payments**: Verify the integration works correctly before going live
* **Monitor your Dub dashboard**: Check that sales are appearing correctly with proper attribution

## Important Notes

<Note>
  * **Amount format**: Dub expects amounts in cents (e.g., \$10.00 = 1000)
  * **Currency**: Use ISO 4217 currency codes (USD, EUR, GBP, etc.)
  * **Free trials**: \$0 payments are not tracked as sales
  * **Refunds**: Consider tracking refunds separately if needed for accurate revenue reporting
</Note>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Sales not appearing in Dub">
    * Verify your Dub API key is correct and has `conversions.write` scope
    * Check that the `dub_click_id` is being captured and stored in payment metadata
    * Ensure the webhook transformation is correctly formatting the payload
    * Verify the webhook is triggering on `payment.succeeded` events
    * Confirm conversion tracking is enabled for your Dub links
  </Accordion>

  <Accordion title="Revenue attribution not working">
    * Confirm users are clicking through your Dub short links before checkout
    * Verify the `dub_id` cookie is being set correctly on your domain
    * Check that click IDs match between checkout creation and payment completion
    * Ensure you're capturing the click ID before creating the checkout session
  </Accordion>

  <Accordion title="Transformation errors">
    * Validate the JSON structure matches Dub's Track Sale API format
    * Check that all required fields (`clickId`, `externalId`, `amount`) are present
    * Ensure amount is in cents (integer, not decimal)
    * Verify the API endpoint URL is correct: `https://api.dub.co/track/sale`
    * Test the transformation with sample webhook payloads
  </Accordion>

  <Accordion title="Duplicate sales being tracked">
    * Ensure you're only tracking on `payment.succeeded` events, not `payment.processing`
    * Use unique `invoiceId` values for each sale
    * For subscriptions, append timestamps or billing period to prevent duplicates on renewals
  </Accordion>
</AccordionGroup>

## Additional Resources

<CardGroup>
  <Card title="Dub Conversions Documentation" icon="book" href="https://dub.co/docs/conversions/quickstart">
    Learn more about Dub's conversion tracking and analytics features.
  </Card>

  <Card title="Dub Track Sale API" icon="code" href="https://dub.co/docs/api-reference/track/track-sale">
    View the complete API reference for Dub's Track Sale endpoint.
  </Card>

  <Card title="Dub Dashboard" icon="chart-line" href="https://app.dub.co">
    Access your Dub dashboard to view conversion analytics and attribution data.
  </Card>

  <Card title="Webhook Events Guide" icon="webhook" href="/developer-resources/webhooks/intents/webhook-events-guide">
    Learn about all available Dodo Payments webhook events.
  </Card>
</CardGroup>

<Info>
  Need help? Contact Dodo Payments support at [support@dodopayments.com](mailto:support@dodopayments.com) for assistance with the integration.
</Info>


# Framer Plugin
Source: https://docs.dodopayments.com/integrations/framer-plugin

Integrate Dodo Payments checkout functionality into your Framer projects with our powerful plugin. Accept payments with customizable checkout experiences.

## Overview

The Dodo Payments Framer Plugin seamlessly integrates payment processing into your Framer websites. Create customizable checkout experiences with support for both test and production environments.

<Card title="Official Plugin" icon="link" href="https://www.framer.com/marketplace/plugins/dodo-payments">
  Access the official Dodo Payments plugin on the Framer marketplace.
</Card>

## Features

<CardGroup>
  <Card title="Hosted or Overlay Checkout" icon="credit-card">
    Choose a full-page flow or an inline overlay that feels native to your site.
  </Card>

  <Card title="Drag-and-Drop Setup" icon="hand-pointer">
    Add the component, paste your keys, publish.
  </Card>

  <Card title="Instant Digital Delivery" icon="envelope">
    Secure download links or license keys emailed the moment payment clears.
  </Card>

  <Card title="Worldwide Coverage" icon="globe">
    Bank-level acquiring on six continents, local methods built-in.
  </Card>

  <Card title="Automatic Tax & Invoicing" icon="receipt">
    VAT, GST, sales tax, and receipts handled for every order.
  </Card>

  <Card title="No-Code Subscriptions" icon="toggle-on">
    Flip a switch to sell subscription plans for your products.
  </Card>
</CardGroup>

## Setup Guide

<Steps>
  <Step title="Generate API Key">
    Visit the [Dodo Payments Dashboard](https://app.dodopayments.com/developer/api-keys) and create a new API key.

    <Tabs>
      <Tab title="Live Mode">
        For production use with real payment processing.
      </Tab>

      <Tab title="Test Mode">
        Perfect for development and testing with no real charges.
      </Tab>
    </Tabs>

    <Check>
      Copy your API key securely - you'll need it for the next step.
    </Check>
  </Step>

  <Step title="Authenticate Plugin">
    1. Open the Dodo Payments plugin in Framer
    2. Navigate to the Authentication page
    3. Paste your API key
    4. Select the appropriate mode (Test or Live)
    5. Click **Continue** to authenticate

    <Warning>
      Keep your API keys secure and never share them publicly.
    </Warning>
  </Step>

  <Step title="Manage Products">
    After authentication, you'll see your products list:

    * **Existing products**: Displayed automatically
    * **No products**: Click the **Plus (+)** button next to 'Products'

    <Info>
      You'll be redirected to the Dodo Payments Dashboard to create products with pricing, descriptions, and settings.
    </Info>
  </Step>

  <Step title="Add Buy Buttons">
    1. Select a product from your available list
    2. Click the `Add Buy Button` button
    3. A buy button with the text `Buy {product_name}` will be added to your canvas

    <Warning>
      The Add Buy Button will be disabled if you don't have the correct project permissions.
    </Warning>
  </Step>
</Steps>

## Customization

<Steps>
  <Step title="Select Checkout Experience">
    Choose your preferred checkout experience:

    * **Overlay (Embedded)**: Checkout appears as an overlay within your Framer project, keeping users on your site.
    * **Hosted**: Users are redirected to a Dodo Payments hosted checkout page for a streamlined experience.
  </Step>

  <Step title="Customize Appearance Options">
    Customize your checkout experience with the following appearance settings:

    * **Checkout Theme**: Choose between light or dark themes to match your brand aesthetic.
    * **Button Label**: Customize text (e.g., 'Buy Now', 'Purchase', 'Get Started').
    * **Button Styles**: Adjust colors, fonts, sizes, and other styling properties.
    * **Return URL**: Set a Framer page for the user to return to after checkout.
  </Step>
</Steps>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Authentication Issues">
    **Problem**: Plugin won't authenticate

    **Solutions**:

    * Verify your API key is correct
    * Ensure you're using the right mode (Test/Live)
    * Check your internet connection
  </Accordion>

  <Accordion title="Button Creation Issues">
    **Problem**: Add Buy Button is disabled

    **Solutions**:

    * Verify you have the correct permissions in your Framer project
    * Ensure you're authenticated properly
    * Try refreshing the plugin
  </Accordion>

  <Accordion title="Product Display Issues">
    **Problem**: Products not showing

    **Solutions**:

    * Make sure you have products created in your Dodo Payments dashboard
    * Check that your API key has the correct permissions
    * Try re-authenticating
  </Accordion>
</AccordionGroup>


# HubSpot
Source: https://docs.dodopayments.com/integrations/hubspot

Automatically create and update contacts, companies, and deals in HubSpot from Dodo Payments events.

## Introduction

Sync your payment data directly to HubSpot CRM. Create contacts from successful payments, track subscription lifecycle, and build comprehensive customer profiles—all automatically triggered by Dodo Payments events.

<Info>
  This integration requires HubSpot admin access to configure OAuth scopes and API permissions.
</Info>

## Getting Started

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, go to <b>Webhooks → + Add Endpoint</b> and expand the integrations dropdown.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select HubSpot">
    Choose the <b>HubSpot</b> integration card.
  </Step>

  <Step title="Connect HubSpot">
    Click <b>Connect to HubSpot</b> and authorize the required OAuth scopes.
  </Step>

  <Step title="Configure Transformation">
    Edit the transformation code to map payment data to HubSpot CRM objects.
  </Step>

  <Step title="Test & Create">
    Test with sample payloads and click <b>Create</b> to activate the sync.
  </Step>

  <Step title="Done!">
    🎉 Payment events will now automatically create/update records in your HubSpot CRM.
  </Step>
</Steps>

## Transformation Code Examples

### Create Contact from Payment

```javascript create_contact.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.url = "https://api.hubapi.com/crm/v3/objects/contacts";
    webhook.payload = {
      properties: {
        email: p.customer.email,
        firstname: p.customer.name.split(' ')[0] || '',
        lastname: p.customer.name.split(' ').slice(1).join(' ') || '',
        phone: p.customer.phone || '',
        company: p.customer.company || '',
        amount: (p.total_amount / 100).toString(),
        payment_method: p.payment_method || '',
        currency: p.currency || 'USD'
      }
    };
  }
  return webhook;
}
```

### Update Contact with Subscription

```javascript update_contact.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "subscription.active") {
    const s = webhook.payload.data;
    webhook.url = `https://api.hubapi.com/crm/v3/objects/contacts/${s.customer.customer_id}`;
    webhook.method = "PATCH";
    webhook.payload = {
      properties: {
        subscription_status: "active",
        subscription_amount: (s.recurring_pre_tax_amount / 100).toString(),
        subscription_frequency: s.payment_frequency_interval,
        next_billing_date: s.next_billing_date,
        product_id: s.product_id
      }
    };
  }
  return webhook;
}
```

### Create Deal from Payment

```javascript create_deal.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.url = "https://api.hubapi.com/crm/v3/objects/deals";
    webhook.payload = {
      properties: {
        dealname: `Payment - ${p.customer.email}`,
        amount: (p.total_amount / 100).toString(),
        dealstage: "closedwon",
        closedate: new Date().toISOString(),
        hs_currency: p.currency || "USD"
      },
      associations: [
        {
          to: {
            id: p.customer.customer_id
          },
          types: [
            {
              associationCategory: "HUBSPOT_DEFINED",
              associationTypeId: 3
            }
          ]
        }
      ]
    };
  }
  return webhook;
}
```

## Tips

* Use HubSpot's API explorer to test object creation
* Map payment amounts to HubSpot currency fields
* Include customer IDs for proper associations
* Set appropriate deal stages based on payment status

## Troubleshooting

<AccordionGroup>
  <Accordion title="Records not created in HubSpot">
    * Verify OAuth scopes include write permissions
    * Check that required HubSpot properties exist
    * Ensure customer email is valid and unique
    * Review HubSpot API rate limits
  </Accordion>

  <Accordion title="Transformation errors">
    * Validate JSON structure matches HubSpot API format
    * Check that all required properties are included
    * Ensure property names match HubSpot field names exactly
  </Accordion>
</AccordionGroup>


# Inngest
Source: https://docs.dodopayments.com/integrations/inngest

Trigger serverless functions and background jobs in Inngest based on Dodo Payments events.

## Introduction

Execute serverless functions and background jobs automatically when payment events occur. Process payments, send notifications, update databases, and run complex workflows with Inngest's reliable function execution platform.

<Info>
  This integration requires your Inngest webhook URL from your function configuration.
</Info>

## Getting Started

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, navigate to <b>Webhooks → + Add Endpoint</b> and expand the integrations dropdown.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select Inngest">
    Choose the <b>Inngest</b> integration card.
  </Step>

  <Step title="Create Inngest Function">
    In Inngest, create a new function and copy the webhook URL from the function configuration.
  </Step>

  <Step title="Paste Webhook URL">
    Paste the Inngest webhook URL into the endpoint configuration.
  </Step>

  <Step title="Configure Transformation">
    Edit the transformation code to format events for your Inngest function.
  </Step>

  <Step title="Test & Create">
    Test with sample payloads and click <b>Create</b> to activate the integration.
  </Step>

  <Step title="Done!">
    🎉 Payment events will now trigger your Inngest functions automatically.
  </Step>
</Steps>

## Transformation Code Examples

### Basic Event Payload

```javascript basic_event.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.payload = {
      name: "payment.succeeded",
      data: {
        payment_id: p.payment_id,
        amount: (p.total_amount / 100).toFixed(2),
        currency: p.currency || "USD",
        customer_email: p.customer.email,
        customer_name: p.customer.name,
        payment_method: p.payment_method || "unknown"
      },
      user: {
        email: p.customer.email
      },
      ts: Math.floor(new Date(webhook.payload.timestamp).getTime() / 1000)
    };
  }
  return webhook;
}
```

### Subscription Event Handler

```javascript subscription_event.js icon="js" expandable theme={null}
function handler(webhook) {
  const s = webhook.payload.data;
  switch (webhook.eventType) {
    case "subscription.active":
      webhook.payload = {
        name: "subscription.started",
        data: {
          subscription_id: s.subscription_id,
          customer_email: s.customer.email,
          customer_name: s.customer.name,
          product_id: s.product_id,
          amount: (s.recurring_pre_tax_amount / 100).toFixed(2),
          frequency: s.payment_frequency_interval,
          next_billing: s.next_billing_date
        },
        user: {
          email: s.customer.email
        },
        ts: Math.floor(new Date(webhook.payload.timestamp).getTime() / 1000)
      };
      break;
    case "subscription.cancelled":
      webhook.payload = {
        name: "subscription.cancelled",
        data: {
          subscription_id: s.subscription_id,
          customer_email: s.customer.email,
          cancelled_at: s.cancelled_at,
          cancel_at_next_billing: s.cancel_at_next_billing_date
        },
        user: {
          email: s.customer.email
        },
        ts: Math.floor(new Date(webhook.payload.timestamp).getTime() / 1000)
      };
      break;
  }
  return webhook;
}
```

### Dispute Event Handler

```javascript dispute_event.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType.startsWith("dispute.")) {
    const d = webhook.payload.data;
    webhook.payload = {
      name: webhook.eventType,
      data: {
        dispute_id: d.dispute_id,
        payment_id: d.payment_id,
        amount: (d.amount / 100).toFixed(2),
        status: d.dispute_status,
        stage: d.dispute_stage,
        remarks: d.remarks || "",
        urgent: webhook.eventType === "dispute.opened"
      },
      user: {
        email: d.customer?.email || "unknown"
      },
      ts: Math.floor(new Date(webhook.payload.timestamp).getTime() / 1000)
    };
  }
  return webhook;
}
```

## Common Inngest Use Cases

<AccordionGroup>
  <Accordion title="Payment Processing">
    * Send confirmation emails
    * Update customer records
    * Process refunds
    * Generate invoices
    * Update inventory
  </Accordion>

  <Accordion title="Subscription Management">
    * Welcome new subscribers
    * Process cancellations
    * Send renewal reminders
    * Update billing cycles
    * Handle failed payments
  </Accordion>

  <Accordion title="Analytics & Reporting">
    * Update revenue metrics
    * Track customer behavior
    * Generate reports
    * Sync data to analytics platforms
    * Calculate churn rates
  </Accordion>
</AccordionGroup>

## Tips

* Use descriptive event names for better function organization
* Include user context for function execution
* Set proper timestamps for event ordering
* Structure data consistently across events
* Use Inngest's retry and error handling features

## Troubleshooting

<AccordionGroup>
  <Accordion title="Functions not triggering">
    * Verify webhook URL is correct and active
    * Check that Inngest function is deployed and active
    * Ensure event names match function triggers
    * Review Inngest function logs for errors
  </Accordion>

  <Accordion title="Data not received correctly">
    * Check payload structure matches Inngest expectations
    * Verify event names are properly formatted
    * Ensure all required fields are included
    * Test with Inngest's webhook testing tool
  </Accordion>
</AccordionGroup>


# External Integrations
Source: https://docs.dodopayments.com/integrations/introduction

Connect Dodo Payments with your favorite tools and platforms to automate workflows and enhance your payment experience.

## Overview

Dodo Payments offers native integrations with popular platforms and tools to help you streamline your payment operations and automate your workflows. Whether you need to send notifications to your team, sync customer data to your CRM, trigger email campaigns, or connect with your favorite development tools, we have an integration that fits your needs.

Our integrations are designed to be easy to set up and require minimal configuration. Most integrations can be connected directly from your Dodo Payments dashboard with just a few clicks, allowing you to start automating your payment workflows immediately.

<Info>
  Browse the available integrations below or use the search to quickly find the integration you're looking for. Each integration includes step-by-step setup instructions to get you started.
</Info>

## Benefits of Integrations

<CardGroup>
  <Card title="Real-time Notifications" icon="bell">
    Stay informed about important payment events as they happen, ensuring you never miss critical updates about your business.
  </Card>

  <Card title="Automated Workflows" icon="bolt">
    Reduce manual tasks by automatically triggering actions based on payment events, saving time and reducing errors.
  </Card>

  <Card title="Enhanced Visibility" icon="chart-bar">
    Get better insights into your payment operations with centralized notifications and reporting across your favorite tools.
  </Card>

  <Card title="Improved Customer Experience" icon="face-smile">
    Provide seamless payment experiences by integrating with your existing tools and workflows.
  </Card>
</CardGroup>

<Tip>
  Each integration includes detailed setup instructions and example configurations to help you get started quickly.
</Tip>

## Available Integrations

Connect Dodo Payments with the following platforms and tools:

<CardGroup>
  <Card title="N8N" icon="diagram-project" href="/integrations/n8n">
    Connect Dodo Payments to 5000+ apps through N8N webhooks for unlimited automation possibilities with self-hosted or cloud workflows.
  </Card>

  <Card title="Slack" icon="slack" href="/integrations/slack">
    Receive real-time notifications about your payments directly in your Slack workspace.
  </Card>

  <Card title="HubSpot" icon="hubspot" href="/integrations/hubspot">
    Automatically create and update contacts, companies, and deals in HubSpot from Dodo Payments events.
  </Card>

  <Card title="WooCommerce Plugin" icon="wordpress" href="/integrations/woocommerce-plugin">
    Integrate Dodo Payments seamlessly with your WooCommerce store to accept global payments.
  </Card>

  <Card title="Discord" icon="discord" href="/integrations/discord">
    Send real-time Dodo Payments notifications to your Discord channels.
  </Card>

  <Card title="Microsoft Teams" icon="microsoft" href="/integrations/microsoft-teams">
    Send Dodo Payments notifications to Microsoft Teams channels with rich Adaptive Cards.
  </Card>

  <Card title="Resend" icon="envelope" href="/integrations/resend">
    Send transactional emails through Resend based on Dodo Payments events with high deliverability.
  </Card>

  <Card title="SendGrid" icon="inbox" href="/integrations/sendgrid">
    Send transactional emails based on Dodo Payments events using SendGrid's Mail Send API.
  </Card>

  <Card title="Customer.io" icon="chart-area" href="/integrations/customer-io">
    Send Dodo Payments events to Customer.io to trigger email automations and customer journeys.
  </Card>

  <Card title="Loops" icon="infinity" href="/integrations/loops">
    Send transactional emails and manage customer communication through Loops based on Dodo Payments events.
  </Card>

  <Card title="MailerLite" icon="check-circle" href="/integrations/mailerlite">
    Automatically add customers to MailerLite subscriber lists and trigger email automations based on Dodo Payments events.
  </Card>

  <Card title="AutoSend" icon="paper-plane" href="/integrations/autosend">
    Send automated transactional emails for your Dodo Payments transactions, refunds, and payment events using AutoSend's email API.
  </Card>

  <Card title="Segment" icon="chart-line" href="/integrations/segment">
    Send Dodo Payments events to Segment for analytics and customer data platform integration.
  </Card>

  <Card title="DataFast" icon="chart-bar" href="/integrations/datafast">
    Attribute revenue to marketing channels with DataFast analytics. Track which traffic sources drive paying customers and optimize your growth.
  </Card>

  <Card title="Dub" icon="link" href="/integrations/dub">
    Track sale conversion events in Dub when customers complete purchases. Measure ROI of marketing campaigns and referral programs.
  </Card>

  <Card title="Inngest" icon="cloud" href="/integrations/inngest">
    Trigger serverless functions and background jobs in Inngest based on Dodo Payments events.
  </Card>

  <Card title="Zapier" icon="diagram-project" href="/integrations/zapier">
    Connect Dodo Payments to 5000+ apps through Zapier for unlimited automation possibilities.
  </Card>

  <Card title="Windmill" icon="wind" href="/integrations/windmill">
    Trigger Windmill workflows and scripts based on Dodo Payments events for custom automation.
  </Card>

  <Card title="Close CRM" icon="handshake" href="/integrations/close-crm">
    Sync Dodo Payments data with Close CRM to track leads and manage sales pipeline.
  </Card>

  <Card title="Figma Plugin" icon="figma" href="/integrations/figma-plugin">
    Build Figma plugins with Dodo Payments license key validation and activation.
  </Card>

  <Card title="Framer Plugin" icon="puzzle-piece" href="/integrations/framer-plugin">
    Integrate Dodo Payments checkout functionality into your Framer projects with customizable checkout experiences.
  </Card>

  <Card title="Raycast Extension" icon="puzzle-piece" href="/integrations/raycast-extension">
    Install the Raycast extension to browse and manage Dodo Payments resources from your keyboard.
  </Card>
</CardGroup>

## Integration Categories

Our integrations are organized into several categories to help you find what you need:

* **Communication & Collaboration**: Keep your team informed with real-time notifications in Slack, Discord, and Microsoft Teams
* **Email Services**: Automate transactional emails and customer communication with Resend, SendGrid, Customer.io, Loops, MailerLite, and AutoSend
* **CRM & Sales**: Sync payment data and customer information with HubSpot and Close CRM
* **Automation Platforms**: Connect with Zapier, N8N, Inngest, and Windmill to build custom workflows
* **Analytics**: Track and analyze payment events with Segment and DataFast
* **E-commerce**: Seamlessly integrate payments into your WooCommerce store
* **Design Tools**: Build plugins and extensions for Figma and Framer
* **Developer Tools**: Access Dodo Payments functionality from Raycast

## Need a Different Integration?

Don't see the platform you're looking for? We're constantly adding new integrations based on user feedback.

* **Request a new integration** by contacting the Dodo Payments team at [support@dodopayments.com](mailto:support@dodopayments.com). Let us know which platform you want to connect, and our team will review your request.
* **Build a custom integration** using our webhook system if you need a solution right away. Our webhook documentation provides all the details you need to get started.

<Card title="Webhook Documentation" icon="webhook" href="/developer-resources/webhooks">
  Learn how to build custom integrations using our webhook system.
</Card>


# Loops
Source: https://docs.dodopayments.com/integrations/loops

Send transactional emails and manage customer communication through Loops based on Dodo Payments events.

## Introduction

Send transactional emails and manage customer communication automatically when payment events occur. Deliver payment confirmations, subscription updates, and important notifications with Loops' email infrastructure.

<Info>
  This integration requires your Loops API Key for authentication.
</Info>

## Getting Started

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, navigate to <b>Webhooks → + Add Endpoint</b> and expand the integrations dropdown.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select Loops">
    Choose the <b>Loops</b> integration card.
  </Step>

  <Step title="Enter API Key">
    Provide your Loops API Key in the configuration.
  </Step>

  <Step title="Configure Transformation">
    Edit the transformation code to format emails for Loops' API.
  </Step>

  <Step title="Test & Create">
    Test with sample payloads and click <b>Create</b> to activate the email sending.
  </Step>

  <Step title="Done!">
    🎉 Payment events will now automatically trigger transactional emails via Loops.
  </Step>
</Steps>

## Transformation Code Examples

### Payment Confirmation Email

```javascript payment_confirmation.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.url = "https://api.loops.so/v1/events/send";
    webhook.payload = {
      eventName: "payment_confirmation",
      email: p.customer.email,
      properties: {
        customer_name: p.customer.name,
        payment_id: p.payment_id,
        amount: (p.total_amount / 100).toFixed(2),
        currency: p.currency || "USD",
        payment_method: p.payment_method || "unknown",
        payment_date: new Date(webhook.payload.timestamp).toLocaleDateString()
      }
    };
  }
  return webhook;
}
```

### Subscription Welcome Email

```javascript subscription_welcome.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "subscription.active") {
    const s = webhook.payload.data;
    webhook.url = "https://api.loops.so/v1/events/send";
    webhook.payload = {
      eventName: "subscription_welcome",
      email: s.customer.email,
      properties: {
        customer_name: s.customer.name,
        subscription_id: s.subscription_id,
        product_id: s.product_id,
        amount: (s.recurring_pre_tax_amount / 100).toFixed(2),
        frequency: s.payment_frequency_interval,
        next_billing: s.next_billing_date
      }
    };
  }
  return webhook;
}
```

### Payment Failure Notification

```javascript payment_failure.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.failed") {
    const p = webhook.payload.data;
    webhook.url = "https://api.loops.so/v1/events/send";
    webhook.payload = {
      eventName: "payment_failed",
      email: p.customer.email,
      properties: {
        customer_name: p.customer.name,
        payment_id: p.payment_id,
        amount: (p.total_amount / 100).toFixed(2),
        error_message: p.error_message || "Payment processing failed",
        retry_link: `https://yourdomain.com/retry-payment/${p.payment_id}`
      }
    };
  }
  return webhook;
}
```

## Tips

* Use descriptive event names for better email template organization
* Include relevant customer properties for personalization
* Set up email templates in Loops dashboard for each event
* Use consistent property naming across events
* Test email delivery before going live

## Troubleshooting

<AccordionGroup>
  <Accordion title="Emails not being sent">
    * Verify API Key is correct and active
    * Check that event names match your Loops templates
    * Ensure recipient email addresses are valid
    * Review Loops sending limits and quotas
  </Accordion>

  <Accordion title="Transformation errors">
    * Validate JSON structure matches Loops API format
    * Check that all required fields are present
    * Ensure event names are properly formatted
    * Verify API key permissions
  </Accordion>
</AccordionGroup>


# MailerLite
Source: https://docs.dodopayments.com/integrations/mailerlite

Automatically add customers to MailerLite subscriber lists and trigger email automations based on Dodo Payments events.

## Introduction

Automatically sync your paying customers to MailerLite subscriber lists when payment events occur. Add customers to specific groups, trigger automation workflows, and keep your email marketing lists up-to-date with real payment data.

MailerLite is a powerful email marketing platform for newsletters, campaigns, and automations. This integration helps you automatically manage subscribers based on payment activity - perfect for onboarding sequences, customer segmentation, and targeted marketing campaigns.

<Info>
  This integration requires your MailerLite API Key for authentication. You can generate one from your [MailerLite Integrations page](https://dashboard.mailerlite.com/integrations/api).
</Info>

## Getting Started

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, navigate to <b>Webhooks + Add Endpoint</b> and expand the integrations dropdown.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select MailerLite">
    Choose the <b>MailerLite</b> integration card.
  </Step>

  <Step title="Enter API Key">
    Provide your MailerLite API Key in the configuration.
  </Step>

  <Step title="Configure Transformation">
    Edit the transformation code to format subscriber data for MailerLite's API.
  </Step>

  <Step title="Test & Create">
    Test with sample payloads and click <b>Create</b> to activate the subscriber sync.
  </Step>

  <Step title="Done!">
    Payment events will now automatically sync customers to your MailerLite lists.
  </Step>
</Steps>

## Transformation Code Examples

### Add Customer on Successful Payment

```javascript add_customer.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.url = "https://connect.mailerlite.com/api/subscribers";
    webhook.payload = {
      email: p.customer.email,
      fields: {
        name: p.customer.name,
        company: p.customer.business_name || "",
        last_name: ""
      },
      groups: ["your-group-id-here"],
      status: "active"
    };
  }
  return webhook;
}
```

### Add Subscriber to Multiple Groups Based on Product

```javascript product_segmentation.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    
    // Determine groups based on product or amount
    const groups = ["customers-group-id"];
    
    // Add to premium group if high-value purchase
    if (p.total_amount >= 10000) { // $100+
      groups.push("premium-customers-group-id");
    }
    
    webhook.url = "https://connect.mailerlite.com/api/subscribers";
    webhook.payload = {
      email: p.customer.email,
      fields: {
        name: p.customer.name,
        last_purchase_amount: (p.total_amount / 100).toFixed(2),
        last_purchase_date: new Date(webhook.payload.timestamp).toISOString().split('T')[0],
        payment_id: p.payment_id
      },
      groups: groups,
      status: "active"
    };
  }
  return webhook;
}
```

### Add New Subscriber on Subscription Activation

```javascript subscription_subscriber.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "subscription.active") {
    const s = webhook.payload.data;
    webhook.url = "https://connect.mailerlite.com/api/subscribers";
    webhook.payload = {
      email: s.customer.email,
      fields: {
        name: s.customer.name,
        subscription_plan: s.product_id,
        subscription_amount: (s.recurring_pre_tax_amount / 100).toFixed(2),
        billing_frequency: s.payment_frequency_interval,
        subscription_start: new Date().toISOString().split('T')[0]
      },
      groups: ["subscribers-group-id", "active-subscriptions-group-id"],
      status: "active"
    };
  }
  return webhook;
}
```

### Update Subscriber on Subscription Cancellation

```javascript subscription_cancelled.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "subscription.cancelled") {
    const s = webhook.payload.data;
    // Use PUT to update existing subscriber
    webhook.url = "https://connect.mailerlite.com/api/subscribers/" + encodeURIComponent(s.customer.email);
    webhook.method = "PUT";
    webhook.payload = {
      fields: {
        subscription_status: "cancelled",
        cancellation_date: new Date().toISOString().split('T')[0]
      },
      groups: ["churned-customers-group-id"]
    };
  }
  return webhook;
}
```

### Add Customer with Custom Fields

```javascript custom_fields.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.url = "https://connect.mailerlite.com/api/subscribers";
    webhook.payload = {
      email: p.customer.email,
      fields: {
        name: p.customer.name,
        company: p.customer.business_name || "",
        country: p.customer.country || "",
        city: p.customer.city || "",
        phone: p.customer.phone || "",
        // Custom fields (must be created in MailerLite first)
        total_spent: (p.total_amount / 100).toFixed(2),
        customer_since: new Date().toISOString().split('T')[0],
        payment_method: p.payment_method || "unknown",
        currency: p.currency || "USD"
      },
      groups: ["paying-customers-group-id"],
      status: "active",
      subscribed_at: new Date().toISOString().replace('T', ' ').split('.')[0]
    };
  }
  return webhook;
}
```

### Trigger Automation via Event

```javascript trigger_automation.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    
    // First, ensure subscriber exists
    webhook.url = "https://connect.mailerlite.com/api/subscribers";
    webhook.payload = {
      email: p.customer.email,
      fields: {
        name: p.customer.name,
        // Add a trigger field that your automation watches
        last_payment_trigger: new Date().toISOString(),
        last_payment_amount: (p.total_amount / 100).toFixed(2)
      },
      status: "active"
    };
    
    // Tip: Create an automation in MailerLite that triggers
    // when 'last_payment_trigger' field is updated
  }
  return webhook;
}
```

## Tips

* Create custom fields in MailerLite before using them in your transformations
* Use groups to segment customers by product, plan tier, or purchase behavior
* Set up automation workflows in MailerLite that trigger on field updates
* Use the upsert behavior (POST to /subscribers) to avoid duplicate subscriber errors
* Store payment metadata in custom fields for better customer insights
* Test with a small group before enabling for all payments

## Custom Fields Setup

Before using custom fields, you need to create them in MailerLite:

1. Go to your MailerLite dashboard
2. Navigate to **Subscribers Fields**
3. Click **Create field** and add fields like:
   * `total_spent` (Number)
   * `customer_since` (Date)
   * `subscription_plan` (Text)
   * `payment_method` (Text)
   * `last_payment_amount` (Number)

## Troubleshooting

<AccordionGroup>
  <Accordion title="Subscribers not being added">
    * Verify API Key is correct and active
    * Check that the email address is valid (RFC 2821 compliant)
    * Ensure group IDs are correct and exist in your account
    * Note: Unsubscribed, bounced, or junk subscribers cannot be reactivated via API
  </Accordion>

  <Accordion title="Custom fields not updating">
    * Verify custom fields exist in MailerLite before using them
    * Check that field names match exactly (case-sensitive)
    * Ensure field values match the expected type (text, number, date)
  </Accordion>

  <Accordion title="Rate limit errors">
    * MailerLite API has a rate limit of 120 requests per minute
    * Use batch endpoints if processing many subscribers
    * Implement backoff strategies for high-volume scenarios
  </Accordion>

  <Accordion title="Group assignment not working">
    * Verify group IDs are numeric strings
    * Check that groups exist in your MailerLite account
    * Note: Using PUT with groups will remove subscriber from unlisted groups
  </Accordion>
</AccordionGroup>

## API Reference

MailerLite Subscribers API accepts the following key parameters:

| Parameter          | Type   | Required | Description                                              |
| ------------------ | ------ | -------- | -------------------------------------------------------- |
| `email`            | string | Yes      | Valid email address (RFC 2821)                           |
| `fields`           | object | No       | Object with field name/value pairs                       |
| `fields.name`      | string | No       | Subscriber's first name                                  |
| `fields.last_name` | string | No       | Subscriber's last name                                   |
| `fields.company`   | string | No       | Company name                                             |
| `fields.country`   | string | No       | Country                                                  |
| `fields.city`      | string | No       | City                                                     |
| `fields.phone`     | string | No       | Phone number                                             |
| `groups`           | array  | No       | Array of group IDs to add subscriber to                  |
| `status`           | string | No       | One of: active, unsubscribed, unconfirmed, bounced, junk |
| `subscribed_at`    | string | No       | Date in format `yyyy-MM-dd HH:mm:ss`                     |
| `ip_address`       | string | No       | Subscriber's IP address                                  |

For complete API documentation, visit [MailerLite Developers](https://developers.mailerlite.com/docs/subscribers.html).


# Microsoft Teams
Source: https://docs.dodopayments.com/integrations/microsoft-teams

Send Dodo Payments notifications to Microsoft Teams channels with rich Adaptive Cards.

## Introduction

Keep your business team in the loop with real-time payment notifications in Microsoft Teams. The integration delivers payment events as rich Adaptive Cards—perfect for enterprise environments where Teams is the primary collaboration tool.

<Info>
  This guide assumes you have admin access to create webhooks in your Microsoft Teams workspace.
</Info>

## Getting Started

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, navigate to <b>Webhooks → + Add Endpoint</b> and expand the integrations dropdown.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select Microsoft Teams">
    Choose the <b>Microsoft Teams</b> integration card.
  </Step>

  <Step title="Create Teams Webhook">
    In Teams, go to your channel → ⋯ → Connectors → Incoming Webhook → Configure. Copy the webhook URL.
  </Step>

  <Step title="Paste Webhook URL">
    Paste the Teams webhook URL into the endpoint configuration.
  </Step>

  <Step title="Customize Transformation">
    Edit the transformation code to format messages as Adaptive Cards for Teams.
  </Step>

  <Step title="Test & Create">
    Test with sample payloads and click <b>Create</b> to activate.
  </Step>

  <Step title="Done!">
    🎉 Your Teams channel will now receive Dodo Payments updates as Adaptive Cards.
  </Step>
</Steps>

## Transformation Code Examples

### Basic Payment Card

```javascript payment_card.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.payload = {
      type: "message",
      attachments: [{
        contentType: "application/vnd.microsoft.card.adaptive",
        content: {
          type: "AdaptiveCard",
          body: [
            {
              type: "TextBlock",
              text: "✅ Payment Successful",
              weight: "Bolder",
              size: "Medium"
            },
            {
              type: "FactSet",
              facts: [
                { title: "Amount", value: `$${(p.total_amount / 100).toFixed(2)}` },
                { title: "Customer", value: p.customer.email },
                { title: "Payment ID", value: p.payment_id }
              ]
            }
          ]
        }
      }]
    };
  }
  return webhook;
}
```

### Subscription Management

```javascript subscription_card.js icon="js" expandable theme={null}
function handler(webhook) {
  const s = webhook.payload.data;
  switch (webhook.eventType) {
    case "subscription.active":
      webhook.payload = {
        type: "message",
        attachments: [{
          contentType: "application/vnd.microsoft.card.adaptive",
          content: {
            type: "AdaptiveCard",
            body: [
              {
                type: "TextBlock",
                text: "📄 Subscription Activated",
                weight: "Bolder",
                color: "Good"
              },
              {
                type: "FactSet",
                facts: [
                  { title: "Customer", value: s.customer.email },
                  { title: "Product", value: s.product_id },
                  { title: "Amount", value: `$${(s.recurring_pre_tax_amount / 100).toFixed(2)}/${s.payment_frequency_interval}` },
                  { title: "Next Billing", value: new Date(s.next_billing_date).toLocaleDateString() }
                ]
              }
            ]
          }
        }]
      };
      break;
    case "subscription.cancelled":
      webhook.payload = {
        type: "message",
        attachments: [{
          contentType: "application/vnd.microsoft.card.adaptive",
          content: {
            type: "AdaptiveCard",
            body: [
              {
                type: "TextBlock",
                text: "⚠️ Subscription Cancelled",
                weight: "Bolder",
                color: "Warning"
              },
              {
                type: "FactSet",
                facts: [
                  { title: "Customer", value: s.customer.email },
                  { title: "Product", value: s.product_id },
                  { title: "Cancelled At", value: new Date(s.cancelled_at).toLocaleDateString() }
                ]
              }
            ]
          }
        }]
      };
      break;
  }
  return webhook;
}
```

### Dispute Alerts

```javascript dispute_card.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType.startsWith("dispute.")) {
    const d = webhook.payload.data;
    const color = d.dispute_status === "won" ? "Good" : d.dispute_status === "lost" ? "Attention" : "Warning";
    const title = d.dispute_status === "won" ? "🏆 Dispute Won" : d.dispute_status === "lost" ? "❌ Dispute Lost" : "🚨 Dispute Update";
    
    webhook.payload = {
      type: "message",
      attachments: [{
        contentType: "application/vnd.microsoft.card.adaptive",
        content: {
          type: "AdaptiveCard",
          body: [
            {
              type: "TextBlock",
              text: title,
              weight: "Bolder",
              color: color
            },
            {
              type: "FactSet",
              facts: [
                { title: "Payment ID", value: d.payment_id },
                { title: "Amount", value: `$${(d.amount / 100).toFixed(2)}` },
                { title: "Status", value: d.dispute_status },
                { title: "Stage", value: d.dispute_stage }
              ]
            }
          ]
        }
      }]
    };
  }
  return webhook;
}
```

## Tips

* Use Adaptive Cards for rich, interactive formatting
* Choose appropriate colors: Good (green), Warning (yellow), Attention (red)
* Keep fact sets concise and readable
* Test with Teams webhook tester before deploying

## Troubleshooting

<AccordionGroup>
  <Accordion title="No messages in Teams">
    * Verify the webhook URL is correct and active
    * Check that the transformation returns valid Adaptive Card JSON
    * Ensure the webhook has permission to post in the channel
  </Accordion>

  <Accordion title="Card formatting issues">
    * Validate Adaptive Card schema in Teams webhook tester
    * Check that all required fields are present
    * Ensure color values are valid (Good, Warning, Attention, Default)
  </Accordion>
</AccordionGroup>


# N8N
Source: https://docs.dodopayments.com/integrations/n8n

Integrate Dodo Payments with N8N to automate workflows and connect with over 5,000 apps using webhooks—power powerful, customizable automation in self-hosted or cloud N8N environments.

## Introduction

Connect Dodo Payments to thousands of apps and services through N8N. Automate workflows by triggering N8N workflows when payment events occur, from sending emails to updating spreadsheets, creating tasks, database operations, and much more.

<Info>
  This integration requires an N8N webhook URL from your workflow configuration.
</Info>

## Getting Started

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, navigate to <b>Webhooks → + Add Endpoint</b> and expand the integrations dropdown.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select N8N">
    Choose the <b>N8N</b> integration card.
  </Step>

  <Step title="Create Webhook in N8N">
    In N8N, create a new workflow and add a <b>Webhook</b> node as the trigger. Configure it as a POST webhook and copy the webhook URL.
  </Step>

  <Step title="Paste Webhook URL">
    Paste the N8N webhook URL into the endpoint configuration.
  </Step>

  <Step title="Configure Transformation">
    Edit the transformation code to format data for your N8N workflow.
  </Step>

  <Step title="Test & Create">
    Test with sample payloads and click <b>Create</b> to activate the integration.
  </Step>

  <Step title="Activate Workflow">
    In N8N, activate your workflow to start receiving webhook events.
  </Step>

  <Step title="Done!">
    🎉 Payment events will now trigger your N8N workflows automatically.
  </Step>
</Steps>

## Transformation Code Examples

### Basic Webhook Payload

```javascript basic_webhook.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.payload = {
      event_type: webhook.eventType,
      payment_id: p.payment_id,
      amount: (p.total_amount / 100).toFixed(2),
      currency: p.currency || "USD",
      customer_email: p.customer.email,
      customer_name: p.customer.name,
      payment_method: p.payment_method || "unknown",
      timestamp: webhook.payload.timestamp
    };
  }
  return webhook;
}
```

### Subscription Event Handler

```javascript subscription_webhook.js icon="js" expandable theme={null}
function handler(webhook) {
  const s = webhook.payload.data;
  switch (webhook.eventType) {
    case "subscription.active":
      webhook.payload = {
        event_type: "subscription_started",
        subscription_id: s.subscription_id,
        customer_email: s.customer.email,
        customer_name: s.customer.name,
        product_id: s.product_id,
        amount: (s.recurring_pre_tax_amount / 100).toFixed(2),
        frequency: s.payment_frequency_interval,
        next_billing: s.next_billing_date,
        timestamp: webhook.payload.timestamp
      };
      break;
    case "subscription.cancelled":
      webhook.payload = {
        event_type: "subscription_cancelled",
        subscription_id: s.subscription_id,
        customer_email: s.customer.email,
        cancelled_at: s.cancelled_at,
        cancel_at_next_billing: s.cancel_at_next_billing_date,
        timestamp: webhook.payload.timestamp
      };
      break;
  }
  return webhook;
}
```

### Dispute Alert Handler

```javascript dispute_webhook.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType.startsWith("dispute.")) {
    const d = webhook.payload.data;
    webhook.payload = {
      event_type: webhook.eventType,
      dispute_id: d.dispute_id,
      payment_id: d.payment_id,
      amount: (d.amount / 100).toFixed(2),
      status: d.dispute_status,
      stage: d.dispute_stage,
      remarks: d.remarks || "",
      urgent: webhook.eventType === "dispute.opened",
      timestamp: webhook.payload.timestamp
    };
  }
  return webhook;
}
```

## Popular N8N Use Cases

<AccordionGroup>
  <Accordion title="Email Notifications">
    * Send Gmail/Outlook emails for payment confirmations
    * Create email sequences in Mailchimp/ConvertKit
    * Send Slack/Discord notifications via webhooks
    * Create Google Sheets records automatically
    * Send Telegram/WhatsApp messages
  </Accordion>

  <Accordion title="CRM Updates">
    * Add contacts to HubSpot/Salesforce
    * Create deals in Pipedrive/Close
    * Update customer records in Airtable
    * Log activities in Monday.com
    * Sync data to PostgreSQL/MySQL databases
  </Accordion>

  <Accordion title="Task Management">
    * Create tasks in Asana/Trello
    * Add to-do items in Notion
    * Create calendar events in Google Calendar
    * Send SMS notifications via Twilio
    * Create GitHub issues for disputes
  </Accordion>

  <Accordion title="Data Processing">
    * Transform and enrich payment data
    * Store events in databases (PostgreSQL, MongoDB)
    * Aggregate metrics and analytics
    * Generate reports and exports
    * Trigger complex multi-step workflows
  </Accordion>
</AccordionGroup>

## Tips

* Keep payload structure simple for easy N8N node parsing
* Use consistent field names across all events
* Include timestamps for workflow timing and scheduling
* Test your workflow with sample data before activating
* Use N8N's IF node for conditional logic and routing
* Leverage N8N's Code node for custom data transformations
* Use the Switch node to route different event types to different paths
* Set up error workflows to handle failed webhook deliveries

## Troubleshooting

<AccordionGroup>
  <Accordion title="Workflow not triggering">
    * Verify webhook URL is correct and accessible
    * Check that workflow is activated in N8N
    * Ensure webhook node is configured as POST method
    * Test webhook delivery in N8N's execution history
    * Verify firewall/network settings allow incoming webhooks
    * Check N8N webhook authentication settings if configured
  </Accordion>

  <Accordion title="Data not mapping correctly">
    * Check field names in N8N node configurations
    * Verify data types match expected formats in nodes
    * Use N8N's test feature to inspect incoming data
    * Ensure transformation code returns valid JSON
    * Check the webhook node's response format settings
    * Use the Set node to rename or restructure fields
  </Accordion>

  <Accordion title="Workflow execution errors">
    * Review execution logs in N8N for detailed error messages
    * Check node connection settings and credentials
    * Verify all required fields are present in the payload
    * Test individual nodes with sample data
    * Enable error workflows to catch and handle failures
    * Check rate limits and API quotas for connected services
  </Accordion>
</AccordionGroup>


# Raycast Extension
Source: https://docs.dodopayments.com/integrations/raycast-extension

Install the Raycast extension to browse and manage Dodo Payments resources from your keyboard.

<Frame>
  <img alt="Raycast extension home showing Dodo Payments commands" />
</Frame>

Your Dodo Payments dashboard, a few keystrokes away. Use Raycast to quickly view payments, subscriptions, customers, products, discount codes, license keys, and refunds without opening the dashboard.

## Install

<Card title="Install from Raycast Store →" icon="puzzle-piece" href="https://www.raycast.com/dodopayments/dodo-payments">
  Open the Dodo Payments extension page in the Raycast Store.
</Card>

<Info>
  Requires Raycast on macOS and a Dodo Payments API key.
</Info>

## Setup

<Steps>
  <Step title="Get your API Key">
    1. Log in to your Dodo Payments dashboard.
    2. Go to Settings › API Keys.
    3. Copy your API key.
  </Step>

  <Step title="Configure the Extension">
    1. Open Raycast.
    2. Search for "Dodo Payments" and select any command.
    3. When prompted, enter your API key in the API Key field.
    4. Choose the API mode:
       * Test: use for development and testing.
       * Live: use for production data.
    5. Save the settings.
  </Step>
</Steps>

<Tip>
  Start in Test mode to validate your setup, then switch to Live.
</Tip>

<Warning>
  Treat your API key like a password. Do not share it or store it in plaintext.
</Warning>

## Use the extension

* **Search**: open Raycast, type "Dodo Payments", and pick a command.
* **Filter**: narrow results by typing parts of IDs, emails, names, or statuses.
* **Open details**: press Enter on a list item to view more information.

## Commands and views

### Payments

Browse recent payments and jump into detailed views in seconds.

<Frame>
  <img alt="Payments list view in the Raycast extension" />
</Frame>

### Subscriptions

Quickly scan active, trialing, and canceled subscriptions.

<Frame>
  <img alt="Subscriptions list view in the Raycast extension" />
</Frame>

### Customers

Find customers fast and open full profiles.

<Frame>
  <img alt="Customers list view in the Raycast extension" />
</Frame>

### Products

Review and manage your product catalog at a glance.

<Frame>
  <img alt="Products list view in the Raycast extension" />
</Frame>

### Discount Codes

Search and reference active discount codes quickly.

<Frame>
  <img alt="Discount codes list view in the Raycast extension" />
</Frame>

### License Keys

Look up and manage license keys without leaving Raycast.

<Frame>
  <img alt="License keys list view in the Raycast extension" />
</Frame>

### Refunds

See recent refunds and drill into their details.

<Frame>
  <img alt="Refunds list view in the Raycast extension" />
</Frame>

<Info>
  Additional live-only views: disputes and payouts.
</Info>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Authentication failed or 401/403 errors">
    Confirm the API key and mode (Test vs Live) match your dashboard data. Reopen the command and re-enter the key if needed.
  </Accordion>

  <Accordion title="No results appear">
    Ensure your selected mode has data. Try switching between Test and Live.
  </Accordion>

  <Accordion title="Rate limits or timeouts">
    Wait a moment and try again. If the issue persists, check your network connectivity.
  </Accordion>
</AccordionGroup>

<Card title="Need help? Contact support →" icon="life-ring" href="/miscellaneous/help-support">
  Get assistance from the Dodo Payments team.
</Card>


# Resend
Source: https://docs.dodopayments.com/integrations/resend

Send transactional emails through Resend based on Dodo Payments events with high deliverability.

## Introduction

Send professional transactional emails automatically when payment events occur. Deliver payment confirmations, subscription updates, and important notifications with Resend's reliable email infrastructure and excellent deliverability rates.

<Info>
  This integration requires your Resend API Key for authentication.
</Info>

## Getting Started

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, navigate to <b>Webhooks → + Add Endpoint</b> and expand the integrations dropdown.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select Resend">
    Choose the <b>Resend</b> integration card.
  </Step>

  <Step title="Enter API Key">
    Provide your Resend API Key in the configuration.
  </Step>

  <Step title="Configure Transformation">
    Edit the transformation code to format emails for Resend's API.
  </Step>

  <Step title="Test & Create">
    Test with sample payloads and click <b>Create</b> to activate the email sending.
  </Step>

  <Step title="Done!">
    🎉 Payment events will now automatically trigger transactional emails via Resend.
  </Step>
</Steps>

## Transformation Code Examples

### Payment Confirmation Email

```javascript payment_confirmation.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.url = "https://api.resend.com/emails";
    webhook.payload = {
      from: "payments@yourdomain.com",
      to: [p.customer.email],
      subject: "Payment Confirmation - $" + (p.total_amount / 100).toFixed(2),
      html: `
        <h2>Payment Successful!</h2>
        <p>Hi ${p.customer.name},</p>
        <p>Your payment of $${(p.total_amount / 100).toFixed(2)} has been processed successfully.</p>
        <ul>
          <li><strong>Payment ID:</strong> ${p.payment_id}</li>
          <li><strong>Amount:</strong> $${(p.total_amount / 100).toFixed(2)}</li>
          <li><strong>Date:</strong> ${new Date(webhook.payload.timestamp).toLocaleDateString()}</li>
          <li><strong>Method:</strong> ${p.payment_method || "Unknown"}</li>
        </ul>
        <p>Thank you for your business!</p>
      `,
      text: `Payment Successful! Your payment of $${(p.total_amount / 100).toFixed(2)} has been processed. Payment ID: ${p.payment_id}`
    };
  }
  return webhook;
}
```

### Subscription Welcome Email

```javascript subscription_welcome.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "subscription.active") {
    const s = webhook.payload.data;
    webhook.url = "https://api.resend.com/emails";
    webhook.payload = {
      from: "welcome@yourdomain.com",
      to: [s.customer.email],
      subject: "Welcome to Your Subscription!",
      html: `
        <h2>Welcome to Your Subscription!</h2>
        <p>Hi ${s.customer.name},</p>
        <p>Your subscription has been activated successfully.</p>
        <ul>
          <li><strong>Subscription ID:</strong> ${s.subscription_id}</li>
          <li><strong>Product:</strong> ${s.product_id}</li>
          <li><strong>Amount:</strong> $${(s.recurring_pre_tax_amount / 100).toFixed(2)}/${s.payment_frequency_interval}</li>
          <li><strong>Next Billing:</strong> ${new Date(s.next_billing_date).toLocaleDateString()}</li>
        </ul>
        <p>You can manage your subscription anytime from your account dashboard.</p>
      `,
      text: `Welcome! Your subscription is now active. Amount: $${(s.recurring_pre_tax_amount / 100).toFixed(2)}/${s.payment_frequency_interval}`
    };
  }
  return webhook;
}
```

### Payment Failure Notification

```javascript payment_failure.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.failed") {
    const p = webhook.payload.data;
    webhook.url = "https://api.resend.com/emails";
    webhook.payload = {
      from: "support@yourdomain.com",
      to: [p.customer.email],
      subject: "Payment Failed - Action Required",
      html: `
        <h2>Payment Failed</h2>
        <p>Hi ${p.customer.name},</p>
        <p>We were unable to process your payment of $${(p.total_amount / 100).toFixed(2)}.</p>
        <ul>
          <li><strong>Payment ID:</strong> ${p.payment_id}</li>
          <li><strong>Amount:</strong> $${(p.total_amount / 100).toFixed(2)}</li>
          <li><strong>Error:</strong> ${p.error_message || "Payment processing failed"}</li>
        </ul>
        <p>Please update your payment method or contact support for assistance.</p>
        <a href="https://yourdomain.com/update-payment">Update Payment Method</a>
      `,
      text: `Payment Failed: We couldn't process your $${(p.total_amount / 100).toFixed(2)} payment. Please update your payment method.`
    };
  }
  return webhook;
}
```

## Tips

* Use verified sender domains for better deliverability
* Include both HTML and text versions of emails
* Personalize content with customer data
* Use clear, action-oriented subject lines
* Include unsubscribe links for compliance
* Test email templates before going live

## Troubleshooting

<AccordionGroup>
  <Accordion title="Emails not being sent">
    * Verify API Key is correct and active
    * Check that sender domain is verified in Resend
    * Ensure recipient email addresses are valid
    * Review Resend sending limits and quotas
  </Accordion>

  <Accordion title="Transformation errors">
    * Validate JSON structure matches Resend API format
    * Check that all required fields are present
    * Ensure HTML content is properly formatted
    * Verify from email address is verified
  </Accordion>
</AccordionGroup>


# Segment
Source: https://docs.dodopayments.com/integrations/segment

Send Dodo Payments events to Segment for analytics and customer data platform integration.

## Introduction

Track payment events in Segment to power your analytics, marketing automation, and customer data platform. Send payment, subscription, and customer lifecycle events to 300+ downstream tools automatically.

<Info>
  This integration requires a Segment Write Key from your Segment workspace.
</Info>

## Getting Started

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, navigate to <b>Webhooks → + Add Endpoint</b> and expand the integrations dropdown.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select Segment">
    Choose the <b>Segment</b> integration card.
  </Step>

  <Step title="Enter Write Key">
    Provide your Segment Write Key in the configuration.
  </Step>

  <Step title="Configure Transformation">
    Edit the transformation code to format events for Segment's Track API.
  </Step>

  <Step title="Test & Create">
    Test with sample payloads and click <b>Create</b> to activate the sync.
  </Step>

  <Step title="Done!">
    🎉 Payment events will now be tracked in Segment and sent to your connected tools.
  </Step>
</Steps>

## Transformation Code Examples

### Track Payment Events

```javascript track_payments.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.url = "https://api.segment.io/v1/track";
    webhook.payload = {
      userId: p.customer.customer_id,
      event: "Payment Completed",
      properties: {
        amount: (p.total_amount / 100).toFixed(2),
        currency: p.currency || "USD",
        payment_method: p.payment_method || "unknown",
        payment_id: p.payment_id,
        customer_email: p.customer.email,
        customer_name: p.customer.name
      },
      timestamp: webhook.payload.timestamp
    };
  }
  return webhook;
}
```

### Track Subscription Lifecycle

```javascript track_subscriptions.js icon="js" expandable theme={null}
function handler(webhook) {
  const s = webhook.payload.data;
  switch (webhook.eventType) {
    case "subscription.active":
      webhook.url = "https://api.segment.io/v1/track";
      webhook.payload = {
        userId: s.customer.customer_id,
        event: "Subscription Started",
        properties: {
          subscription_id: s.subscription_id,
          product_id: s.product_id,
          amount: (s.recurring_pre_tax_amount / 100).toFixed(2),
          frequency: s.payment_frequency_interval,
          next_billing: s.next_billing_date,
          customer_email: s.customer.email
        },
        timestamp: webhook.payload.timestamp
      };
      break;
    case "subscription.cancelled":
      webhook.url = "https://api.segment.io/v1/track";
      webhook.payload = {
        userId: s.customer.customer_id,
        event: "Subscription Cancelled",
        properties: {
          subscription_id: s.subscription_id,
          product_id: s.product_id,
          cancelled_at: s.cancelled_at,
          cancel_at_next_billing: s.cancel_at_next_billing_date,
          customer_email: s.customer.email
        },
        timestamp: webhook.payload.timestamp
      };
      break;
  }
  return webhook;
}
```

### Identify Customer Properties

```javascript identify_customer.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.url = "https://api.segment.io/v1/identify";
    webhook.payload = {
      userId: p.customer.customer_id,
      traits: {
        email: p.customer.email,
        name: p.customer.name,
        total_spent: (p.total_amount / 100).toFixed(2),
        payment_method: p.payment_method || "unknown",
        last_payment_date: webhook.payload.timestamp,
        customer_since: webhook.payload.timestamp
      }
    };
  }
  return webhook;
}
```

## Tips

* Use consistent event names across your integration
* Include relevant properties for analytics and segmentation
* Set proper timestamps for accurate event tracking
* Use customer IDs as userId for proper user identification

## Troubleshooting

<AccordionGroup>
  <Accordion title="Events not appearing in Segment">
    * Verify Write Key is correct and active
    * Check that event names follow Segment naming conventions
    * Ensure userId is properly set for user identification
    * Review Segment API rate limits
  </Accordion>

  <Accordion title="Transformation errors">
    * Validate JSON structure matches Segment API format
    * Check that all required fields are present
    * Ensure event names are strings, not objects
  </Accordion>
</AccordionGroup>


# SendGrid
Source: https://docs.dodopayments.com/integrations/sendgrid

Send transactional emails based on Dodo Payments events using SendGrid's Mail Send API.

## Introduction

Automatically send transactional emails for payment confirmations, subscription updates, and important notifications using SendGrid. Trigger personalized emails based on payment events with dynamic content and professional templates.

<Info>
  This integration requires a SendGrid API Key with Mail Send permissions.
</Info>

## Getting Started

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, navigate to <b>Webhooks → + Add Endpoint</b> and expand the integrations dropdown.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select SendGrid">
    Choose the <b>SendGrid</b> integration card.
  </Step>

  <Step title="Enter API Key">
    Provide your SendGrid API Key in the configuration.
  </Step>

  <Step title="Configure Transformation">
    Edit the transformation code to format emails for SendGrid's Mail Send API.
  </Step>

  <Step title="Test & Create">
    Test with sample payloads and click <b>Create</b> to activate the email sending.
  </Step>

  <Step title="Done!">
    🎉 Payment events will now automatically trigger transactional emails via SendGrid.
  </Step>
</Steps>

## Transformation Code Examples

### Payment Confirmation Email

```javascript payment_confirmation.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.url = "https://api.sendgrid.com/v3/mail/send";
    webhook.payload = {
      personalizations: [
        {
          to: [{ email: p.customer.email }],
          dynamic_template_data: {
            customer_name: p.customer.name,
            payment_amount: (p.total_amount / 100).toFixed(2),
            payment_id: p.payment_id,
            payment_date: new Date(webhook.payload.timestamp).toLocaleDateString(),
            currency: p.currency || "USD"
          }
        }
      ],
      from: {
        email: "payments@yourdomain.com",
        name: "Your Company"
      },
      template_id: "d-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
    };
  }
  return webhook;
}
```

### Subscription Welcome Email

```javascript subscription_welcome.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "subscription.active") {
    const s = webhook.payload.data;
    webhook.url = "https://api.sendgrid.com/v3/mail/send";
    webhook.payload = {
      personalizations: [
        {
          to: [{ email: s.customer.email }],
          dynamic_template_data: {
            customer_name: s.customer.name,
            subscription_id: s.subscription_id,
            product_name: s.product_id,
            amount: (s.recurring_pre_tax_amount / 100).toFixed(2),
            frequency: s.payment_frequency_interval,
            next_billing: new Date(s.next_billing_date).toLocaleDateString()
          }
        }
      ],
      from: {
        email: "welcome@yourdomain.com",
        name: "Your Company"
      },
      template_id: "d-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
    };
  }
  return webhook;
}
```

### Payment Failure Notification

```javascript payment_failure.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.failed") {
    const p = webhook.payload.data;
    webhook.url = "https://api.sendgrid.com/v3/mail/send";
    webhook.payload = {
      personalizations: [
        {
          to: [{ email: p.customer.email }],
          dynamic_template_data: {
            customer_name: p.customer.name,
            payment_amount: (p.total_amount / 100).toFixed(2),
            error_message: p.error_message || "Payment processing failed",
            payment_id: p.payment_id,
            retry_link: `https://yourdomain.com/retry-payment/${p.payment_id}`
          }
        }
      ],
      from: {
        email: "support@yourdomain.com",
        name: "Your Company Support"
      },
      template_id: "d-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
    };
  }
  return webhook;
}
```

## Tips

* Use SendGrid dynamic templates for personalized content
* Include relevant payment data in template variables
* Set proper from addresses and sender names
* Use template IDs for consistent email formatting
* Include unsubscribe links for compliance

## Troubleshooting

<AccordionGroup>
  <Accordion title="Emails not being sent">
    * Verify API Key has Mail Send permissions
    * Check that template IDs are valid and active
    * Ensure recipient email addresses are valid
    * Review SendGrid sending limits and quotas
  </Accordion>

  <Accordion title="Transformation errors">
    * Validate JSON structure matches SendGrid API format
    * Check that all required fields are present
    * Ensure template data variables are properly formatted
    * Verify from email addresses are verified in SendGrid
  </Accordion>
</AccordionGroup>


# Slack
Source: https://docs.dodopayments.com/integrations/slack

Integrate Dodo Payments with Slack to receive real-time notifications about your payments.

## Introduction

The Dodo Payments Slack integration allows you to receive real-time notifications about your payments directly in your Slack workspace. This integration enables you to stay updated on the status of your payments, track transactions, and manage your payments more efficiently.

<Info>
  This integration uses our webhook management portal to automatically transform Dodo Payments webhook events into Slack-compatible messages. No additional coding is required - just configure the connector and start receiving notifications.
</Info>

## Getting Started

<Steps>
  <Step title="Open the Webhook Section">
    Go to the <b>Webhook</b> section in your Dodo Payments dashboard. Click the <b>+ Add Endpoint</b> button, then open the webhook dropdown to reveal other integrations.

    <Frame>
      <img alt="Dodo Payments dashboard showing Add Endpoint button and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select Slack Integration">
    Select the <b>Slack</b> integration and click <b>Connect your Slack workspace</b>.

    <Frame>
      <img alt="Slack integration card and connect button" />
    </Frame>
  </Step>

  <Step title="Grant Slack Permissions">
    Grant the necessary permissions to the Incoming Webhooks Slack App so it can post messages in your chosen channel.

    <Frame>
      <img alt="Slack OAuth permissions screen for Incoming Webhooks app" />
    </Frame>
  </Step>

  <Step title="Customize Transformation Code">
    Add or edit the transformation code to customize your Slack notifications for your use case. You can use the pre-made templates or write your own logic.

    <Frame>
      <img alt="Transformation code editor for Slack integration" />
    </Frame>
  </Step>

  <Step title="Test and Create">
    Test your transformation code with custom or pre-made event payloads. Once you're satisfied, click <b>Create</b> to activate the integration.

    <Frame>
      <img alt="Test transformation and create button" />
    </Frame>
  </Step>

  <Step title="Integration Complete!">
    🎉 You have successfully created the Slack integration! Your Dodo Payments events will now be delivered to your selected Slack channel in real time.
  </Step>
</Steps>

## Transformation Code Examples

### Basic Payment Notifications

This transformation sends simple text messages for payment events:

```javascript payment_notifs.js icon="js" expandable theme={null}
function handler(webhook) {
  switch (webhook.eventType) {
    case "payment.succeeded":
      webhook.payload = {
        text: `✅ Payment Successful\nAmount: $${(webhook.payload.data.total_amount / 100).toFixed(2)}\nCustomer: ${webhook.payload.data.customer.email}\nPayment ID: ${webhook.payload.data.payment_id}`
      };
      break;
      
    case "payment.failed":
      webhook.payload = {
        text: `❌ Payment Failed\nAmount: $${(webhook.payload.data.total_amount / 100).toFixed(2)}\nCustomer: ${webhook.payload.data.customer.email}\nReason: ${webhook.payload.data.error_message || 'Unknown'}`
      };
      break;
      
    case "payment.processing":
      webhook.payload = {
        text: `⏳ Payment Processing\nAmount: $${(webhook.payload.data.total_amount / 100).toFixed(2)}\nCustomer: ${webhook.payload.data.customer.email}`
      };
      break;
  }

  return webhook;
}
```

### Rich Subscription Notifications

This transformation creates rich Slack messages with attachments for subscription events:

```javascript subscription_notifs.js icon="js" expandable theme={null}
function handler(webhook) {
  switch (webhook.eventType) {
    case "subscription.active":
      webhook.payload = {
        attachments: [{
          color: "good",
          title: "🎉 Subscription Activated",
          fields: [
            {
              title: "Customer",
              value: webhook.payload.data.customer.email,
              short: true
            },
            {
              title: "Product ID",
              value: webhook.payload.data.product_id,
              short: true
            },
            {
              title: "Amount",
              value: `$${(webhook.payload.data.recurring_pre_tax_amount / 100).toFixed(2)}/${webhook.payload.data.payment_frequency_interval}`,
              short: true
            },
            {
              title: "Next Billing",
              value: new Date(webhook.payload.data.next_billing_date).toLocaleDateString(),
              short: true
            }
          ],
          footer: "Dodo Payments",
          ts: Math.floor(new Date(webhook.payload.timestamp).getTime() / 1000)
        }]
      };
      break;
      
    case "subscription.cancelled":
      webhook.payload = {
        attachments: [{
          color: "warning",
          title: "⚠️ Subscription Cancelled",
          fields: [
            {
              title: "Customer",
              value: webhook.payload.data.customer.email,
              short: true
            },
            {
              title: "Product ID",
              value: webhook.payload.data.product_id,
              short: true
            },
            {
              title: "Cancellation Date",
              value: new Date(webhook.payload.data.cancelled_at).toLocaleDateString(),
              short: true
            },
            {
              title: "Cancel at Next Billing",
              value: webhook.payload.data.cancel_at_next_billing_date ? "Yes" : "No",
              short: true
            }
          ],
          footer: "Dodo Payments",
          ts: Math.floor(new Date(webhook.payload.timestamp).getTime() / 1000)
        }]
      };
      break;
      
    case "subscription.renewed":
      webhook.payload = {
        attachments: [{
          color: "good",
          title: "🔄 Subscription Renewed",
          fields: [
            {
              title: "Customer",
              value: webhook.payload.data.customer.email,
              short: true
            },
            {
              title: "Product ID",
              value: webhook.payload.data.product_id,
              short: true
            },
            {
              title: "Amount",
              value: `$${(webhook.payload.data.recurring_pre_tax_amount / 100).toFixed(2)}`,
              short: true
            },
            {
              title: "Next Billing",
              value: new Date(webhook.payload.data.next_billing_date).toLocaleDateString(),
              short: true
            }
          ],
          footer: "Dodo Payments",
          ts: Math.floor(new Date(webhook.payload.timestamp).getTime() / 1000)
        }]
      };
      break;
  }

  return webhook;
}
```

### Dispute Management Notifications

This transformation handles dispute events with appropriate colors and urgency:

```javascript dispute_notifs.js icon="js" expandable theme={null}
function handler(webhook) {
  switch (webhook.eventType) {
    case "dispute.opened":
      webhook.payload = {
        attachments: [{
          color: "danger",
          title: "🚨 New Dispute Opened",
          fields: [
            {
              title: "Payment ID",
              value: webhook.payload.data.payment_id,
              short: true
            },
            {
              title: "Amount",
              value: `$${(webhook.payload.data.amount / 100).toFixed(2)}`,
              short: true
            },
            {
              title: "Status",
              value: webhook.payload.data.dispute_status,
              short: true
            },
            {
              title: "Stage",
              value: webhook.payload.data.dispute_stage,
              short: true
            },
            {
              title: "Remarks",
              value: webhook.payload.data.remarks || "No remarks",
              short: false
            }
          ],
          footer: "Dodo Payments - Action Required",
          ts: Math.floor(new Date(webhook.payload.timestamp).getTime() / 1000)
        }]
      };
      break;
      
    case "dispute.won":
      webhook.payload = {
        attachments: [{
          color: "good",
          title: "✅ Dispute Won",
          fields: [
            {
              title: "Payment ID",
              value: webhook.payload.data.payment_id,
              short: true
            },
            {
              title: "Amount",
              value: `$${(webhook.payload.data.amount / 100).toFixed(2)}`,
              short: true
            },
            {
              title: "Status",
              value: webhook.payload.data.dispute_status,
              short: true
            },
            {
              title: "Resolution",
              value: "Dispute resolved in your favor",
              short: false
            }
          ],
          footer: "Dodo Payments",
          ts: Math.floor(new Date(webhook.payload.timestamp).getTime() / 1000)
        }]
      };
      break;
      
    case "dispute.lost":
      webhook.payload = {
        attachments: [{
          color: "danger",
          title: "❌ Dispute Lost",
          fields: [
            {
              title: "Payment ID",
              value: webhook.payload.data.payment_id,
              short: true
            },
            {
              title: "Amount",
              value: `$${(webhook.payload.data.amount / 100).toFixed(2)}`,
              short: true
            },
            {
              title: "Status",
              value: webhook.payload.data.dispute_status,
              short: true
            },
            {
              title: "Impact",
              value: "Funds will be debited from your account",
              short: false
            }
          ],
          footer: "Dodo Payments - Review Required",
          ts: Math.floor(new Date(webhook.payload.timestamp).getTime() / 1000)
        }]
      };
      break;
  }

  return webhook;
}
```

### Comprehensive All-Events Handler

This transformation handles all event types with consistent formatting:

```javascript all_events_notifs.js icon="js" expandable  theme={null}
function handler(webhook) {
  const event = webhook.payload.data;
  const timestamp = new Date(webhook.payload.timestamp).toLocaleString();
  
  let color, emoji, title, fields = [];
  
  switch (webhook.eventType) {
    case "payment.succeeded":
      color = "good";
      emoji = "✅";
      title = "Payment Successful";
      fields = [
        { title: "Amount", value: `$${(event.total_amount / 100).toFixed(2)}`, short: true },
        { title: "Customer", value: event.customer.email, short: true },
        { title: "Payment ID", value: event.payment_id, short: true },
        { title: "Method", value: event.payment_method || "Unknown", short: true }
      ];
      break;
      
    case "payment.failed":
      color = "danger";
      emoji = "❌";
      title = "Payment Failed";
      fields = [
        { title: "Amount", value: `$${(event.total_amount / 100).toFixed(2)}`, short: true },
        { title: "Customer", value: event.customer.email, short: true },
        { title: "Reason", value: event.error_message || "Unknown", short: false }
      ];
      break;
      
    case "subscription.active":
      color = "good";
      emoji = "🎉";
      title = "Subscription Activated";
      fields = [
        { title: "Customer", value: event.customer.email, short: true },
        { title: "Product ID", value: event.product_id, short: true },
        { title: "Amount", value: `$${(event.recurring_pre_tax_amount / 100).toFixed(2)}/${event.payment_frequency_interval}`, short: true },
        { title: "Next Billing", value: new Date(event.next_billing_date).toLocaleDateString(), short: true }
      ];
      break;
      
    case "subscription.cancelled":
      color = "warning";
      emoji = "⚠️";
      title = "Subscription Cancelled";
      fields = [
        { title: "Customer", value: event.customer.email, short: true },
        { title: "Product ID", value: event.product_id, short: true },
        { title: "Cancellation Date", value: new Date(event.cancelled_at).toLocaleDateString(), short: true },
        { title: "Cancel at Next Billing", value: event.cancel_at_next_billing_date ? "Yes" : "No", short: true }
      ];
      break;
      
    case "refund.succeeded":
      color = "good";
      emoji = "💰";
      title = "Refund Processed";
      fields = [
        { title: "Amount", value: `$${(event.amount / 100).toFixed(2)}`, short: true },
        { title: "Refund ID", value: event.refund_id, short: true },
        { title: "Payment ID", value: event.payment_id, short: true },
        { title: "Reason", value: event.reason || "Not specified", short: true }
      ];
      break;
      
    case "dispute.opened":
      color = "danger";
      emoji = "🚨";
      title = "New Dispute Opened";
      fields = [
        { title: "Payment ID", value: event.payment_id, short: true },
        { title: "Amount", value: `$${(event.amount / 100).toFixed(2)}`, short: true },
        { title: "Status", value: event.dispute_status, short: true },
        { title: "Stage", value: event.dispute_stage, short: true },
        { title: "Remarks", value: event.remarks || "No remarks", short: false }
      ];
      break;
      
    case "license_key.created":
      color = "good";
      emoji = "🔑";
      title = "License Key Created";
      fields = [
        { title: "License ID", value: event.id, short: true },
        { title: "Product ID", value: event.product_id, short: true },
        { title: "License Key", value: event.key.substring(0, 8) + "...", short: true },
        { title: "Expires", value: event.expires_at ? new Date(event.expires_at).toLocaleDateString() : "Never", short: true }
      ];
      break;
      
    default:
      // Handle any other events with a generic format
      color = "warning";
      emoji = "ℹ️";
      title = webhook.eventType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
      fields = [
        { title: "Event Type", value: webhook.eventType, short: true },
        { title: "Timestamp", value: timestamp, short: true }
      ];
  }
  
  webhook.payload = {
    attachments: [{
      color: color,
      title: `${emoji} ${title}`,
      fields: fields,
      footer: "Dodo Payments",
      ts: Math.floor(new Date(webhook.payload.timestamp).getTime() / 1000)
    }]
  };

  return webhook;
}
```

## Best Practices

To make your Slack notifications effective:

* Use rich message attachments with colors, fields, and formatting for clarity and actionability.
* Always include key data such as amounts, customer emails, and IDs for quick identification.
* Choose colors that match the event type: green (`good`) for success, red (`danger`) for disputes or failures, yellow (`warning`) for cancellations, and blue (`#36a64f`) for informational events.
* Add timestamps to help track when each event occurred.

<Warning>
  **Handle Sensitive Data**: Be careful not to include sensitive information like full license keys or personal data in Slack messages. Consider truncating or masking sensitive values.
</Warning>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Notifications not appearing in Slack">
    * Verify that the Slack webhook URL is correct and active
    * Check that the transformation code is valid JavaScript
    * Ensure the selected event types are being triggered
    * Verify that your Slack app has the necessary permissions
  </Accordion>

  <Accordion title="Transformation errors">
    * Check the webhook management portal for transformation error logs
    * Verify that the webhook payload structure matches your transformation code
    * Test your transformation code with sample data
    * Ensure all required fields are present in the webhook payload
  </Accordion>

  <Accordion title="Missing event types">
    * Confirm that the events you want to receive are enabled in your Dodo Payments webhook configuration
    * Check that the event types are selected in your Slack connector configuration
    * Verify that your endpoint is properly configured to receive the events
  </Accordion>
</AccordionGroup>


# Windmill
Source: https://docs.dodopayments.com/integrations/windmill

Trigger Windmill workflows and scripts based on Dodo Payments events for custom automation.

## Introduction

Execute custom workflows and scripts in Windmill when payment events occur. Run database operations, send notifications, process data, and automate complex business logic with Windmill's powerful workflow engine.

<Info>
  This integration requires your Windmill webhook URL from your workflow configuration.
</Info>

## Getting Started

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, navigate to <b>Webhooks → + Add Endpoint</b> and expand the integrations dropdown.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select Windmill">
    Choose the <b>Windmill</b> integration card.
  </Step>

  <Step title="Create Windmill Workflow">
    In Windmill, create a new workflow and copy the webhook URL from the trigger configuration.
  </Step>

  <Step title="Paste Webhook URL">
    Paste the Windmill webhook URL into the endpoint configuration.
  </Step>

  <Step title="Configure Transformation">
    Edit the transformation code to format events for your Windmill workflow.
  </Step>

  <Step title="Test & Create">
    Test with sample payloads and click <b>Create</b> to activate the integration.
  </Step>

  <Step title="Done!">
    🎉 Payment events will now trigger your Windmill workflows automatically.
  </Step>
</Steps>

## Transformation Code Examples

### Basic Workflow Payload

```javascript basic_workflow.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.payload = {
      event_type: webhook.eventType,
      payment_id: p.payment_id,
      amount: (p.total_amount / 100).toFixed(2),
      currency: p.currency || "USD",
      customer_email: p.customer.email,
      customer_name: p.customer.name,
      payment_method: p.payment_method || "unknown",
      timestamp: webhook.payload.timestamp,
      metadata: {
        business_id: p.business_id,
        product_id: p.product_id
      }
    };
  }
  return webhook;
}
```

### Subscription Workflow Handler

```javascript subscription_workflow.js icon="js" expandable theme={null}
function handler(webhook) {
  const s = webhook.payload.data;
  switch (webhook.eventType) {
    case "subscription.active":
      webhook.payload = {
        event_type: "subscription_started",
        subscription_id: s.subscription_id,
        customer_email: s.customer.email,
        customer_name: s.customer.name,
        product_id: s.product_id,
        amount: (s.recurring_pre_tax_amount / 100).toFixed(2),
        frequency: s.payment_frequency_interval,
        next_billing: s.next_billing_date,
        customer_id: s.customer.customer_id,
        timestamp: webhook.payload.timestamp
      };
      break;
    case "subscription.cancelled":
      webhook.payload = {
        event_type: "subscription_cancelled",
        subscription_id: s.subscription_id,
        customer_email: s.customer.email,
        cancelled_at: s.cancelled_at,
        cancel_at_next_billing: s.cancel_at_next_billing_date,
        customer_id: s.customer.customer_id,
        timestamp: webhook.payload.timestamp
      };
      break;
  }
  return webhook;
}
```

### Dispute Workflow Handler

```javascript dispute_workflow.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType.startsWith("dispute.")) {
    const d = webhook.payload.data;
    webhook.payload = {
      event_type: webhook.eventType,
      dispute_id: d.dispute_id,
      payment_id: d.payment_id,
      amount: (d.amount / 100).toFixed(2),
      status: d.dispute_status,
      stage: d.dispute_stage,
      remarks: d.remarks || "",
      urgent: webhook.eventType === "dispute.opened",
      business_id: d.business_id,
      timestamp: webhook.payload.timestamp
    };
  }
  return webhook;
}
```

## Common Windmill Use Cases

<AccordionGroup>
  <Accordion title="Database Operations">
    * Update customer records in PostgreSQL/MySQL
    * Log payment events to data warehouses
    * Sync data to external systems
    * Update inventory levels
    * Track analytics metrics
  </Accordion>

  <Accordion title="Business Logic">
    * Calculate revenue metrics
    * Process refunds and adjustments
    * Handle subscription lifecycle
    * Generate reports and exports
    * Validate payment data
  </Accordion>

  <Accordion title="External Integrations">
    * Send data to analytics platforms
    * Update CRM systems
    * Trigger email campaigns
    * Create calendar events
    * Send SMS notifications
  </Accordion>
</AccordionGroup>

## Tips

* Structure payload data for easy workflow processing
* Include all relevant metadata for business logic
* Use consistent field naming across events
* Include timestamps for workflow timing
* Leverage Windmill's built-in error handling

## Troubleshooting

<AccordionGroup>
  <Accordion title="Workflows not triggering">
    * Verify webhook URL is correct and active
    * Check that Windmill workflow is published and active
    * Ensure payload structure matches workflow expectations
    * Review Windmill execution logs for errors
  </Accordion>

  <Accordion title="Data processing issues">
    * Check workflow input parameter mapping
    * Verify data types match expected formats
    * Test workflow with sample data
    * Review Windmill script execution logs
  </Accordion>
</AccordionGroup>


# WooCommerce Plugin
Source: https://docs.dodopayments.com/integrations/woocommerce-plugin

Integrate Dodo Payments seamlessly with your WooCommerce store to accept global payments through UPI, cards, and more.

## Introduction

The Dodo Payments WooCommerce plugin provides a seamless integration with your store, enabling you to accept payments through multiple methods including UPI, cards, net banking, and digital wallets. This comprehensive guide will walk you through the installation and configuration process.

## Step-by-Step Installation Guide

1. Download the latest zip of the WooCommerce payment plugin.

   <Card title="Download Plugin" icon="download" href="https://github.com/dodopayments/dodo-woocommerce/releases">
     Get the latest version of our WooCommerce plugin
   </Card>

   Alternatively, you can install directly from the WordPress plugin directory:

   <Card title="WordPress Plugin Directory" icon="wordpress" href="https://wordpress.org/plugins/dodo-payments-for-woocommerce/">
     Install Dodo Payments for WooCommerce from WordPress.org
   </Card>

2. Log in to your WordPress website as an administrator (we assume you already have WooCommerce set up)

3. Navigate to **Plugins → Add New Plugin**

   <Frame>
     <img alt="Dodo Payments for WooCommerce Plugin" />
   </Frame>

4. Click on the **Upload Plugin** button and a file selection dialog will appear

   <Frame>
     <img alt="Dodo Payments for WooCommerce Plugin" />
   </Frame>

   <Frame>
     <img alt="Dodo Payments for WooCommerce Plugin" />
   </Frame>

5. Click **Browse…** and select the zip file you downloaded

6. Click the **Install Now** button to begin the installation process

   <Frame>
     <img alt="Dodo Payments for WooCommerce Plugin" />
   </Frame>

7. After installation completes, click **Activate Plugin** or activate it from the **Installed Plugins** section

   <Frame>
     <img alt="Dodo Payments for WooCommerce Plugin" />
   </Frame>

8. The plugin is now installed, but configuration is still required. Continue to the setup guide below.

## Configuration Guide

### Setting Up API Keys and Webhooks

1. Navigate to **WooCommerce → Settings → Payments** or click the **Payments** button in the left sidebar below the WooCommerce menu item

   <Frame>
     <img alt="Dodo Payments for WooCommerce Plugin" />
   </Frame>

   <Frame>
     <img alt="Dodo Payments for WooCommerce Plugin" />
   </Frame>

2. Enable the **Dodo Payments** payment provider if not already enabled, then click **Manage** to configure the plugin

3. You'll see various configuration options, each with helpful explanatory text. Begin by setting up your Live API Key

   <Frame>
     <img alt="Dodo Payments for WooCommerce Plugin" />
   </Frame>

4. Log in to your Dodo Payments dashboard in **Live Mode**, then navigate to **Dodo Payments (Live Mode) > Developer > API Keys** or visit [this direct link](https://app.dodopayments.com/developer/api-keys) and click **Add API Key**

   <Frame>
     <img alt="Dodo Payments for WooCommerce Plugin" />
   </Frame>

5. Give your API Key a descriptive name and click **Create**

   <Frame>
     <img alt="Dodo Payments for WooCommerce Plugin" />
   </Frame>

6. Copy the generated API Key and paste it into the **Live API Key** field in your WooCommerce plugin settings

   <Frame>
     <img alt="Dodo Payments for WooCommerce Plugin" />
   </Frame>

   <Frame>
     <img alt="Dodo Payments for WooCommerce Plugin" />
   </Frame>

7. Next, set up the Webhook Signing Key to enable payment status synchronization between Dodo Payments and WooCommerce

8. Scroll to the bottom of the plugin settings page and copy the webhook URL displayed there

   <Frame>
     <img alt="Dodo Payments for WooCommerce Plugin" />
   </Frame>

9. Return to your Dodo Payments dashboard and navigate to **Dodo Payments (Live Mode) > Developer > Webhooks** and click **Add Webhook**

   <Frame>
     <img alt="Dodo Payments for WooCommerce Plugin" />
   </Frame>

10. Paste the URL you copied in step 8 into the dialog and click **Add Webhook**

    <Frame>
      <img alt="Dodo Payments for WooCommerce Plugin" />
    </Frame>

11. After creating the webhook, click the eye icon next to the redacted **Signing Key** to reveal and copy it

    <Frame>
      <img alt="Dodo Payments for WooCommerce Plugin" />
    </Frame>

12. Paste the Signing Key into the **Live Webhook Signing Key** field in your plugin settings and save the changes

    <Frame>
      <img alt="Dodo Payments for WooCommerce Plugin" />
    </Frame>

13. Review the remaining settings such as **Global Tax Category** and **All Prices are Tax Inclusive**, as these options determine how products sync from WooCommerce to Dodo Payments. Note that **Test API Key** and **Test Webhook Signing Key** are only needed if you plan to use Test Mode

    <Frame>
      <img alt="Dodo Payments for WooCommerce Plugin" />
    </Frame>

## You're All Set!

Your WooCommerce store is now integrated with Dodo Payments! Customers can select Dodo Payments at checkout to access all supported payment methods.

<Frame>
  <img alt="Dodo Payments checkout option in WooCommerce" />
</Frame>

When customers choose Dodo Payments, they'll be seamlessly redirected to the Dodo Payments checkout page to complete their transaction.

<Frame>
  <img alt="Dodo Payments checkout page" />
</Frame>

## Key Features

* **Seamless Checkout Experience**: Redirect customers to a secure, optimized checkout page
* **Multiple Payment Methods**: Support for various local and international payment options
* **Real-time Status Updates**: Instant order status synchronization via webhooks
* **Detailed Transaction Records**: Comprehensive payment history in your WooCommerce dashboard
* **Multi-currency Support**: Accept payments in multiple currencies

## Troubleshooting

### Common Issues

1. **Payment Processing Failures**
   * Verify API keys are correctly configured
   * Ensure webhook URL is properly set up
   * Check that your SSL certificate is valid

2. **Webhook Synchronization Problems**
   * Confirm webhook signing key matches
   * Review server logs for potential errors
   * Verify your server can receive incoming webhook requests

### Support Resources

For additional assistance:

* Contact us at [support@dodopayments.com](mailto:support@dodopayments.com)
* Refer to our [comprehensive documentation](https://docs.dodopayments.com)

## Maintenance Best Practices

1. Regularly update the plugin for security patches and new features
2. Test all payment flows in sandbox mode before processing live transactions
3. Keep WordPress and WooCommerce updated to the latest versions
4. Implement regular site backups
5. Monitor transaction logs for any unusual activity
6. Store API keys securely and never share them publicly


# Zapier
Source: https://docs.dodopayments.com/integrations/zapier

Connect Dodo Payments to 5000+ apps through Zapier webhooks for unlimited automation possibilities.

## Introduction

Connect Dodo Payments to thousands of apps and services through Zapier. Automate workflows by triggering Zaps when payment events occur, from sending emails to updating spreadsheets, creating tasks, and much more.

<Info>
  This integration requires a Zapier webhook URL from your Zap configuration.
</Info>

## Getting Started

<Steps>
  <Step title="Open the Webhook Section">
    In your Dodo Payments dashboard, navigate to <b>Webhooks → + Add Endpoint</b> and expand the integrations dropdown.

    <Frame>
      <img alt="Add Endpoint and integrations dropdown" />
    </Frame>
  </Step>

  <Step title="Select Zapier">
    Choose the <b>Zapier</b> integration card.
  </Step>

  <Step title="Create Zap in Zapier">
    In Zapier, create a new Zap with "Webhooks by Zapier" as the trigger. Copy the webhook URL.
  </Step>

  <Step title="Paste Webhook URL">
    Paste the Zapier webhook URL into the endpoint configuration.
  </Step>

  <Step title="Configure Transformation">
    Edit the transformation code to format data for your Zapier workflow.
  </Step>

  <Step title="Test & Create">
    Test with sample payloads and click <b>Create</b> to activate the integration.
  </Step>

  <Step title="Done!">
    🎉 Payment events will now trigger your Zapier workflows automatically.
  </Step>
</Steps>

## Transformation Code Examples

### Basic Webhook Payload

```javascript basic_webhook.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType === "payment.succeeded") {
    const p = webhook.payload.data;
    webhook.payload = {
      event_type: webhook.eventType,
      payment_id: p.payment_id,
      amount: (p.total_amount / 100).toFixed(2),
      currency: p.currency || "USD",
      customer_email: p.customer.email,
      customer_name: p.customer.name,
      payment_method: p.payment_method || "unknown",
      timestamp: webhook.payload.timestamp
    };
  }
  return webhook;
}
```

### Subscription Event Handler

```javascript subscription_webhook.js icon="js" expandable theme={null}
function handler(webhook) {
  const s = webhook.payload.data;
  switch (webhook.eventType) {
    case "subscription.active":
      webhook.payload = {
        event_type: "subscription_started",
        subscription_id: s.subscription_id,
        customer_email: s.customer.email,
        customer_name: s.customer.name,
        product_id: s.product_id,
        amount: (s.recurring_pre_tax_amount / 100).toFixed(2),
        frequency: s.payment_frequency_interval,
        next_billing: s.next_billing_date,
        timestamp: webhook.payload.timestamp
      };
      break;
    case "subscription.cancelled":
      webhook.payload = {
        event_type: "subscription_cancelled",
        subscription_id: s.subscription_id,
        customer_email: s.customer.email,
        cancelled_at: s.cancelled_at,
        cancel_at_next_billing: s.cancel_at_next_billing_date,
        timestamp: webhook.payload.timestamp
      };
      break;
  }
  return webhook;
}
```

### Dispute Alert Handler

```javascript dispute_webhook.js icon="js" expandable theme={null}
function handler(webhook) {
  if (webhook.eventType.startsWith("dispute.")) {
    const d = webhook.payload.data;
    webhook.payload = {
      event_type: webhook.eventType,
      dispute_id: d.dispute_id,
      payment_id: d.payment_id,
      amount: (d.amount / 100).toFixed(2),
      status: d.dispute_status,
      stage: d.dispute_stage,
      remarks: d.remarks || "",
      urgent: webhook.eventType === "dispute.opened",
      timestamp: webhook.payload.timestamp
    };
  }
  return webhook;
}
```

## Popular Zapier Use Cases

<AccordionGroup>
  <Accordion title="Email Notifications">
    * Send Gmail/Outlook emails for payment confirmations
    * Create email sequences in Mailchimp/ConvertKit
    * Send Slack/Discord notifications
    * Create Google Sheets records
  </Accordion>

  <Accordion title="CRM Updates">
    * Add contacts to HubSpot/Salesforce
    * Create deals in Pipedrive/Close
    * Update customer records in Airtable
    * Log activities in Monday.com
  </Accordion>

  <Accordion title="Task Management">
    * Create tasks in Asana/Trello
    * Add to-do items in Notion
    * Create calendar events
    * Send SMS notifications via Twilio
  </Accordion>
</AccordionGroup>

## Tips

* Keep payload structure simple for easy Zapier parsing
* Use consistent field names across all events
* Include timestamps for workflow timing
* Test your Zap with sample data before going live
* Use Zapier's built-in filters for conditional logic

## Troubleshooting

<AccordionGroup>
  <Accordion title="Zap not triggering">
    * Verify webhook URL is correct and active
    * Check that Zap is turned on in Zapier
    * Ensure payload structure matches Zapier expectations
    * Test webhook delivery in Zapier dashboard
  </Accordion>

  <Accordion title="Data not mapping correctly">
    * Check field names in Zapier action steps
    * Verify data types match expected formats
    * Use Zapier's test feature to debug mapping
    * Ensure transformation code returns valid JSON
  </Accordion>
</AccordionGroup>


